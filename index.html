<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="recording">
<meta name="keywords" content="Tech;Data;Vision">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qi">
<meta name="twitter:description" content="recording">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.fastolf.com/">





  <title>Qi</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">to learn</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2019/01/04/markdown公式编辑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/markdown公式编辑/" itemprop="url">markdown 公式编辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:10:37+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>文本中加入公式  <code>$ 数学公式 $</code></p>
<p>单独加入公式 <code>$$ 数学公式 $$</code></p>
<pre><code>\begin{equation}
数学公式
\label{eq:当前公式名}
\end{equation}
自动编号后的公式可在全文任意处使用 \eqref{eq:公式名} 语句引用。
</code></pre><p><code>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例}</code></p>
<p>示例： $ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p>
<p><code>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</code></p>
<p>示例：$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$ </p>
<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><code>^</code>表示上标, <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>{}</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用</p>
<p><code>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</code></p>
<p>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</p>
<p>左右两边都有上下标，可以用<code>\sideset</code> 命令</p>
<p><code>$$ \sideset{^1_2}{^3_4}\bigotimes $$</code></p>
<p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p>
<h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code>。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令</p>
<p><code>$$\langle表达式\rangle$$</code></p>
<p>$$\langle表达式\rangle$$</p>
<p><code>$$\lceil表达式\rceil$$</code></p>
<p>$$\lceil表达式\rceil$$</p>
<p><code>$$\lfloor表达式\rfloor$$</code></p>
<p>$$\lfloor表达式\rfloor$$</p>
<p><code>$$\lbrace表达式\rbrace$$</code></p>
<p>$$\lbrace表达式\rbrace$$</p>
<p><code>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</code></p>
<p>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p>
<h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac {分子} {分母}</code> 命令产生一个分数\frac {分子} {分母}，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层</p>
<p><code>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</code></p>
<p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p>
<h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] {被开方数}</code>命令输入开方。</p>
<p><code>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</code></p>
<p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号</p>
<p><code>$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</code></p>
<p>$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</p>
<h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec{矢量}</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号</p>
<p><code>$$\vec{a} \cdot \vec{b}=0$$</code></p>
<p>$$\vec{a} \cdot \vec{b}=0$$</p>
<p><code>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</code></p>
<p>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_</code>积分下限^积分上限  <code>{被积表达式}</code> 来输入一个积分</p>
<p><code>$$\int_0^1 {x^2} \,{\rm d}x$$</code></p>
<p>$$\int_0^1 {x^2} \,{\rm d}x$$</p>
<h2 id="极限运算"><a href="#极限运算" class="headerlink" title="极限运算"></a>极限运算</h2><p>使用<code>\lim_{变量 \to 表达式}</code> 表达式 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号</p>
<p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p>
<p><code>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</code></p>
<h2 id="累加、累乘运算"><a href="#累加、累乘运算" class="headerlink" title="累加、累乘运算"></a>累加、累乘运算</h2><p>使用 <code>\sum_{下标表达式}^{上标表达式} {累加表达式}</code>来输入一个累加。<br>与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>此类符号在行内显示时上下标表达式将会移至右上角和右下角</p>
<p><code>$$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$</code></p>
<p>$$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code>和<code>\首字母大写希腊字母英文全称</code>来分别输入小写和大写希腊字母。</p>
<table>
<thead>
<tr>
<th style="text-align:right">输入</th>
<th style="text-align:right">显示</th>
<th style="text-align:right">输入</th>
<th style="text-align:right">显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">\alpha</td>
<td style="text-align:right">α</td>
<td style="text-align:right">A</td>
<td style="text-align:right">A</td>
</tr>
<tr>
<td style="text-align:right">\beta</td>
<td style="text-align:right">β</td>
<td style="text-align:right">B</td>
<td style="text-align:right">B</td>
</tr>
<tr>
<td style="text-align:right">\gamma</td>
<td style="text-align:right">γ</td>
<td style="text-align:right">\Gamma</td>
<td style="text-align:right">Γ</td>
</tr>
<tr>
<td style="text-align:right">\delta</td>
<td style="text-align:right">δ</td>
<td style="text-align:right">\Delta</td>
<td style="text-align:right">Δ</td>
</tr>
<tr>
<td style="text-align:right">\epsilon</td>
<td style="text-align:right">ϵ</td>
<td style="text-align:right">E</td>
<td style="text-align:right">E</td>
</tr>
<tr>
<td style="text-align:right">\zeta</td>
<td style="text-align:right">ζ</td>
<td style="text-align:right">Z</td>
<td style="text-align:right">Z</td>
</tr>
<tr>
<td style="text-align:right">\eta</td>
<td style="text-align:right">η</td>
<td style="text-align:right">H</td>
<td style="text-align:right">H</td>
</tr>
<tr>
<td style="text-align:right">\theta</td>
<td style="text-align:right">θ</td>
<td style="text-align:right">\Theta</td>
<td style="text-align:right">Θ</td>
</tr>
<tr>
<td style="text-align:right">\iota</td>
<td style="text-align:right">ι</td>
<td style="text-align:right">I</td>
<td style="text-align:right">I</td>
</tr>
<tr>
<td style="text-align:right">\kappa</td>
<td style="text-align:right">κ</td>
<td style="text-align:right">K</td>
<td style="text-align:right">K</td>
</tr>
<tr>
<td style="text-align:right">\lambda</td>
<td style="text-align:right">λ</td>
<td style="text-align:right">\Lambda</td>
<td style="text-align:right">Λ</td>
</tr>
<tr>
<td style="text-align:right">\nu</td>
<td style="text-align:right">ν</td>
<td style="text-align:right">N</td>
<td style="text-align:right">N</td>
</tr>
<tr>
<td style="text-align:right">\mu</td>
<td style="text-align:right">μ</td>
<td style="text-align:right">M</td>
<td style="text-align:right">M</td>
</tr>
<tr>
<td style="text-align:right">\xi</td>
<td style="text-align:right">ξ</td>
<td style="text-align:right">\Xi</td>
<td style="text-align:right">Ξ</td>
</tr>
<tr>
<td style="text-align:right">o</td>
<td style="text-align:right">o</td>
<td style="text-align:right">O</td>
<td style="text-align:right">O</td>
</tr>
<tr>
<td style="text-align:right">\pi</td>
<td style="text-align:right">π</td>
<td style="text-align:right">\Pi</td>
<td style="text-align:right">Π</td>
</tr>
<tr>
<td style="text-align:right">\rho</td>
<td style="text-align:right">ρ</td>
<td style="text-align:right">P</td>
<td style="text-align:right">P</td>
</tr>
<tr>
<td style="text-align:right">\sigma</td>
<td style="text-align:right">σ</td>
<td style="text-align:right">\Sigma</td>
<td style="text-align:right">Σ</td>
</tr>
<tr>
<td style="text-align:right">\tau</td>
<td style="text-align:right">τ</td>
<td style="text-align:right">T</td>
<td style="text-align:right">T</td>
</tr>
<tr>
<td style="text-align:right">\upsilon</td>
<td style="text-align:right">υ</td>
<td style="text-align:right">\Upsilon</td>
<td style="text-align:right">Υ</td>
</tr>
<tr>
<td style="text-align:right">\phi</td>
<td style="text-align:right">ϕ</td>
<td style="text-align:right">\Phi</td>
<td style="text-align:right">Φ</td>
</tr>
<tr>
<td style="text-align:right">\chi</td>
<td style="text-align:right">χ</td>
<td style="text-align:right">X</td>
<td style="text-align:right">X</td>
</tr>
<tr>
<td style="text-align:right">\psi</td>
<td style="text-align:right">ψ</td>
<td style="text-align:right">\Psi</td>
<td style="text-align:right">Ψ</td>
</tr>
<tr>
<td style="text-align:right">\omega</td>
<td style="text-align:right">ω</td>
<td style="text-align:right">\Omega</td>
<td style="text-align:right">Ω</td>
</tr>
</tbody>
</table>
<h2 id="大括号和行标的使用"><a href="#大括号和行标的使用" class="headerlink" title="大括号和行标的使用"></a>大括号和行标的使用</h2><p>使用 <code>\left</code>和 <code>\right</code>来创建自动匹配高度的 <code>(圆括号)，[方括号] 和 {花括号}</code>。<br>在每个公式末尾前使用<code>\tag{行标}</code>来实现行标。</p>
<pre><code>$$
f\left(
   \left[ 
     \frac{
       1+\left\{x,y\right\}
     }{
       \left(
          \frac{x}{y}+\frac{y}{x}
       \right)
       \left(u+1\right)
     }+a
   \right]^{3/2}
\right)
\tag{行标}
$$
</code></pre><p>$$<br>f\left(<br>   \left[<br>     \frac{<br>       1+\left{x,y\right}<br>     }{<br>       \left(<br>          \frac{x}{y}+\frac{y}{x}<br>       \right)<br>       \left(u+1\right)<br>     }+a<br>   \right]^{3/2}<br>\right)<br>\tag{行标}<br>$$</p>
<p><code>$\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$</code></p>
<p>$\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$</p>
<p><code>$f(x + \epsilon) \approx f(x) + f&#39;(x) \epsilon + \mathcal{O}(\epsilon^2).$</code></p>
<p>$f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$</p>
<p><code>$\text{d}x$</code></p>
<p>$\text{d}x$</p>
<p>链接：<a href="https://www.cnblogs.com/q735613050/p/7253073.html" target="_blank" rel="noopener">https://www.cnblogs.com/q735613050/p/7253073.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2019/01/04/GMM模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/GMM模型/" itemprop="url">GMM模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:09:14+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>高斯混合模型是一种混合模型，混合的基本分布是高斯分布</p>
<p>参考《统计学习方法》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2019/01/03/基于信息熵分词/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/基于信息熵分词/" itemprop="url">基于信息熵分词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T10:07:46+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分片属性：分片概率、分片频度、自由度、凝固程度</p>
<h2 id="自由度"><a href="#自由度" class="headerlink" title="自由度"></a>自由度</h2><p>文本片段的自由运用程度</p>
<p>如果一个文本片段能够算作一个词的话，它应该能够灵活地出现在各种不同的环境中，具有非常丰富的左邻字集合和右邻字集合。</p>
<h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>衡量信息量大小</p>
<p>用信息熵来衡量一个文本片段的左邻字集合和右邻字集合丰富程度。考虑这么一句话”吃葡萄不吐葡萄皮不吃葡萄倒吐葡萄皮”，”葡萄”一词出现了四次，其中左邻字分别为 {吃, 吐, 吃, 吐} ，右邻字分别为 {不, 皮, 倒, 皮} 。根据公式，”葡萄”一词的左邻字的信息熵为 - (1/2) · log(1/2) - (1/2) · log(1/2) ≈ 0.693 ，它的右邻字的信息熵则为 - (1/2) · log(1/2) - (1/4) · log(1/4) - (1/4) · log(1/4) ≈ 1.04 。可见，在这个句子中，”葡萄”一词的右邻字更加丰富一些。</p>
<p>一个文本片段的自由运用程度为它的左邻字信息熵和右邻字信息熵中的较小值。</p>
<p>通过信息熵算法，可以很好的区分一些专有名词像玫瑰、蝙蝠等，一些地名像新西兰、伦敦等，这些自由度较低的词汇的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2019/01/02/EL-Spring 表达式语言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/EL-Spring 表达式语言/" itemprop="url">EL-Spring 表达式语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T10:13:35+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>EL-Spring 表达式语言，支持xml和注解中使用表达式，类似JSP 的EL 表达式，可以实现普通文件、网址、配置文件、系统环境变量的注入</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>@PropertySource(&quot;classpath:application.properties&quot;)

@Value(&quot;This is common string&quot;) // 注入普通字符串
private String normal;

@Value(&quot;#{systemProperties[&apos;os.name&apos;]}&quot;) // 注入操作系统属性
private String osName;

@Value(&quot;#{T(java.lang.Math).random()*100.0}&quot;) // 注入表达式结果
private double randomNumber;

@Value(&quot;#{anotherService.property}&quot;) // 注入其他Bean属性
private String propfromAnother;

@Value(&quot;#{T(com.demo.el.spring_el_demo.DemoService).getCalc()*100}&quot;) // 注入类static方法结果,支持运算处理
private double result;

@Value(&quot;classpath:test.txt&quot;) // 注入文件资源
private Resource testFile;

@Value(&quot;http://www.baidu.com&quot;) // 注入网址资源
private Resource testUrl;

@Value(&quot;${book.name}&quot;) // 注入配置文件
private String bookName;

@Autowired
private Environment environment;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/图的遍历/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/图的遍历/" itemprop="url">图的遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T14:04:44+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/**
 * 无向图
 */
public class NoDirectionGraph {

    private int mMaxSize; //图中包含的最大顶点数
    private GraphVertex[] vertexList; //顶点数组
    private int[][] indicatorMat; //指示顶点之间的连通关系的邻接矩阵
    private int nVertex; //当前实际保存的顶点数目


    public NoDirectionGraph(int maxSize) {
        mMaxSize = maxSize;
        vertexList = new GraphVertex[mMaxSize];
        indicatorMat = new int[mMaxSize][mMaxSize];
        nVertex = 0;
        //初始化邻接矩阵元素为0
        for(int j=0;j&lt;mMaxSize;j++) {
            for(int k=0;k&lt;mMaxSize;k++) {
                indicatorMat[j][k] = 0;
            }
        }
    }


    public void addVertex(GraphVertex v) {
        if(nVertex &lt; mMaxSize) {
            vertexList[nVertex++] = v;

        } else {
            System.out.println(&quot;---插入失败，顶点数量已达上限!&quot;);
        }
    }

    /**
     * 修改邻接矩阵，添加新的边
     * @param start
     * @param end
     */
    public void addEdge(int start,int end) {
        indicatorMat[start][end] = 1;
        indicatorMat[end][start] = 1;
    }

    /**
     * 打印邻接矩阵
     */
    public void printIndicatorMat() {

        for(int[] line:indicatorMat) {
            for(int i:line) {
                System.out.print(i + &quot; &quot;);
            }
            System.out.println();
        }
    }

    /**
     * 深度优先遍历
     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数
     */
    public void DFS(int vertexIndex) {
        ArrayStack stack = new ArrayStack();
        //1.添加检索元素到栈中
        vertexList[vertexIndex].setVisited(true);
        stack.push(vertexIndex);
        int nextVertexIndex = getNextVertexIndex(vertexIndex);
        while(!stack.isEmpty()) { //不断地压栈、出栈，直到栈为空(检索元素也没弹出了栈)为止
            if(nextVertexIndex != -1) {
                vertexList[nextVertexIndex].setVisited(true);
                stack.push(nextVertexIndex);
                stack.printElems();
            } else {
                stack.pop();
            }
            //检索当前栈顶元素是否包含其他未遍历过的节点
            if(!stack.isEmpty()) {
                nextVertexIndex = getNextVertexIndex(stack.peek()); 
            }
        }
    }

    /**
     * 得到当前顶点的下一个顶点所在行
     * @param column
     * @return
     */
    public int getNextVertexIndex(int column) {
        for(int i=0;i&lt;indicatorMat[column].length;i++) {
            if(indicatorMat[column][i] == 1 &amp;&amp; !vertexList[i].isVisited()) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 广度优先遍历
     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数
     */
    public void BFS(int vertexIndex) {
        ChainQueue queue = new ChainQueue();
        vertexList[vertexIndex].setVisited(true);
        queue.insert(new QueueNode(vertexIndex));
        int nextVertexIndex = getNextVertexIndex(vertexIndex);
        while(!queue.isEmpty()) {
            if(nextVertexIndex != -1) {
                vertexList[nextVertexIndex].setVisited(true);
                queue.insert(new QueueNode(nextVertexIndex));
            } else {
                queue.remove();
            }
            if(!queue.isEmpty()) {
                nextVertexIndex = getNextVertexIndex(queue.peek().data);
                queue.printElems();
            }
        }
    }
}




/**
 * 使用数组实现栈结构
 */
public class ArrayStack {

    private int[] tArray; 
    private int topIndex = -1; //表示当前栈顶元素的索引位置
    private int CAPACITY_STEP = 12; //数组容量扩展步长


    public ArrayStack() {
        /***创建泛型数组的一种方法***/
        tArray = new int[CAPACITY_STEP]; 
    }

    /**
     * 弹出栈顶元素方法
     * @return
     */
    public int pop() {
        if(isEmpty()) {
            System.out.println(&quot;错误，栈中元素为空，不能pop&quot;);
            return -1;
        } else {
            int i = tArray[topIndex];
            tArray[topIndex--] = -1; //擦除pop元素
            return i;
        }
    }

    /**
     * 向栈中插入一个元素
     * @param t
     */
    public void push(int t) {
        //检查栈是否已满
        if(topIndex == (tArray.length-1)) {
            //扩展容量
            int[] tempArray = new int[tArray.length + CAPACITY_STEP];
            for(int i=0;i&lt;tArray.length;i++) {
                tempArray[i] = tArray[i];
            }
            tArray = tempArray;
            tempArray = null;
        } else {
            topIndex ++;
            tArray[topIndex] = t;
        }
    }

    /**
     * 得到栈顶元素，但不弹出
     * @return
     */
    public int peek() {
        if(isEmpty()) {
            System.out.println(&quot;错误，栈中元素为空，不能peek&quot;);
            return -1;
        } else {
            return tArray[topIndex];
        }
    }

    /**
     * 判断当前栈是否为空
     * @return
     */
    public boolean isEmpty() {
        return (topIndex &lt; 0);
    }

    /**
     * 打印栈中元素
     */
    public void printElems() {
        for(int i=0;i&lt;=topIndex;i++) {
            System.out.print(tArray[i] + &quot; &quot;);
        }
        System.out.println();
    }
}


/**
 * 使用链表实现队列
 */
public class ChainQueue {
    private QueueNode head; // 指向队列头节点
    private QueueNode tail; // 指向队列尾节点
    private int size = 0; // 队列尺寸

    public ChainQueue() {

    }

    /**
     * 插入新节点到队列尾
     */
    public void insert(QueueNode node) {

        // 当然也可以这么写,添加tail.prev = node
        if (head == null) {
            head = node;
            tail = head;
        } else {
            node.next = tail;
            tail.prev = node; // 双向连接，确保head.prev不为空
            tail = node;
        }
        size++;
    }

    /**
     * 移除队列首节点
     */
    public QueueNode remove() {
        if (!isEmpty()) {
            QueueNode temp = head;
            head = head.prev;
            size--;
            return temp;
        } else {
            System.out.println(&quot;异常操作，当前队列为空!&quot;);
            return null;
        }
    }

    /**
     * 队列是否为空
     * 
     * @return
     */
    public boolean isEmpty() {
        if (size &gt; 0) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * 返回队列首节点，但不移除
     */
    public QueueNode peek() {
        if (!isEmpty()) {
            return head;
        } else {
            System.out.println();
            System.out.println(&quot;异常操作，当前队列为空!&quot;);
            return null;
        }
    }

    /**
     * 返回队列大小
     * 
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 打印队列中的元素
     */
    public void printElems() {
        QueueNode tempNode = head;
        while(tempNode != null) {
            System.out.print(tempNode.data + &quot; &quot;);
            tempNode = tempNode.prev;
        }
        System.out.println();
    }
}

/**
 * 节点类
 * 
 * @author wly
 * 
 */
class QueueNode {
    QueueNode prev;
    QueueNode next;

    int data;

    public QueueNode(int data) {
        this.data = data;
    }

    public int getData() {
        return data;
    }

    public void setData(int data) {
        this.data = data;
    }

    @Override
    public String toString() {
        // TODO Auto-generated method stub
        super.toString();
        return data + &quot;&quot;;
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-图/" itemprop="url">数据结构-图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T13:12:06+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>图是由顶点集（VertexSet）和边集（EdgeSet）组成，针对图G，顶点集和边集分别记为V(G)和E(G)。依据图的边集是否为有向，可把图分为有向图和无向图，根据图是否有权重，可以分为有权图和无权图</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li>邻接点-在一个无向图中，若存在一条边<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2. 出/入边-在一个有向图张，若存在一条边```&lt;Vi,Vj&gt;```，则称此边为顶点Vi的出边，顶点Vj的一条入边</span><br><span class="line">3. 度/入度/出度-无向图中的度定义为以该顶点为一个端点的边的数目，记为D(V)。有向图的入度定为多少边指向该顶点，出度是该顶点出边的个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 邻接矩阵</span><br><span class="line"></span><br><span class="line">```邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。对于无向图 如果顶点b1和b2是连接的，那么在二维矩阵中matrix[b1,b2]和matrix[b2,b1]位置的值置为1，如果是有向图b1指向b2，那么 matrix[b1,b2]=1,matrix[b2,b1]=0；下面用一个例子表示无向图和有向图的邻接矩阵；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果图是一个带权图，需要把1换为相应边上的权值，把非对角线上的换成一个很大的特定的实数则可，表示相应的边不存在，这个特定的实数通常用无穷大或MaxValue来表示，他要大于图G中所有边的权值</p>
<p><a href="#matrix">代码实现</a></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接矩阵与邻接表相比，它会造成空间的一定损失，它需要为每个顶点都分配n个边的空间，其实有很多边都是不存在边，但是邻接表的实现就不一样，它只关心存在的边，不关心不存在的边。邻接表由数组+链表组成对于上面的无向图，邻接表表示为（由于有向和无向的差别不是太大，所以只是画出了无向的邻接表表示）</p>
<p><a href="#table">代码实现</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><span id="matrix">邻接矩阵实现</span></p>
<pre><code>package Graph;
//边集数组 ，存放边的信息
//邻域数组表示  和 邻域表表示  是两种不同的表示方式
//表示的是插入边的元素，边的起点和终点  边的权重
public class EdgeElement {
    int fromvex;
    int endvex;
    int weight;

    public EdgeElement(int v1,int v2){
        //对于无权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=1;
    }
    public EdgeElement(int v1,int v2,int wgt){
        //对于有权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=wgt;
    }    
}


package Graph;
//可以通过边集来得到一个图的构成
public interface Graph {
    void creatGraph(EdgeElement d[]);        //通过边结点来构建一个图
    GraphType graphType();                //返回图的类型  无向无权图 无向有权图  有向无权图  有向有权图 定义一个枚举变量
    int vertices();                    //返回图的顶点数
    int edges();                    //返回图的边数
    boolean find(int i,int j);            //从图中查找一条边(i,j)是否存在
    void putEdge(EdgeElement theEdge);        //像图中插入一条边 theEdge
    void removeEdge(int i,int j);            //从图中删除一条边
    int degree(int i);                //返回顶点i的度
    int inDegree(int i);                //返回顶点i的入度
    int outDegree(int i);                //返回顶点i的出度
    void output();                    //以图的顶点集和边集的形式输出一个图
    void depthFirstSearch(int v);            //从顶点v开始深度优先搜索整幅图
    void breadthFirstSearch(int v);            //从顶点v开始广度优先搜索整幅图
}

//在邻域数组中写数据
public void creatGraph(EdgeElement[] d) {
    int i;
    for(i=0;i&lt;d.length;i++){
        if(d[i]==null) break;
        int v1,v2;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2){
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        }
        if(type==GraphType.NoDirectionNoWeight){
            a[v1][v2]=a[v2][v1]=1;
        }else if(type==GraphType.NoDirectionWeight){
            a[v1][v2]=a[v2][v1]=d[i].weight;
        }else if(type==GraphType.DirectionNoWeight){
            a[v1][v2]=1;
        }else{
            a[v1][v2]=d[i].weight;
        }
    }
    e=i;            //边的数目
}

public void putEdge(EdgeElement theEdge) {
    int v1,v2;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    }
    if(a[v1][v2]==0 || a[v1][v2]==MaxValue) e++;        //边数e的值加一
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        if(type==GraphType.NoDirectionNoWeight){
            a[v1][v2]=a[v2][v1]=1;
        }else{
            a[v1][v2]=a[v2][v1]=theEdge.weight;
        }
    }else{
        if(type==GraphType.DirectionNoWeight) a[v1][v2]=1;
        else{
            a[v1][v2]=theEdge.weight;
        }
    }
}

public void removeEdge(int i, int j) {
    if(i&lt;0 || i&gt;n-1 || j&lt;0 || j&gt;n-1 || i==j){
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    }
    if(a[i][j]==0 || a[i][j]==MaxValue){
        System.out.println(&quot;要删除的边不存在，退出运行！&quot;);
        System.exit(0);            
    }
    if(type==GraphType.NoDirectionNoWeight){
        a[i][j]=a[j][i]=0;
    }else if(type==GraphType.NoDirectionWeight){
        a[i][j]=a[j][i]=MaxValue;
    }else if(type==GraphType.DirectionNoWeight){
        a[i][j]=0;
    }else a[i][j]=MaxValue;
    e--;
}

//得到该结点的度
public int degree(int i) {
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    int k=0;
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        for(int j=0;j&lt;n;j++){
            if(a[i][j]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;

        }
    }else{
        k = inDegree(i)+outDegree(i);
    }
    return k;
}
//入度
public int inDegree(int i) {                    
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        return -1;
    }
    int k=0;
    for(int j=0;j&lt;n;i++){
        if(a[j][i]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;
    }
    return k;
}
//出度
public int outDegree(int i) {
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        return -1;
    }
    int k=0;
    for(int j=0;j&lt;n;i++){
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue) k++;
    }
    return k;
}

//输出
public void output() {
    int i,j;
    System.out.print(&quot;V={&quot;);//输出顶点集合
    for(i=0;i&lt;n-1;i++){
        System.out.print(i+&quot;,&quot;);
    }
    System.out.print(n-1+&quot;}&quot;);//输出顶点集合
    //输出边集合
    System.out.print(&quot;E={&quot;);
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.DirectionNoWeight){
        for(i=0;i&lt;n;i++){
            for(j=0;j&lt;n;j++){
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue){
                    if(type==GraphType.NoDirectionNoWeight){
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;),&quot;);
                    }else{
                        System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;);
                    }
                }
            }
        }
    }else{
        for(i=0;i&lt;n;i++){
            for(j=0;j&lt;n;j++){
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue){
                    if(type==GraphType.NoDirectionWeight){
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;+a[i][j]+&quot;,&quot;);
                    }else System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;+a[i][j]+&quot;,&quot;);
                }
            }
        }
    }
    System.out.print(&quot;}&quot;);
}

//深度优先进行搜索   是从哪个顶点开始遍历，这里可以用顶点序号表示顶点
public void depthFirstSearch(int v) {        //驱动函数
    boolean visited[]=new boolean[n];
    for(int i=0;i&lt;n;i++){
        visited[i]=false;
    }
    dfs(v,visited);                            //把每个结点遍历一次。
    System.out.println();
}
//进行深度优先搜索的内部递归方法使用
private void dfs(int i,boolean visited[]){    //工作函数
    System.out.print(i+&quot; &quot;);
    visited[i]=true;
    for(int j=0;j&lt;n;j++){
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue &amp;&amp; !visited[j]){
            dfs(j,visited);
        }
    }
}
</code></pre><p><span id="table">邻接表实现</span></p>
<pre><code>package GraphLink;
//定义邻接表类型
public class EdgeNode{
    //需要一个存储自身结点
    int adjvex;
    int weight;
    EdgeNode next;
    //无权图
    public EdgeNode(int adj,EdgeNode nt){
        this.adjvex=adj;
        this.next=nt;
        this.weight=1;
    }
    //有权图
    public EdgeNode(int adj,int wgt,EdgeNode nt){
        this.adjvex=adj;
        this.weight=wgt;
        this.next=nt;
    }
}

//生成图函数
@Override
public void creatGraph(EdgeElement[] d) {
    int i;
    for(i=0;i&lt;d.length;i++){//处理边集合  如果边集合重复 那程序不就有问题了么  这点要处理
        if(d[i]==null) break;
        int v1,v2,weight;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        weight=d[i].weight;
        if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        }
        if(type==GraphType.NoDirectionNoWeight){//处理无方向 无权重的图
            a[v1]=new EdgeNode(v2,a[v1]);//把边挂载在主干上,a为EdgeNode类型的一维数组
            a[v2]=new EdgeNode(v1,a[v2]);//处理第二条边
        }else if(type==GraphType.NoDirectionWeight){//处理无向有权图
            a[v1]=new EdgeNode(v2,weight,a[v1]);
            a[v2]=new EdgeNode(v1,weight,a[v2]);
        }else if(type==GraphType.DirectionNoWeight){//处理有向无权图
            a[v1]=new EdgeNode(v2,a[v1]);
        }else {
            a[v1]=new EdgeNode(v2,weight,a[v1]);
        }
    }
    e=i;
}

//在图中查找一条边
public boolean find(int v1,int v2){
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1];
    while(p!=null){
        if(p.adjvex==v2){
            return true;
        }
        p=p.next;
    }
    return false;
}

//向图中插入一条边
public void putEdge(EdgeElement theEdge){
    int v1,v2,weight;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    weight=theEdge.weight;
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1];
    while(p!=null){
        if(p.adjvex==v2){
            break;//退出后处理
        }
        p=p.next;
    }
    if(p==null) e++;
    else{
        if(type==GraphType.DirectionWeight || type==GraphType.NoDirectionWeight){
            p.weight=weight;
        }
        if(type==GraphType.NoDirectionWeight){//无向有权重的另一条边也要处理
            EdgeNode q=a[v2];
            while(q!=null){
                if(q.adjvex==v1) break;
                q=q.next;
            }
            q.weight=weight;
        }
        return;
    }
    if(type==GraphType.NoDirectionNoWeight){//如果是无向无权重
        a[v1]=new EdgeNode(v2, a[v1]);
        a[v2]=new EdgeNode(v1, a[v2]);
    }else if(type==GraphType.NoDirectionWeight){//处理无向有权重
        a[v1]=new EdgeNode(v2,weight,a[v1]);
        a[v2]=new EdgeNode(v1,weight,a[v2]);
    }else if(type==GraphType.DirectionNoWeight){//有向无权重
        a[v1]=new EdgeNode(v2,a[v1]);
    }else{
        a[v1]=new EdgeNode(v2, weight,a[v1]);
    }
}

public void removeEdge(int v1,int v2){
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1],q=null;//拿到主干结点
    while(p!=null){
        if(p.adjvex==v2) break;
        q=p;
        p=p.next;
    }
    if(p==null){
        System.out.println(&quot;要删除的边不存在，程序退出运行&quot;);
        System.exit(0);
    }
    if(q==null){//该结点在表头上 主干的节点就是需要找的结点
        a[v1]=a[v1].next;
    }else{
        q.next=p.next;//嫁接上
    }
    //删除无向图的另一个结点上的边
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        EdgeNode p1=a[v2],q1=null;
        while(p1!=null){
            if(p1.adjvex==v1){
                break;
            }
            q1=p1;
            p1=p1.next;
        }
        if(q1==null){
            a[v2]=a[v2].next;
        }else{
            q1.next=p1.next;
        }
    }
    e--;
}

//返回一个顶点的度，度分为入度和出度，要分别处理
public int degree(int i){
    if(i&lt;0||i&gt;n-1){
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);            
    }
    int k=0;
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        EdgeNode p=a[i];
        while(p!=null){
            k++;
            p=p.next;
        }
        return k;
    }else return inDegree(i)+outDegree(i);
}
//求出并返回一个顶点的入度
public int inDegree(int i){//返回指向该顶点的度，入度，用双循环来实现
    int k=0;//记录入度个数
    if(i&lt;0||i&gt;n-1){
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);            
    }
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        return -1;
    }else{
        for(int j=0;j&lt;n;j++){
            EdgeNode p=a[j];
            while(p!=null){
                if(p.adjvex==i)k++;
                p=p.next;
            }
        }
    }
    return k;
}
//返回一个顶点的出度
public int outDegree(int i){
    int k=0;//记录出度的数目
    EdgeNode p=a[i];
    while(p!=null){
        k++;
        p=p.next;
    }
    return k;
}

//得到邻接矩阵
public int[][] getAdjacencyMatrix(){
    int adjacencyMatrix[][]=new int[n][n];
    if(type==GraphType.DirectionNoWeight||type==GraphType.DirectionWeight){//有向性
        //有向 那不存在的边是存在一个InfinityValue
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                if(i==j) adjacencyMatrix[i][j]=0;
                else adjacencyMatrix[i][j]=InfinityValue;
            }
        }
    }else{
        //无向 都设置为0
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                 adjacencyMatrix[i][j]=0;
            }
        }            
    }
        //遍历整个图
        for(int i=0;i&lt;n;i++){
            EdgeNode p=a[i];
            while(p!=null){
                adjacencyMatrix[i][p.adjvex]=p.weight;
                p=p.next;
            }
        }    
    return adjacencyMatrix;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-矩阵压缩/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-矩阵压缩/" itemprop="url">数据结构-矩阵压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:47:29+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对称矩阵的压缩"><a href="#对称矩阵的压缩" class="headerlink" title="对称矩阵的压缩"></a>对称矩阵的压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    //对称矩阵的压缩算法</span><br><span class="line">    public class SymeMatric &#123;</span><br><span class="line">    </span><br><span class="line">        double[] a;// 矩阵元素</span><br><span class="line">        int n; // 矩阵的阶数</span><br><span class="line">        int m;// 一维数组的元素的个数--长度</span><br><span class="line">    </span><br><span class="line">        public SymeMatric(int n) &#123;</span><br><span class="line">            // 对称矩阵中不重复元素，保存到一维数组中所需要的一维数组的长度</span><br><span class="line">            // 2阶对称矩阵对应(1+2=3)维数组，3阶对称矩阵对应1+2+3=6维数组，</span><br><span class="line">            // 4阶对称矩阵对应1+2+3+4维数组，n阶对称矩阵对应前n项和，</span><br><span class="line">            // 所以一维数组的长度m的值为1,2,3...n的前n项和</span><br><span class="line">            m = n * (n + 1) / 2; </span><br><span class="line">            a = new double[m];</span><br><span class="line">            this.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 通过一个二维数组来初始化</span><br><span class="line">        public void evalute(double[][] b) &#123;</span><br><span class="line">            int k = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    // i &gt;= j表示只保存下三角元素</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        a[k++] = b[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 通过一个一维数组来初始化,那么这个一维数组就是对称矩阵元素的一个副本</span><br><span class="line">        public void evalute(double[] b) &#123;</span><br><span class="line">            for (int k = 0; k &lt; m; k++) &#123;</span><br><span class="line">                a[k] = b[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 对称矩阵相加</span><br><span class="line">        public SymeMatric add(SymeMatric b) &#123;</span><br><span class="line">            SymeMatric t = new SymeMatric(n);</span><br><span class="line">            int k;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        k = i * (i - 1) / 2 + j - 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        k = j * (j - 1) / 2 + i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 求和</span><br><span class="line">                    t.a[k] = a[k] + b.a[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 打印对称矩阵，这个才是关键！！</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            int k;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        k = i * (i - 1) / 2 + j - 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        k = j * (j - 1) / 2 + i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(&quot; &quot; + a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三角矩阵的压缩</span><br><span class="line"></span><br><span class="line">```m对角矩阵：非零元素在每行中有m个，一维数组s[k]和A[i][j]的对应关系为：k = m*i+j</span><br></pre></td></tr></table></figure>
<h2 id="稀疏矩阵的压缩"><a href="#稀疏矩阵的压缩" class="headerlink" title="稀疏矩阵的压缩"></a>稀疏矩阵的压缩</h2><p><code>矩阵m*n如果有t个非零元素，那么s = t/m*n称为矩阵的稀疏因子，如果s&lt;=0.05那么矩阵为稀疏矩阵</code></p>
<p>注：三元组顺序表表示，其中三元组格式为(i,j,e)记录了非零元素的行号、列号以及非零元素</p>
<pre><code>inal int _ROWS=5;        //定义行数
final int _COLS=5;        //定义列数
final int _NOTZERO=6;    //定义稀疏矩阵中不为零的个数
int i,j,tmpRW,tmpCL,tmpNZ;
int temp=1;
int Sparse[][]=new int[_ROWS][_COLS];    //声明稀疏矩阵
int Compress[][]=new int[_NOTZERO+1][3];//声明压缩矩阵

for(i=0;i&lt;_ROWS;i++)         //将矩阵初始值都设为0
    for(j=0;j&lt;_COLS;j++)
        Sparse[i][j]=0;

tmpNZ=_NOTZERO;            //产生随机稀疏矩阵
for(i=1;i&lt;tmpNZ+1;i++) {
    tmpRW=(int)(Math.random()*100);
    tmpRW=(tmpRW%_ROWS);
    tmpCL=(int)(Math.random()*100);
    tmpCL=(tmpCL%_COLS);
    if(Sparse[tmpRW][tmpCL]!=0)
        tmpNZ++;
    Sparse[tmpRW][tmpCL]=i;
}

/*开始压缩稀疏矩阵*/
Compress[0][0]=_ROWS;
Compress[0][1]=_COLS;
Compress[0][2]=_NOTZERO;
for(i=0;i&lt;_ROWS;i++) {
    for(j=0;j&lt;_COLS;j++) {
        if(Sparse[i][j]!=0){
            Compress[temp][0]=i;
            Compress[temp][1]=j;
            Compress[temp][2]=Sparse[i][j];
            temp++;
        }
    }
}
</code></pre><p>链接：<a href="https://www.cnblogs.com/gaosheng-221/p/6133443.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosheng-221/p/6133443.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-栈、队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-栈、队列/" itemprop="url">数据结构-栈、队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:27:56+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(LIFO, Last In First Out)</p>
<h3 id="静态栈"><a href="#静态栈" class="headerlink" title="静态栈"></a>静态栈</h3><p>数组 栈大小固定</p>
<h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>链表 栈大小不固定</p>
<pre><code>public class Node {

    //数据域
    public int data;

    //指针域，指向下一个节点
    public Node next;

    public Node() {
    }

    public Node(int data) {
        this.data = data;
    }

    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

}

public class Stack {

    public Node stackTop;//栈顶
    public Node stackBottom;//栈底

    public Stack(Node stackTop, Node stackBottom) {
        this.stackTop = stackTop;
        this.stackBottom = stackBottom;
    }

    public Stack() {
    }


}

/**
 * 进栈
 *
 * @param stack 栈
 * @param value 要进栈的元素
 */
public static void pushStack(Stack stack, int value) {

    // 封装数据成节点
    Node newNode = new Node(value);


    // 栈顶本来指向的节点交由新节点来指向
    newNode.next = stack.stackTop;

    // 栈顶指针指向新节点
    stack.stackTop = newNode;

}


/**
 * 遍历栈(只要栈顶指针不指向栈底指针，就一直输出)
 *
 * @param stack
 */
public static void traverse(Stack stack) {
    Node stackTop = stack.stackTop;

    while (stackTop != stack.stackBottom) {

        System.out.println(&quot;关注公众号：Java3y：&quot; + stackTop.data);

        stackTop = stackTop.next;
    }


}

/**
 * 判断该栈是否为空
 *
 * @param stack
 */
public static void isEmpty(Stack stack) {
    if (stack.stackTop == stack.stackBottom) {

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈为空&quot;);
    } else {

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈不为空&quot;);

    }

}

/**
 * 出栈(将栈顶的指针指向下一个节点)
 * @param stack
 */
public static void popStack(Stack stack) {

    // 栈不为空才能出栈
    if (!isEmpty(stack)) {

        //栈顶元素
        Node top = stack.stackTop;

        // 栈顶指针指向下一个节点
        stack.stackTop = top.next;

        System.out.println(&quot;关注公众号：Java3y----&gt;出栈的元素是：&quot; + top.data);

    }
}

/**
 * 清空栈
 * @param stack
 */
public static void clearStack(Stack stack) {

    stack.stackTop = null;
    stack.stackBottom = stack.stackTop;
}
</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(LILO, Last In Last Out)</p>
<h3 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h3><p>数组实现循环队列，节省内存资源</p>
<pre><code>public class Queue {


    //数组
    public int [] arrays;

    //指向第一个有效的元素
    public int front = 0;

    //指向有效数据的下一个元素(即指向无效的数据)
    public int rear = 0;

}


/**
 * 入队
 *
 * @param queue
 */
public static void enQueue(Queue queue,int value) {

    // 不是满的队列才能入队
    if (!isFull(queue)) {

        // 将新的元素插入到队尾中
        queue.arrays[queue.rear] = value;

        // rear节点移动到新的无效元素位置上
        queue.rear = (queue.rear + 1) % queue.arrays.length;
    }
}

/**
 * 出队
 *
 * @param queue
 */
public static void outQueue(Queue queue) {

    //判断该队列是否为null
    if (!isEmpty(queue)) {


        //不为空才出队
        int value = queue.arrays[queue.front];
        System.out.println(&quot;关注公众号：Java3y---&gt;出队的元素是：&quot; + value);

        // front指针往后面移
        queue.front = (queue.front + 1) % queue.arrays.length;

    }


}

/**
 * 判断队列是否空，front和rear指针相等，就是空了
 * @param queue
 * @return
 */
public static boolean isEmpty(Queue queue) {
    if (queue.rear  == queue.front) {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列空的！&quot;);
        return true;
    } else {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列非空！&quot;);
        return false;
    }
}

/**
 * 判断队列是否满了，front和rear指针紧挨着，就是满了
 * @param queue
 * @return
 */
public static boolean isFull(Queue queue) {
    if ((queue.rear + 1) % queue.arrays.length == queue.front) {

        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列满了！&quot;);
        return true;
    } else {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列没满了！&quot;);
        return false;
    }
}

/**
 * 遍历队列
 * @param queue
 *
 */
public static void traverseQueue(Queue queue) {

    // front的位置
    int i = queue.front;

    while (i != queue.rear) {

        System.out.println(&quot;关注公众号：Java3y---&gt;&quot; + queue.arrays[i]);

        //移动front
        i = (i + 1) % queue.arrays.length;
    }

}
</code></pre><h3 id="动态队列"><a href="#动态队列" class="headerlink" title="动态队列"></a>动态队列</h3><p>链表实现</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-线性表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-线性表/" itemprop="url">数据结构-线性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:18:54+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>开始节点--&gt;  数据元素 ... --&gt; 终端节点</code></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>clear、isEmpty、length、get、insert、remove、indexOf</p>
<pre><code>public interface IList {
    // 线性表置空操作
    public void clear();

    // 判断线性表是否为空操作
    public boolean isEmpty();

    // 获取线性表中元素的长度操作
    public int length();

    // 获取指定位置上面的元素操作
    public Object get(int i);

    // 在指定位置上面插入元素的操作
    public void insert(int i, Object x);

    // 删除指定位置上面的元素的操作
    public void remove(int i);

    // 查找指定元素的位置首次出现的位置操作
    public int indexOf(Object x);

    // 显示线性表中的内容操作
    public void display();
}
</code></pre><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序存储， 逻辑上相邻的数据元素，在物理存储上也是相邻的。 不便于插入和删除</p>
<pre><code>public class SqList implements IList {
    // 线性表存储空间
    private Object[] listElem;
    // 线性表的当前长度
    private int curLen;

    // 顺序表类的构造函数，构造一个存储空间容量为maxSize的线性表
    public SqList(int maxSize) {
        // TODO Auto-generated constructor stub
        curLen = 0;
        listElem = new Object[maxSize];
    }

    // 将一个已经存在的线性表置成空表
    public void clear() {
        // TODO Auto-generated method stub
        // 置顺序表的当前长度为0
        curLen = 0;
    }

    // 判断线性表中的数据元素的个数是否为0，若为0则返回true，否则返回false
    public boolean isEmpty() {
        // TODO Auto-generated method stub
        return curLen == 0;
    }

    // 求线性表中的数据元素的个数并返回其值
    public int length() {
        // TODO Auto-generated method stub
        // 返回顺序表的当前长度
        return curLen;
    }

    // 读取到线性表中的第i个数据元素并由函数返回其值，其中i的取值范围为0≤i≤length()-1，若i不在此范围则抛出异常
    public Object get(int i) {
        // TODO Auto-generated method stub
        if (i &lt; 0 || i &gt;= curLen) {
            throw new RuntimeException(&quot;第&quot; + i + &quot;个元素不存在&quot;);
        }
        return listElem[i];
    }

    // 在线性表的第i个数据元素之前插入一个值位x的数据元素
    public void insert(int i, Object x) {
        // TODO Auto-generated method stub
        // 判断表是否满了
        if (curLen == listElem.length) {
            throw new RuntimeException(&quot;存储空间已经满了，无法插入新的元素&quot;);
        }
        // 插入的位置不合法
        if (i &lt; 0 || i &gt; curLen) {
            throw new RuntimeException(&quot;插入的位置不合法&quot;);
        }
        // 必须要从最后一个元素开始依次逐个后移动，直到第i个数据元素移动完毕为止。
        for (int j = curLen; j &gt; i; j--) {
            listElem[j] = listElem[j - 1];
        }
        listElem[i] = x;
        curLen++;
    }

    public void remove(int i) {
        // TODO Auto-generated method stub
        if (i &lt; 0 || i &gt; curLen - 1) {
            throw new RuntimeException(&quot;删除的位置不合法&quot;);
        }
        for (int j = i; j &lt; curLen; j++) {
            listElem[j] = listElem[j+1];
        }
        curLen--;
    }

    // 返回线性表中首次出现指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1
    public int indexOf(Object x) {
        // TODO Auto-generated method stub
        for (int i = 0; i &lt; curLen; i++) {
            if (listElem[i].equals(x)) {
                return i;
            }
        }
        return -1;
    }

    // 输出线性表中的数据元素
    public void display() {
        // TODO Auto-generated method stub
        for (int i = 0; i &lt; curLen; i++) {
            System.out.print(listElem[i] + &quot; &quot;);
        }
        System.out.println();
    }

    // 测试
    public static void main(String[] args) {
        SqList sqList = new SqList(10);
        sqList.insert(0, &quot;a&quot;);
        sqList.insert(1, &quot;z&quot;);
        sqList.insert(2, &quot;d&quot;);
        sqList.insert(3, &quot;m&quot;);
        sqList.insert(4, &quot;z&quot;);
        int order = sqList.indexOf(&quot;z&quot;);
        if (order!=-1) {
            System.out.println(&quot;顺序表中第一次出现的值为z的数据元素的位置为：&quot;+order);
        }else {
            System.out.println(&quot;顺序表中不包括z元素&quot;);
        }
    }
}
</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式存储，单向链表，节点保存下一个节点的引用，便于插入和删除</p>
<pre><code>public class Node {
    // 存放结点的值
    private Object data;
    // 后继结点的引用
    private Node next;

    // 无参数时的构造函数
    public Node() {
        // TODO Auto-generated constructor stub
        this(null, null);
    }

    // 带有一个参数时的构造函数
    public Node(Object data) {
        this(data, null);
    }

    // 带有两个参数时的构造函数
    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/兔子数列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/兔子数列/" itemprop="url">兔子数列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T11:53:36+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自然界现象抽象化得到的数列模型——斐波那契数列</p>
<ol>
<li>初始状态：一对刚出生的兔子</li>
<li>下一步：生长</li>
<li><figure class="highlight plain"><figcaption><span>一对刚出生的兔子-> 第1步```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">总结： 当月的兔子数=上月兔子数+当月新生兔子  数列的当前列=前两列之和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 递归算法</span><br><span class="line"></span><br><span class="line">指数阶算法，效率较低，时间复杂度爆炸增量</span><br><span class="line"></span><br><span class="line">        Fib1(int n)</span><br><span class="line">        </span><br><span class="line">        &#123; if(n&lt;1)</span><br><span class="line">        </span><br><span class="line">               return -1;</span><br><span class="line">        </span><br><span class="line">          if(n==1||n==2)</span><br><span class="line">        </span><br><span class="line">                return 1;</span><br><span class="line">        </span><br><span class="line">           return Fib1(n-1)+Fib1(n-2);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">## 数组记录先两项值</span><br><span class="line"></span><br><span class="line">时间复杂度从指数阶降到了多项式阶O(n),空间复杂度O(n)</span><br><span class="line"></span><br><span class="line">    Fib2(intn)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;1)</span><br><span class="line">            return-1;</span><br><span class="line">        int[] a=new int[n];</span><br><span class="line">        a[1]=1;</span><br><span class="line">        a[2]=1;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)</span><br><span class="line">            a[i]=a[i-1]+a[i-2];</span><br><span class="line">            return a[n];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">             </span><br><span class="line">        </span><br><span class="line">## 迭代法</span><br><span class="line"></span><br><span class="line">不记录中间结果，只记录中间项，空间复杂度降到O(1)</span><br><span class="line"></span><br><span class="line">    Fib3(intn)</span><br><span class="line">    &#123;</span><br><span class="line">        inti,s1,s2;</span><br><span class="line">        if(n&lt;1)</span><br><span class="line">            return-1;</span><br><span class="line">        if(n==1||n==2)</span><br><span class="line">            return1;</span><br><span class="line">        s1=1;s2=1;</span><br><span class="line">        for(i=3;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2=s1+s2;//辗转相加法</span><br><span class="line">            s1=s2-s1;//记录前一项</span><br><span class="line">        &#125;</span><br><span class="line">        return s2;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">## 矩阵乘法</span><br><span class="line"></span><br><span class="line">```斐波那契数列(F(n),F(n-1))为(1,1)与&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;的n-2次幂的乘积, 可通过递推求证</span><br></pre></td></tr></table></figure>
<pre><code>public static int ValueN(int n){
      if(n&lt;1){
          return 0;
      }
      if(n==1 || n==2){
          return 1;
      }
       int [][] base={{1,1},{1,0}};
       int [][] res=matrixPower(base,n-2);
       return res[0][0]+res[1][0];
    }
    public static int[][] matrixPower(int[][] m,int p){
        if(p==0)
            return null;
        if(p==1)
            return m;
        int[][] res=matrixPower(m,p&gt;&gt;1);
        res=muliMatrix(res,res);
        if((p&amp;1)==1){
            res=muliMatrix(res,m);
        }
        return res;
    }
    //求两个矩阵相乘得到一个新的矩阵
    public static int[][] muliMatrix(int[][] m1,int[][] m2){
        int [][] res=new int[m1.length][m2[0].length];
        for(int i=0;i&lt;m1.length;i++){
            for(int j=0;j&lt;m2[0].length;j++){
                for(int k=0;k&lt;m2.length;k++){
                    res[i][j]+=m1[i][k]*m2[k][j];
                }
            }
        }
        return res;
    }
}
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Meng Qi</p>
              <p class="site-description motion-element" itemprop="description">recording</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
