<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="recording">
<meta name="keywords" content="Tech;Data;Vision">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qi">
<meta name="twitter:description" content="recording">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.fastolf.com/">





  <title>Qi</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">to learn</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/红黑树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/红黑树/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T22:16:48+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>红黑树是特殊的二叉查找树</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 （这里叶子节点，是指为空的叶子节点！）</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注：确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

    }

    ...
}

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

    }

    ...
}

/* 
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                              px
 *     /                               /
 *    x                               y                
 *   /  \      --(左旋)-.           / \                #
 *  lx   y                          x  ry     
 *     /   \                       /  \
 *    ly   ry                     lx  ly  
 *
 *
 */
private void leftRotate(RBTNode&lt;T&gt; x) {
    // 设置x的右孩子为y
    RBTNode&lt;T&gt; y = x.right;

    // 将 “y的左孩子” 设为 “x的右孩子”；
    // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
    x.right = y.left;
    if (y.left != null)
        y.left.parent = x;

    // 将 “x的父亲” 设为 “y的父亲”
    y.parent = x.parent;

    if (x.parent == null) {
        this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
    } else {
        if (x.parent.left == x)
            x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        else
            x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
    }

    // 将 “x” 设为 “y的左孩子”
    y.left = x;
    // 将 “x的父节点” 设为 “y”
    x.parent = y;
}

/* 
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x                  
 *         /  \      --(右旋)-.            /  \                     #
 *        x   ry                           lx   y  
 *       / \                                   / \                   #
 *      lx  rx                                rx  ry
 * 
 */
private void rightRotate(RBTNode&lt;T&gt; y) {
    // 设置x是当前节点的左孩子。
    RBTNode&lt;T&gt; x = y.left;

    // 将 “x的右孩子” 设为 “y的左孩子”；
    // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
    y.left = x.right;
    if (x.right != null)
        x.right.parent = y;

    // 将 “y的父亲” 设为 “x的父亲”
    x.parent = y.parent;

    if (y.parent == null) {
        this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
    } else {
        if (y == y.parent.right)
            y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
        else
            y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
    }

    // 将 “y” 设为 “x的右孩子”
    x.right = y;

    // 将 “y的父节点” 设为 “x”
    y.parent = x;
}

/* 
 * 将结点插入到红黑树中
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的node
 */
private void insert(RBTNode&lt;T&gt; node) {
    int cmp;
    RBTNode&lt;T&gt; y = null;
    RBTNode&lt;T&gt; x = this.mRoot;

    // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
    while (x != null) {
        y = x;
        cmp = node.key.compareTo(x.key);
        if (cmp &lt; 0)
            x = x.left;
        else
            x = x.right;
    }

    node.parent = y;
    if (y!=null) {
        cmp = node.key.compareTo(y.key);
        if (cmp &lt; 0)
            y.left = node;
        else
            y.right = node;
    } else {
        this.mRoot = node;
    }

    // 2. 设置节点的颜色为红色
    node.color = RED;

    // 3. 将它重新修正为一颗二叉查找树
    insertFixUp(node);
}

/* 
 * 新建结点(key)，并将其插入到红黑树中
 *
 * 参数说明：
 *     key 插入结点的键值
 */
public void insert(T key) {
    RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

    // 如果新建结点失败，则返回。
    if (node != null)
        insert(node);
}


/*
 * 红黑树插入修正函数
 *
 * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的z
 */
private void insertFixUp(RBTNode&lt;T&gt; node) {
    RBTNode&lt;T&gt; parent, gparent;

    // 若“父节点存在，并且父节点的颜色是红色”
    while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) {
        gparent = parentOf(parent);

        //若“父节点”是“祖父节点的左孩子”
        if (parent == gparent.left) {
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.right;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            }

            // Case 2条件：叔叔是黑色，且当前节点是右孩子
            if (parent.right == node) {
                RBTNode&lt;T&gt; tmp;
                leftRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是左孩子。
            setBlack(parent);
            setRed(gparent);
            rightRotate(gparent);
        } else {    //若“z的父节点”是“z的祖父节点的右孩子”
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.left;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            }

            // Case 2条件：叔叔是黑色，且当前节点是左孩子
            if (parent.left == node) {
                RBTNode&lt;T&gt; tmp;
                rightRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是右孩子。
            setBlack(parent);
            setRed(gparent);
            leftRotate(gparent);
        }
    }

    // 将根节点设为黑色
    setBlack(this.mRoot);
}


/* 
 * 删除结点(node)，并返回被删除的结点
 *
 * 参数说明：
 *     node 删除的结点
 */
private void remove(RBTNode&lt;T&gt; node) {
    RBTNode&lt;T&gt; child, parent;
    boolean color;

    // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
    if ( (node.left!=null) &amp;&amp; (node.right!=null) ) {
        // 被删节点的后继节点。(称为&quot;取代节点&quot;)
        // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
        RBTNode&lt;T&gt; replace = node;

        // 获取后继节点
        replace = replace.right;
        while (replace.left != null)
            replace = replace.left;

        // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
        if (parentOf(node)!=null) {
            if (parentOf(node).left == node)
                parentOf(node).left = replace;
            else
                parentOf(node).right = replace;
        } else {
            // &quot;node节点&quot;是根节点，更新根节点。
            this.mRoot = replace;
        }

        // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
        // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
        child = replace.right;
        parent = parentOf(replace);
        // 保存&quot;取代节点&quot;的颜色
        color = colorOf(replace);

        // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
        if (parent == node) {
            parent = replace;
        } else {
            // child不为空
            if (child!=null)
                setParent(child, parent);
            parent.left = child;

            replace.right = node.right;
            setParent(node.right, replace);
        }

        replace.parent = node.parent;
        replace.color = node.color;
        replace.left = node.left;
        node.left.parent = replace;

        if (color == BLACK)
            removeFixUp(child, parent);

        node = null;
        return ;
    }

    if (node.left !=null) {
        child = node.left;
    } else {
        child = node.right;
    }

    parent = node.parent;
    // 保存&quot;取代节点&quot;的颜色
    color = node.color;

    if (child!=null)
        child.parent = parent;

    // &quot;node节点&quot;不是根节点
    if (parent!=null) {
        if (parent.left == node)
            parent.left = child;
        else
            parent.right = child;
    } else {
        this.mRoot = child;
    }

    if (color == BLACK)
        removeFixUp(child, parent);
    node = null;
}

/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 红黑树的根结点
 *     z 删除的结点
 */
public void remove(T key) {
    RBTNode&lt;T&gt; node; 

    if ((node = search(mRoot, key)) != null)
        remove(node);
}



/*
 * 红黑树删除修正函数
 *
 * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 待修正的节点
 */
private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
    RBTNode&lt;T&gt; other;

    while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) {
        if (parent.left == node) {
            other = parent.right;
            if (isRed(other)) {
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                leftRotate(parent);
                other = parent.right;
            }

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) {
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            } else {

                if (other.right==null || isBlack(other.right)) {
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.left);
                    setRed(other);
                    rightRotate(other);
                    other = parent.right;
                }
                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.right);
                leftRotate(parent);
                node = this.mRoot;
                break;
            }
        } else {

            other = parent.left;
            if (isRed(other)) {
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                rightRotate(parent);
                other = parent.left;
            }

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) {
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            } else {

                if (other.left==null || isBlack(other.left)) {
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.right);
                    setRed(other);
                    leftRotate(other);
                    other = parent.left;
                }

                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.left);
                rightRotate(parent);
                node = this.mRoot;
                break;
            }
        }
    }

    if (node!=null)
        setBlack(node);
}
</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>/**
 * Java 语言: 红黑树
 *
 * @author skywang
 * @date 2013/11/07
 */

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public T getKey() {
            return key;
        }

        public String toString() {
            return &quot;&quot;+key+(this.color==RED?&quot;(R)&quot;:&quot;B&quot;);
        }
    }

    public RBTree() {
        mRoot=null;
    }

    private RBTNode&lt;T&gt; parentOf(RBTNode&lt;T&gt; node) {
        return node!=null ? node.parent : null;
    }
    private boolean colorOf(RBTNode&lt;T&gt; node) {
        return node!=null ? node.color : BLACK;
    }
    private boolean isRed(RBTNode&lt;T&gt; node) {
        return ((node!=null)&amp;&amp;(node.color==RED)) ? true : false;
    }
    private boolean isBlack(RBTNode&lt;T&gt; node) {
        return !isRed(node);
    }
    private void setBlack(RBTNode&lt;T&gt; node) {
        if (node!=null)
            node.color = BLACK;
    }
    private void setRed(RBTNode&lt;T&gt; node) {
        if (node!=null)
            node.color = RED;
    }
    private void setParent(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
        if (node!=null)
            node.parent = parent;
    }
    private void setColor(RBTNode&lt;T&gt; node, boolean color) {
        if (node!=null)
            node.color = color;
    }

    /*
     * 前序遍历&quot;红黑树&quot;
     */
    private void preOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null) {
            System.out.print(tree.key+&quot; &quot;);
            preOrder(tree.left);
            preOrder(tree.right);
        }
    }

    public void preOrder() {
        preOrder(mRoot);
    }

    /*
     * 中序遍历&quot;红黑树&quot;
     */
    private void inOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null) {
            inOrder(tree.left);
            System.out.print(tree.key+&quot; &quot;);
            inOrder(tree.right);
        }
    }

    public void inOrder() {
        inOrder(mRoot);
    }


    /*
     * 后序遍历&quot;红黑树&quot;
     */
    private void postOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null)
        {
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.key+&quot; &quot;);
        }
    }

    public void postOrder() {
        postOrder(mRoot);
    }


    /*
     * (递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; search(RBTNode&lt;T&gt; x, T key) {
        if (x==null)
            return x;

        int cmp = key.compareTo(x.key);
        if (cmp &lt; 0)
            return search(x.left, key);
        else if (cmp &gt; 0)
            return search(x.right, key);
        else
            return x;
    }

    public RBTNode&lt;T&gt; search(T key) {
        return search(mRoot, key);
    }

    /*
     * (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; iterativeSearch(RBTNode&lt;T&gt; x, T key) {
        while (x!=null) {
            int cmp = key.compareTo(x.key);

            if (cmp &lt; 0) 
                x = x.left;
            else if (cmp &gt; 0) 
                x = x.right;
            else
                return x;
        }

        return x;
    }

    public RBTNode&lt;T&gt; iterativeSearch(T key) {
        return iterativeSearch(mRoot, key);
    }

    /* 
     * 查找最小结点：返回tree为根结点的红黑树的最小结点。
     */
    private RBTNode&lt;T&gt; minimum(RBTNode&lt;T&gt; tree) {
        if (tree == null)
            return null;

        while(tree.left != null)
            tree = tree.left;
        return tree;
    }

    public T minimum() {
        RBTNode&lt;T&gt; p = minimum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /* 
     * 查找最大结点：返回tree为根结点的红黑树的最大结点。
     */
    private RBTNode&lt;T&gt; maximum(RBTNode&lt;T&gt; tree) {
        if (tree == null)
            return null;

        while(tree.right != null)
            tree = tree.right;
        return tree;
    }

    public T maximum() {
        RBTNode&lt;T&gt; p = maximum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /* 
     * 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。
     */
    public RBTNode&lt;T&gt; successor(RBTNode&lt;T&gt; x) {
        // 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。
        if (x.right != null)
            return minimum(x.right);

        // 如果x没有右孩子。则x有以下两种可能：
        // (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。
        // (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.right)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /* 
     * 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。
     */
    public RBTNode&lt;T&gt; predecessor(RBTNode&lt;T&gt; x) {
        // 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。
        if (x.left != null)
            return maximum(x.left);

        // 如果x没有左孩子。则x有以下两种可能：
        // (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。
        // (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.left)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /* 
     * 对红黑树的节点(x)进行左旋转
     *
     * 左旋示意图(对节点x进行左旋)：
     *      px                              px
     *     /                               /
     *    x                               y                
     *   /  \      --(左旋)-.           / \                #
     *  lx   y                          x  ry     
     *     /   \                       /  \
     *    ly   ry                     lx  ly  
     *
     *
     */
    private void leftRotate(RBTNode&lt;T&gt; x) {
        // 设置x的右孩子为y
        RBTNode&lt;T&gt; y = x.right;

        // 将 “y的左孩子” 设为 “x的右孩子”；
        // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
        x.right = y.left;
        if (y.left != null)
            y.left.parent = x;

        // 将 “x的父亲” 设为 “y的父亲”
        y.parent = x.parent;

        if (x.parent == null) {
            this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
        } else {
            if (x.parent.left == x)
                x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
            else
                x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        }

        // 将 “x” 设为 “y的左孩子”
        y.left = x;
        // 将 “x的父节点” 设为 “y”
        x.parent = y;
    }

    /* 
     * 对红黑树的节点(y)进行右旋转
     *
     * 右旋示意图(对节点y进行左旋)：
     *            py                               py
     *           /                                /
     *          y                                x                  
     *         /  \      --(右旋)-.            /  \                     #
     *        x   ry                           lx   y  
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     * 
     */
    private void rightRotate(RBTNode&lt;T&gt; y) {
        // 设置x是当前节点的左孩子。
        RBTNode&lt;T&gt; x = y.left;

        // 将 “x的右孩子” 设为 “y的左孩子”；
        // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
        y.left = x.right;
        if (x.right != null)
            x.right.parent = y;

        // 将 “y的父亲” 设为 “x的父亲”
        x.parent = y.parent;

        if (y.parent == null) {
            this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
        } else {
            if (y == y.parent.right)
                y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
            else
                y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
        }

        // 将 “y” 设为 “x的右孩子”
        x.right = y;

        // 将 “y的父节点” 设为 “x”
        y.parent = x;
    }

    /*
     * 红黑树插入修正函数
     *
     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的z
     */
    private void insertFixUp(RBTNode&lt;T&gt; node) {
        RBTNode&lt;T&gt; parent, gparent;

        // 若“父节点存在，并且父节点的颜色是红色”
        while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) {
            gparent = parentOf(parent);

            //若“父节点”是“祖父节点的左孩子”
            if (parent == gparent.left) {
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.right;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是右孩子
                if (parent.right == node) {
                    RBTNode&lt;T&gt; tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是左孩子。
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            } else {    //若“z的父节点”是“z的祖父节点的右孩子”
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.left;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是左孩子
                if (parent.left == node) {
                    RBTNode&lt;T&gt; tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是右孩子。
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            }
        }

        // 将根节点设为黑色
        setBlack(this.mRoot);
    }

    /* 
     * 将结点插入到红黑树中
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的node
     */
    private void insert(RBTNode&lt;T&gt; node) {
        int cmp;
        RBTNode&lt;T&gt; y = null;
        RBTNode&lt;T&gt; x = this.mRoot;

        // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
        while (x != null) {
            y = x;
            cmp = node.key.compareTo(x.key);
            if (cmp &lt; 0)
                x = x.left;
            else
                x = x.right;
        }

        node.parent = y;
        if (y!=null) {
            cmp = node.key.compareTo(y.key);
            if (cmp &lt; 0)
                y.left = node;
            else
                y.right = node;
        } else {
            this.mRoot = node;
        }

        // 2. 设置节点的颜色为红色
        node.color = RED;

        // 3. 将它重新修正为一颗二叉查找树
        insertFixUp(node);
    }

    /* 
     * 新建结点(key)，并将其插入到红黑树中
     *
     * 参数说明：
     *     key 插入结点的键值
     */
    public void insert(T key) {
        RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

        // 如果新建结点失败，则返回。
        if (node != null)
            insert(node);
    }


    /*
     * 红黑树删除修正函数
     *
     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 待修正的节点
     */
    private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
        RBTNode&lt;T&gt; other;

        while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) {
            if (parent.left == node) {
                other = parent.right;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.right==null || isBlack(other.right)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node = this.mRoot;
                    break;
                }
            } else {

                other = parent.left;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.left==null || isBlack(other.left)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }

                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node = this.mRoot;
                    break;
                }
            }
        }

        if (node!=null)
            setBlack(node);
    }

    /* 
     * 删除结点(node)，并返回被删除的结点
     *
     * 参数说明：
     *     node 删除的结点
     */
    private void remove(RBTNode&lt;T&gt; node) {
        RBTNode&lt;T&gt; child, parent;
        boolean color;

        // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
        if ( (node.left!=null) &amp;&amp; (node.right!=null) ) {
            // 被删节点的后继节点。(称为&quot;取代节点&quot;)
            // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
            RBTNode&lt;T&gt; replace = node;

            // 获取后继节点
            replace = replace.right;
            while (replace.left != null)
                replace = replace.left;

            // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
            if (parentOf(node)!=null) {
                if (parentOf(node).left == node)
                    parentOf(node).left = replace;
                else
                    parentOf(node).right = replace;
            } else {
                // &quot;node节点&quot;是根节点，更新根节点。
                this.mRoot = replace;
            }

            // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
            // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
            child = replace.right;
            parent = parentOf(replace);
            // 保存&quot;取代节点&quot;的颜色
            color = colorOf(replace);

            // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
            if (parent == node) {
                parent = replace;
            } else {
                // child不为空
                if (child!=null)
                    setParent(child, parent);
                parent.left = child;

                replace.right = node.right;
                setParent(node.right, replace);
            }

            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;

            if (color == BLACK)
                removeFixUp(child, parent);

            node = null;
            return ;
        }

        if (node.left !=null) {
            child = node.left;
        } else {
            child = node.right;
        }

        parent = node.parent;
        // 保存&quot;取代节点&quot;的颜色
        color = node.color;

        if (child!=null)
            child.parent = parent;

        // &quot;node节点&quot;不是根节点
        if (parent!=null) {
            if (parent.left == node)
                parent.left = child;
            else
                parent.right = child;
        } else {
            this.mRoot = child;
        }

        if (color == BLACK)
            removeFixUp(child, parent);
        node = null;
    }

    /* 
     * 删除结点(z)，并返回被删除的结点
     *
     * 参数说明：
     *     tree 红黑树的根结点
     *     z 删除的结点
     */
    public void remove(T key) {
        RBTNode&lt;T&gt; node; 

        if ((node = search(mRoot, key)) != null)
            remove(node);
    }

    /*
     * 销毁红黑树
     */
    private void destroy(RBTNode&lt;T&gt; tree) {
        if (tree==null)
            return ;

        if (tree.left != null)
            destroy(tree.left);
        if (tree.right != null)
            destroy(tree.right);

        tree=null;
    }

    public void clear() {
        destroy(mRoot);
        mRoot = null;
    }

    /*
     * 打印&quot;红黑树&quot;
     *
     * key        -- 节点的键值 
     * direction  --  0，表示该节点是根节点;
     *               -1，表示该节点是它的父结点的左孩子;
     *                1，表示该节点是它的父结点的右孩子。
     */
    private void print(RBTNode&lt;T&gt; tree, T key, int direction) {

        if(tree != null) {

            if(direction==0)    // tree是根节点
                System.out.printf(&quot;%2d(B) is root\n&quot;, tree.key);
            else                // tree是分支节点
                System.out.printf(&quot;%2d(%s) is %2d&apos;s %6s child\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction==1?&quot;right&quot; : &quot;left&quot;);

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        }
    }

    public void print() {
        if (mRoot != null)
            print(mRoot, mRoot.key, 0);
    }
}

/**
 * Java 语言: 二叉查找树
 *
 * @author skywang
 * @date 2013/11/07
 */
public class RBTreeTest {

    private static final int a[] = {10, 40, 30, 60, 90, 70, 20, 50, 80};
    private static final boolean mDebugInsert = false;    // &quot;插入&quot;动作的检测开关(false，关闭；true，打开)
    private static final boolean mDebugDelete = false;    // &quot;删除&quot;动作的检测开关(false，关闭；true，打开)

    public static void main(String[] args) {
        int i, ilen = a.length;
        RBTree&lt;Integer&gt; tree=new RBTree&lt;Integer&gt;();

        System.out.printf(&quot;== 原始数据: &quot;);
        for(i=0; i&lt;ilen; i++)
            System.out.printf(&quot;%d &quot;, a[i]);
        System.out.printf(&quot;\n&quot;);

        for(i=0; i&lt;ilen; i++) {
            tree.insert(a[i]);
            // 设置mDebugInsert=true,测试&quot;添加函数&quot;
            if (mDebugInsert) {
                System.out.printf(&quot;== 添加节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            }
        }

        System.out.printf(&quot;== 前序遍历: &quot;);
        tree.preOrder();

        System.out.printf(&quot;\n== 中序遍历: &quot;);
        tree.inOrder();

        System.out.printf(&quot;\n== 后序遍历: &quot;);
        tree.postOrder();
        System.out.printf(&quot;\n&quot;);

        System.out.printf(&quot;== 最小值: %s\n&quot;, tree.minimum());
        System.out.printf(&quot;== 最大值: %s\n&quot;, tree.maximum());
        System.out.printf(&quot;== 树的详细信息: \n&quot;);
        tree.print();
        System.out.printf(&quot;\n&quot;);

        // 设置mDebugDelete=true,测试&quot;删除函数&quot;
        if (mDebugDelete) {
            for(i=0; i&lt;ilen; i++)
            {
                tree.remove(a[i]);

                System.out.printf(&quot;== 删除节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            }
        }

        // 销毁二叉树
        tree.clear();
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/深度广度优先/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/深度广度优先/" itemprop="url">深度优先广度优先</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T22:12:33+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点压入栈中，stack（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）；</p>
</li>
<li><p>将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）；</p>
</li>
<li><p>将E节点弹出，同时将E的子节点I压入，stack（I,C）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void depthFirst() {

    Stack&lt;Map&lt;String, Object&gt;&gt; nodeStack = new Stack&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeStack.add(node);

    while (!nodeStack.isEmpty()) {

        node = nodeStack.pop();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) {

            for (Map child : children) {

                nodeStack.push(child);

            }

        }

    }

}
</code></pre><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p> 广度优先遍历各个节点，需要使用到队列（Queue）这种数据结构，queue的特点是先进先出，其实也可以使用双端队列，区别就是双端队列首尾都可以插入和弹出节点。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点插入队列中，queue（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;</p>
</li>
<li><p>将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；</p>
</li>
<li><p>将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void breadthFirst() {

    Deque&lt;Map&lt;String, Object&gt;&gt; nodeDeque = new ArrayDeque&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeDeque.add(node);

    while (!nodeDeque.isEmpty()) {

        node = nodeDeque.peekFirst();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) {

            for (Map child : children) {

                nodeDeque.add(child);

            }

        }

    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/234树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/234树/" itemprop="url">234树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T21:57:12+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>平衡树，子节点数目可以达到4个</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p>若父节点中存有1个数据项，则必有2个子节点。</p>
</li>
<li><p>若父节点中存有2个数据项，则必有3个子节点。</p>
</li>
<li><p>若父节点中存有3个数据项，则必有4个子节点。</p>
</li>
</ol>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>插入数据：</p>
<ul>
<li><p>未满节点直接插入</p>
</li>
<li><p>满节点 ABC 分裂 A不变 B到父节点 C到右侧</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Node
{
private static final int ORDER = 4;
private int numItems;//节点中实际存储的数据项数目，其值一定不大于3
private Node parent;
private Node childArray[] = new Node[ORDER];//子节点数组
private DataItem itemArray[] = new DataItem[ORDER-1];//存储数据项数组
//-------------------------------------------------------------
// 把参数中的节点作为子节点，与当前节点进行连接
public void connectChild(int childNum, Node child)
   {
   childArray[childNum] = child;
   if(child != null)
      child.parent = this;//当前节点作为父节点
   }
//-------------------------------------------------------------
// 断开参数确定的节点与当前节点的连接，这个节点一定是当前节点的子节点。
public Node disconnectChild(int childNum)
   {
   Node tempNode = childArray[childNum];
   childArray[childNum] = null; //断开连接
   return tempNode;//返回要这个子节点
   }
//-------------------------------------------------------------
public Node getChild(int childNum)//获取相应的子节点
   { return childArray[childNum]; }
//-------------------------------------------------------------
public Node getParent()//获取父节点
   { return parent; }
//-------------------------------------------------------------
public boolean isLeaf()//是否是叶结点
   { return (childArray[0]==null) ? true : false; }//叶结点没有子节点
//-------------------------------------------------------------
public int getNumItems()//获取实际存储的数据项数目
  { return numItems; }
//-------------------------------------------------------------
public DataItem getItem(int index)   // 获取具体的数据项
   { return itemArray[index]; }
//-------------------------------------------------------------
public boolean isFull()//该节点是否已满
   { return (numItems==ORDER-1) ? true : false; }
//-------------------------------------------------------------
public int findItem(long key)       // 查找
   {                                    
   for(int j=0; j&lt;ORDER-1; j++)         // 遍历数组
      {                                 
      if(itemArray[j] == null)          // 数组未满，未找到
         break;
      else if(itemArray[j].dData == key)
         return j;
      }
   return -1;
   }  // end findItem
//-------------------------------------------------------------
public int insertItem(DataItem newItem)//节点未满的插入
   {
   numItems++;                          
   long newKey = newItem.dData;         // 获得关键字

   for(int j=ORDER-2; j&gt;=0; j--)        // 因为节点未满，所以从倒数第二项向前查找
      {                              
      if(itemArray[j] == null)          // 没存数据
         continue;                      
      else                              
         {                              
         long itsKey = itemArray[j].dData;//获得关键字
         if(newKey &lt; itsKey)            //插入位置在其前面，但未必相邻
            itemArray[j+1] = itemArray[j]; //当前数据项后移
         else
            {
            itemArray[j+1] = newItem;   // 在其后位置插入
            return j+1;                 // 返回插入的位置下标
            }                           //    new item
         }  // end else (not null)
      }  // end for                     // shifted all items,
   //若上述代码没有执行返回操作，那么这是空节点（只有初始时根是这个情况）
   itemArray[0] = newItem;              // insert new item
   return 0;
   }  // end insertItem()
//-------------------------------------------------------------
public DataItem removeItem()        // 移除数据项，从后向前移除
   {
   // 假设节点非空
   DataItem temp = itemArray[numItems-1];  // 要移除的数据项
   itemArray[numItems-1] = null;           // 移除
   numItems--;                             // 数据项数目减一
   return temp;                            // 返回要移除的数据项
   }
//-------------------------------------------------------------
public void displayNode()           // format &quot;/24/56/74/&quot;
   {
   for(int j=0; j&lt;numItems; j++)
      itemArray[j].displayItem();   // &quot;/56&quot;
   System.out.println(&quot;/&quot;);         // final &quot;/&quot;
   }
//-------------------------------------------------------------
}  // end class Node
////////////////////////////////////////////////////////////////


class Tree234
{
private Node root = new Node();            // 创建树的根
//-------------------------------------------------------------
//获取查找的下一个节点
public Node getNextChild(Node theNode, long theValue)
{
int j;
// 假设这个节点不是叶结点
int numItems = theNode.getNumItems();//获得当前节点的数据项数目
for(j=0; j&lt;numItems; j++)          
   {                             
   if( theValue &lt; theNode.getItem(j).dData )
      return theNode.getChild(j);  // 返回相应的节点
   }  // end for                   
return theNode.getChild(j);        // 此时j=numItems
}
//-------------------------------------------------------------
public int find(long key)
   {
   Node curNode = root;
   int childNumber;
   while(true)
      {
      if(( childNumber=curNode.findItem(key) ) != -1)//每次循环这句一定执行
         return childNumber;               // found it
      else if( curNode.isLeaf() )//叶结点上也没找到
         return -1;                        // can&apos;t find it
      else                                 // 不是叶结点，则继续向下查找
         curNode = getNextChild(curNode, key);
      }  // end while
   }
//-------------------------------------------------------------
// 插入数据项
public void insert(long dValue)
   {
   Node curNode = root;//当前节点标志
   DataItem tempItem = new DataItem(dValue);//插入数据项封装

   while(true)
      {
      if( curNode.isFull() )               // 是满节点
         {
         split(curNode);                   // 分裂
         curNode = curNode.getParent();    // 回到分裂出的父节点上
                                           // 继续向下查找
         curNode = getNextChild(curNode, dValue);
         }  // end if(node is full)
//后面的操作中节点都未满，否则先执行上面的代码
      else if( curNode.isLeaf() )          // 是叶结点，非满
         break;                            // 跳出，直接插入

      else
         curNode = getNextChild(curNode, dValue);//向下查找
      }  // end while

   curNode.insertItem(tempItem);       // 此时节点一定不满，直接插入数据项，
   }  // end insert()
//-------------------------------------------------------------
public void split(Node thisNode)     // 分裂
   {
   // 操作中节点一定是满节点，否则不会执行该操作
   DataItem itemB, itemC;
   Node parent, child2, child3;
   int itemIndex;

   itemC = thisNode.removeItem();    // 移除最右边的两个数据项，并保存为B和C
   itemB = thisNode.removeItem();    // 
   child2 = thisNode.disconnectChild(2); // //断开最右边两个子节点的链接
   child3 = thisNode.disconnectChild(3); // 

   Node newRight = new Node();       //新建一个节点，作为当前节点的兄弟节点

   if(thisNode==root)                // 是根
      {
      root = new Node();                // 新建一个根
      parent = root;                    // 把新根设为父节点
      root.connectChild(0, thisNode);   // 连接父节点和子节点
      }
   else                              // 不是根
      parent = thisNode.getParent();    // 获取父节点


   itemIndex = parent.insertItem(itemB); // 把B插入父节点中，返回插入位置
   int n = parent.getNumItems();         // 获得总数据项数目

   for(int j=n-1; j&gt;itemIndex; j--)          //从后向前移除
      {                                    
      Node temp = parent.disconnectChild(j); // 断开连接
      parent.connectChild(j+1, temp);        // 连接到新的位置
      }

   parent.connectChild(itemIndex+1, newRight);//连接到新位置

   // 处理兄弟节点
   newRight.insertItem(itemC);       // 将C放入兄弟节点中
   newRight.connectChild(0, child2); // 把子节点中最右边的两个连接到兄弟节点上
   newRight.connectChild(1, child3); //
   }  // end split()
//-------------------------------------------------------------
// gets appropriate child of node during search for value

public void displayTree()
   {
   recDisplayTree(root, 0, 0);
   }
//-------------------------------------------------------------
private void recDisplayTree(Node thisNode, int level,
                                           int childNumber)
   {
   System.out.print(&quot;level=&quot;+level+&quot; child=&quot;+childNumber+&quot; &quot;);
   thisNode.displayNode();               // display this node

   // call ourselves for each child of this node
   int numItems = thisNode.getNumItems();
   for(int j=0; j&lt;numItems+1; j++)
      {
      Node nextNode = thisNode.getChild(j);
      if(nextNode != null)
         recDisplayTree(nextNode, level+1, j);
      else
         return;
      }
   }  // end recDisplayTree()
//-------------------------------------------------------------\
}  // end class Tree234
////////////////////////////////////////////////////////////////


import java.io.*;

class Tree234App
{
public static void main(String[] args) throws IOException
   {
   long value;
   Tree234 theTree = new Tree234();

   theTree.insert(50);
   theTree.insert(40);
   theTree.insert(60);
   theTree.insert(30);
   theTree.insert(70);

   while(true)
      {
      System.out.print(&quot;Enter first letter of &quot;);
      System.out.print(&quot;show, insert, or find: &quot;);
      char choice = getChar();
      switch(choice)
         {
         case &apos;s&apos;:
            theTree.displayTree();
            break;
         case &apos;i&apos;:
            System.out.print(&quot;Enter value to insert: &quot;);
            value = getInt();
            theTree.insert(value);
            break;
         case &apos;f&apos;:
            System.out.print(&quot;Enter value to find: &quot;);
            value = getInt();
            int found = theTree.find(value);
            if(found != -1)
               System.out.println(&quot;Found &quot;+value);
            else
               System.out.println(&quot;Could not find &quot;+value);
            break;
         default:
            System.out.print(&quot;Invalid entry\n&quot;);
         }  // end switch
      }  // end while
   }  // end main()
//--------------------------------------------------------------
public static String getString() throws IOException
   {
   InputStreamReader isr = new InputStreamReader(System.in);
   BufferedReader br = new BufferedReader(isr);
   String s = br.readLine();
   return s;
   }
//--------------------------------------------------------------
public static char getChar() throws IOException
   {
   String s = getString();
   return s.charAt(0);
   }

//-------------------------------------------------------------
public static int getInt() throws IOException
   {
   String s = getString();
   return Integer.parseInt(s);
   }
//-------------------------------------------------------------
}  // end class Tree234App
////////////////////////////////////////////////////////////////
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/13/中文分词/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/中文分词/" itemprop="url">中文分词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T10:38:02+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>基于字典、词库匹配</li>
<li>基于词频度统计</li>
<li>基于知识理解</li>
</ul>
<h2 id="字典、词库匹配"><a href="#字典、词库匹配" class="headerlink" title="字典、词库匹配"></a>字典、词库匹配</h2><p>中文复杂、丰富，词典、词库匹配无法有效处理大规模文本分词处理</p>
<ol>
<li>逐词遍历法：全字典遍历一遍，效率低，不适用于大系统</li>
<li>机械分词法</li>
</ol>
<h3 id="最大正向匹配法"><a href="#最大正向匹配法" class="headerlink" title="最大正向匹配法"></a>最大正向匹配法</h3><p>假定词典词最大长度为i,被处理文档的当前字串中的前i个字作为匹配字段，匹配成功，则切分出来，匹配失败，则i-1，继续匹配，若成功则i+1，知道文档处理完成</p>
<h3 id="逆向最大匹配法"><a href="#逆向最大匹配法" class="headerlink" title="逆向最大匹配法"></a>逆向最大匹配法</h3><p>文档逆序处理，通过逆序词典匹配，汉语中偏正结构较多，若从后向前匹配，可以适当提高精确度，逆向最大匹配法比正向最大匹配法的误差要小</p>
<h3 id="最少切分法"><a href="#最少切分法" class="headerlink" title="最少切分法"></a>最少切分法</h3><p>使每一句中切出的词数最小</p>
<h3 id="双向匹配法"><a href="#双向匹配法" class="headerlink" title="双向匹配法"></a>双向匹配法</h3><p>将正向最大匹配法与逆向最大匹配法组合，如果两种分词方法得到的匹配结果相同，则认为分词正确，否则，按最小集处理</p>
<h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>考虑到相邻字词关系、词频、共现信息，有较好的实用性</p>
<h3 id="全切分和基于词的频度统计的分词方法"><a href="#全切分和基于词的频度统计的分词方法" class="headerlink" title="全切分和基于词的频度统计的分词方法"></a>全切分和基于词的频度统计的分词方法</h3><p>基于词的频度统计的分词方法是一种全切分方法</p>
<p>全切分要求获得输入序列的所有可接受的切分形式，而部分切分只取得一种或几种可接受的切分形式，由于部分切分忽略了可能的其他切分形式，所以建立在部分切分基础上的分词方法不管采取何种歧义纠正策略，都可能会遗漏正确的切分，造成分词错误或失败。而建立在全切分基础上的分词方法，由于全切分取得了所有可能的切分形式，因而从根本上避免了可能切分形式的遗漏，克服了部分切分方法的缺陷。</p>
<p>问题：</p>
<ol>
<li><p>全切分算法只是能获得正确分词的前提，因为全切分不具有歧义检测功能，最终分词结果的正确性和完全性依赖于独立的歧义处理方法，如果评测有误，也会造成错误的结果。</p>
</li>
<li><p>全切分的切分结果个数随句子长度的增长呈指数增长，一方面将导致庞大的无用数据充斥于存储数据库；另一方面当句长达到一定长度后，由于切分形式过多,造成分词效率严重下降。</p>
</li>
</ol>
<p>解决方案：</p>
<p>基于词的频度统计的分词方法：</p>
<p>这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。</p>
<h2 id="基于知识理解"><a href="#基于知识理解" class="headerlink" title="基于知识理解"></a>基于知识理解</h2><p>基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。</p>
<h2 id="并行分词方法"><a href="#并行分词方法" class="headerlink" title="并行分词方法"></a>并行分词方法</h2><p>并行分词方法：这种分词方法借助于一个含有分词词库的管道进行 ,比较匹配过程是分步进行的 ,每一步可以对进入管道中的词同时与词库中相应的词进行比较 ,由于同时有多个词进行比较匹配 ,因而分词速度可以大幅度提高。这种方法涉及到多级内码理论和管道的词典数据结构。（详细算法可以参考吴胜远的《并行分词方法的研究》。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/13/redis统计信息/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/redis统计信息/" itemprop="url">redis统计信息--INFO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T10:14:50+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>显示关于redis服务器的状态报告和统计数值</p>
<pre><code>redis&gt; INFO
# Server
redis_version:2.9.11 //服务器版本
redis_git_sha1:937384d0
redis_git_dirty:0
redis_build_id:8e9509442863f22
redis_mode:standalone  //mode
os:Linux 3.13.0-35-generic x86_64
arch_bits:64
multiplexing_api:epoll //事件处理机制
gcc_version:4.8.2
process_id:4716 //进程ID
run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc  //随机标识符（用于 Sentinel 和集群）
tcp_port:6379   //监听端口号
uptime_in_seconds:362  //启动以来，经过的秒数
uptime_in_days:0  //启动以来，经过的天数
hz:10  //serverCron运行频率，此值越大表示redis对&quot;间歇性task&quot;的执行次数越频繁(次数/秒)
lru_clock:1725349  //以分钟为单位进行自增的时钟，用于 LRU 管理
config_file:

# Clients
connected_clients:1  //已连接客户端的数量（不包括通过从属服务器连接的客户端）
client_longest_output_list:0  //当前连接的客户端当中，最长的输出列表
client_biggest_input_buf:0  //当前连接的客户端当中，最大输入缓存
blocked_clients:0 //正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量

# Memory
used_memory:508536  //由 Redis 分配器分配的内存总量，以字节（byte）为单位
used_memory_human:496.62K  //以人类可读的格式返回 Redis 分配的内存总量
used_memory_rss:7974912  //从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。
//理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿  
//当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片
//当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。
used_memory_peak:508536 //Redis 的内存消耗峰值（以字节为单位）
used_memory_peak_human:496.62K //以人类可读的格式返回 Redis 的内存消耗峰值
used_memory_lua:33792  // Lua 引擎所使用的内存大小（以字节为单位）
mem_fragmentation_ratio:15.68  //used_memory_rss 和 used_memory 之间的比率
mem_allocator:jemalloc-3.2.0  //在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc

# Persistence
loading:0  //一个标志值，记录了服务器是否正在载入持久化文件  
rdb_changes_since_last_save:6 //距离最近一次成功创建持久化文件之后，经过了多少秒
rdb_bgsave_in_progress:0 //一个标志值，记录了服务器是否正在创建 RDB 文件
rdb_last_save_time:1411011131 //最近一次成功创建 RDB 文件的 UNIX 时间戳
rdb_last_bgsave_status:ok //一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败
rdb_last_bgsave_time_sec:-1 //记录了最近一次创建 RDB 文件耗费的秒数
rdb_current_bgsave_time_sec:-1 // 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
aof_enabled:0 //标志值，记录了 AOF 是否处于打开状态。
  //如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：    
  // aof_current_size : AOF 文件目前的大小。
  // aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。
  // aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。
  // aof_buffer_length : AOF 缓冲区的大小。
  // aof_rewrite_buffer_length : AOF 重写缓冲区的大小。
  // aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。
  // aof_delayed_fsync : 被延迟的 fsync 调用数量。
aof_rewrite_in_progress:0 //一个标志值，记录了服务器是否正在创建 AOF 文件。
aof_rewrite_scheduled:0 //一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作
aof_last_rewrite_time_sec:-1 //最近一次创建 AOF 文件耗费的时长。
aof_current_rewrite_time_sec:-1 //如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
aof_last_bgrewrite_status:ok //一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。
aof_last_write_status:ok //

# Stats
total_connections_received:2 //服务器已接受的连接请求数量
total_commands_processed:4 //服务器已执行的命令数量
instantaneous_ops_per_sec:0 //服务器每秒钟执行的命令数量
rejected_connections:0 //因为最大客户端数量限制而被拒绝的连接请求数量
sync_full:0 
sync_partial_ok:0 
sync_partial_err:0
expired_keys:0 //因为过期而被自动删除的数据库键数量
evicted_keys:0 //因为最大内存容量限制而被驱逐（evict）的键数量。
keyspace_hits:0 //查找数据库键成功的次数。
keyspace_misses:0 //查找数据库键失败的次数。
pubsub_channels:0 //目前被订阅的频道数量。
pubsub_patterns:0 //目前被订阅的模式数量。
latest_fork_usec:0 //最近一次 fork() 操作耗费的毫秒数。
migrate_cached_sockets:0

# Replication
role:master //如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:0.21  // Redis 服务器耗费的系统 CPU 。
used_cpu_user:0.17  // Redis 服务器耗费的用户 CPU 。
used_cpu_sys_children:0.00 //后台进程耗费的系统 CPU 。
used_cpu_user_children:0.00 //后台进程耗费的用户 CPU 。

# Cluster
cluster_enabled:0  //一个标志值，记录集群功能是否已经开启

# Keyspace
db0:keys=2,expires=0,avg_ttl=0 //部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/10/模型-欠采样过采样/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/10/模型-欠采样过采样/" itemprop="url">欠采样undersampling，过采样oversampling</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-10T19:41:37+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>又称为 上采样  下采样</p>
<h2 id="数据不平衡问题"><a href="#数据不平衡问题" class="headerlink" title="数据不平衡问题"></a>数据不平衡问题</h2><p>默认阈值(比如二分类正反例中0.5)导致模型输出倾向于数据多的类别</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>调整分类阈值，偏向数据少的类别</li>
<li>选择ROC或F1作为评估标准</li>
<li>过采样、欠采样</li>
</ol>
<h3 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h3><p>将样本数量少的类别生成的样本数量和数量多的类别一样多，合成新的样本来缓解类不平衡</p>
<p>注：随机过采样采用简单复制样本增加少数类样本，导致模型不够泛化</p>
<h3 id="欠采样"><a href="#欠采样" class="headerlink" title="欠采样"></a>欠采样</h3><p>从数量多的类别中抽取与等量的样本数据，抛弃一些样本来缓解类不平衡</p>
<h3 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h3><p>经典过采样</p>
<p>人工合成数据（Synthetic Minority Over-sampling Technique）</p>
<p>分析数量较少类别的样本数据，基于“插值”来为少数类合成新样本，并添加到数据集</p>
<ol>
<li>确定采样倍率 N（N为整数，N&gt;=1）</li>
<li>计算少数类 样本x(i)到本样本欧式距离，得到x(i)的k个近邻</li>
<li>随机选择近邻x^, xnew = x + rand(0,1)*(x^-x),重复N次，得到N个新样本</li>
<li>对所有少数类样本x(i)执行1，2操作，合成NT个新样本</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/07/数据结构-常用的树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/数据结构-常用的树/" itemprop="url">树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-07T08:36:10+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>树由根节点(root)和若干子树(T1,T2, … Tm-1)构成的具有层次关系的数据结构。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>节点的度 : 该节点子树个数，度为0的节点为叶子节点，度不为0的节点为分支节点</p>
<p>树的度 : 树中的节点的度最大值为树的度</p>
<p>节点的层次 : 根为第一层，往下依次递增</p>
<p>树的深度 : 节点层次最大值为树的深度</p>
<p>森林 : n棵不相交的树的集合为森林</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>常用于实现二叉查找树、二叉堆</p>
<ul>
<li><p>每个节点至多有两颗子树（树的度&lt;=2）,子树分左右</p>
</li>
<li><p>第i层至多有2i-1个节点，深度为k的二叉树，最多节点数2^k-1个节点（具有最多节点的称作满二叉树），其中每个节点都与深度k满二叉树中1-n节点对应，则为完全二叉树</p>
</li>
</ul>
<p><img src="http://thyrsi.com/t6/626/1544146169x2890211738.jpg" alt="满二叉树"></p>
<p><img src="http://thyrsi.com/t6/626/1544146212x2890211738.jpg" alt="完全二叉树"></p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><ul>
<li>左子树所有节点值小于根节点，右子树所有节点值大于根节点值</li>
<li>左右子树都是二叉排序树</li>
</ul>
<h2 id="二叉平衡树-AVL"><a href="#二叉平衡树-AVL" class="headerlink" title="二叉平衡树 AVL"></a>二叉平衡树 AVL</h2><ul>
<li>左右子树深度差不超过1</li>
<li>左右子树都是二叉平衡树</li>
</ul>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>平衡的多路查找树</p>
<p>B树的阶：所有孩子节点树的最大值（m叉树：每个节点最多m棵子树）</p>
<p>分支节点最少有两颗子树</p>
<p>分支节点包含信息（n，A0，K1，A1，K2，A2，…，Kn，An），其中，n为结点中的关键字树，A为指向子树根结点的指针，K为关键字，且Ai-1所指子树中所有结点的关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/06/synchronized/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/synchronized/" itemprop="url">同步锁-synchronized</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T11:10:56+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>控制Java多线程环境下的线程同步</p>
<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>synchronized修饰方法或者代码块</p>
<h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>synchronized修饰静态方法或者代码块</p>
<h2 id="方法锁（对象锁）"><a href="#方法锁（对象锁）" class="headerlink" title="方法锁（对象锁）"></a>方法锁（对象锁）</h2><p>synchronized修饰方法，锁住的也是这个对象</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public class SynchronizeTest {
    static class S{
        String name;
        public void setName(String name) throws InterruptedException {
            synchronized (this) {
                System.out.println(&quot;..........&quot;);
                Thread.sleep(1000*5L);
                this.name = name;
            }
        }
        public void print(){
            synchronized (this){
                System.out.println(name);
            }
        }
        public synchronized void doSomething1(){
            System.out.println(&quot;doSomething1&quot;);
            try {
                Thread.sleep(1000*5L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        public synchronized void doSomething2(){
            System.out.println(name);
        }
    }
    public static void main(String[] args) throws Exception{
        S s = new S();
//        Thread t1 = new Thread(() -&gt; {
//            try {
//                s.setName(&quot;hello&quot;);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//        });
//        t1.start();
//        Thread t2 = new Thread(() -&gt; {
//                s.print();
//        });
//        t2.start();
//        t1.join();
//        t2.join();
        Thread t1 = new Thread(() -&gt; {
             s.doSomething1();
        });
        t1.start();
        Thread t2 = new Thread(() -&gt; {
            s.doSomething2();
        });
        t2.start();
        t1.join();
        t2.join();

    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/06/设计模式-单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/设计模式-单例模式/" itemprop="url">设计模式-单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T10:35:11+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>volatile：保证多线程下的可见性</p>
<blockquote>
<p>读volatile：每当子线程读取volatile变量时，都会从主线程重新拷贝一份<br>写volatile: 每当子线程修改volatile变量时，都会在修改后同步到主线程去</p>
</blockquote>
<p>synchronized：对象锁、类锁、方法锁（其它篇有介绍）</p>
<pre><code>public class Singleton {

    private static volatile Singleton instance;

    private Singleton(){
    }

    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/06/设计模式-委派模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/设计模式-委派模式/" itemprop="url">设计模式-委派模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T09:46:55+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代理模式+策略模式，典型 Spring 中的 DispatcherServlet</p>
<p>用户将任务全权委派给代理负责，代理负责根据策略任务调度具体的执行单元</p>
<h2 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h2><pre><code>/**
 * 执行单元实现的接口
 */
public interface ITarget {

    void doSomething(String command);

}

/**
 * 执行单元A
 */
public class TargetA implements ITarget {
    @Override
    public void doSomething(String command) {

    }
}

/**
 * 执行单元B
 */
public class TargetB implements ITarget {
    @Override
    public void doSomething(String command) {

    }
}
</code></pre><h2 id="执行单元调度者"><a href="#执行单元调度者" class="headerlink" title="执行单元调度者"></a>执行单元调度者</h2><pre><code>public class Manager {
    private Map&lt;String ,ITarget&gt; targets = new HashMap&lt;String ,ITarget&gt;();

    public Manager(){
        targets.put(&quot;commandA&quot;,new TargetA());
        targets.put(&quot;commandB&quot;,new TargetB());
    }

    public void dispatch(String command){
        targets.get(command).doSomething(command);
    }
}
</code></pre><h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><pre><code>public class Boss {

    public static void main(String[] args) {
        Manager manager = new Manager();
        manager.dispatch(&quot;Command1&quot;);
    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Meng Qi</p>
              <p class="site-description motion-element" itemprop="description">recording</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
