<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="recording">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/16/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="Tech;Data;Vision">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/fbe10c45.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/fbe10c45.html" class="post-title-link" itemprop="url">mysql-为什么这些SQL语句逻辑相同，性能却差异巨大</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 06:19:47" itemprop="dateCreated datePublished" datetime="2019-11-22T06:19:47+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？2018-12-24 林晓斌</p>
<p>在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的</p>
<p>话，就会不经意间导致整个数据库的压力变大。我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速</p>
<p>解决问题。案例一：条件字段函数操作</p>
<p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员</p>
<p>id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个</p>
<p>表的建表语句如下：</p>
<p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发</p>
<p>生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么</p>
<p>写：</p>
<p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了</p>
<p>特别久，才返回了结果。如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就</p>
<p>用不上索引了，这是MySQL的规定。现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where</p>
<p>t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成where month(t_modified)&#x3D;7的时候就不行</p>
<p>了？下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。mysql&gt; CREATE TABLE <code>tradelog</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>tradeid</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>operator</code> int(11) DEFAULT NULL,</p>
<p>  <code>t_modified</code> datetime DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>tradeid</code> (<code>tradeid</code>),</p>
<p>  KEY <code>t_modified</code> (<code>t_modified</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>mysql&gt; select count(*) from tradelog where month(t_modified)&#x3D;7;</p>
<p>图1 t_modified索引示意图</p>
<p>如果你的SQL语句条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的</p>
<p>路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃</p>
<p>走树搜索功能。需要注意的是，优化器并不是要放弃使用这个索引。在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引</p>
<p>t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引</p>
<p>来得更快。因此最终还是会选择索引t_modified。接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。图2 explain 结果</p>
<p>key&#x3D;”t_modified”表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数</p>
<p>据，rows&#x3D;100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的</p>
<p>是使用了覆盖索引。也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引</p>
<p>的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化</p>
<p>器就能按照我们预期的，用上t_modified索引的快速定位能力了。当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他</p>
<p>年份补齐。到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只</p>
<p>能使用全索引扫描。不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索</p>
<p>引。比如，对于select * from tradelog where id + 1 &#x3D; 10000这个SQL语句，这个加1操作并不会</p>
<p>改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写</p>
<p>SQL语句的时候，手动改写成 where id &#x3D; 10000 -1才可以。案例二：隐式类型转换</p>
<p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。我们一起看一下这条SQL语句：</p>
<p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表</p>
<p>扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做</p>
<p>类型转换。那么，现在这里就有两个问题：</p>
<p>mysql&gt; select count(*) from tradelog where</p>
<pre><code>-&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or

-&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or 

-&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);
</code></pre>
<p>mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<ol>
<li>数据类型转换的规则是什么？2. 为什么有数据类型转换，就需要走全索引扫描？先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不</li>
</ol>
<p>住，应该怎么办呢？这里有一个简单的方法，看 select “10” &gt; 9的结果：</p>
<ol>
<li><p>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</p>
</li>
<li><p>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。验证结果如图3所示。图3 MySQL中字符串和数字转换的效果示意图</p>
</li>
</ol>
<p>从图中可知，select “10” &gt; 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL</p>
<p>中，字符串和数字做比较的话，是将字符串转换成数字。这时，你再看这个全表扫描的语句：</p>
<p>就知道对于优化器来说，这个语句相当于：</p>
<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜</p>
<p>索功能。现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<p>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717;</p>
<p>select * from tradelog where id&#x3D;”83126”;</p>
<p>你可以先自己分析一下，再到数据库里面去验证确认。接下来，我们再来看一个稍微复杂点的例子。案例三：隐式字符编码转换</p>
<p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复</p>
<p>现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p>
<p>mysql&gt; CREATE TABLE <code>trade_detail</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>tradeid</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>trade_step</code> int(11) DEFAULT NULL, &#x2F;<em>操作步骤</em>&#x2F;</p>
<p>  <code>step_info</code> varchar(32) DEFAULT NULL, &#x2F;<em>步骤信息</em>&#x2F;</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>tradeid</code> (<code>tradeid</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert into tradelog values(1, ‘aaaaaaaa’, 1000, now());</p>
<p>insert into tradelog values(2, ‘aaaaaaab’, 1000, now());</p>
<p>insert into tradelog values(3, ‘aaaaaaac’, 1000, now());</p>
<p>insert into trade_detail values(1, ‘aaaaaaaa’, 1, ‘add’);</p>
<p>insert into trade_detail values(2, ‘aaaaaaaa’, 2, ‘update’);</p>
<p>insert into trade_detail values(3, ‘aaaaaaaa’, 3, ‘commit’);</p>
<p>insert into trade_detail values(4, ‘aaaaaaab’, 1, ‘add’);</p>
<p>insert into trade_detail values(5, ‘aaaaaaab’, 2, ‘update’);</p>
<p>insert into trade_detail values(6, ‘aaaaaaab’, 3, ‘update again’);</p>
<p>insert into trade_detail values(7, ‘aaaaaaab’, 4, ‘commit’);</p>
<p>insert into trade_detail values(8, ‘aaaaaaac’, 1, ‘add’);</p>
<p>insert into trade_detail values(9, ‘aaaaaaac’, 2, ‘update’);</p>
<p>insert into trade_detail values(10, ‘aaaaaaac’, 3, ‘update again’);</p>
<p>insert into trade_detail values(11, ‘aaaaaaac’, 4, ‘commit’);</p>
<p>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2; &#x2F;<em>语句Q1</em>&#x2F;</p>
<p>图4 语句Q1的explain 结果</p>
<p>我们一起来看下这个结果：</p>
<ol>
<li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索</li>
</ol>
<p>引，rows&#x3D;1表示只扫描一行；</p>
<ol start="2">
<li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫</li>
</ol>
<p>描。在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因</p>
<p>此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。接下来，我们看下这个explain结果表示的执行流程：</p>
<p>图5 语句Q1的执行过程</p>
<p>图中：</p>
<p>第1步，是根据id在tradelog表里找到L2这一行；</p>
<p>第2步，是从L2中取出tradeid字段的值；</p>
<p>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的</p>
<p>key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是</p>
<p>否匹配。进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引</p>
<p>的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是</p>
<p>utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问</p>
<p>题时会得到的答案。但是你应该再追问一下，为什么字符集不同就用不上索引呢？我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p>
<p>其中，$L2.tradeid.value的字符集是utf8mb4。参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字</p>
<p>符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再</p>
<p>跟L2做比较。也就是说，实际上这个语句等同于下面这个写法：</p>
<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。到这里，你终于明确了，字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段</p>
<p>上加函数操作，是直接导致对被驱动表做全表扫描的原因。mysql&gt; select * from trade_detail where tradeid&#x3D;$L2.tradeid.value; </p>
<p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换</p>
<p>的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方</p>
<p>向”进行转换的。select * from trade_detail  where CONVERT(traideid USING utf8mb4)&#x3D;$L2.tradeid.value; </p>
<p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id&#x3D;4的操作，对应的操作者是</p>
<p>谁”，再来看下这个语句和它的执行计划。图6 explain 结果</p>
<p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了</p>
<p>被驱动表tradelog里的索引(tradeid)，扫描行数是1。这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一</p>
<p>下。假设驱动表trade_detail里id&#x3D;4的行记为R4，那么在连接的时候（图5的第3步），被驱动表</p>
<p>tradelog上执行的就是类似这样的SQL 语句：</p>
<p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程</p>
<p>就被改写成：</p>
<p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。理解了原理以后，就可以用来指导操作了。如果要优化语句</p>
<p>的执行过程，有两种做法：</p>
<p>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就</p>
<p>mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;</p>
<p>select operator from tradelog  where traideid &#x3D;$R4.tradeid.value; </p>
<p>select operator from tradelog  where traideid &#x3D;CONVERT($R4.tradeid.value USING utf8mb4); </p>
<p>select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2;</p>
<p>没有字符集转换的问题了。如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不</p>
<p>能做这个DDL的话，那就只能采用修改SQL语句的方法了。图7 SQL语句优化后的explain结果</p>
<p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看</p>
<p>到，这次索引走对了。小结</p>
<p>今天我给你举了三个例子，其实是在说同一件事儿，即：对索引字段做函数操作，可能会破坏</p>
<p>索引值的有序性，因此优化器就决定放弃走树搜索功能。第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为</p>
<p>要求在索引字段上做函数操作而导致了全索引扫描。MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1&#x3D;1000改写成where id&#x3D;1000-1就</p>
<p>能够用上索引快速查找，也不会主动做这个语句重写。因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习</p>
<p>惯。最后，又到了思考题时间。今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什</p>
<p>么，又是怎么解决的呢？你可以把你经历和分析写在留言区里，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</p>
<p>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid&#x3D;CONVERT(l.tradeid USING utf8) and l.id&#x3D;2; </p>
<p>上期问题时间</p>
<p>我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得</p>
<p>到需要的数据，你觉得有没有进一步的优化方法。这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后</p>
<p>执行下面这条SQL语句：</p>
<p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以</p>
<p>的。@倪大人 同学在评论区就提到了这个方法。这次评论区出现了很多很棒的留言：</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>@老杨同志 提出了重新整理的方法、@雪中鼠[悠闲] 提到了用rowid的方法，是类似的思路，</p>
<p>就是让表里面保存一个无空洞的自增值，这样就可以用我们的随机算法1来实现；</p>
<p>@吴宇晨 提到了拿到第一个值以后，用id迭代往下找的方案，利用了主键索引的有序性。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/ca522c4d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/ca522c4d.html" class="post-title-link" itemprop="url">mysql-为什么这些SQL语句逻辑相同性能却差异巨大</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-21 06:02:02" itemprop="dateCreated datePublished" datetime="2019-11-21T06:02:02+08:00">2019-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？2018-12-24 林晓斌</p>
<p>在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的</p>
<p>话，就会不经意间导致整个数据库的压力变大。我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速</p>
<p>解决问题。案例一：条件字段函数操作</p>
<p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员</p>
<p>id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个</p>
<p>表的建表语句如下：</p>
<p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发</p>
<p>生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么</p>
<p>写：</p>
<p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了</p>
<p>特别久，才返回了结果。如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就</p>
<p>用不上索引了，这是MySQL的规定。现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where</p>
<p>t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成where month(t_modified)&#x3D;7的时候就不行</p>
<p>了？下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。mysql&gt; CREATE TABLE t̀radelog  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  t̀radeid  ̀varchar(32) DEFAULT NULL,</p>
<p>  &#96;operator̀  int(11) DEFAULT NULL,</p>
<p>  t̀_modified  ̀datetime DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY t̀radeid  ̀(̀ tradeid )̀,</p>
<p>  KEY t̀_modified  ̀(̀ t_modified )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>mysql&gt; select count(*) from tradelog where month(t_modified)&#x3D;7;</p>
<p>图1 t_modified索引示意图</p>
<p>如果你的SQL语句条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的</p>
<p>路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃</p>
<p>走树搜索功能。需要注意的是，优化器并不是要放弃使用这个索引。在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引</p>
<p>t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引</p>
<p>来得更快。因此最终还是会选择索引t_modified。接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。图2 explain 结果</p>
<p>key&#x3D;”t_modified”表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数</p>
<p>据，rows&#x3D;100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的</p>
<p>是使用了覆盖索引。也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引</p>
<p>的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化</p>
<p>器就能按照我们预期的，用上t_modified索引的快速定位能力了。当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他</p>
<p>年份补齐。到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只</p>
<p>能使用全索引扫描。不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索</p>
<p>引。比如，对于select * from tradelog where id + 1 &#x3D; 10000这个SQL语句，这个加1操作并不会</p>
<p>改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写</p>
<p>SQL语句的时候，手动改写成 where id &#x3D; 10000 -1才可以。案例二：隐式类型转换</p>
<p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。我们一起看一下这条SQL语句：</p>
<p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表</p>
<p>扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做</p>
<p>类型转换。那么，现在这里就有两个问题：</p>
<p>mysql&gt; select count(*) from tradelog where</p>
<pre><code>-&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or

-&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or 

-&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);
</code></pre>
<p>mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<ol>
<li>数据类型转换的规则是什么？2. 为什么有数据类型转换，就需要走全索引扫描？先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不</li>
</ol>
<p>住，应该怎么办呢？这里有一个简单的方法，看 select “10” &gt; 9的结果：</p>
<ol>
<li><p>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</p>
</li>
<li><p>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。验证结果如图3所示。图3 MySQL中字符串和数字转换的效果示意图</p>
</li>
</ol>
<p>从图中可知，select “10” &gt; 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL</p>
<p>中，字符串和数字做比较的话，是将字符串转换成数字。这时，你再看这个全表扫描的语句：</p>
<p>就知道对于优化器来说，这个语句相当于：</p>
<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜</p>
<p>索功能。现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<p>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717;</p>
<p>select * from tradelog where id&#x3D;”83126”;</p>
<p>你可以先自己分析一下，再到数据库里面去验证确认。接下来，我们再来看一个稍微复杂点的例子。案例三：隐式字符编码转换</p>
<p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复</p>
<p>现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p>
<p>mysql&gt; CREATE TABLE t̀rade_detail  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  t̀radeid  ̀varchar(32) DEFAULT NULL,</p>
<p>  t̀rade_step  ̀int(11) DEFAULT NULL, &#x2F;<em>操作步骤</em>&#x2F;</p>
<p>  &#96;step_info  ̀varchar(32) DEFAULT NULL, &#x2F;<em>步骤信息</em>&#x2F;</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY t̀radeid  ̀(̀ tradeid )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert into tradelog values(1, ‘aaaaaaaa’, 1000, now());</p>
<p>insert into tradelog values(2, ‘aaaaaaab’, 1000, now());</p>
<p>insert into tradelog values(3, ‘aaaaaaac’, 1000, now());</p>
<p>insert into trade_detail values(1, ‘aaaaaaaa’, 1, ‘add’);</p>
<p>insert into trade_detail values(2, ‘aaaaaaaa’, 2, ‘update’);</p>
<p>insert into trade_detail values(3, ‘aaaaaaaa’, 3, ‘commit’);</p>
<p>insert into trade_detail values(4, ‘aaaaaaab’, 1, ‘add’);</p>
<p>insert into trade_detail values(5, ‘aaaaaaab’, 2, ‘update’);</p>
<p>insert into trade_detail values(6, ‘aaaaaaab’, 3, ‘update again’);</p>
<p>insert into trade_detail values(7, ‘aaaaaaab’, 4, ‘commit’);</p>
<p>insert into trade_detail values(8, ‘aaaaaaac’, 1, ‘add’);</p>
<p>insert into trade_detail values(9, ‘aaaaaaac’, 2, ‘update’);</p>
<p>insert into trade_detail values(10, ‘aaaaaaac’, 3, ‘update again’);</p>
<p>insert into trade_detail values(11, ‘aaaaaaac’, 4, ‘commit’);</p>
<p>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2; &#x2F;<em>语句Q1</em>&#x2F;</p>
<p>图4 语句Q1的explain 结果</p>
<p>我们一起来看下这个结果：</p>
<ol>
<li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索</li>
</ol>
<p>引，rows&#x3D;1表示只扫描一行；</p>
<ol start="2">
<li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫</li>
</ol>
<p>描。在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因</p>
<p>此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。接下来，我们看下这个explain结果表示的执行流程：</p>
<p>图5 语句Q1的执行过程</p>
<p>图中：</p>
<p>第1步，是根据id在tradelog表里找到L2这一行；</p>
<p>第2步，是从L2中取出tradeid字段的值；</p>
<p>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的</p>
<p>key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是</p>
<p>否匹配。进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引</p>
<p>的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是</p>
<p>utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问</p>
<p>题时会得到的答案。但是你应该再追问一下，为什么字符集不同就用不上索引呢？我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p>
<p>其中，$L2.tradeid.value的字符集是utf8mb4。参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字</p>
<p>符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再</p>
<p>跟L2做比较。也就是说，实际上这个语句等同于下面这个写法：</p>
<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。到这里，你终于明确了，字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段</p>
<p>上加函数操作，是直接导致对被驱动表做全表扫描的原因。mysql&gt; select * from trade_detail where tradeid&#x3D;$L2.tradeid.value; </p>
<p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换</p>
<p>的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方</p>
<p>向”进行转换的。select * from trade_detail  where CONVERT(traideid USING utf8mb4)&#x3D;$L2.tradeid.value; </p>
<p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id&#x3D;4的操作，对应的操作者是</p>
<p>谁”，再来看下这个语句和它的执行计划。图6 explain 结果</p>
<p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了</p>
<p>被驱动表tradelog里的索引(tradeid)，扫描行数是1。这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一</p>
<p>下。假设驱动表trade_detail里id&#x3D;4的行记为R4，那么在连接的时候（图5的第3步），被驱动表</p>
<p>tradelog上执行的就是类似这样的SQL 语句：</p>
<p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程</p>
<p>就被改写成：</p>
<p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。理解了原理以后，就可以用来指导操作了。如果要优化语句</p>
<p>的执行过程，有两种做法：</p>
<p>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就</p>
<p>没有字符集转换的问题了。mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;</p>
<p>select operator from tradelog  where traideid &#x3D;$R4.tradeid.value; </p>
<p>select operator from tradelog  where traideid &#x3D;CONVERT($R4.tradeid.value USING utf8mb4); </p>
<p>select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2;</p>
<p>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不</p>
<p>能做这个DDL的话，那就只能采用修改SQL语句的方法了。图7 SQL语句优化后的explain结果</p>
<p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看</p>
<p>到，这次索引走对了。小结</p>
<p>今天我给你举了三个例子，其实是在说同一件事儿，即：对索引字段做函数操作，可能会破坏</p>
<p>索引值的有序性，因此优化器就决定放弃走树搜索功能。第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为</p>
<p>要求在索引字段上做函数操作而导致了全索引扫描。MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1&#x3D;1000改写成where id&#x3D;1000-1就</p>
<p>能够用上索引快速查找，也不会主动做这个语句重写。因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习</p>
<p>惯。最后，又到了思考题时间。今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什</p>
<p>么，又是怎么解决的呢？你可以把你经历和分析写在留言区里，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得</p>
<p>alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</p>
<p>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid&#x3D;CONVERT(l.tradeid USING utf8) and l.id&#x3D;2; </p>
<p>到需要的数据，你觉得有没有进一步的优化方法。这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后</p>
<p>执行下面这条SQL语句：</p>
<p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以</p>
<p>的。@倪大人 同学在评论区就提到了这个方法。这次评论区出现了很多很棒的留言：</p>
<p>老杨同志   20</p>
<p>感谢老师鼓励，我本人工作时间比较长，有一定的基础，听老师的课还是收获很大。每次公司</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>@老杨同志 提出了重新整理的方法、@雪中鼠[悠闲] 提到了用rowid的方法，是类似的思路，</p>
<p>就是让表里面保存一个无空洞的自增值，这样就可以用我们的随机算法1来实现；</p>
<p>@吴宇晨 提到了拿到第一个值以后，用id迭代往下找的方案，利用了主键索引的有序性。精选留言</p>
<p>内部有技术分享，我都去听课，但是多数情况，一两个小时的分享，就只有一两句话受益。老</p>
<p>师的每篇文章都能命中我的知识盲点，感觉太别爽。对应今天的隐式类型转换问题也踩过坑。我们有个任务表记录待执行任务，表结构简化后如下：</p>
<p>CREATE TABLE <code>task</code> (</p>
<p><code>task_id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增主键’,</p>
<p><code>task_type</code> int(11) DEFAULT NULL COMMENT ‘任务类型id’,</p>
<p><code>task_rfid</code> varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT ‘关联外键1’,</p>
<p>PRIMARY KEY (<code>task_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci COMME</p>
<p>NT&#x3D;’任务表’;</p>
<p>task_rfid 是业务主键，当然都是数字，查询时使用sql：</p>
<p>select * from task where task_rfid &#x3D;123;</p>
<p>其实这个语句也有隐式转换问题，但是待执行任务只有几千条记录，并没有什么感觉。这个表还有个对应的历史表，数据有几千万</p>
<p>忽然有一天，想查一下历史记录，执行语句</p>
<p>select * from task_history where task_rfid &#x3D;99;</p>
<p>直接就等待很长时间后超时报错了。如果仔细看，其实我的表没有task_rfid 索引，写成task_rfid &#x3D;‘99’也一样是全表扫描。运维时的套路是，猜测主键task_id的范围，怎么猜，我原表有creat_time字段，我会先查</p>
<p>select max(task_id) from task_history 然后再看看 select * from task_history where task_id &#x3D; m</p>
<p>axId - 10000的时间，估计出大概的id范围。然后语句变成</p>
<p>select * from task_history where task_rfid &#x3D;99 and id between ？ and ？;</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>你最后这个id预估，加上between ，</p>
<p>有种神来之笔的感觉 </p>
<p>感觉隐约里面有二分法的思想</p>
<p>  </p>
<p>2018-12-24</p>
<p>可凡不凡   1</p>
<p>1.老师好</p>
<p>2.如果在用一个 MySQL 关键字做字段,并且字段上索引,当我用这个索引作为唯一查询条件的时</p>
<p>候 ,会 造 成隐式的转换吗? </p>
<p>例如:SELECT * FROM b_side_order WHERE CODE &#x3D; 332924 ; (code 上有索引)</p>
<ol start="3">
<li>mysql5.6 code 上有索引 intime 上没有索引</li>
</ol>
<p>语句一:</p>
<p>SELECT * FROM b_side_order WHERE CODE &#x3D; 332924 ;</p>
<p>语句二;</p>
<p>UPDATE b_side_order SET in_time &#x3D; ‘2018-08-04 08:34:44’ WHERE 1&#x3D;2 or CODE &#x3D; 332924;</p>
<p>这两个语句 执行计划走 select 走了索引,update 没有走索引 是执行计划的bug 吗??</p>
<p>2018-12-25</p>
<p> 作者回复</p>
<ol>
<li><p>你好 </p>
</li>
<li><p>CODE不是关键字呀， 另外优化器选择跟关键字无关哈，关键字的话，要用 反‘ 括起来</p>
</li>
<li><p>不是bug, update如果把 or 改成 and , 就能走索引 </p>
</li>
</ol>
<p>2018-12-25</p>
<p>冠超   0</p>
<p>非常感谢老师分享的内容，实打实地学到了。这里提个建议，希望老师能介绍一下设计表的时</p>
<p>候要怎么考虑这方面的知识哈 </p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p>是这样的，其实我们整个专栏大部分的文章，最后都是为了说明 “怎么设计表”、“怎么考虑优化</p>
<p>SQL语句”</p>
<p>但是因为这个不是一成不变的，很多是需要考虑现实的情况，</p>
<p>所以这个专栏就是想把对应的原理说一下，这样大家在应对不同场景的时候，可以组合来考虑</p>
<p>。也就是说没有一段话可以把“怎么设计表”讲清楚（或者说硬写出来很可能就是一些general的没</p>
<p>有什么针对性作用的描述）</p>
<p>你可以把你的业务背景抽象说下，我们来具体讨论吧</p>
<p>2019-01-28</p>
<p>700   0</p>
<p>老师您好，有个问题恳请指教。背景如下，我长话短说：</p>
<p>mysql&gt;select @@version;</p>
<p>5.6.30-log</p>
<p>CREATE TABLE <code>t1</code> ( <code>id</code> int(11) unsigned NOT NULL AUTO_INCREMENT,</p>
<p><code>user_id</code> int(11) NOT NULL, <code>plan_id</code> int(11) NOT NULL DEFAULT ‘0’ , PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>userid</code> (<code>user_id</code>) USING BTREE, KEY <code>idx_planid</code> (<code>plan_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;gb2312;</p>
<p>CREATE TABLE <code>t3</code> (</p>
<p><code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p><code>status</code> int(4) NOT NULL DEFAULT ‘0’,</p>
<p><code>ootime</code> varchar(11) DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>idx_xxoo</code> (<code>status</code>,<code>ootime</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>t1 和 t3 表的字符集不一样</p>
<p>sql 执行计划如下：</p>
<p>explain</p>
<p>SELECT t1.id, t1.user_id</p>
<p>FROM t1, t3</p>
<p>WHERE t1.plan_id &#x3D; t3.id</p>
<p>AND t3.ootime &lt; UNIX_TIMESTAMP(‘2022-01-18’)</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>| 1 | SIMPLE | t3 | index | PRIMARY | idx_xxoo | 51 | NULL | 39106 | Using where; Using index</p>
<p>|</p>
<p>| 1 | SIMPLE | t1 | ref | idx_planid | idx_planid | 4 | t3.id | 401 | Using join buffer (Batched Key Ac</p>
<p>cess) |</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>我的疑惑是</p>
<p>1)t3 的 status 没出现在 where 条件中，但执行计划为什么用到了 idex_xxoo 索引？2)为什么 t3.ootime 也用到索引了，从 key_len 看出。t3.ootime 是 varchar 类型的，而 UNIX_TI</p>
<p>MESTAMP(‘2022-01-18’) 是数值，不是发生了隐式转换吗？请老师指点。2019-01-18</p>
<p> 作者回复</p>
<p>这个查询语句会对t3做全索引扫描，是使用了索引的，只是没有用上快速搜索功能</p>
<p>2019-01-19</p>
<p>赖阿甘   0</p>
<p>“mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;”</p>
<p>图6上面那句sql是不是写错了。d.tradeid&#x3D;l.tradeid是不是该写成l.tradeid &#x3D; d.tradeid？不然函数</p>
<p>会作用在索引字段上，就只能全表扫描了</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>这个问题不是等号顺序决定的哈</p>
<p>好问题</p>
<p>2018-12-24</p>
<p>Leon    16</p>
<p>索引字段不能进行函数操作，但是索引字段的参数可以玩函数，一言以蔽之</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>精辟 </p>
<p>2018-12-24</p>
<p>探索无止境   5</p>
<p>多表连接时，mysql是怎么选择驱动表和被驱动表的？这个很重要，希望老师可以讲讲</p>
<p>2018-12-25</p>
<p>可凡不凡   5</p>
<p>1.老师对于多表联合查询中,MySQL 对索引的选择 以后会详细介绍吗?</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>额，你是第三个提这个问题的了，我得好好考虑下安排 </p>
<p>2018-12-24</p>
<p>某、人   4</p>
<p>SQL逻辑相同,性能差异较大的,通过老师所讲学习到的,和平时碰到的,大概有以下几类:</p>
<p>一.字段发生了转换,导致本该使用索引而没有用到索引</p>
<p>1.条件字段函数操作</p>
<p>2.隐式类型转换</p>
<p>3.隐式字符编码转换</p>
<p>(如果驱动表的字符集比被驱动表得字符集小，关联列就能用到索引,如果更大,需要发生隐式编</p>
<p>码转换,则不能用到索引,latin&lt;gbk&lt;utf8&lt;utf8mb4)</p>
<p>二.嵌套循环,驱动表与被驱动表选择错误</p>
<p>1.连接列上没有索引,导致大表驱动小表,或者小表驱动大表(但是大表走的是全表扫描) –连接列</p>
<p>上建立索引</p>
<p>2.连接列上虽然有索引,但是驱动表任然选择错误。–通过straight_join强制选择关联表顺序</p>
<p>3.子查询导致先执行外表在执行子查询,也是驱动表与被驱动表选择错误。 </p>
<p>–可以考虑把子查询改写为内连接,或者改写内联视图(子查询放在from后组成一个临时表,在于</p>
<p>其他表进行关联)</p>
<p>4.只需要内连接的语句,但是写成了左连接或者右连接。比如select * from t left join b on t.id&#x3D;b.id</p>
<p>where b.name&#x3D;’abc’驱动表被固定,大概率会扫描更多的行,导致效率降低. </p>
<p>–根据业务情况或sql情况,把左连接或者右连接改写为内连接</p>
<p>三.索引选择不同,造成性能差异较大</p>
<p>1.select * from t where aid&#x3D; and create_name&gt;’’ order by id limit 1;</p>
<p>选择走id索引或者选择走(aid,create_time)索引,性能差异较大.结果集都有可能不一致</p>
<p>–这个可以通过where条件过滤的值多少来大概判断,该走哪个索引</p>
<p>四.其它一些因素</p>
<p>1.比如之前学习到的是否有MDL X锁</p>
<p>2.innodb_buffer_pool设置得太小,innodb_io_capacity设置得太小,刷脏速度跟不上</p>
<p>3.是否是对表做了DML语句之后,马上做select,导致change buffer收益不高</p>
<p>4.是否有数据空洞</p>
<p>5.select选取的数据是否在buffer_pool中</p>
<p>6.硬件原因,资源抢占</p>
<p>原因多种多样,还需要慢慢补充。老师我问一个问题:</p>
<p>连接列上一个是int一个是bigint或者一个是char一个varchar,为什么被驱动表上会出现(using inde</p>
<p>x condition)?</p>
<p>2018-12-24</p>
<p>Destroy、   2</p>
<p>老师，对于最后回答上一课的问题：mysql&gt; select * from t limit N, M-N+1;</p>
<p>这个语句也不是取3条记录。 没理解。2018-12-27</p>
<p> 作者回复</p>
<p>取其中三条…</p>
<p>2018-12-27</p>
<p>风轨   2</p>
<p>刚试了文中穿插得思考题:当主键是整数类型条件是字符串时，会走索引。文中提到了当字符串和数字比较时会把字符串转化为数字，所以隐式转换不会应用到字段上，</p>
<p>所以可以走索引。另外，select ‘a’ &#x3D; 0 ; 的结果是1，说明无法转换成数字的字符串都被转换成0来处理了。2018-12-24</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-24</p>
<p>匿名的朋友   1</p>
<p>丁奇老师，我有个疑问，就是sql语句执行时那些order by group by limit 以及where条件，有执</p>
<p>行的先后顺序吗？2019-01-05</p>
<p> 作者回复</p>
<p>有，先where ,再order by 最后limit</p>
<p>2019-01-05</p>
<p>大坤   1</p>
<p>之前遇到过按时间范围查询大表不走索引的情况，如果缩小时间范围，又会走索引，记得在一</p>
<p>些文章中看到过结果数据超过全表的30%就会走全表扫描，但是前面说的时间范围查询大表，</p>
<p>这个时间范围绝对是小于30%的情况，想请教下老师，这个优化器都是在什么情况下会放弃索</p>
<p>引呢？2018-12-25</p>
<p> 作者回复</p>
<p>总体来说就是判断哪种方式消耗更小，选哪种</p>
<p>2018-12-25</p>
<p>Leon    1</p>
<p>老师，经常面试被问到工作中做了什么优化，有没有好的业务表的设计，请问老师课程结束后</p>
<p>能不能给我们一个提纲挈领的大纲套路，让我们有个脉络和思路来应付这种面试套路</p>
<p>2018-12-25</p>
<p> 作者回复</p>
<p>有没有好的业务表的设计，这类问题我第一次听到，能不能展开一下，这样说不要清楚面试官</p>
<p>的考核点是啥…</p>
<p>2018-12-25</p>
<p>果然如此   1</p>
<p>我想问一个上期的问题，随机算法2虽然效率高，但是还是有个瑕疵，比如我们的随机出题算法</p>
<p>无法直接应用，因为每次随机一个试题id，多次随机没有关联，会产生重复id，有没有更好的解</p>
<p>决方法？2018-12-25</p>
<p> 作者回复</p>
<p>内存里准备个set这样的数据结构，重读的不算，这样可以不 </p>
<p>2018-12-25</p>
<p>长杰   1</p>
<p>这里我给出一种方法，取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，</p>
<p>然后执行下面这条 SQL 语句：</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>再加上取整个表总行数的 C 行，这个方案的扫描行数总共只需要 C+M 行。优化后的方案应该是C+M+1行吧？2018-12-24</p>
<p> 作者回复</p>
<p>你说的对  ，我改下</p>
<p>2018-12-25</p>
<p>asdf100   1</p>
<p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_mo</p>
<p>dified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得</p>
<p>更快。优化器如何对比的，根据参与字段字段类型占用空间大小吗？2018-12-24</p>
<p> 作者回复</p>
<p>优化器信息是引擎给的，</p>
<p>引擎是这么判断的</p>
<p>2018-12-24</p>
<p>约书亚   1</p>
<p>谁是驱动表谁是被驱动表，是否大多数情况看where条件就可以了？这是否本质上涉及到mysql</p>
<p>底层决定用什么算法进行级联查询的问题？后面会有课程详细说明嘛？2018-12-24</p>
<p> 作者回复</p>
<p>可以简单看where之后剩下的行数（预判不一定准哈）</p>
<p>2018-12-24</p>
<p>Lukia   0</p>
<p>老师好，之前看了《数据索引与优化》，提到表之间的连接操作可以有嵌套循环连接（本文中</p>
<p>提到的驱动表和被驱动表）和合并扫描连接（先在临时表中针对谓词作排序）还有哈希连接。请问MySQL中是否存在后面两种方式的连接，如果有的话优化器会在什么情况下选择呢？谢谢</p>
<p>！</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<p>第34、35两篇就会说到了，今晚关注下 </p>
<p>2019-01-29</p>
<p>涛哥哥   0</p>
<p>老师，您好！我是做后端开发的。想问一下 mysql in关键字 的内部原理，能抽一点点篇幅讲一</p>
<p>下吗？比如：select * from T where id in (a,b,d,c,,e,f); id是主键。1、为什么查询出来的结果集</p>
<p>会按照id排一次序呢（是跟去重有关系么）？2、如果 in 里面的值较多的时候，就会比较慢啊（</p>
<p>是还不如全表扫描么）？问我们公司很多后端的，都不太清楚，问我们DBA，他说默认就是这</p>
<p>样（这不跟没说一样吗）。希望老师可以帮忙解惑。祝老师身体健康！微笑~</p>
<p>2019-01-26</p>
<p> 作者回复</p>
<ol>
<li>优化器会排个序，目的是如果这几个记录对应的数据都不在内存里，可以触发顺序读盘，后</li>
</ol>
<p>面文章我们介绍到join的时候，会提到MRR，你关注下</p>
<ol start="2">
<li>in里面值多就是多次执行树搜索，跟全表扫描的速度对比，就看in里面的数据个数的比例了。你的in里面一般多少个value呀</li>
</ol>
<p>2019-01-26</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/d1d469cd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/d1d469cd.html" class="post-title-link" itemprop="url">mysql-如何正确地显示随机消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-20 06:10:31" itemprop="dateCreated datePublished" datetime="2019-11-20T06:10:31+08:00">2019-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>17 | 如何正确地显示随机消息？2018-12-21 林晓斌</p>
<p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习</p>
<p>App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL</p>
<p>中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，</p>
<p>然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选</p>
<p>单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。现在，如果让你来设计这个SQL语句，你会怎么写呢？为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻</p>
<p>辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p>
<p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择</p>
<p>3个单词，有什么方法实现，存在什么问题以及如何改进。内存临时表</p>
<p>首先，你会想到用order by rand()来实现这个逻辑。这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点</p>
<p>复杂的。我们先用explain命令来看看这个语句的执行情况。mysql&gt; CREATE TABLE <code>words</code> (</p>
<p>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>word</code> varchar(64) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;0;</p>
<p>  while i&lt;10000 do</p>
<pre><code>insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select word from words order by rand() limit 3;</p>
<p>图1 使用explain命令查看语句的执行情况</p>
<p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行</p>
<p>排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。这里，你可以先回顾一下上一篇文章中全字段排序和rowid排序的内容。我把上一篇文章的两个</p>
<p>流程图贴过来，方便你复习。图2 全字段排序</p>
<p>图3 rowid排序</p>
<p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一</p>
<p>下上一篇文章的一个结论：对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被</p>
<p>优先选择。我强调了“InnoDB表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位</p>
<p>置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它</p>
<p>会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们</p>
<p>来尝试分析一下语句的扫描行数。这条语句的执行流程是这样的：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是</li>
</ol>
<p>double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段</p>
<p>W。并且，这个表没有建索引。2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一</p>
<p>个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到</p>
<p>此，扫描行数是10000。3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排</p>
<p>序。4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信</p>
<p>息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时</p>
<p>扫描行数增加10000，变成了20000。6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫</p>
<p>描行数。7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户</p>
<p>端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分</p>
<p>析得出的结论。这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行</p>
<p>数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有</p>
<p>趣，分析对了开心，分析错了但是弄清楚了也很开心。现在，我来把完整的排序执行流程图画出来。# Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</p>
<p>SET timestamp&#x3D;1541402277;</p>
<p>select word from words order by rand() limit 3;</p>
<p>图4 随机排序完整流程图1</p>
<p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章</p>
<p>中，我们对InnoDB表排序的时候，明明用的还是ID字段。这时候，我们就要回到一个基本概念：MySQL的表是用什么方法来定位“一行数据”的。在前面第4和第5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是</p>
<p>不是就没有主键，就没办法回表了？其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成</p>
<p>一个长度为6字节的rowid来作为主键。这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行</p>
<p>的信息。对于有主键的InnoDB表来说，这个rowid就是主键ID；</p>
<p>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</p>
<p>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个</p>
<p>rowid其实就是数组的下标。到这里，我来稍微小结一下：order by rand()使用了内存临时表，内存临时表排序的时候使</p>
<p>用了rowid排序方法。磁盘临时表</p>
<p>那么，是不是所有的临时表都是内存表呢？其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大</p>
<p>小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把</p>
<p>max_length_for_sort_data 设置成16。set tmp_table_size&#x3D;1024;</p>
<p>set sort_buffer_size&#x3D;32768;</p>
<p>set max_length_for_sort_data&#x3D;16;</p>
<p>&#x2F;* 打开 optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select word from words order by rand() limit 3;</p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM <code>information_schema</code>.<code>OPTIMIZER_TRACE</code>\G</p>
<p>图5 OPTIMIZER_TRACE部分结果</p>
<p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到</p>
<p>sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字</p>
<p>段组成的行。这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于</p>
<p>为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，</p>
<p>超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道</p>
<p>不需要用临时文件吗？这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，</p>
<p>即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序</p>
<p>算法，而是采用了优先队列排序算法。其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的</p>
<p>话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，</p>
<p>想一下就明白了，这浪费了非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li>
</ol>
<p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p>
<ol>
<li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中</li>
</ol>
<p>去掉，换成(R’,rowid’)；</p>
<ol start="2">
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。这里我简单画了一个优先队列排序过程的示意图。图6 优先队列排序算法示例</li>
</ol>
<p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程</p>
<p>中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的</p>
<p>chosen&#x3D;true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的</p>
<p>number_of_tmp_files是0。这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它</p>
<p>们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一</p>
<p>样了。我们再看一下上面一篇文章的SQL查询语句：</p>
<p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是</p>
<p>limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超</p>
<p>过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要</p>
<p>大量的扫描行数，因此排序过程的资源消耗也会很大。再回到我们文章开头的问题，怎么正确地随机排序呢？随机排序方法</p>
<p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p>
<ol>
<li><p>取得这个表的主键id的最大值M和最小值N;</p>
</li>
<li><p>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</p>
</li>
<li><p>取不小于X的第一个ID的行。我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p>
</li>
</ol>
<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用</p>
<p>索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要</p>
<p>求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>mysql&gt; select max(id),min(id) into @M,@N from t ;</p>
<p>set @X&#x3D; floor((@M-@N+1)*rand() + @N);</p>
<p>select * from t where id &gt;&#x3D; @X limit 1;</p>
<p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取</p>
<p>得其他行概率的两倍。如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<ol>
<li>取得整个表的行数，并记为C。2. 取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。3. 再用limit Y,1 取得一行。我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。这个随机算法2，解决了算法1里面明显的概率不均匀问题。MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为</li>
</ol>
<p>返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，</p>
<p>执行代价比随机算法1的代价要高。当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那</p>
<p>扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小</p>
<p>很多呢？我就把这个问题留给你去课后思考吧。现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p>
<ol>
<li><p>取得整个表的行数，记为C；</p>
</li>
<li><p>根据相同的随机方法得到Y1、Y2、Y3；</p>
</li>
</ol>
<p>mysql&gt; select count(*) into @C from t;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @sql &#x3D; concat(“select * from t limit “, @Y, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>execute stmt;</p>
<p>DEALLOCATE prepare stmt;</p>
<ol start="3">
<li>再执行三个limit Y, 1语句得到三行数据。我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。小结</li>
</ol>
<p>今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代</p>
<p>价往往是比较大的。所以，在设计的时候你要量避开这种写法。今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在</p>
<p>实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读</p>
<p>写数据”的事情。因此，这类方法的应用还是比较广泛的。最后，我给你留下一个思考题吧。上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来</p>
<p>进一步减少扫描行数的。我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，</p>
<p>并说明你的方案需要的扫描行数。你可以把你的设计和结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，select * from t where city in (“杭州”,” 苏州 “) order by</p>
<p>name limit 100;这个SQL语句是否需要排序？有什么方案可以避免排序？虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要</p>
<p>单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不</p>
<p>是递增的了。也就是说，这条SQL语句需要排序。mysql&gt; select count(*) into @C from t;</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>set @Y3 &#x3D; floor(@C * rand());</p>
<p>select * from t limit @Y1，1； &#x2F;&#x2F;在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</p>
<p>select * from t limit @Y2，1；</p>
<p>select * from t limit @Y3，1；</p>
<p>那怎么避免排序呢？这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p>
<ol>
<li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客</li>
</ol>
<p>户端用一个长度为100的内存数组A保存结果。2. 执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存</p>
<p>进了内存数组B。3. 现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就</p>
<p>是我们需要的结果了。如果把这条SQL语句里“limit 100”改成“limit 10000,100”的话，处理方式其实也差不多，即：要把</p>
<p>上面的两条语句改成写：</p>
<p>和</p>
<p>这时候数据量较大，可以同时起两个连接一行行读结果，用归并排序算法拿到这两个结果集里，</p>
<p>按顺序取第10001~10100的name值，就是需要的结果了。当然这个方案有一个明显的损失，就是从数据库返回给客户端的数据量变大了。所以，如果数据的单行比较大的话，可以考虑把这两条SQL语句改成下面这种写法：</p>
<p>和</p>
<p>然后，再用归并排序的方法取得按name顺序第10001~10100的name、id的值，然后拿着这100</p>
<p>个id到数据库中去查出所有记录。上面这些方法，需要你根据性能需求和开发的复杂度做出权衡。select * from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p> select * from t where city&#x3D;”苏州” order by name limit 10100。select id,name from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p>select id,name from t where city&#x3D;”苏州” order by name limit 10100。评论区留言点赞板：</p>
<p>评论区很多同学都提到不能排序，说明各位对索引的存储都理解对了。@峰 同学提到了归并排序，是我们这个问题解法的核心思想；</p>
<p>@老杨同志 的回答中提到了“从业务上砍掉功能”，这个也确实是在业务设计中可以考虑的一个</p>
<p>方向；</p>
<p>@某、人 帮忙回答了@发条橙子同学的问题，尤其是对问题一的回答，非常精彩。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/e1069275.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/e1069275.html" class="post-title-link" itemprop="url">mysql-如何正确地显示随机消息(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-19 06:00:14" itemprop="dateCreated datePublished" datetime="2019-11-19T06:00:14+08:00">2019-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>17 | 如何正确地显示随机消息？2018-12-21 林晓斌</p>
<p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习</p>
<p>App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL</p>
<p>中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，</p>
<p>然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选</p>
<p>单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。现在，如果让你来设计这个SQL语句，你会怎么写呢？为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻</p>
<p>辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p>
<p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择</p>
<p>3个单词，有什么方法实现，存在什么问题以及如何改进。内存临时表</p>
<p>首先，你会想到用order by rand()来实现这个逻辑。这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点</p>
<p>复杂的。我们先用explain命令来看看这个语句的执行情况。mysql&gt; CREATE TABLE &#96;words  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  &#96;word  ̀varchar(64) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;0;</p>
<p>  while i&lt;10000 do</p>
<pre><code>insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select word from words order by rand() limit 3;</p>
<p>图1 使用explain命令查看语句的执行情况</p>
<p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行</p>
<p>排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。这里，你可以先回顾一下上一篇文章中全字段排序和rowid排序的内容。我把上一篇文章的两个</p>
<p>流程图贴过来，方便你复习。图2 全字段排序</p>
<p>图3 rowid排序</p>
<p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一</p>
<p>下上一篇文章的一个结论：对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被</p>
<p>优先选择。我强调了“InnoDB表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位</p>
<p>置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它</p>
<p>会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们</p>
<p>来尝试分析一下语句的扫描行数。这条语句的执行流程是这样的：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是</li>
</ol>
<p>double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段</p>
<p>W。并且，这个表没有建索引。2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一</p>
<p>个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到</p>
<p>此，扫描行数是10000。3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排</p>
<p>序。4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信</p>
<p>息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时</p>
<p>扫描行数增加10000，变成了20000。6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫</p>
<p>描行数。7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户</p>
<p>端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分</p>
<p>析得出的结论。这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行</p>
<p>数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有</p>
<p>趣，分析对了开心，分析错了但是弄清楚了也很开心。现在，我来把完整的排序执行流程图画出来。# Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</p>
<p>SET timestamp&#x3D;1541402277;</p>
<p>select word from words order by rand() limit 3;</p>
<p>图4 随机排序完整流程图1</p>
<p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章</p>
<p>中，我们对InnoDB表排序的时候，明明用的还是ID字段。这时候，我们就要回到一个基本概念：MySQL的表是用什么方法来定位“一行数据”的。在前面第4和第5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是</p>
<p>不是就没有主键，就没办法回表了？其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成</p>
<p>一个长度为6字节的rowid来作为主键。这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行</p>
<p>的信息。对于有主键的InnoDB表来说，这个rowid就是主键ID；</p>
<p>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</p>
<p>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个</p>
<p>rowid其实就是数组的下标。到这里，我来稍微小结一下：order by rand()使用了内存临时表，内存临时表排序的时候使</p>
<p>用了rowid排序方法。磁盘临时表</p>
<p>那么，是不是所有的临时表都是内存表呢？其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大</p>
<p>小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把</p>
<p>max_length_for_sort_data 设置成16。set tmp_table_size&#x3D;1024;</p>
<p>set sort_buffer_size&#x3D;32768;</p>
<p>set max_length_for_sort_data&#x3D;16;</p>
<p>&#x2F;* 打开 optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select word from words order by rand() limit 3;</p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM ìnformation_schema .̀&#96;OPTIMIZER_TRACE \̀G</p>
<p>图5 OPTIMIZER_TRACE部分结果</p>
<p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到</p>
<p>sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字</p>
<p>段组成的行。这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于</p>
<p>为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，</p>
<p>超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道</p>
<p>不需要用临时文件吗？这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，</p>
<p>即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序</p>
<p>算法，而是采用了优先队列排序算法。其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的</p>
<p>话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，</p>
<p>想一下就明白了，这浪费了非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li>
</ol>
<p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p>
<ol>
<li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中</li>
</ol>
<p>去掉，换成(R’,rowid’)；</p>
<ol start="2">
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。这里我简单画了一个优先队列排序过程的示意图。图6 优先队列排序算法示例</li>
</ol>
<p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程</p>
<p>中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的</p>
<p>chosen&#x3D;true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的</p>
<p>number_of_tmp_files是0。这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它</p>
<p>们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一</p>
<p>样了。我们再看一下上面一篇文章的SQL查询语句：</p>
<p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是</p>
<p>limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超</p>
<p>过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要</p>
<p>大量的扫描行数，因此排序过程的资源消耗也会很大。再回到我们文章开头的问题，怎么正确地随机排序呢？随机排序方法</p>
<p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p>
<ol>
<li><p>取得这个表的主键id的最大值M和最小值N;</p>
</li>
<li><p>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</p>
</li>
<li><p>取不小于X的第一个ID的行。我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p>
</li>
</ol>
<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用</p>
<p>索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要</p>
<p>求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>mysql&gt; select max(id),min(id) into @M,@N from t ;</p>
<p>set @X&#x3D; floor((@M-@N+1)*rand() + @N);</p>
<p>select * from t where id &gt;&#x3D; @X limit 1;</p>
<p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取</p>
<p>得其他行概率的两倍。如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<ol>
<li>取得整个表的行数，并记为C。2. 取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。3. 再用limit Y,1 取得一行。我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。这个随机算法2，解决了算法1里面明显的概率不均匀问题。MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为</li>
</ol>
<p>返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，</p>
<p>执行代价比随机算法1的代价要高。当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那</p>
<p>扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小</p>
<p>很多呢？我就把这个问题留给你去课后思考吧。现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p>
<ol>
<li><p>取得整个表的行数，记为C；</p>
</li>
<li><p>根据相同的随机方法得到Y1、Y2、Y3；</p>
</li>
</ol>
<p>mysql&gt; select count(*) into @C from t;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @sql &#x3D; concat(“select * from t limit “, @Y, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>execute stmt;</p>
<p>DEALLOCATE prepare stmt;</p>
<ol start="3">
<li>再执行三个limit Y, 1语句得到三行数据。我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。小结</li>
</ol>
<p>今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代</p>
<p>价往往是比较大的。所以，在设计的时候你要量避开这种写法。今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在</p>
<p>实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读</p>
<p>写数据”的事情。因此，这类方法的应用还是比较广泛的。最后，我给你留下一个思考题吧。上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来</p>
<p>进一步减少扫描行数的。我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，</p>
<p>并说明你的方案需要的扫描行数。你可以把你的设计和结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，select * from t where city in (“杭州”,” 苏州 “) order by</p>
<p>name limit 100;这个SQL语句是否需要排序？有什么方案可以避免排序？虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要</p>
<p>单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不</p>
<p>是递增的了。也就是说，这条SQL语句需要排序。mysql&gt; select count(*) into @C from t;</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>set @Y3 &#x3D; floor(@C * rand());</p>
<p>select * from t limit @Y1，1； &#x2F;&#x2F;在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</p>
<p>select * from t limit @Y2，1；</p>
<p>select * from t limit @Y3，1；</p>
<p>那怎么避免排序呢？这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p>
<ol>
<li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客</li>
</ol>
<p>户端用一个长度为100的内存数组A保存结果。2. 执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存</p>
<p>进了内存数组B。3. 现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就</p>
<p>是我们需要的结果了。如果把这条SQL语句里“limit 100”改成“limit 10000,100”的话，处理方式其实也差不多，即：要把</p>
<p>上面的两条语句改成写：</p>
<p>和</p>
<p>这时候数据量较大，可以同时起两个连接一行行读结果，用归并排序算法拿到这两个结果集里，</p>
<p>按顺序取第10001~10100的name值，就是需要的结果了。当然这个方案有一个明显的损失，就是从数据库返回给客户端的数据量变大了。所以，如果数据的单行比较大的话，可以考虑把这两条SQL语句改成下面这种写法：</p>
<p>和</p>
<p>然后，再用归并排序的方法取得按name顺序第10001~10100的name、id的值，然后拿着这100</p>
<p>个id到数据库中去查出所有记录。上面这些方法，需要你根据性能需求和开发的复杂度做出权衡。select * from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p> select * from t where city&#x3D;”苏州” order by name limit 10100。select id,name from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p>select id,name from t where city&#x3D;”苏州” order by name limit 10100。评论区留言点赞板：</p>
<p>老杨同志   21</p>
<p>对应单词这种总量不是很多的数据，第一感觉应该装jdk缓存或者redis缓存。由于需要随机访问</p>
<p>，数组比较好。假如一个单词平均10个字节，10*10000，不到1M就装下了。如果一定要用数据库来做，老师的方案1比较好，空洞的问题，如果单词库不变，可以在上线前</p>
<p>整理数据，把空洞处理调。比如：原来单词存在A表，新建B表 ，执行 insert into B(word) selec</p>
<p>t word from A. B的id是自增的，就会生成连续的主键。当然如果A表写比较频繁，且数据量较大</p>
<p>，业务上禁用 这种写法，RR的隔离级别会锁A表 </p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>重新整理表这个思路很赞  </p>
<p>看得出你是业务经验很丰富啊，这几次问题，对底层实现和业务功能的平衡，考虑点很不错</p>
<p>评论区很多同学都提到不能排序，说明各位对索引的存储都理解对了。@峰 同学提到了归并排序，是我们这个问题解法的核心思想；</p>
<p>@老杨同志 的回答中提到了“从业务上砍掉功能”，这个也确实是在业务设计中可以考虑的一个</p>
<p>方向；</p>
<p>@某、人 帮忙回答了@发条橙子同学的问题，尤其是对问题一的回答，非常精彩。精选留言</p>
<p>2018-12-21</p>
<p>雪中鼠[悠闲]   4</p>
<p>如果按照业务需求，随机取三个，数据库还在设计阶段,可以增加一个主键字段,用来记录每行记</p>
<p>录的rowid，这样一万行，那就是连续的一万，然后随机，用该随机rowid回表查询该行记录</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>这个也是个好方法，就是确保连续，可以快速的得到C和几个偏移量</p>
<p>2018-12-21</p>
<p>吴宇晨   16</p>
<p>我觉得可以按Y排个序，第一条取完，拿到对应id，然后有一条语句就是where id大于xxx，limit </p>
<p>y2-y1，1</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>抓住了关键点  </p>
<p>2018-12-21</p>
<p>慧鑫coming   10</p>
<p>又到周五了，开心 </p>
<p>2018-12-21</p>
<p>HuaMax   7</p>
<p>假设Y1，Y2，Y3是由小到大的三个数，则可以优化成这样，这样扫描行数为Y3</p>
<p>id1 &#x3D; select * from t limit @Y1，1；</p>
<p>id2&#x3D; select * from t where id &gt; id1 limit @Y2-@Y1，1；</p>
<p>select * from t where id &gt; id2 limit @Y3 - @Y2，1；</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-21</p>
<p>freesia   4</p>
<p>从上一讲到这一讲，我发现老师在处理问题时，提出的方法就不再是单纯依靠MySQL解决，因</p>
<p>为可能会耗费很多资源，而是把问题分担一部分到客户端，比如客户端拿到数据后再排序，或</p>
<p>者客户端产生随机数再到MySQL中去查询。2018-12-23</p>
<p> 作者回复</p>
<p>嗯嗯，MySQL 的代码和业务代码都是代码  配合起来用</p>
<p>2018-12-23</p>
<p>李皮皮皮皮皮   4</p>
<p>我经常在文中看到多个事务的执行时序。线下做实验的时候，是怎么保证能按这个时序执行呢</p>
<p>？2018-12-21</p>
<p> 作者回复</p>
<p>开两个窗口，按顺序执行命令哦</p>
<p>2018-12-21</p>
<p>岁月安然   2</p>
<p>为什么随机算法2比order by rand()的代价小很多？因为随机算法2进行limit获取数据的时候是根据主键排序获取的，主键天然索引排序。获取到第</p>
<p>9999条的数据也远比order by rand()方法的组成临时表R字段排序再获取rowid代价小的多。2018-12-21</p>
<p> 作者回复</p>
<p>对的，</p>
<p>你是第一个回答正文中间问题的   </p>
<p>2018-12-21</p>
<p>倪大人   2</p>
<p>课后题可以在随机出Y1、Y2、Y3后，算出Ymax、Ymin</p>
<p>再用 select id from t limit Ymin，(Ymax - Ymin)；</p>
<p>得到id集后算出Y1、Y2、Y3对应的三个id</p>
<p>最后 select * from t where id in (id1, id2, id3)</p>
<p>这样扫描的行数应该是C+Ymax+3</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>漂亮</p>
<p>2018-12-21</p>
<p>董航   2</p>
<p>堆结构，大顶树，小顶树！！！</p>
<p>2018-12-21</p>
<p>王飞洋   2</p>
<p>归并排序，优先队列，算法无处不在。2018-12-21</p>
<p> 作者回复</p>
<p>要说算法还是隔壁王老师讲的专业，这里咱们就只追求MySQL 里面用到的，能给大家讲明白</p>
<p>就行了 </p>
<p>2018-12-21</p>
<p>某、人   1</p>
<p>今天这个问题我的理解转换成sql是:</p>
<p>mysql&gt; select count(*) into @C from t1;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>select LEAST(@Y,@Y1,@Y2) into @Y4;</p>
<p>select GREATEST(@Y,@Y1,@Y2) into @Y6;</p>
<p>select floor((@Y6+@Y4)&#x2F;2) into @Y5;</p>
<p>set @sql &#x3D; concat(“select id into @id from t1 limit “, @Y4, “,1”);</p>
<p>set @sql1 &#x3D; concat(“select id into @id1 from t1 where id&gt;@id limit “, @Y5-@Y4, “,1”);</p>
<p>set @sql2 &#x3D; concat(“select id into @id2 from t1 where id&gt;@id1 limit “, @Y6-@Y5, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>prepare stmt1 from @sql1;</p>
<p>prepare stmt2 from @sql2;</p>
<p>execute stmt;</p>
<p>execute stmt1;</p>
<p>execute stmt2;</p>
<p>DEALLOCATE prepare stmt;</p>
<p>DEALLOCATE prepare stmt1;</p>
<p>DEALLOCATE prepare stmt2;</p>
<p>select * from t1 where id in (@id,@id1,@id2);</p>
<p>感觉mysql不太适合处理随机数的问题,稍稍有点复杂。不过这两节课收获很多,对order by排序理解又深入不少,原来堆排序是放limit m,m行如果比sort_</p>
<p>buffer占用空间小,则先把m行放进数据集里,然后在把表里的数据一行一行取出来做比较。得出</p>
<p>的结果,在根据MRR回表取数据。老师,我有一个问题:</p>
<p>堆排序,如果比较的值是相等的情况下,会不会替换在sort_buffer里？我感觉是不会,如果不会才能</p>
<p>解释得通排序值相等,id不等的情况,不管是大顶堆还是小顶堆,得到的结果集都是id相对更小的</p>
<p>2018-12-23</p>
<p>路过   1</p>
<p>老师，我为快速执行存储过程。把参数位置为：</p>
<p>innodb_flush_log_at_trx_commit&#x3D;2</p>
<p>sync_binlog&#x3D;0</p>
<p>执行马上就结束了。否则要等很久。请教老师，上面修改后，数据和log还没有真正刷到磁盘。请问我在哪里可以看到相关的信息。使用show engine innodb status\G 看到：</p>
<p>0 pending log flushes, 0 pending chkp writes</p>
<p>20197 log i&#x2F;o’s done, 0.00 log i&#x2F;o’s&#x2F;second</p>
<p>谢谢！</p>
<p>2018-12-22</p>
<p> 作者回复</p>
<p>确实没地方看 </p>
<p>2018-12-22</p>
<p>风动草   1</p>
<p>老师好！您说的在建二级索引的过程中，是把主键取出来构造二级索引，而且要读全表，这个</p>
<p>读全表意思是不是，读了主键，就意味着主键的叶子节点也一起读出来了？2018-12-22</p>
<p> 作者回复</p>
<p>是的</p>
<p>2018-12-22</p>
<p>无眠   1</p>
<p>一直比较疑惑什么情况下会产生临时表Using temporary，希望老师指点下</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>查询需要临时表，比如我们这个例子里，需要临时表来放rand()结果</p>
<p>2018-12-21</p>
<p>银太@巨益科技   1</p>
<p>请教下老师：</p>
<p>表A有sku和warehouse两个字段组成的唯一索引,udx_sku_warehouse，高并发下容易死锁</p>
<p>执行的语句：update A set quantity&#x3D;quantity+1 where sku&#x3D;xx and warehouse&#x3D;xx</p>
<p>查看死锁的日志：两个事务都在等待udx_sku_warehouse的X锁，但两个事务修改的并不是同</p>
<p>一条记录，不是很明白，可以讲解一下吗？多谢</p>
<p>*** (1) TRANSACTION:</p>
<p>TRANSACTION 466841895, ACTIVE 0.021 sec starting index read</p>
<p>mysql tables in use 1, locked 1</p>
<p>LOCK WAIT 11 lock struct(s), heap size 2936, 9 row lock(s), undo log entries 11</p>
<p>LOCK BLOCKING MySQL thread id: 1927379 block 1895984</p>
<p>MySQL thread id 1895984, OS thread handle 0x2b2ffed85700, query id 783954740 10.27.8.222 </p>
<p>oms updating</p>
<p>UPDATE oms_stock</p>
<p>SET quantity &#x3D; quantity + -1</p>
<p>WHERE sku_id &#x3D; 13978218638755841</p>
<p>AND virtual_warehouse_id &#x3D; 13867758969455616</p>
<p>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 297 page no 89 n bits 424 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841895 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 18 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>*** (2) TRANSACTION:</p>
<p>TRANSACTION 466841901, ACTIVE 0.015 sec starting index read</p>
<p>mysql tables in use 1, locked 1</p>
<p>11 lock struct(s), heap size 2936, 8 row lock(s), undo log entries 9</p>
<p>MySQL thread id 1927379, OS thread handle 0x2b2f97440700, query id 783954758 10.27.8.222 </p>
<p>oms updating</p>
<p>UPDATE oms_stock</p>
<p>SET quantity &#x3D; quantity + -1</p>
<p>WHERE sku_id &#x3D; 1809040003028</p>
<p>AND virtual_warehouse_id &#x3D; 13867758969455616</p>
<p>*** (2) HOLDS THE LOCK(S):</p>
<p>RECORD LOCKS space id 297 page no 89 n bits 424 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841901 lock_mode X locks rec but not gap</p>
<p>Record lock, heap no 18 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 297 page no 74 n bits 400 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841901 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 12 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>你一个事务里面是不是不止一个这样的update 语句?</p>
<p>2018-12-21</p>
<p>penelopewu   1</p>
<p>运行老师给的存储过程特别慢，怎么排查原因呢，mysql版本是8.0.13</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>把innodb_flush_at_trx_commit设置成2，sync_binlog设置成1000看看</p>
<p>2018-12-21</p>
<p>往事随风，顺其自然   1</p>
<p>临时表设置参数单位是k还是m?</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>字节</p>
<p>2018-12-21</p>
<p>奋斗心   0</p>
<p>20000行是指：扫描10000行到内存临时表，还有10000行是随机排序吗</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>第一个10000是扫描原表，第二个10000是扫描内存表；</p>
<p>排序过程本身是不增加扫描行数的</p>
<p>2019-02-03</p>
<p>阿狸爱JAVA   0</p>
<p>感觉老师的思路很宽广，就像一个大宝藏，方案一不行还有方案二，方案二不行还有方案三，</p>
<p>并且每个方案都能给出具体的性能比较与证据，而自己自能顺着老师的思路还能明白，可是一</p>
<p>旦扩展开来，便大脑一片空白</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>加油慢慢来哈~~ </p>
<p>2019-01-31</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/ab80f837.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/ab80f837.html" class="post-title-link" itemprop="url">mysql-“order by”是怎么工作的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-18 06:02:14" itemprop="dateCreated datePublished" datetime="2019-11-18T06:02:14+08:00">2019-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>16 | “order by”是怎么工作的？2018-12-19 林晓斌</p>
<p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们</p>
<p>前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回</p>
<p>前1000个人的姓名、年龄。假设这个表的部分定义是这样的：</p>
<p>这时，你的SQL语句可以这么写：</p>
<p>CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>city</code> varchar(16) NOT NULL,</p>
<p>  <code>name</code> varchar(16) NOT NULL,</p>
<p>  <code>age</code> int(11) NOT NULL,</p>
<p>  <code>addr</code> varchar(128) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>city</code> (<code>city</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么</p>
<p>执行的，以及有什么参数会影响执行的行为。全字段排序</p>
<p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索</p>
<p>引。在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。图1 使用explain命令查看语句的执行情况</p>
<p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于</p>
<p>排序，称为sort_buffer。为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。图2 city字段的索引示意图</p>
<p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li><p>初始化sort_buffer，确定放入name、city、age这三个字段；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name做快速排序；</p>
</li>
<li><p>按照排序结果取前1000行返回给客户端。我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还</p>
</li>
</ol>
<p>会用到这个排序。图3 全字段排序</p>
<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所</p>
<p>需的内存和参数sort_buffer_size。sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量</p>
<p>小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不</p>
<p>利用磁盘临时文件辅助排序。你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中</p>
<p>看到是否使用了临时文件。&#x2F;* 打开optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* @a保存Innodb_rows_read的初始值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select city, name,age from t where city&#x3D;’杭州’ order by name limit 1000; </p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM <code>information_schema</code>.<code>OPTIMIZER_TRACE</code>\G</p>
<p>&#x2F;* @b保存Innodb_rows_read的当前值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 计算Innodb_rows_read差值 *&#x2F;</p>
<p>select @b-@a;</p>
<p>图4 全排序的OPTIMIZER_TRACE部分结果</p>
<p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个</p>
<p>文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理</p>
<p>解，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把</p>
<p>这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序</p>
<p>可以直接在内存中完成。否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越</p>
<p>多，number_of_tmp_files的值就越大。接下来，我再和你解释一下图4中其他两个值的意思。我们的示例表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示</p>
<p>参与排序的行数是4000行。sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使</p>
<p>name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000</p>
<p>行。这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成</p>
<p>MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而</p>
<p>internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数</p>
<p>据从临时表取出来的时候，会让Innodb_rows_read的值加1。rowid排序</p>
<p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件</p>
<p>中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面</p>
<p>要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能</p>
<p>会很差。所以如果单行很大，这个方法效率不够好。那么，如果MySQL认为排序的单行长度太大会怎么做呢？接下来，我来修改一个参数，让MySQL采用另外一种算法。max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意</p>
<p>思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我</p>
<p>们再来看看计算过程有什么改变。新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如</p>
<p>下所示的样子：</p>
<ol>
<li><p>初始化sort_buffer，确定放入两个字段，即name和id；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name进行排序；</p>
</li>
<li><p>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回</p>
</li>
</ol>
<p>给客户端。这个执行流程的示意图如下，我把它称为rowid排序。SET max_length_for_sort_data &#x3D; 16;</p>
<p>图5 rowid排序</p>
<p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中</p>
<p>依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存</p>
<p>存储结果，是直接返回给客户端的。根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？现在，我们就来看看结果有什么不同。首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-</p>
<p>@a这个语句的值变成5000了。因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因</p>
<p>此会多读1000行。图6 rowid排序的OPTIMIZER_TRACE部分输出</p>
<p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一</p>
<p>行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。全字段排序 VS rowid排序</p>
<p>我们来分析一下，从这两个执行流程里，还能得出什么结论。如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过</p>
<p>程中一次可以排序更多行，但是需要再回到原表去取数据。如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这</p>
<p>样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的</p>
<p>order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句</p>
<p>的执行时间也会变得更短。其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看</p>
<p>到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无</p>
<p>序的。你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，</p>
<p>是不是就可以不用再排序了呢？确实是这样的。所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<p>作为与city索引的对比，我们来看看这个索引的示意图。图7 city和name联合索引示意图</p>
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外</p>
<p>确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是</p>
<p>有序的。这样整个查询过程的流程就变成了：</p>
<ol>
<li><p>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返</p>
</li>
</ol>
<p>回；</p>
<ol start="3">
<li>从索引(city,name)取下一个记录主键id；</li>
</ol>
<p>alter table t add index city_user(city, name);</p>
<ol start="4">
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图8 引入(city,name)联合索引后，查询语句的执行计划</li>
</ol>
<p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一</p>
<p>下。图9 引入(city,name)联合索引后，查询语句的执行计划</p>
<p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)</p>
<p>这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前</p>
<p>1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。既然说到这里了，我们再往前讨论，这个语句的执行流程有没有可能进一步简化呢？不知道</p>
<p>你还记不记得，我在第5篇文章《 深入浅出索引（下）》中，和你介绍的覆盖索引。这里我们可以再稍微复习一下。覆盖索引是指，索引上的信息足够满足查询请求，不需要再</p>
<p>回到主键索引上去取数据。按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也</p>
<p>就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age</li>
</ol>
<p>这三个字段的值，作为结果集的一部分直接返回；</p>
<ol start="2">
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接</li>
</ol>
<p>返回；</p>
<ol start="3">
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图10 引入(city,name,age)联合索引后，查询语句的执行流程</li>
</ol>
<p>然后，我们再来看看explain的结果。alter table t add index city_user_age(city, name, age);</p>
<p>图11 引入(city,name,age)联合索引后，查询语句的执行计划</p>
<p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索</p>
<p>引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。小结</p>
<p>今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻</p>
<p>辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能</p>
<p>做到下笔如有神，不犯低级错误。最后，我给你留下一个思考题吧。假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市</p>
<p>中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p>
<p>那么，这个语句执行的时候会有排序过程吗，为什么？如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你</p>
<p>的实现方法又会是什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会</p>
<p>真的去执行一次修改吗？还是看到值相同就直接返回呢？这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我</p>
<p>们可以用一个锁实验来确认。mysql&gt; select * from t where city in (‘杭州’,”苏州”) order by name limit 100;</p>
<p>假设，当前表t里的值是(1,2)。图12 锁验证方式</p>
<p>session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新，</p>
<p>直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。假设当前表里的值是(1,2)。图13 可见性验证方式</p>
<p>session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语</p>
<p>句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章《事务到底是隔</p>
<p>离的还是不隔离的？》中的相关内容）</p>
<p>所以，我们上期思考题的答案应该是选项3，即：InnoDB认真执行了“把这个值修改成(1,2)”这个</p>
<p>操作，该加锁的加锁，该更新的更新。然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不</p>
<p>就不用浪费InnoDB操作，多去更新一次了？其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的</p>
<p>(id&#x3D;1), 而要写的是(a&#x3D;3)，只从这两个信息是看不出来“不需要修改”的。作为验证，你可以看一下下面这个例子。图14 可见性验证方式–对照</p>
<p>补充说明：</p>
<p>上面我们的验证结果都是在binlog_format&#x3D;statement格式下进行的。@didiren 补充了一个case， 如果是binlog_format&#x3D;row 并且binlog_row_image&#x3D;FULL的时候，由</p>
<p>于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id&#x3D;1，</p>
<p>结果就是“返回 (1,2)”。同理，如果是binlog_row_image&#x3D;NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里，</p>
<p>结果还是“返回 (1,2)”。对应的代码如图15所示。这是MySQL 5.6版本引入的，在此之前我没有看过。所以，特此说明。图15 binlog_row_image&#x3D;FULL读字段逻辑</p>
<p>类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字</p>
<p>段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样</p>
<p>通过判断，就会发现不需要修改。这两个点我会在后面讲更新性能的文章中再展开。评论区留言点赞板：</p>
<p>@Gavin 、@melon、@阿建 等同学提到了锁验证法；</p>
<p>@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的：</p>
<p>第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下</p>
<p>的策略。你可以把binlog_format 改成statement再验证下。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/5d094abf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/5d094abf.html" class="post-title-link" itemprop="url">mysql-“order by”是怎么工作的(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-17 06:18:29" itemprop="dateCreated datePublished" datetime="2019-11-17T06:18:29+08:00">2019-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>16 | “order by”是怎么工作的？2018-12-19 林晓斌</p>
<p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们</p>
<p>前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回</p>
<p>前1000个人的姓名、年龄。假设这个表的部分定义是这样的：</p>
<p>这时，你的SQL语句可以这么写：</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;city  ̀varchar(16) NOT NULL,</p>
<p>  &#96;name  ̀varchar(16) NOT NULL,</p>
<p>  &#96;age  ̀int(11) NOT NULL,</p>
<p>  &#96;addr̀  varchar(128) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;city  ̀(̀ city )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么</p>
<p>执行的，以及有什么参数会影响执行的行为。全字段排序</p>
<p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索</p>
<p>引。在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。图1 使用explain命令查看语句的执行情况</p>
<p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于</p>
<p>排序，称为sort_buffer。为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。图2 city字段的索引示意图</p>
<p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li><p>初始化sort_buffer，确定放入name、city、age这三个字段；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name做快速排序；</p>
</li>
<li><p>按照排序结果取前1000行返回给客户端。我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还</p>
</li>
</ol>
<p>会用到这个排序。图3 全字段排序</p>
<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所</p>
<p>需的内存和参数sort_buffer_size。sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量</p>
<p>小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不</p>
<p>利用磁盘临时文件辅助排序。你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中</p>
<p>看到是否使用了临时文件。&#x2F;* 打开optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* @a保存Innodb_rows_read的初始值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select city, name,age from t where city&#x3D;’杭州’ order by name limit 1000; </p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM ìnformation_schema .̀&#96;OPTIMIZER_TRACE \̀G</p>
<p>&#x2F;* @b保存Innodb_rows_read的当前值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 计算Innodb_rows_read差值 *&#x2F;</p>
<p>select @b-@a;</p>
<p>图4 全排序的OPTIMIZER_TRACE部分结果</p>
<p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个</p>
<p>文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理</p>
<p>解，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把</p>
<p>这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序</p>
<p>可以直接在内存中完成。否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越</p>
<p>多，number_of_tmp_files的值就越大。接下来，我再和你解释一下图4中其他两个值的意思。我们的示例表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示</p>
<p>参与排序的行数是4000行。sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使</p>
<p>name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000</p>
<p>行。这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成</p>
<p>MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而</p>
<p>internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数</p>
<p>据从临时表取出来的时候，会让Innodb_rows_read的值加1。rowid排序</p>
<p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件</p>
<p>中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面</p>
<p>要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能</p>
<p>会很差。所以如果单行很大，这个方法效率不够好。那么，如果MySQL认为排序的单行长度太大会怎么做呢？接下来，我来修改一个参数，让MySQL采用另外一种算法。max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意</p>
<p>思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我</p>
<p>们再来看看计算过程有什么改变。新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如</p>
<p>下所示的样子：</p>
<ol>
<li><p>初始化sort_buffer，确定放入两个字段，即name和id；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name进行排序；</p>
</li>
<li><p>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回</p>
</li>
</ol>
<p>给客户端。这个执行流程的示意图如下，我把它称为rowid排序。SET max_length_for_sort_data &#x3D; 16;</p>
<p>图5 rowid排序</p>
<p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中</p>
<p>依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存</p>
<p>存储结果，是直接返回给客户端的。根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？现在，我们就来看看结果有什么不同。首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-</p>
<p>@a这个语句的值变成5000了。因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因</p>
<p>此会多读1000行。图6 rowid排序的OPTIMIZER_TRACE部分输出</p>
<p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一</p>
<p>行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。全字段排序 VS rowid排序</p>
<p>我们来分析一下，从这两个执行流程里，还能得出什么结论。如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过</p>
<p>程中一次可以排序更多行，但是需要再回到原表去取数据。如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这</p>
<p>样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的</p>
<p>order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句</p>
<p>的执行时间也会变得更短。其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看</p>
<p>到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无</p>
<p>序的。你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，</p>
<p>是不是就可以不用再排序了呢？确实是这样的。所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<p>作为与city索引的对比，我们来看看这个索引的示意图。图7 city和name联合索引示意图</p>
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外</p>
<p>确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是</p>
<p>有序的。这样整个查询过程的流程就变成了：</p>
<ol>
<li><p>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返</p>
</li>
</ol>
<p>回；</p>
<ol start="3">
<li>从索引(city,name)取下一个记录主键id；</li>
</ol>
<p>alter table t add index city_user(city, name);</p>
<ol start="4">
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图8 引入(city,name)联合索引后，查询语句的执行计划</li>
</ol>
<p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一</p>
<p>下。图9 引入(city,name)联合索引后，查询语句的执行计划</p>
<p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)</p>
<p>这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前</p>
<p>1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。既然说到这里了，我们再往前讨论，这个语句的执行流程有没有可能进一步简化呢？不知道</p>
<p>你还记不记得，我在第5篇文章《 深入浅出索引（下）》中，和你介绍的覆盖索引。这里我们可以再稍微复习一下。覆盖索引是指，索引上的信息足够满足查询请求，不需要再</p>
<p>回到主键索引上去取数据。按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也</p>
<p>就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age</li>
</ol>
<p>这三个字段的值，作为结果集的一部分直接返回；</p>
<ol start="2">
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接</li>
</ol>
<p>返回；</p>
<ol start="3">
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图10 引入(city,name,age)联合索引后，查询语句的执行流程</li>
</ol>
<p>然后，我们再来看看explain的结果。alter table t add index city_user_age(city, name, age);</p>
<p>图11 引入(city,name,age)联合索引后，查询语句的执行计划</p>
<p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索</p>
<p>引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。小结</p>
<p>今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻</p>
<p>辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能</p>
<p>做到下笔如有神，不犯低级错误。最后，我给你留下一个思考题吧。假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市</p>
<p>中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p>
<p>那么，这个语句执行的时候会有排序过程吗，为什么？如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你</p>
<p>的实现方法又会是什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会</p>
<p>真的去执行一次修改吗？还是看到值相同就直接返回呢？这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我</p>
<p>们可以用一个锁实验来确认。mysql&gt; select * from t where city in (‘杭州’,”苏州”) order by name limit 100;</p>
<p>假设，当前表t里的值是(1,2)。图12 锁验证方式</p>
<p>session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新，</p>
<p>直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。假设当前表里的值是(1,2)。图13 可见性验证方式</p>
<p>session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语</p>
<p>句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章《事务到底是隔</p>
<p>离的还是不隔离的？》中的相关内容）</p>
<p>所以，我们上期思考题的答案应该是选项3，即：InnoDB认真执行了“把这个值修改成(1,2)”这个</p>
<p>操作，该加锁的加锁，该更新的更新。然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不</p>
<p>就不用浪费InnoDB操作，多去更新一次了？其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的</p>
<p>(id&#x3D;1), 而要写的是(a&#x3D;3)，只从这两个信息是看不出来“不需要修改”的。作为验证，你可以看一下下面这个例子。图14 可见性验证方式–对照</p>
<p>补充说明：</p>
<p>上面我们的验证结果都是在binlog_format&#x3D;statement格式下进行的。@didiren 补充了一个case， 如果是binlog_format&#x3D;row 并且binlog_row_image&#x3D;FULL的时候，由</p>
<p>于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id&#x3D;1，</p>
<p>结果就是“返回 (1,2)”。同理，如果是binlog_row_image&#x3D;NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里，</p>
<p>结果还是“返回 (1,2)”。对应的代码如图15所示。这是MySQL 5.6版本引入的，在此之前我没有看过。所以，特此说明。图15 binlog_row_image&#x3D;FULL读字段逻辑</p>
<p>类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字</p>
<p>段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样</p>
<p>通过判断，就会发现不需要修改。这两个点我会在后面讲更新性能的文章中再展开。评论区留言点赞板：</p>
<p>某、人   20</p>
<p>回答下@发条橙子同学的问题:</p>
<p>问题一：</p>
<p>1)无条件查询如果只有order by create_time,即便create_time上有索引,也不会使用到。因为优化器认为走二级索引再去回表成本比全表扫描排序更高。所以选择走全表扫描,然后根据老师讲的两种方式选择一种来排序</p>
<p>2)无条件查询但是是order by create_time limit m.如果m值较小,是可以走索引的.</p>
<p>因为优化器认为根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比</p>
<p>@Gavin 、@melon、@阿建 等同学提到了锁验证法；</p>
<p>@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的：</p>
<p>第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下</p>
<p>的策略。你可以把binlog_format 改成statement再验证下。精选留言</p>
<p>全表扫描小,则选择走二级索引。即便没有二级索引,mysql针对order by limit也做了优化,采用堆排序。这部分老师明天会讲</p>
<p>问题二:</p>
<p>如果是group by a,a上不能使用索引的情况,是走rowid排序。如果是group by limit,不能使用索引的情况,是走堆排序</p>
<p>如果是只有group by a,a上有索引的情况,又根据选取值不同,索引的扫描方式又有不同</p>
<p>select * from t group by a –走的是索引全扫描,至于这里为什么选择走索引全扫描,还需要老师解</p>
<p>惑下</p>
<p>select a from t group by a –走的是索引松散扫描,也就说只需要扫描每组的第一行数据即可,不</p>
<p>用扫描每一行的值</p>
<p>问题三:</p>
<p>bigint和int加数字都不影响能存储的值。bigint(1)和bigint(19)都能存储2^64-1范围内的值,int是2^32-1。只是有些前端会根据括号里来截</p>
<p>取显示而已。建议不加varchar()就必须带,因为varchar()括号里的数字代表能存多少字符。假设</p>
<p>varchar(2),就只能存两个字符,不管是中文还是英文。目前来看varchar()这个值可以设得稍稍大</p>
<p>点,因为内存是按照实际的大小来分配内存空间的,不是按照值来预分配的。老师我有几个问题:</p>
<p>1.我还是想在确认之前问的问题。一个长连接,一条sql申请了sort_buffer_size等一系列的会话级</p>
<p>别的内存,sql成功执行完,该连接变为sleep状态。这些内存只是内容会被情况,但是占用的内存空</p>
<p>间不会释放?</p>
<p>2.假设要给a值加1,执行器先找引擎取a&#x3D;1的行,然后执行器给a+1,在调用接口写入a+1了数据。那么加锁不应该是在执行器第一次去取数据时，引擎层就加该加的锁？为什么要等到第二次调</p>
<p>用写入数据时,才加锁。第一次和第二次之间,难道不会被其他事务修改吗？如果没有锁保证</p>
<p>3.始终没太明白堆排序是采用的什么算法使得只需要对limit的数据进行排序就可以,而不是排序</p>
<p>所有的数据在取前m条。–不过这里期待明天的文章</p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>发条橙子同学的问题：</p>
<p>问题1:你回答得比我回复的答案还好！  </p>
<p>问题2:这个后面我们展开哈，要配图才能说得清 </p>
<p>问题3:回答得也很好，需要注意的是255这个边界。小于255都需要一个字节记录长度，超过25</p>
<p>5就需要两个字节</p>
<p>你的问题：#好问题_#</p>
<ol>
<li><p>排序相关的内存在排序后就free掉还给系统了</p>
</li>
<li><p>读的时候加了写锁的</p>
</li>
<li><p>堆排序要读所有行的，只读一次，我估计你已经理解对了 </p>
</li>
</ol>
<p>2018-12-20</p>
<p>didiren   6</p>
<p>刚才又测了一下，在binlog-row-image&#x3D;full的情况下，第二次update是不写redolog的，说明upd</p>
<p>ate并没有发生</p>
<p>这样我就理解了，当full时，mysql需要读到在更新时读到a值，所以会判断a值不变，不需要更</p>
<p>新，与你给出的update t set a&#x3D;3 where id&#x3D;1 and a&#x3D;3原理相同，但binlog-row-image会影响查询</p>
<p>结果还是会让人吃一惊</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>是的。这个我也盲点了。但是细想MySQL 选择这个策略又是合理的。我需要再更新一下专栏内容</p>
<p>2018-12-19</p>
<p>null   2</p>
<p>re: 问题3:回答得也很好，需要注意的是255这个边界。小于255都需要一个字节记录长度，超过</p>
<p>255就需要两个字节</p>
<p>11 月过数据库设计方案，总监现场抛了一个问题，就是关于 varchar 255 的。现在回看，木有</p>
<p>人回答到点上，都说是历史原因。下回再问，就可以分享这一点了。  (˵¯̴ ͒  ¯̴ ͒ ˵) ”哇哈哈～</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>最怕的回答“历史原因”、“大家都这么做的所以…”、“别人要求的”  </p>
<p>2018-12-21</p>
<p>老杨同志   11</p>
<ol>
<li></li>
</ol>
<p>mysql&gt; select * from t where city in (‘杭州’,” 苏州 “) order by name limit 100;</p>
<p>需要排序</p>
<p>原因是索引顺序城市、名称 与 单独按name排序的顺序不一致。2）如果不想mysql排序</p>
<p>方案a</p>
<p>可以执行两条语句</p>
<p>select * from t where city &#x3D; ‘杭州’ limit 100;</p>
<p>select * from t where city &#x3D; ‘苏州’ limit 100;</p>
<p>然后把200条记录在java中排序。方案b</p>
<p>分别取前100，然后在数据端对200条数据进行排序。可以sort buffer就可以完成排序了。少了一次应用程序与数据库的网络交互</p>
<p>select * from (</p>
<p>select * from t where city &#x3D; ‘杭州’ limit 100</p>
<p>union all</p>
<p>select * from t where city &#x3D; ‘苏州’ limit 100</p>
<p>) as tt order by name limit 100</p>
<p>3）对分页的优化。没有特别好的办法。如果业务允许不提供排序功能，不提供查询最后一页，只能一页一页的翻</p>
<p>，基本上前几页的数据已经满足客户需求。为了意义不大的功能优化，可能会得不偿失。如果一定要优化可以 select id from t where city in (‘杭州’,” 苏州 “) order by name limit 10000,10</p>
<p>0</p>
<p>因为有city\name索引，上面的语句走覆盖索引就可以完成，不用回表。最后使用 select * from t where id in (); 取得结果</p>
<p>对于这个优化方法，我不好确定的是临界点，前几页直接查询就可以，最后几页使用这个优化</p>
<p>方法。但是中间的页码应该怎么选择不太清楚</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>从业务上砍掉功能，这个意识很好   </p>
<p>2018-12-19</p>
<p>波波   6</p>
<p>笔记:</p>
<p>1.MySQL会为每个线程分配一个内存（sort_buffer）用于排序该内存大小为sort_buffer_size</p>
<p>1&gt;如果排序的数据量小于sort_buffer_size，排序将会在内存中完成</p>
<p>2&gt;如果排序数据量很大，内存中无法存下这么多数据，则会使用磁盘临时文件来辅助排序，也</p>
<p>称外部排序</p>
<p>3&gt;在使用外部排序时，MySQL会分成好几份单独的临时文件用来存放排序后的数据，然后在将</p>
<p>这些文件合并成一个大文件</p>
<p>2.mysql会通过遍历索引将满足条件的数据读取到sort_buffer，并且按照排序字段进行快速排序</p>
<p>1&gt;如果查询的字段不包含在辅助索引中，需要按照辅助索引记录的主键返回聚集索引取出所需</p>
<p>字段</p>
<p>2&gt;该方式会造成随机IO，在MySQL5.6提供了MRR的机制，会将辅助索引匹配记录的主键取出</p>
<p>来在内存中进行排序，然后在回表</p>
<p>3&gt;按照情况建立联合索引来避免排序所带来的性能损耗，允许的情况下也可以建立覆盖索引来</p>
<p>避免回表</p>
<p>全字段排序</p>
<p>1.通过索引将所需的字段全部读取到sort_buffer中</p>
<p>2.按照排序字段进行排序</p>
<p>3.将结果集返回给客户端</p>
<p>缺点：</p>
<p>1.造成sort_buffer中存放不下很多数据，因为除了排序字段还存放其他字段，对sort_buffer的利</p>
<p>用效率不高</p>
<p>2.当所需排序数据量很大时，会有很多的临时文件，排序性能也会很差</p>
<p>优点：MySQL认为内存足够大时会优先选择全字段排序，因为这种方式比rowid 排序避免了一</p>
<p>次回表操作</p>
<p>rowid排序</p>
<p>1.通过控制排序的行数据的长度来让sort_buffer中尽可能多的存放数据，max_length_for_sort_</p>
<p>data</p>
<p>2.只将需要排序的字段和主键读取到sort_buffer中，并按照排序字段进行排序</p>
<p>3.按照排序后的顺序，取id进行回表取出想要获取的数据</p>
<p>4.将结果集返回给客户端</p>
<p>优点：更好的利用内存的sort_buffer进行排序操作，尽量减少对磁盘的访问</p>
<p>缺点：回表的操作是随机IO，会造成大量的随机读，不一定就比全字段排序减少对磁盘的访问</p>
<p>3.按照排序的结果返回客户所取行数</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-21</p>
<p>峰   3</p>
<p>由于city有两个值，相当于匹配到了索引树的两段区域，虽然各自都是按name排序，但整体需</p>
<p>要做一次归并，当然只是limit100，所以够数就行。再然后如果需要不做排序，业务端就按city</p>
<p>不同的取值查询两次，每次都limit100，然后业务端做归并处理喽。再然后要做分页的话，好吧</p>
<p>，我的思路是先整出一张临时的结果表，create table as select rownumber,* from t where city&#x3D;</p>
<p>x order by name(写的不对哈，只是表达意思，rownumber为行数,并为主键)然后直接从这张表</p>
<p>中按rownumber进行分页查询就好。2018-12-19</p>
<p> 作者回复</p>
<p>分页这个再考虑考虑哈 </p>
<p>2018-12-19</p>
<p>赵海亮   2</p>
<p>老师你好，全字段排序那一节，我做了实验，我的排序缓存大小是1M， examined rows 是771</p>
<p>5892，查询的三个字段都有数据，那么如果这些数据都放到缓存应该需要（4+8+11）*771589</p>
<p>2等于160M，但是我看了都没有用到临时表，这是为什么？CREATE TABLE <code>phone_call_logs</code> (</p>
<p><code>id</code> int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT ‘主键ID’,</p>
<p><code>city_id</code> int(11) NOT NULL DEFAULT ‘11’,</p>
<p><code>call_sender</code> varchar(40) DEFAULT NULL COMMENT ‘电话主叫号码’,</p>
<p><code>phone_id</code> bigint(20) NOT NULL DEFAULT ‘0’ COMMENT ‘手机id’,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>idx_city</code> (<code>city_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;64551193;</p>
<p>—————-sort_buffer_size&#x3D;1M—————————-</p>
<p>root:(none)&gt; show variables like ‘sort_buffer_size’;</p>
<p>+——————+———+</p>
<p>| Variable_name | Value |</p>
<p>+——————+———+</p>
<p>| sort_buffer_size | 1048576 |</p>
<p>+——————+———+</p>
<p>1 row in set (0.00 sec)</p>
<p>—————查询sql———————</p>
<p>select city_id,phone_id,call_sender from phone_call_logs where city_id&#x3D;11 order by phone_id d</p>
<p>esc limit 1000;</p>
<p>———————–执行计划结果———————————————</p>
<p>“filesort_priority_queue_optimization”: {</p>
<p>“limit”: 1000,</p>
<p>“rows_estimate”: 146364461,</p>
<p>“row_size”: 146,</p>
<p>“memory_available”: 1048576,</p>
<p>“chosen”: true</p>
<p>},</p>
<p>“filesort_execution”: [</p>
<p>],</p>
<p>“filesort_summary”: {</p>
<p>“rows”: 1001,</p>
<p>“examined_rows”: 7715892,</p>
<p>“number_of_tmp_files”: 0,</p>
<p>“sort_buffer_size”: 154160,</p>
<p>“sort_mode”: “&lt;sort_key, additional_fields&gt;”</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>好问题，明天见  </p>
<p>（明天的一篇也是跟排序有关的哦）</p>
<p>2018-12-20</p>
<p>didiren   2</p>
<p>感谢！针对我之前提出的疑问，我又详细的做了实验，发现一个新的问题，我感觉是个bug，</p>
<p>希望解答</p>
<h1 id="SessionA"><a href="#SessionA" class="headerlink" title="SessionA"></a>SessionA</h1><p>mysql&gt; show variables like ‘%binlog_row_image%’;</p>
<p>| Variable_name | Value |</p>
<p>| binlog_row_image | FULL |</p>
<p>mysql&gt; create table t (id int not null primary key auto_increment,</p>
<p>-&gt; a int default null)</p>
<p>-&gt; engine&#x3D;innodb;</p>
<p>mysql&gt; insert into t values(1,2);</p>
<p>mysql&gt; set tx_isolation &#x3D; ‘repeatable-read’;</p>
<p>mysql&gt; begin;</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>此时在另一个SessionB执行update t set a&#x3D;3 where id &#x3D; 1;成功更新一条记录。通过show engin</p>
<p>e innodb status看，Log sequence number 2573458</p>
<p>然后在SessionA继续。。mysql&gt; update t set a&#x3D;3 where id &#x3D; 1;</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>Log sequence number 2573467</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>这里与你给出的答案里的实验结果不同</p>
<p>可以看到redolog是记录了第二次的update的，但是select却没有看到更新后的值，于是我又换</p>
<p>了一个平时测试用的实例，同样的步骤却得到了与你的答案相同的结果</p>
<p>然后我对比了2个实例的参数，发现当binlog-row-image&#x3D;minimal时第二次查询结果a&#x3D;3，当binl</p>
<p>og-row-image&#x3D;full时第二次查询结果a&#x3D;2，而且不论哪个参数，redolog都会因为SessionA的up</p>
<p>date增长，说明redolog都做了记录，update是发生了的，但是binlog-row-image参数会影响查</p>
<p>询结果，难以理解，我用的mysql版本是官方的5.7.13</p>
<p>下面是binlog-row-image &#x3D; minimal的实验结果</p>
<p>mysql&gt; set binlog_row_image&#x3D;MINIMAL;</p>
<p>mysql&gt; drop table t;</p>
<p>mysql&gt; create table t (id int not null primary key auto_increment,</p>
<p>-&gt; a int default null)</p>
<p>-&gt; engine&#x3D;innodb;</p>
<p>insert into t values(1,2);</p>
<p>mysql&gt; insert into t values(1,2);</p>
<p>mysql&gt; set tx_isolation &#x3D; ‘repeatable-read’;</p>
<p>mysql&gt; begin;</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>此时在另一个SessionB执行update t set a&#x3D;3 where id &#x3D; 1;成功更新一条记录。mysql&gt; update t set a&#x3D;3 where id &#x3D; 1;</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>mysql&gt; select * from t where id &#x3D; 1; </p>
<p>| id | a |</p>
<p>| 1 | 3 |</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>！！！</p>
<p>你说的对</p>
<p>我验证的是statement格式。MySQL 看来选了不错吧路径。这个我之前真不知道 </p>
<p>多谢</p>
<p>2018-12-19</p>
<p>cyberbit   2</p>
<p>1.不会有排序，这种情况属于《高性能mysql》里提到的“in技法”，符合索引的最左原则，是2个</p>
<p>等值查询，可以用到右边的索引列。2.分页查询，可以用延迟关联来优化：</p>
<p>select * from t join </p>
<p>(select id from t where city in(‘杭州’,’苏州’) order by name limit 10000,100) t_id</p>
<p>on t.id&#x3D;t_id.id;</p>
<p>2018-12-19</p>
<p>尘封   2</p>
<p>请问，第7步中遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 ag</p>
<p>e 三个字段返回给客户端：这里会把id再进行排序吗？转随机io为顺序io？2018-12-19</p>
<p> 作者回复</p>
<p>要是排序就结果不符合order by 的语义逻辑了…</p>
<p>2018-12-19</p>
<p>进击的菜鸡   1</p>
<p>关于上期问题里的最后一个例子不太明白，还请老师指点一下。按说在更新操作的时候应该是</p>
<p>当前读，那么应该能读到id&#x3D;1 and a &#x3D; 3的记录并修改。那么为什么再select还会查到a &#x3D; 2。难</p>
<p>道是即便update但是where条件也是快照读？但是如果这样那么幻读的问题不就不会存在了吗</p>
<p>？（B insert了一条记录，此时A范围update后再select会把B insert的语句查出来）</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>你是说图14这里对吧， </p>
<p>这里update语句自己是当前读，但是它没有更新数据；</p>
<p>所以之后的查询还是看不到(1,3)这个版本。好问题 </p>
<p>2019-02-02</p>
<p>发条橙子 。   1</p>
<p>老师 ， 接前面 create_time的回答 。 语句确实是 select * from t order by create_time desc ;</p>
<p>老师是指 优化器会根据 order by create_time 来选择使用 create_time 索引么 </p>
<p>我之前误以为优化器是根据 where 后面的字段条件来选择索引 ，所以上面那条语句没有where </p>
<p>的时候我就想当然地以为不会走索引 。 看来是自己跳进了一个大坑里面  </p>
<p>另 ： 我之前在本地建了张表加了20w数据 ，用explain 查了一次 ，发现走的是全表没有走索引</p>
<p>， 老师说会走索引。我想了一下， 可能是统计的数据有误的缘故，用 analyze table重新统计 </p>
<p>，再次查询果然走了索引 。 </p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>嗯 where和 order都会共同影响哦，今天这篇你要再看看最后加了联合索引以后，语句的执行逻</p>
<p>辑</p>
<p>Analyze table 立功啦 </p>
<p>2018-12-20</p>
<p>发条橙子 。   1</p>
<p>正好有个 order by 使用场景 ， 有个页面，需要按数据插入时间倒序来查看一张记录表的信息 </p>
<p>，因为除了分页的参数 ， 没有其他 where 的条件 ，所以除了主键外没有其他索引 。 </p>
<p>这时候 DBA 让我给 create_time 创建索引， 说是按照顺序排列 ，查询会增快 。这篇文章看完</p>
<p>后 ， 让我感觉实际上创建 create_time 索引是没用的 。 </p>
<p>因为查询本身并没有用到 create_time 索引 ，实际上查询的步骤是 ：</p>
<ol>
<li><p>初始化 sort_buffer 内存</p>
</li>
<li><p>因为没索引 ， 所以扫出全表的数据到 sort_buffer 中</p>
</li>
<li><p>如果内存够则直接内存按时间排序 </p>
</li>
<li><p>如果内存不够则按数据量分成不同文件分别按时间排序后整合</p>
</li>
<li><p>根据数量分页查询数量 回聚集索引中用 ID 查询数据</p>
</li>
<li><p>返回</p>
</li>
</ol>
<p>所以我分析create_time索引应该不需要创建。反而增加了维护成本</p>
<p>问题一 ：这种无条件查列表页除了全表扫还有其他建立索引的办法么</p>
<p>问题二 : 如果加入 group by ， 数据该如何走</p>
<p>问题三 ：老师之后的文章会有讲解 bigInt(20) 、 tinyint(2) 、varchar(32) 这种后面带数字与不带</p>
<p>数字有何区别的文章么 。 每次建字段都会考虑长度 ，但实际却不知道他有何作用 </p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>你说的这样场景，加上create_time索引的话，是可以加速的呀，</p>
<p>语句是这样吗？select * from t order by create_time desk limit 100? 如果是这样，创建索引有用</p>
<p>的。问题二后面会有文章会说哈</p>
<p>问题三 嗯，这个也会安排文章说到</p>
<p>2018-12-20</p>
<p>明亮   1</p>
<p>需要排序，可以将原来的索引中name字段放前面，city字段放后面，来建索引就可以了</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>这样不太好哈，变成全索引扫描了</p>
<p>2018-12-19</p>
<p>进击的菜鸡   0</p>
<p>图14那个疑问明白了，是因为where条件中存在update的值InnoDB认为值一致所以没有修改，</p>
<p>从而导致A的一致性视图中看不到B的修改。这篇又看了一遍，还有个疑问，想请老师解答一下。1.asc和desc会影响使用索引排序吗？2.如果采用rowid也无法放入排序字段还是会转用磁盘排序吧。2019-02-06</p>
<p> 作者回复</p>
<p>新年快乐</p>
<ol>
<li><p>不影响</p>
</li>
<li><p>再小也用rowid ，对，会转成磁盘排序</p>
</li>
</ol>
<p>2019-02-06</p>
<p>frogman   0</p>
<p>你好，不知道可否讲一下 Group By 怎样运用索引来优化呢？文档说只有 MIN 和 MAX 的情况</p>
<p>下索引才能提高效率，但是我认为 COUNT 应该也行吧。如 select name count(*) from table w</p>
<p>here name&#x3D;$name group by address; 如果建立 id 和 name 的联合索引，效率会提高吗。2019-02-03</p>
<p> 作者回复</p>
<p>你的理解对的。我们后面有一篇会讲到group by</p>
<p>2019-02-03</p>
<p>Crayon   0</p>
<p>老师，您好，我想问一下对于评论区中的无条件排序问题，知道了走索引和不走索引的两种情</p>
<p>况。在我的测试中，无条件多字段排序，即使加了LIMIT，也会走全表扫描，这是为什么呢。排序的</p>
<p>字段们都加了普通索引</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>试下，是不是其实你不加limit反而会用索引</p>
<p>2019-01-30</p>
<p>过去、今日   0</p>
<p>老师，您好！大概是这样子的，app表的数据量是10w，api_form的数据量大概50w以后还是增</p>
<p>加，app表的索引为app_key,api_form索引为app_key、modified。但是从执行计划上看Extra的</p>
<p>值为Using where Using fileSort</p>
<p>select * from app t1,api_form t2 where t1.app_key&#x3D;t2.app_key and t2.status&#x3D;1 order by t2.modi</p>
<p>fied</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<p>api_form索引为app_key、modified </p>
<p>是联合索引吗，如果是可以force一下这个索引</p>
<p>你还是两个表（脱敏后）发一下表结构，还有这个语句explain的结果</p>
<p>2019-01-28</p>
<p>过去、今日   0</p>
<p>老师有个问题</p>
<p>select * from a t1,b t2 where t1.id &#x3D; t2.id order by t1.created </p>
<p>即时a表和b表都创建了索引，但是通过执行计划看都是using filesort</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<p>贴一下你这两个表的表结构，和explain的结果。这个语句要没有filesort的话，需要t1当驱动表，并且t1 有（id, created）联合索引</p>
<p>2019-01-27</p>
<p>Wesley   0</p>
<p>表T有id name city age 三列，对name，city两列做联合索引。执行explain select name，city from T where name like ‘%’ and city &#x3D;‘BJ’ order by name limit 10</p>
<p>；rows的值永远都和limit的值一样。虽然rows是预估的值，但是也不会每次和要limit的值一样</p>
<p>吧</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>给一下你的复现步骤哈，不太可能“永远一样的”</p>
<p>2019-01-23</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/6d416b67.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/6d416b67.html" class="post-title-link" itemprop="url">mysql-答疑文章（一）：日志和索引相关问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 06:06:30" itemprop="dateCreated datePublished" datetime="2019-11-16T06:06:30+08:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>15 | 答疑文章（一）：日志和索引相关问题</p>
<p>2018-12-17 林晓斌</p>
<p>在今天这篇答疑文章更新前，MySQL实战这个专栏已经更新了14篇。在这些文章中，大家在评</p>
<p>论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点，</p>
<p>也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以</p>
<p>说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这</p>
<p>些被记下来的问题，就是我们今天这篇答疑文章的素材了。到目前为止，我已经收集了47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中</p>
<p>找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其</p>
<p>他问题，我们就留着后面慢慢展开吧。日志相关问题</p>
<p>我在第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，和你讲到binlog（归档日</p>
<p>志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提</p>
<p>交，会导致MySQL出现主备数据不一致等问题。在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎</p>
<p>么保证数据完整性的？现在，我们就从这个问题开始吧。我再放一次两阶段提交的图，方便你学习下面的内容。图1 两阶段提交示意图</p>
<p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句</p>
<p>的执行流程吗，怎么还会调用commit语句？他产生这个疑问的原因，是把两个“commit”的概念混淆了：</p>
<p>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin&#x2F;start</p>
<p>transaction 配对使用。而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一</p>
<p>步。当这个步骤执行完成后，这个事务就提交完成了。“commit语句”执行的时候，会包含“commit 步骤”。而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行</p>
<p>完成后提交事务时，就会用到这个“commit步骤“。接下来，我们就一起分析一下在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩</p>
<p>溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会</p>
<p>回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生</p>
<p>crash，那崩溃恢复的时候MySQL会怎么处理？我们先来看一下崩溃恢复时的判断规则。1. 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</p>
<ol start="2">
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：</li>
</ol>
<p>a. 如果是，则提交事务；</p>
<p>b. 否则，回滚事务。这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。现在，我们继续延展一下这个问题。追问1：MySQL怎么知道binlog是完整的?</p>
<p>回答：一个事务的binlog是有完整格式的：</p>
<p>statement格式的binlog，最后会有COMMIT；</p>
<p>row格式的binlog，最后会有一个XID event。另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确</p>
<p>性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验</p>
<p>checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。追问2：redo log 和 binlog是怎么关联起来的?</p>
<p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p>
<p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p>
<p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢</p>
<p>复，MySQL为什么要这么设计?</p>
<p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就</p>
<p>是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个</p>
<p>binlog恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写</p>
<p>binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能</p>
<p>覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回</p>
<p>滚不了，数据和binlog日志又不一致了。两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩</p>
<p>溃恢复，又能支持归档，不就可以了？回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内</p>
<p>存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？答案是不可以。如果说历史原因的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是</p>
<p>MyISAM，设计之初就有没有支持崩溃恢复。InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支</p>
<p>持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log</p>
<p>好了。而如果说实现上的原因的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流</p>
<p>程，我画了一张示意图，这里就没有redo log了。图2 只用binlog支持崩溃恢复</p>
<p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢</p>
<p>复“数据页”。如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生</p>
<p>了crash。重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经</p>
<p>认为提交完成了，不会再应用一次binlog1。但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此</p>
<p>时，binlog里面并没有记录数据页的更新细节，是补不回来的。你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又</p>
<p>做了一个redo log出来。所以，至少现在的binlog能力，还不能支持崩溃恢复。追问6：那能不能反过来，只用redo log，不要binlog？回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交</p>
<p>了，但系统依然是crash-safe的。但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是</p>
<p>开着的。因为binlog有着redo log无法替代的功能。一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保</p>
<p>留，redo log也就起不到归档的作用。一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新</p>
<p>自己的数据。关掉binlog的话，这些下游系统就没法输入了。总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo</p>
<p>log还做不到。你看，发展生态是多么重要。追问7：redo log一般设置多大？回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的</p>
<p>能力就发挥不出来了。所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文</p>
<p>件、每个文件1GB吧。追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的</p>
<p>还是从buffer pool更新过来的呢？回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也</p>
<p>就不存在“数据最终落盘，是由redo log更新过去”的情况。1. 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终</p>
<p>数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。2. 在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就</p>
<p>会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了</p>
<p>第一种情况的状态。追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？回答：这两个问题可以一起回答。在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在</p>
<p>还没commit的时候就直接写到redo log文件里。所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时</p>
<p>候，数据的内存被修改了，redo log buffer也写入了日志。但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候</p>
<p>做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被</p>
<p>动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章</p>
<p>《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过</p>
<p>程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。如</p>
<p>果你还有问题，可以在评论区继续留言补充。业务设计问题</p>
<p>接下来，我再和你分享@ithunter 同学在第8篇文章《事务到底是隔离的还是不隔离的？》的评</p>
<p>论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰</p>
<p>上这样的场景，在这里解答和分享一下。问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p>
<p>begin;</p>
<p>insert into t1 …</p>
<p>insert into t2 …</p>
<p>commit;</p>
<p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一</p>
<p>个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即</p>
<p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家</p>
<p>能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能</p>
<p>借鉴这种方式。接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索</p>
<p>uk_user_id_liker_id。语句执行逻辑是这样的：</p>
<p>以A关注B为例：</p>
<p>第一步，先查询对方有没有关注自己（B有没有关注A）</p>
<p>select * from like where user_id &#x3D; B and liker_id &#x3D; A;</p>
<p>如果有，则成为好友</p>
<p>insert into friend;</p>
<p>没有，则只是单向关注关系</p>
<p>insert into like;</p>
<p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对</p>
<p>方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在</p>
<p>MySQL锁层面有没有办法处理？CREATE TABLE <code>like</code> (</p>
<p>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>user_id</code> int(11) NOT NULL,</p>
<p>  <code>liker_id</code> int(11) NOT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  UNIQUE KEY <code>uk_user_id_liker_id</code> (<code>user_id</code>,<code>liker_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>CREATE TABLE <code>friend</code> (</p>
<p>  id&#96; int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>friend_1_id</code> int(11) NOT NULL,</p>
<p>  <code>firned_2_id</code> int(11) NOT NULL,</p>
<p>  UNIQUE KEY <code>uk_friend</code> (<code>friend_1_id</code>,<code>firned_2_id</code>)</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>引，为便于描述，我给加上唯一索引。顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功</p>
<p>加为朋友关系。现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：</p>
<p>图3 并发“喜欢”逻辑操作顺序</p>
<p>由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同</p>
<p>样是这个逻辑。这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在</p>
<p>friend表里面插入一行记录的。如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，</p>
<p>我想到了另外一个方法，来解决这个问题。首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。值是1的时候，表示user_id 关注 liker_id;</p>
<p>值是2的时候，表示liker_id 关注 user_id;</p>
<p>值是3的时候，表示互相关注。然后，当 A关注B的时候，逻辑改成如下所示的样子：</p>
<p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p>
<p>如果A&gt;B，则执行下面的逻辑</p>
<p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在</p>
<p>操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这</p>
<p>个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B</p>
<p>的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。mysql&gt; begin; &#x2F;<em>启动事务</em>&#x2F;</p>
<p>insert into <code>like</code>(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship&#x3D;relation_ship | 1;</p>
<p>select relation_ship from <code>like</code> where user_id&#x3D;A and liker_id&#x3D;B;</p>
<p>&#x2F;*代码中判断返回的 relation_ship，</p>
<p>  如果是1，事务结束，执行 commit</p>
<p>  如果是3，则执行下面这两个语句：</p>
<p>  *&#x2F;</p>
<p>insert ignore into friend(friend_1_id, friend_2_id) values(A,B);</p>
<p>commit;</p>
<p>mysql&gt; begin; &#x2F;<em>启动事务</em>&#x2F;</p>
<p>insert into <code>like</code>(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship&#x3D;relation_ship | 2;</p>
<p>select relation_ship from <code>like</code> where user_id&#x3D;B and liker_id&#x3D;A;</p>
<p>&#x2F;*代码中判断返回的 relation_ship，</p>
<p>  如果是2，事务结束，执行 commit</p>
<p>  如果是3，则执行下面这两个语句：</p>
<p>*&#x2F;</p>
<p>insert ignore into friend(friend_1_id, friend_2_id) values(B,A);</p>
<p>commit;</p>
<p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两</p>
<p>个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的</p>
<p>情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要</p>
<p>有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。小结</p>
<p>这是专栏的第一篇答疑文章。我针对前14篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了</p>
<p>今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇</p>
<p>文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。最后，虽然这篇是答疑文章，但课后问题还是要有的。我们创建了一个简单的表t，并插入一行，然后对这一行做修改。这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p>
<p>你会看到这样的结果：</p>
<p>结果显示，匹配(rows matched)了一行，修改(Changed)了0行。仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行</li>
</ol>
<p>mysql&gt; CREATE TABLE <code>t</code> (</p>
<p><code>id</code> int(11) NOT NULL primary key auto_increment,</p>
<p><code>a</code> int(11) DEFAULT NULL</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(1,2);</p>
<p>mysql&gt; update t set a&#x3D;2 where id&#x3D;1;</p>
<p>结束；</p>
<ol start="2">
<li>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不</li>
</ol>
<p>更新，直接返回；</p>
<ol start="3">
<li>InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以</li>
</ol>
<p>思考一下，MySQL为什么要选择这种策略呢？你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢</p>
<p>你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计</p>
<p>数值加1。逻辑实现上是启动一个事务，执行两个语句：</p>
<ol>
<li><p>insert into 数据表；</p>
</li>
<li><p>update 计数表，计数值加1。从系统并发能力的角度考虑，怎么安排这两个语句的顺序。这里，我直接复制 @阿建 的回答过来供你参考：</p>
</li>
</ol>
<p>评论区有同学说，应该把update计数表放后面，因为这个计数表可能保存了多个业务表的计数</p>
<p>值。如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会</p>
<p>更长。这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也</p>
<p>肯定会给表名字段加唯一索引。类似于下面这样的表结构：</p>
<p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。知识点在《行锁功过：怎么减少行锁对性能的影响？》</p>
<p>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升</p>
<p>并发度。在更新计数表的时候，一定会传入where table_name&#x3D;$table_name，使用主键索引，更新加行</p>
<p>锁只会锁在一行上。而在不同业务表插入数据，是更新不同的行，不会有行锁。评论区留言点赞板：</p>
<p>CREATE TABLE <code>rows_stat</code> (</p>
<p>  <code>table_name</code> varchar(64) NOT NULL,</p>
<p>  <code>row_count</code> int(10) unsigned NOT NULL,</p>
<p>  PRIMARY KEY (<code>table_name</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>@北天魔狼、@斜面镜子 Bil 和@Bin 等同学，都给出了正确答案；</p>
<p>@果然如此 同学提了一个好问题，虽然引入事务，避免看到”业务上还没提交的更新”，但是</p>
<p>Redis的计数被提前看到了。核心原因还是两个系统，不支持一致性视图；</p>
<p>@ 帆帆帆帆帆帆帆帆 同学的问题提醒了大家，count(id)也是可以走普通索引得到的。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/6fde2059.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/6fde2059.html" class="post-title-link" itemprop="url">mysql-count性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-15 06:10:36" itemprop="dateCreated datePublished" datetime="2019-11-15T06:10:36+08:00">2019-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><h2 id="count-语句实现方式"><a href="#count-语句实现方式" class="headerlink" title="count(*)语句实现方式"></a>count(*)语句实现方式</h2><p>在不同的MySQL引擎中，count(*)有不同的实现方式。</p>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM引擎把一个表的总行数存在了磁盘上，执行count(*)的时候会直接返回这个数，效率很高； 加 where 条件后，无法直接得到结果，也需要过滤。</p>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB引执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
<p>InnoDB不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。当你的记录数越来越多的时候，计算一个表的总行数会越来越慢。 </p>
<h4 id="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"><a href="#为什么InnoDB不跟MyISAM一样，也把数字存起来呢？" class="headerlink" title="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"></a>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</h4><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<p>这里，我用一个算count(*)的例子来为你解释一下。表“应该返回多少行”也是不确定的。</p>
<p>假设表t中现在有10000条记录，我们设计了三个用户并行的会话。假设表t中现在有10000条记录，我们设计了三个用户并行的会话。</p>
<p>会话A先启动事务并查询一次表的总行数；</p>
<p>会话B启动事务，插入一行后记录后，查询表的总行数；</p>
<p>会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。</p>
<p>我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p>
<p>你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p>
<p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p>
<p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p>
<p>索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。是通过采样来估算的。<br>有多不准呢，官方文档说误差可能达到40%到50%。所以，show table status命令显示的行数也不能直接使用。</p>
<p>MyISAM表虽然count(*)很快，但是不支持事务；</p>
<p>show table status命令虽然返回很快，但是不准确；</p>
<p>InnoDB表直接count(<em>)会遍历全表，虽然结果准确，但会导致性能问题。InnoDB表直接count(</em>)会遍历全表，虽然结果准确，但会导致性能问题。</p>
<p>如果你现在有一个页面经常要显示交易系统的操作记录总数，到底</p>
<h2 id="最佳实现"><a href="#最佳实现" class="headerlink" title="最佳实现"></a>最佳实现</h2><p>自己计数</p>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？没错，缓存系统可能会丢失更新。</p>
<p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p>
<p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>
<p>但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p>
<p>我们是这么定义不精确的：</p>
<ol>
<li><p>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</p>
</li>
<li><p>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</p>
</li>
</ol>
<p>这两种情况，都是逻辑不一致的。</p>
<p>会话A是一个插入交易记录的逻辑，往数据表里插入一行R，然后Redis计数加1；会话B就是查询页面显示时需要的数据。</p>
<p>在图2的这个时序里，在T3时刻会话B来查询的时候，会显示出新插入的R这个记录，但是Redis的计数还没加1。这时候，就会出现我们说的数据不一致。</p>
<p>你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改Redis计数。而读的时候是先读Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。</p>
<p>调整顺序后，会话B在T3时刻查询的时候，Redis计数加了1了，但还查不到新插入的R这一行，也是数据不一致的情况。</p>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，</p>
<p>所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p>
<h3 id="用数据库保存计数"><a href="#用数据库保存计数" class="headerlink" title="用数据库保存计数"></a>用数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p>
<p>会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。还没有提交，所以计数值加1这个操作对会话B还不可见。</p>
<p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p>
<h2 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h2><p>基于InnoDB引擎，count(*)、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。</p>
<p>首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p>
<p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p>
<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>
<ol>
<li><p>server层要什么就给什么；</p>
</li>
<li><p>InnoDB只给必要的值；</p>
</li>
<li><p>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</p>
</li>
</ol>
<p>这是什么意思呢？接下来，我们就一个个地来看看。这是什么意思呢？接下来，我们就一个个地来看看。</p>
<p>对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p>
<p>对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。返回id会涉及到解析数据行，以及拷贝字段值的操作。</p>
<p>对于count(字段)来说：</p>
<ol>
<li><p>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</p>
</li>
<li><p>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</p>
</li>
</ol>
<p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p>
<p>但是count(<em>)是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>)肯定不是null，按行累加。</p>
<p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p>
<p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p>
<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</p>
<p>今天，我和你聊了聊MySQL中获得表行数的两种方法。我们提到了在不同引擎中count(*)的实现</p>
<p>把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。而把计数值也放在MySQL中，就解决了一致性视图的问题。</p>
<p>InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。</p>
<p>我们用事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/89a00def.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/89a00def.html" class="post-title-link" itemprop="url">mysql-为什么表数据删掉一半，表文件大小不变</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-14 06:15:11" itemprop="dateCreated datePublished" datetime="2019-11-14T06:15:11+08:00">2019-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>13 | 为什么表数据删掉一半，表文件大小不变？2018-12-12 林晓斌</p>
<p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表</p>
<p>文件的大小还是没变？那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部</p>
<p>分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而</p>
<p>MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很</p>
<p>小，所以我们今天主要讨论的是表数据。接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正</p>
<p>确回收空间的方法。参数innodb_file_per_table</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数</p>
<p>innodb_file_per_table控制的：</p>
<ol>
<li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一</li>
</ol>
<p>起；</p>
<ol start="2">
<li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。从MySQL 5.6.6版本开始，它的默认值就是ON了。我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文</li>
</ol>
<p>件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文</p>
<p>件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。所以，将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个</p>
<p>设置展开的。我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除</p>
<p>数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空</p>
<p>间却没有被回收。我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。数据删除流程</p>
<p>我们先再来看一下InnoDB中一个索引的示意图。在前面第4和第5篇文章中，我和你介绍索引时</p>
<p>曾经提到过，InnoDB里的数据都是用B+树的结构组织的。图1 B+树索引示意图</p>
<p>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入</p>
<p>一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记</p>
<p>录，会怎么样？答案是，整个数据页就可以被复用了。但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果</p>
<p>插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复</p>
<p>用这个位置了。而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的</p>
<p>所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新</p>
<p>页的时候，page A是可以被复用的。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一</p>
<p>个数据页就被标记为可复用。进一步地，如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记</p>
<p>为可复用。但是磁盘上，文件不会变小。你现在知道了，delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件</p>
<p>的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被</p>
<p>使用的空间，看起来就像是“空洞”。实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造</p>
<p>成索引的数据页分裂。假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？图2 插入数据导致页分裂</p>
<p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面</p>
<p>page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1</p>
<p>个记录的位置是空洞）。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造</p>
<p>成空洞的。也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就</p>
<p>能达到收缩表空间的目的。而重建表，就可以达到这样的目的。重建表</p>
<p>试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么</p>
<p>做呢？你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A</p>
<p>里读出来再插入到表B中。由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键</p>
<p>索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完</p>
<p>成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。这里，你可以使用alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命</p>
<p>令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自</p>
<p>动完成转存数据、交换表名、删除旧表的操作。图3 改锁表DDL</p>
<p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到</p>
<p>表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个</p>
<p>DDL不是Online的。而在MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。我给你简单描述一下引入了Online DDL之后，重建表的流程：</p>
<ol>
<li><p>建立一个临时文件，扫描表A主键的所有数据页；</p>
</li>
<li><p>用数据页中表A的记录生成B+树，存储到临时文件中；</p>
</li>
<li><p>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图</p>
</li>
</ol>
<p>中state2的状态；</p>
<ol start="4">
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的</li>
</ol>
<p>数据文件，对应的就是图中state3的状态；</p>
<ol start="5">
<li>用临时文件替换表A的数据文件。图4 Online DDL</li>
</ol>
<p>可以看到，与图3过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方</p>
<p>案在重建表的过程中，允许对表A做增删改操作。这也就是Online DDL名字的来源。我记得有同学在第6篇讲表锁的文章《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》的评</p>
<p>论区留言说，DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据</p>
<p>之前就退化成读锁了。为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执</p>
<p>行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，</p>
<p>就可以认为是Online的。需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来</p>
<p>说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时</p>
<p>间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。Online 和 inplace</p>
<p>说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。你可能注意到了，在图3中，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临</p>
<p>时表，是在server层创建的。在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出</p>
<p>来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是</p>
<p>一个“原地”操作，这就是“inplace”名称的来源。所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL</p>
<p>呢？答案是不能。因为，tmp_file也是要占用临时空间的。我们重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p>
<p>跟inplace对应的就是拷贝表的方式了，用法是：</p>
<p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？其实不是的，只是在重建表这个逻辑中刚好是这样而已。比如，如果我要给InnoDB表的一个字段加全文索引，写法是：</p>
<p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。如果说这两个逻辑之间的关系是什么的话，可以概括为：</p>
<ol>
<li>DDL过程如果是Online的，就一定是inplace的；</li>
</ol>
<p>alter table t engine&#x3D;innodb,ALGORITHM&#x3D;inplace;</p>
<p>alter table t engine&#x3D;innodb,ALGORITHM&#x3D;copy;</p>
<p>alter table t add FULLTEXT(field_name);</p>
<ol start="2">
<li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文</li>
</ol>
<p>索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。最后，我们再延伸一下。在第10篇文章《MySQL为什么有时候会选错索引》的评论区中，有同学问到使用optimize</p>
<p>table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一</p>
<p>下。从MySQL 5.6版本开始，alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4</p>
<p>的流程了；</p>
<p>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程</p>
<p>中加了MDL读锁；</p>
<p>optimize table t 等于recreate+analyze。小结</p>
<p>今天这篇文章，我和你讨论了数据库中收缩表空间的方法。现在你已经知道了，如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是</p>
<p>不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。我跟你介绍了重建</p>
<p>表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的</p>
<p>版本，这个命令是会阻塞DML的，这个你需要特别小心。最后，又到了我们的课后问题时间。假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：</p>
<ol>
<li><p>一个表t文件大小为1TB；</p>
</li>
<li><p>对这个表执行 alter table t engine&#x3D;InnoDB；</p>
</li>
<li><p>发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。你觉得可能是什么原因呢 ？你可以把你觉得可能的原因写在留言区里，我会在下一篇文章的末尾把大家描述的合理的原因都</p>
</li>
</ol>
<p>列出来，以后其他同学就不用掉到这样的坑里了。感谢你的收听，也欢迎你把这篇文章分享给更</p>
<p>多的朋友一起阅读。上期问题时间</p>
<p>在上期文章最后，我留给你的问题是，如果一个高配的机器，redo log设置太小，会发生什么情</p>
<p>况。每次事务提交都要写redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这</p>
<p>个“环”将很快被写满，write pos一直追着CP。这时候系统不得不停止所有更新，去推进checkpoint。这时，你看到的现象就是磁盘压力很小，但是数据库出现间歇性的性能下跌。评论区留言点赞板：</p>
<p>@某、人 给了一个形象的描述，而且提到了，在这种情况下，连change buffer的优化也失效</p>
<p>了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏</p>
<p>页操作；</p>
<p>有几个同学提到了内存淘汰脏页，对应的redo log的操作，这个我们会在后面的文章中展开，</p>
<p>大家可以先看一下 @melon 同学的描述了解一下；</p>
<p>@算不出流源 提到了“动态平衡”，其实只要出现了这种“平衡”，意味着本应该后台的操作，就</p>
<p>已经影响了业务应用，属于有损失的平衡。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/a5f547a0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/a5f547a0.html" class="post-title-link" itemprop="url">mysql-为什么我的MySQL会“抖”一下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 06:01:45" itemprop="dateCreated datePublished" datetime="2019-11-13T06:01:45+08:00">2019-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>12 | 为什么我的MySQL会“抖”一下？2018-12-10 林晓斌</p>
<p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但</p>
<p>是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持</p>
<p>续时间还很短。看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。你的SQL语句为什么变“慢”了</p>
<p>在前面第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，我为你介绍了WAL机</p>
<p>制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志</p>
<p>叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写</p>
<p>完redo log后，就返回给客户端，本次更新成功。做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记</p>
<p>忆就是内存。掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是</p>
<p>flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一</p>
<p>致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算</p>
<p>进去。当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写</p>
<p>入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10</p>
<p>文，这次又要赊9文。图1 “孔乙己赊账”更新和flush过程</p>
<p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而</p>
<p>MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。那么，什么情况会引发数据库的flush过程呢？我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改</p>
<p>到账本上？第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活</p>
<p>儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确</p>
<p>的账目记录到账本中才行。这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把</p>
<p>checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意</p>
<p>图，这里我改成环形，便于大家理解。图2 redo log状态图</p>
<p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到</p>
<p>CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图</p>
<p>中从write pos到CP’之间就是可以再写入的redo log的区域。第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出</p>
<p>账本把孔乙己这笔账先加进去。这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰</p>
<p>一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据</p>
<p>页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，</p>
<p>就保证了每个数据页有两种状态：</p>
<p>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</p>
<p>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不</p>
<p>如更新账本。这种场景，对应的就是MySQL认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起</p>
<p>来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也</p>
<p>要见缝插针地找时间，只要有机会就刷一点“脏页”。第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都</p>
<p>记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁</p>
<p>盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。接下来，你可以分析一下上面四种场景对性能的影响。其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库</p>
<p>本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前</p>
<p>两种场景下的性能问题。第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况</p>
<p>的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更</p>
<p>新数会跌为0。第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB用缓冲池</p>
<p>（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>
<p>第一种是，还没有使用的；</p>
<p>第二种是，使用了并且是干净页；</p>
<p>第三种是，使用了并且是脏页。InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久</p>
<p>不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是</p>
<p>脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li><p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p>
</li>
<li><p>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。InnoDB刷脏页的控制策略</p>
</li>
</ol>
<p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时</p>
<p>候，可以刷多快。这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设</p>
<p>置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机</p>
<p>读写的命令：</p>
<p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就</p>
<p>曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，</p>
<p>但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个</p>
<p>系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页</p>
<p>累积，影响了查询和更新性能。虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不</p>
<p>能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按</p>
<p>照“全力”的百分比来刷脏页。根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因</p>
<p>素呢？这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是redo log写</p>
<p>满。所以，InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。 fio -filename&#x3D;$filename -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randrw -ioengine&#x3D;psync -bs&#x3D;16k -size&#x3D;500M -numjobs&#x3D;10 -runtime&#x3D;10 -group_reporting -name&#x3D;mytest </p>
<p>InnoDB会根据这两个因素先单独算出两个数字。参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页</p>
<p>比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p>
<p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，</p>
<p>我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为</p>
<p>F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按</p>
<p>照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上</p>
<p>面我们通过脏页比例和redo log写入速度算出来的两个值。F1(M)</p>
<p>{</p>
<p>  if M&gt;&#x3D;innodb_max_dirty_pages_pct then</p>
<pre><code>  return 100;
</code></pre>
<p>  return 100*M&#x2F;innodb_max_dirty_pages_pct;</p>
<p>}</p>
<p>图3 InnoDB刷脏页速度策略</p>
<p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论</p>
<p>是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源</p>
<p>并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且平时要多关注脏页比</p>
<p>例，不要让它经常接近75%。其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到</p>
<p>的，具体的命令参考下面的代码：</p>
<p>接下来，我们再看一个有趣的策略。一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而</p>
<p>MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁</p>
<p>边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还</p>
<p>可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放</p>
<p>到一起刷。在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述</p>
<p>的“连坐”机制，值为0时表示不找邻居，自己刷自己的。找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS</p>
<p>一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值</p>
<p>设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操</p>
<p>作，减少SQL语句响应时间。在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。小结</p>
<p>今天这篇文章，我延续第2篇中介绍的WAL的概念，和你解释了这个机制后续需要的刷脏页操作</p>
<p>和执行时机。利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触</p>
<p>发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。文章最后，我给你留下一个思考题吧。mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME &#x3D; ‘Innodb_buffer_pool_pages_dirty’;</p>
<p>select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME &#x3D; ‘Innodb_buffer_pool_pages_total’;</p>
<p>select @a&#x2F;@b;</p>
<p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo</p>
<p>log设置成4个1GB的文件。但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么</p>
<p>会出现这样的情况呢？你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我留给你的问题是，给一个学号字段创建索引，有哪些方法。由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个</p>
<p>学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定</p>
<p>的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字</p>
<p>节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我</p>
<p>们设定的这个背景，可以保证这个转换后结果的唯一性。评论区中，也有其他一些很不错的见解。评论用户@封建的风 说，一个学校的总人数这种数据量，50年才100万学生，这个表肯定是小</p>
<p>表。为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉</p>
<p>得值得at出来。@小潘 同学提了另外一个极致的方向。如果碰到表数据量特别大的场景，通过这种方式的收益</p>
<p>是很不错的。评论区留言点赞板：</p>
<p>@lttzzlll ，提到了用整型存“四位年份+五位编号”的方法；</p>
<p>由于整个学号的值超过了int上限，@老杨同志 也提到了用8个字节的bigint来存的方法。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">342</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:40</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
