<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="recording">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/17/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="Tech;Data;Vision">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/e1ece7cd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/e1ece7cd.html" class="post-title-link" itemprop="url">mysql-怎么给字符串字段加索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 06:08:14" itemprop="dateCreated datePublished" datetime="2019-11-12T06:08:14+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>11 | 怎么给字符串字段加索引？2018-12-07 林晓斌</p>
<p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天</p>
<p>要讨论的问题。假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p>
<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语</p>
<p>句就只能做全表扫描。同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，</p>
<p>mysql&gt; create table SUser(</p>
<p>ID bigint unsigned primary key,</p>
<p>email varchar(64), </p>
<p>… </p>
<p>)engine&#x3D;innodb; </p>
<p>mysql&gt; select f1, f2 from SUser where email&#x3D;’xxx’;</p>
<p>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。比如，这两个在email字段上创建索引的语句：</p>
<p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2</p>
<p>索引里面，对于每个记录都是只取前6个字节。那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引</p>
<p>的示意图。图1 email 索引结构</p>
<p>mysql&gt; alter table SUser add index index1(email);</p>
<p>或</p>
<p>mysql&gt; alter table SUser add index index2(email(6));</p>
<p>图2 email(6) 索引结构</p>
<p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：</p>
<p>zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。如果使用的是index1（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li><p>从index1索引树找到满足索引值是’<a href="mailto:&#122;&#104;&#97;&#x6e;&#x67;&#115;&#x73;&#120;&#121;&#122;&#64;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#97;&#x6e;&#x67;&#115;&#x73;&#120;&#121;&#122;&#64;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;</a>’的这条记录，取得ID2的值；</p>
</li>
<li><p>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</p>
</li>
<li><p>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足</p>
</li>
</ol>
<p>email&#x3D;‘<a href="mailto:&#122;&#104;&#x61;&#110;&#x67;&#115;&#115;&#x78;&#121;&#122;&#64;&#x78;&#x78;&#120;&#46;&#99;&#111;&#x6d;">&#122;&#104;&#x61;&#110;&#x67;&#115;&#115;&#x78;&#121;&#122;&#64;&#x78;&#x78;&#120;&#46;&#99;&#111;&#x6d;</a>’的条件了，循环结束。这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。select id,name,email from SUser where email&#x3D;‘<a href="mailto:&#x7a;&#104;&#x61;&#110;&#103;&#115;&#x73;&#120;&#121;&#x7a;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#110;&#103;&#115;&#x73;&#120;&#121;&#x7a;&#64;&#x78;&#x78;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a>‘;</p>
<p>如果使用的是index2（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li><p>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</p>
</li>
<li><p>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#122;&#x68;&#97;&#x6e;&#103;&#x73;&#x73;&#120;&#121;&#122;&#x40;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;">&#122;&#x68;&#97;&#x6e;&#103;&#x73;&#x73;&#120;&#121;&#122;&#x40;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;</a>’，这行记录丢</p>
</li>
</ol>
<p>弃；</p>
<ol start="3">
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取</li>
</ol>
<p>整行然后判断，这次值对了，将这行记录加入结果集；</p>
<ol start="4">
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。在这个过程中，要回主键索引取4次数据，也就是扫描了4行。通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变</li>
</ol>
<p>多。但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取</p>
<p>email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到</p>
<p>ID2，只扫描一行就结束了。也就是说使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查</p>
<p>询成本。于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前</p>
<p>缀呢？实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的</p>
<p>键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用</p>
<p>这个语句：</p>
<p>mysql&gt; select count(distinct email) as L from SUser;</p>
<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如</p>
<p>5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以</p>
<p>选择前缀长度为6。前缀索引对覆盖索引的影响</p>
<p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止</p>
<p>如此，我们再看一下另外一个场景。你先来看看这个SQL语句：</p>
<p>与前面例子中的SQL语句</p>
<p>相比，这个语句只要求返回id和email字段。所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查</p>
<p>到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结</p>
<p>构）的话，就不得不回到ID索引再去判断email字段的值。即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，</p>
<p>但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信</p>
<p>息。也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀</p>
<p>索引时需要考虑的一个因素。其他方式</p>
<p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不</p>
<p>mysql&gt; select </p>
<p>  count(distinct left(email,4)）as L4,</p>
<p>  count(distinct left(email,5)）as L5,</p>
<p>  count(distinct left(email,6)）as L6,</p>
<p>  count(distinct left(email,7)）as L7,</p>
<p>from SUser;</p>
<p>select id,email from SUser where email&#x3D;‘<a href="mailto:&#122;&#x68;&#x61;&#x6e;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#111;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#x40;&#120;&#x78;&#x78;&#x2e;&#99;&#111;&#x6d;</a>‘;</p>
<p>select id,name,email from SUser where email&#x3D;‘<a href="mailto:&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x73;&#120;&#x79;&#122;&#64;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x73;&#120;&#x79;&#122;&#64;&#x78;&#120;&#120;&#x2e;&#99;&#x6f;&#x6d;</a>‘;</p>
<p>够好的情况时，我们要怎么办呢？比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前</p>
<p>6位一般会是相同的。假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的</p>
<p>话，这个索引的区分度就非常低了。按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的</p>
<p>效率也就会越低。那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理</p>
<p>方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。答案是，有的。第一种方式是使用倒序存储。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你</p>
<p>可以这么写：</p>
<p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区</p>
<p>分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。第二种方式是使用hash字段。你可以在表上再创建一个整数字段，来保存身份证的校验码，</p>
<p>同时在这个字段上创建索引。然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码</p>
<p>可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你</p>
<p>的查询语句where部分要判断id_card的值是否精确相同。这样，索引的长度变成了4个字节，比原来小了很多。mysql&gt; select field_list from t where id_card &#x3D; reverse(‘input_id_card_string’);</p>
<p>mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</p>
<p>mysql&gt; select field_list from t where id_card_crc&#x3D;crc32(‘input_id_card_string’) and id_card&#x3D;’input_id_card_string’</p>
<p>接下来，我们再一起看看使用倒序存储和使用hash字段这两种方法的异同点。首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的</p>
<p>方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样</p>
<p>地，hash字段的方式也只能支持等值查询。它们的区别，主要体现在以下三个方面：</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字</li>
</ol>
<p>段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如</p>
<p>果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。2. 在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash</p>
<p>字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的</p>
<p>话，reverse函数额外消耗的CPU资源会更小些。3. 从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽</p>
<p>然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储</p>
<p>方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。小结</p>
<p>在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的</p>
<p>方式有：</p>
<ol>
<li><p>直接创建完整索引，这样可能比较占用空间；</p>
</li>
<li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p>
</li>
<li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p>
</li>
<li><p>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支</p>
</li>
</ol>
<p>持范围扫描。在实际应用中，你要根据业务字段的特点选择使用哪种方式。好了，又到了最后的问题时间。如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号</p>
<p>的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第</p>
<p>十位是入学年份、最后五位是顺序编号。系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验</p>
<p>证这个行为的话，你会怎么设计这个登录名的索引呢？你可以把你的分析思路和设计结果写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上篇文章中的第一个例子，评论区有几位同学说没有复现，大家要检查一下隔离级别是不是</p>
<p>RR（Repeatable Read，可重复读），创建的表t是不是InnoDB引擎。我把复现过程做成了一</p>
<p>个视频，供你参考。在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain的结果就不对了？这</p>
<p>里，我来为你分析一下原因。delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来</p>
<p>的10万行。但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之</p>
<p>前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数</p>
<p>据。这样，索引a上的数据其实就有两份。然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令</p>
<p>看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选</p>
<p>字段a作为索引更合适）</p>
<p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是</p>
<p>show table status的值。这个值的计算方法，我会在后面有文章为你详细讲解。评论区留言点赞板：</p>
<p>@斜面镜子 Bill 的评论最接近答案；</p>
<p>@某、人 做了两个很不错的对照试验；</p>
<p>@ye7zi 等几位同学很认真的验证，赞态度。大家的机器如果IO能力比较差的话，做这个验证</p>
<p>的时候，可以把innodb_flush_log_at_trx_commit 和 sync_binlog 都设置成0。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/1591a1f8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/1591a1f8.html" class="post-title-link" itemprop="url">mysql-MySQL为什么有时候会选错索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-11 06:15:26" itemprop="dateCreated datePublished" datetime="2019-11-11T06:15:26+08:00">2019-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>10 | MySQL为什么有时候会选错索引？2018-12-05 林晓斌</p>
<p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你</p>
<p>写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确</p>
<p>定的。不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索</p>
<p>引，而导致执行速度变得很慢？我们一起来看一个例子吧。我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p>
<p>CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>a</code> int(11) DEFAULT NULL,</p>
<p>  <code>b</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>a</code> (<code>a</code>),</p>
<p>  KEY <code>b</code> (<code>b</code>)</p>
<p>) ENGINE&#x3D;InnoDB；</p>
<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到</p>
<p>(100000,100000,100000)。我是用存储过程来插入数据的，这里我贴出来方便你复现：</p>
<p>接下来，我们分析一条SQL语句：</p>
<p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。图1 使用explain命令查看语句执行情况</p>
<p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索</p>
<p>引a。不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做</p>
<p>如下操作。delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;100000)do</p>
<pre><code>insert into t values(i, i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select * from t where a between 10000 and 20000;</p>
<p>图2 session A和session B的执行流程</p>
<p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删</p>
<p>除后，又调用了 idata这个存储过程，插入了10万行数据。这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择</p>
<p>索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强</p>
<p>制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。下面的三条SQL语句，就是这个实验过程。第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日</p>
<p>志中；</p>
<p>第二句，Q1是session B原来的查询；</p>
<p>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。如图3所示是这三条SQL语句执行完成后的慢查询日志。set long_query_time&#x3D;0;</p>
<p>select * from t where a between 10000 and 20000; &#x2F;<em>Q1</em>&#x2F;</p>
<p>select * from t force index(a) where a between 10000 and 20000;&#x2F;<em>Q2</em>&#x2F;</p>
<p>图3 slow log结果</p>
<p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，</p>
<p>执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更</p>
<p>长的执行时间。这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错</p>
<p>索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。优化器的逻辑</p>
<p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库</p>
<p>里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越</p>
<p>少，消耗的CPU资源越少。当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行</p>
<p>综合判断。我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描</p>
<p>行数的时候出问题了。那么，问题就是：扫描行数是怎么判断的？MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根</p>
<p>据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越</p>
<p>好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越</p>
<p>大，索引的区分度越好。我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果</p>
<p>。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不</p>
<p>同，而且其实都不准确。图4 表t的show index 结果</p>
<p>那么，MySQL是怎样得到索引的基数的呢？这里，我给你简单介绍一下MySQL采样统计的方</p>
<p>法。为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太</p>
<p>高了，所以只能选择“采样统计”。采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均</p>
<p>值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1&#x2F;M的</p>
<p>时候，会自动触发重新做一次索引统计。在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选</p>
<p>择：</p>
<p>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。但，这还不是全部。你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多</p>
<p>的，选错索引一定还有别的原因。其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要</p>
<p>扫描多少行。接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。图5 意外的explain结果</p>
<p>rows这个字段表示的是预计扫描行数。其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大</p>
<p>了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划</p>
<p>不用，却选择了扫描行数是100000的执行计划呢？这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，</p>
<p>这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执</p>
<p>行时间看来，这个选择并不是最优的。使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，</p>
<p>但图1的选择是对的。也就是说，这个策略并没有问题。所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于</p>
<p>为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看</p>
<p>一下执行效果。图6 执行analyze table t 命令恢复的explain结果</p>
<p>这回对了。所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个</p>
<p>方法来处理。其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优</p>
<p>化器可不止是看扫描行数。依然是基于这个表t，我们看看另外一个语句：</p>
<p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？为了便于分析，我们先来看一下a、b这两个索引的结构图。图7 a、b索引的结构图</p>
<p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索</p>
<p>引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是</p>
<p>需要回到主键索引上取值再判断，所以需要扫描50001行。所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底</p>
<p>是不是这么一回事儿。mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</p>
<p>图8是执行explain的结果。图8 使用explain方法查看执行计划 2</p>
<p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行</p>
<p>数是50198。从这个结果中，你可以得到两个结论：</p>
<ol>
<li><p>扫描行数的估计值依然不准确；</p>
</li>
<li><p>这个例子里MySQL又选错了索引。索引选择异常和处理</p>
</li>
</ol>
<p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：</p>
<p>原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。MySQL会根据</p>
<p>词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需</p>
<p>要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估</p>
<p>其他索引的执行代价。我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行</p>
<p>效果：</p>
<p>图9 使用不同索引的语句执行耗时</p>
<p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化</p>
<p>器的选择快了40多倍。也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句</p>
<p>mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</p>
<p>也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现</p>
<p>的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修</p>
<p>改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不</p>
<p>够敏捷。所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，我们可以考虑修改</p>
<p>语句，引导MySQL使用我们期望的索引。比如，在这个例子里，显然把“order by b limit 1” 改</p>
<p>成 “order by b,a limit 1” ，语义的逻辑是相同的。我们来看看改之后的效果：</p>
<p>图10 order by b,a limit 1 执行结果</p>
<p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序</p>
<p>的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为</p>
<p>代价更小。现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫</p>
<p>描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条</p>
<p>件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才</p>
<p>可以这么做。如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。图11 改写SQL的explain</p>
<p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数</p>
<p>mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;</p>
<p>据特征诱导了一下优化器，也不具备通用性。第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选</p>
<p>择，或删掉误用的索引。不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较</p>
<p>少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，</p>
<p>最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是</p>
<p>就删掉了这个索引，优化器也就重新选择到了正确的索引。小结</p>
<p>今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改</p>
<p>语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，今</p>
<p>天的话题，我们面对的是MySQL的bug，每一个展开都必须深入到一行行代码去量化，实在不是</p>
<p>我们在这里应该做的事情。所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。你平时在处理MySQL优化器bug的时候有什么别的方法，也发到评论区分享一下吧。最后，我给你留下一个思考题。前面我们在构造第一个例子的过程中，通过session A的配合，</p>
<p>让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001</p>
<p>变成37000多。而如果没有session A的配合，只是单独执行delete from t 、call idata()、explain这三句话，会看</p>
<p>到rows字段其实还是10000左右。你可以自己验证一下这个结果。这是什么原因呢？也请你分析一下吧。你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，如果某次写入使用了change buffer机制，之后主机异常</p>
<p>重启，是否会丢失change buffer和数据。这个问题的答案是不会丢失，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提</p>
<p>交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change</p>
<p>buffer也能找回来。在评论区有同学问到，merge的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为</p>
<p>你分析一下。merge的执行流程是这样的：</p>
<ol>
<li><p>从磁盘读入数据页到内存（老版本的数据页）；</p>
</li>
<li><p>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新</p>
</li>
</ol>
<p>版数据页；</p>
<ol start="3">
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更。到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修</li>
</ol>
<p>改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。评论区留言点赞板：</p>
<p>@某、人 把02篇的redo log更新细节和change buffer的更新串了起来；</p>
<p>@Ivan 回复了其他同学的问题，并联系到Checkpoint机制；</p>
<p>@约书亚 问到了merge和redolog的关系。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/5ec5b1a0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/5ec5b1a0.html" class="post-title-link" itemprop="url">mysql-普通索引和唯一索引，应该怎么选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-10 06:16:37" itemprop="dateCreated datePublished" datetime="2019-11-10T06:16:37+08:00">2019-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>09 | 普通索引和唯一索引，应该怎么选择？2018-12-03 林晓斌</p>
<p>今天的正文开始前，我要特意感谢一下评论区几位留下高质量留言的同学。用户名是 @某、人 的同学，对文章的知识点做了梳理，然后提了关于事务可见性的问题，就是</p>
<p>先启动但是后提交的事务，对数据可见性的影响。@夏日雨同学也提到了这个问题，我在置顶评</p>
<p>论中回复了，今天的文章末尾也会再展开说明。@Justin和@倪大人两位同学提了两个好问题。对于能够引发更深一步思考的问题，我会在回复的内容中写上“好问题”三个字，方便你搜索，你</p>
<p>也可以去看看他们的留言。非常感谢大家很细致地看文章，并且留下了那么多和很高质量的留言。知道文章有给大家带来一</p>
<p>些新理解，对我来说是一个很好的鼓励。同时，也让其他认真看评论区的同学，有机会发现一些</p>
<p>自己还没有意识到的、但可能还不清晰的知识点，这也在总体上提高了整个专栏的质量。再次谢</p>
<p>谢你们。好了，现在就回到我们今天的正文内容。在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引</p>
<p>的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写</p>
<p>入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语</p>
<p>句：</p>
<p>所以，你一定会考虑在id_card字段上建索引。由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给</p>
<p>id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的</p>
<p>身份证号，那么这两个选择逻辑上都是正确的。现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么</p>
<p>呢？简单起见，我们还是用第4篇文章《深入浅出索引（上）》中的例子来说明，假设字段 k 上的值</p>
<p>都不重复。图1 InnoDB的索引组织结构</p>
<p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。查询过程</p>
<p>select name from CUser where id_card &#x3D; ‘xxxxxxxyyyyyyzzzzz’;</p>
<p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先</p>
<p>是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认</p>
<p>为数据页内部通过二分法来定位记录。对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰</p>
<p>到第一个不满足k&#x3D;5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继</p>
<p>续检索。那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，</p>
<p>并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每</p>
<p>个数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针</p>
<p>寻找和一次计算。当然，如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下</p>
<p>一个数据页，这个操作会稍微复杂一些。但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概</p>
<p>率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以</p>
<p>忽略不计。更新过程</p>
<p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change</p>
<p>buffer。当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中</p>
<p>的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样</p>
<p>就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内</p>
<p>存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正</p>
<p>确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是</p>
<p>说，change buffer在内存中有拷贝，也会被写入到磁盘上。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据</p>
<p>页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，</p>
<p>也会执行merge操作。显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显</p>
<p>的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提</p>
<p>高内存利用率。那么，什么条件下可以使用change buffer呢？对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入</p>
<p>(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存</p>
<p>才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer</p>
<p>了。因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通</p>
<p>过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change</p>
<p>buffer的大小最多只能占用buffer pool的50%。现在，你已经理解了change buffer的机制，那么我们再一起来看看如果要在这张表中插入一个</p>
<p>新记录(4,400)的话，InnoDB的处理流程是怎样的。第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：</p>
<p>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</p>
<p>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的</p>
<p>CPU时间。但，这不是我们关注的重点。第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB的处理流程如下：</p>
<p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结</p>
<p>束；</p>
<p>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer</p>
<p>因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突</p>
<p>然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现</p>
<p>这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。change buffer的使用场景</p>
<p>通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change</p>
<p>buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通</p>
<p>索引的所有场景，使用change buffer都可以起到加速作用吗？因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动</p>
<p>作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面</p>
<p>上要更新的次数越多），收益就越大。因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change</p>
<p>buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记</p>
<p>录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问</p>
<p>IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来</p>
<p>说，change buffer反而起到了副作用。索引选择和实践</p>
<p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上</p>
<p>是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在</p>
<p>其他情况下，change buffer都能提升更新性能。在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优</p>
<p>化还是很明显的。特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个</p>
<p>类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索</p>
<p>引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入</p>
<p>速度。change buffer 和 redo log</p>
<p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机</p>
<p>制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个</p>
<p>流程里来说明，便于你区分这两个概念。现在，我们要在表上执行这个插入语句：</p>
<p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer</p>
<p>pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。图2 带change buffer的更新过程</p>
<p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间</p>
<p>（t.ibd）、系统表空间（ibdata1）。这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li><p>Page 1在内存中，直接更新内存；</p>
</li>
<li><p>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个</p>
</li>
</ol>
<p>信息</p>
<p>备注：这里，你可以再回顾下第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中</p>
<p>的相关内容。mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</p>
<ol start="3">
<li>将上述两个动作记入redo log中（图中3和4）。做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了</li>
</ol>
<p>两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。那在这之后的读请求，要怎么处理呢？比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程</p>
<p>图。如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表</p>
<p>空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。图3 带change buffer的读过程</p>
<p>从图中可以看到：</p>
<ol>
<li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果</li>
</ol>
<p>读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其</p>
<p>实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从</p>
<p>内存返回结果，结果是正确的。2. 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作</p>
<p>日志，生成一个正确的版本并返回结果。可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随</p>
<p>机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消</p>
<p>耗。小结</p>
<p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了</p>
<p>change buffer的机制以及应用场景，最后讲到了索引选择的实践。由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建</p>
<p>议你优先考虑非唯一索引。最后，又到了思考题时间。通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不</p>
<p>会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了</p>
<p>merge过程，就等于是数据丢失了。会不会出现这种情况呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。补充：</p>
<p>评论区大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。这里，我再说明一下：</p>
<p>首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况</p>
<p>下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，</p>
<p>必须创建唯一索引。这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存</p>
<p>命中率低的时候，可以给你多提供一个排查思路。然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半</p>
<p>年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高</p>
<p>归档效率，可以考虑把表里面的唯一索引改成普通索引。上期问题时间</p>
<p>上期的问题是：如何构造一个“数据无法修改”的场景。评论区里已经有不少同学给出了正确答</p>
<p>案，这里我再描述一下。这样，session A看到的就是我截图的效果了。其实，还有另外一种场景，同学们在留言区都还没有提到。这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的</p>
<p>事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活</p>
<p>跃事务的判断”，我是准备留到这里再补充的。当我试图在这里讲述完整规则的时候，发现第8篇文章《事务到底是隔离的还是不隔离的？》中</p>
<p>的解释引入了太多的概念，以致于分析起来非常复杂。因此，我重写了第8篇，这样我们人工去判断可见性的时候，才会更方便。【看到这里，我建议</p>
<p>你能够再重新打开第8篇文章并认真学习一次。如果学习的过程中，有任何问题，也欢迎你给我</p>
<p>留言】</p>
<p>用新的方式来分析session B’的更新为什么对session A不可见就是：在session A视图数组创建</p>
<p>的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况。业务中如果要绕过这类问题，@约书亚提供了一个“乐观锁”的解法，大家可以去上一篇的留言区</p>
<p>看一下。评论区留言点赞板：</p>
<p>@某、人、@夏日雨、@周巘、@李金刚 等同学提了一个很好的问题，就是我们今天答案的</p>
<p>session B’ 的情况；</p>
<p>@justin 提到了提交和未提交版本的区别对待，@倪大人 提到了读提交和当前读的区别，都是</p>
<p>经过了思考后提出的好问题，大家可以去留言区看看。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/c6101e2f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/c6101e2f.html" class="post-title-link" itemprop="url">mysql-事务到底是隔离的还是不隔离的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-09 06:17:41" itemprop="dateCreated datePublished" datetime="2019-11-09T06:17:41+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>08 | 事务到底是隔离的还是不隔离的？2018-11-30 林晓斌</p>
<p>我在第3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时</p>
<p>候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的</p>
<p>仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无</p>
<p>争，不受外界影响。但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外</p>
<p>一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进</p>
<p>入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？我给你举一个例子吧。下面是一个只有两行的表的初始化语句。mysql&gt; CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>k</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t(id, k) values(1,1),(2,2);</p>
<p>图1 事务A、B、C的执行流程</p>
<p>这里，我们需要注意的是事务的启动时机。begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表</p>
<p>的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with</p>
<p>consistent snapshot 这个命令。还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认</p>
<p>autocommit&#x3D;1。在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，</p>
<p>语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时</p>
<p>间顺序上是在事务B的查询之后。这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕</p>
<p>呢？所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能</p>
<p>够帮助你对InnoDB的事务和锁有更进一步的理解。在MySQL里，有两个“视图”的概念：</p>
<p>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持</p>
<p>RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。在第3篇文章《事务隔离：为什么你改了我还看不见？》中，我跟你解释过一遍MVCC的实现逻</p>
<p>辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这</p>
<p>两篇文章的说明来更深一步地理解MVCC。“快照”在MVCC里是怎么工作的？在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷</p>
<p>贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向</p>
<p>InnoDB的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且</p>
<p>把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，</p>
<p>并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。如图2所示，就是一个记录被多个事务连续更新后的状态。图2 行状态变更图</p>
<p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id</p>
<p>为25的事务更新的，因此它的row trx_id也是25。你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，undo log</p>
<p>在哪呢？实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而</p>
<p>是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依</p>
<p>次执行U3、U2算出来。明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照</p>
<p>的。按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这</p>
<p>个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我</p>
<p>启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版</p>
<p>本”。当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数</p>
<p>据，它自己还是要认的。在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活</p>
<p>跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水</p>
<p>位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。这个视图数组把所有的row trx_id 分成了几种不同的情况。图3 数据版本可见性规则</p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是</li>
</ol>
<p>可见的；</p>
<ol start="2">
<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>
</li>
<li><p>如果落在黄色部分，那就包括两种情况</p>
</li>
</ol>
<p>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；</p>
<p>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据</p>
<p>时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版</p>
<p>本是不存在的，所以这个事务的快照，就是“静态”的了。所以你现在知道了，InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建</p>
<p>快照”的能力。接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k&#x3D;1。这里，我们不妨做如下假设：</p>
<ol>
<li><p>事务A开始前，系统里面只有一个活跃事务ID是99；</p>
</li>
<li><p>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</p>
</li>
<li><p>三个事务开始前，(1,1）这一行数据的row trx_id是90。这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是</p>
</li>
</ol>
<p>[99,100,101,102]。为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p>
<p>图4 事务A查询数据逻辑图</p>
<p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最</p>
<p>新版本的row trx_id是102，而90这个版本已经成为了历史版本。第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row</p>
<p>trx_id）是101，而102又成为了历史版本。你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已</p>
<p>经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起</p>
<p>的。所以，事务A查询语句的读数据流程是这样的：</p>
<p>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</p>
<p>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</p>
<p>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据</p>
<p>的结果都是一致的，所以我们称之为一致性读。这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以</p>
<p>外，有三种情况：</p>
<ol>
<li><p>版本未提交，不可见；</p>
</li>
<li><p>版本已提交，但是是在视图创建后提交的，不可见；</p>
</li>
<li><p>版本已提交，而且是在视图创建前提交的，可见。现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的</p>
</li>
</ol>
<p>时候生成的，这时候：</p>
<p>(1,3)还没提交，属于情况1，不可见；</p>
<p>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</p>
<p>(1,1)是在视图数组创建之前提交的，可见。你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们</p>
<p>就都用这个规则来分析。更新逻辑</p>
<p>细心的同学可能有疑问了：事务B的update语句，如果按照一致性读，好像结果不对哦？你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能</p>
<p>算出(1,3)来？图5 事务B更新逻辑图</p>
<p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。所以，这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的</p>
<p>值，称为“当前读”（current read）。因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本</p>
<p>的row trx_id是101。所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是</p>
<p>自己的更新，可以直接使用，所以查询得到的k的值是3。这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是</p>
<p>当前读。所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或</p>
<p>for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是</p>
<p>分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？图6 事务A、B、C’的执行流程</p>
<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过</p>
<p>了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事</p>
<p>务B的更新语句会怎么处理呢？这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)</p>
<p>这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被</p>
<p>锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。mysql&gt; select k from t where id&#x3D;1 lock in share mode;</p>
<p>mysql&gt; select k from t where id&#x3D;1 for update;</p>
<p>图7 事务B更新逻辑图（配合事务C’）</p>
<p>到这里，我们把一致性读、当前读和行锁就串起来了。现在，我们再回到文章开头的问题：事务的可重复读的能力是怎么实现的？可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如</p>
<p>果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<p>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询</p>
<p>都共用这个一致性视图；</p>
<p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多</p>
<p>少呢？这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创</p>
<p>建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于</p>
<p>普通的start transaction。下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图</p>
<p>中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p>
<p>图8 读提交隔离级别下的事务状态图</p>
<p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成</p>
<p>时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<p>(1,3)还没提交，属于情况1，不可见；</p>
<p>(1,2)提交了，属于情况3，可见。所以，这时候事务A查询语句返回的是k&#x3D;2。显然地，事务B查询结果k&#x3D;3。小结</p>
<p>InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一</p>
<p>致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的</p>
<p>可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</p>
<p>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</p>
<p>而当前读，总是读取已经提交完成的最新版本。你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有</p>
<p>row trx_id，因此只能遵循当前读的逻辑。当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复</p>
<p>读。又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情</p>
<p>况。请你构造出这种情况，并说明其原理。mysql&gt; CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>c</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);</p>
<p>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码</p>
<p>会不会掉进这个“坑”里，你又是怎么解决的呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后，留给你的问题是：怎么删除表的前10000行。比较多的留言都选择了第二</p>
<p>种方式，即：在一个连接中循环执行20次 delete from T limit 500。确实是这样的，第二种方式是相对较好的。第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也</p>
<p>比较长；而且大事务还会导致主从延迟。第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。评论区留言点赞板：</p>
<p>@Tony Du的评论，详细而且准确。@Knight²º¹  提到了如果可以加上特定条件，将这10000行天然分开，可以考虑第三种。是</p>
<p>的，实际上在操作的时候我也建议你尽量拿到ID再删除。@荒漠甘泉 提了一个不错的问题，大家需要区分行锁、MDL锁和表锁的区别。对InnoDB表更</p>
<p>新一行，可能过了MDL关，却被挡在行锁阶段。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/3f0fbdd7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/3f0fbdd7.html" class="post-title-link" itemprop="url">mysql-行锁功过：怎么减少行锁对性能的影响</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-08 06:09:24" itemprop="dateCreated datePublished" datetime="2019-11-08T06:09:24+08:00">2019-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>07 | 行锁功过：怎么减少行锁对性能的影响？2018-11-28 林晓斌</p>
<p>在上一篇文章中，我跟你介绍了MySQL的全局锁和表级锁，今天我们就来讲讲MySQL的行锁。MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如</p>
<p>MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同</p>
<p>一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，</p>
<p>这也是MyISAM被InnoDB替代的重要原因之一。我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候</p>
<p>事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导</p>
<p>致程序出现非预期行为，比如两阶段锁。从两阶段锁说起</p>
<p>我先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字</p>
<p>段id是表t的主键。这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才</p>
<p>能继续执行。知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释</p>
<p>放，而是要等到事务结束时才释放。这个就是两阶段锁协议。知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把</p>
<p>最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个</p>
<p>业务需要涉及到以下操作：</p>
<ol>
<li><p>从顾客A账户余额中扣除电影票价；</p>
</li>
<li><p>给影院B的账户余额增加这张电影票价；</p>
</li>
<li><p>记录一条交易日志。也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交</p>
</li>
</ol>
<p>易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的</p>
<p>顺序呢？试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为</p>
<p>它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才</p>
<p>释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额</p>
<p>这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，</p>
<p>这并没有完全解决你的困扰。如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动</p>
<p>时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库</p>
<p>每秒就执行不到100个事务。这是什么原因呢？这里，我就要说到死锁和死锁检测了。死锁和死锁检测</p>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致</p>
<p>这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和</p>
<p>事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数</p>
<p>innodb_lock_wait_timeout来设置。另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事</p>
<p>务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现</p>
<p>死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于</p>
<p>在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确</p>
<p>实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会</p>
<p>出现很多误伤。所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且</p>
<p>innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发</p>
<p>现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁</p>
<p>住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是</p>
<p>O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级</p>
<p>的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到</p>
<p>CPU利用率很高，但是每秒却执行不了几个事务。根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结</p>
<p>在于，死锁检测要耗费大量的CPU资源。一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检</p>
<p>测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严</p>
<p>重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关</p>
<p>掉死锁检测意味着可能会出现大量的超时，这是业务有损的。另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时</p>
<p>最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法</p>
<p>就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过</p>
<p>一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务</p>
<p>端以后，峰值并发数也可能要达到3000。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的</p>
<p>团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，</p>
<p>在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。可能你会问，如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设</p>
<p>计上优化这个问题呢？你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多</p>
<p>条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账</p>
<p>户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等</p>
<p>待个数，也就减少了死锁检测的CPU消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会</p>
<p>减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处</p>
<p>理。小结</p>
<p>今天，我和你介绍了MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的</p>
<p>原则&#x2F;我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并</p>
<p>发度的锁的申请时机尽量往后放。但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了</p>
<p>三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事</p>
<p>务量。最后，我给你留下一个问题吧。如果你要删除一个表里面的前10000行数据，有以下三种方法可</p>
<p>以做到：</p>
<p>第一种，直接执行delete from T limit 10000;</p>
<p>第二种，在一个连接中循环执行20次 delete from T limit 500;</p>
<p>第三种，在20个连接中同时执行delete from T limit 500。你会选择哪一种方法呢？为什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我给你留的问题是：当备库用–single-transaction做逻辑备份的时候，如果从主库的binlog传</p>
<p>来一个DDL语句会怎么样？假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p>
<p>Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</p>
<p>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</p>
<p>&#x2F;* other tables *&#x2F;</p>
<p>Q3:SAVEPOINT sp;</p>
<p>&#x2F;* 时刻 1 *&#x2F;</p>
<p>Q4:show create table <code>t1</code>;</p>
<p>&#x2F;* 时刻 2 *&#x2F;</p>
<p>Q5:SELECT * FROM <code>t1</code>;</p>
<p>&#x2F;* 时刻 3 *&#x2F;</p>
<p>Q6:ROLLBACK TO SAVEPOINT sp;</p>
<p>&#x2F;* 时刻 4 *&#x2F;</p>
<p>&#x2F;* other tables *&#x2F;</p>
<p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p>
<p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性</p>
<p>视图（Q2)；</p>
<p>设置一个保存点，这个很重要（Q3）；</p>
<p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这</p>
<p>里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，</p>
<p>如果开始执行，则很快能够执行完成。参考答案如下：</p>
<ol>
<li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。2. 如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed,</li>
</ol>
<p>please retry transaction，现象：mysqldump终止；</p>
<ol start="3">
<li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：</li>
</ol>
<p>主从延迟，直到Q6执行完成。4. 从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表</p>
<p>结构。评论区留言点赞板：</p>
<p>@Aurora 给了最接近的答案；</p>
<p>@echo＿陈 问了一个好问题；</p>
<p>@壹笙☞漂泊 做了很好的总结。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/9cd031b1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/9cd031b1.html" class="post-title-link" itemprop="url">mysql-全局锁和表锁 ：给表加个字段怎么有这么多阻碍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-07 06:18:19" itemprop="dateCreated datePublished" datetime="2019-11-07T06:18:19+08:00">2019-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？2018-11-26 林晓斌</p>
<p>今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资</p>
<p>源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访</p>
<p>问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。今天这篇文</p>
<p>章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介</p>
<p>绍。这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是</p>
<p>碰到锁时的现象和其背后的原理。全局锁</p>
<p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是</p>
<p>Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命</p>
<p>令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括</p>
<p>建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</p>
<p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</p>
<p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问</p>
<p>题。假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉</p>
<p>他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表</p>
<p>(u_course)，会怎么样呢？你可以看一下这个图：</p>
<p>图1 业务和备份状态图</p>
<p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了</p>
<p>一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程</p>
<p>表再备份账户余额表，又可能会出现什么结果？也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致</p>
<p>的。说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视</p>
<p>图的，对吧？是的，就是在可重复读隔离级别下开启一个事务。官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导</p>
<p>数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是</p>
<p>可以正常更新的。你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？一致性读是好，但前提是引擎要支</p>
<p>持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是</p>
<p>只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。所以，single-transaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不</p>
<p>支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用</p>
<p>InnoDB替代MyISAM的原因之一。你也许会问，既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢？确实</p>
<p>readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原</p>
<p>因：</p>
<p>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备</p>
<p>库。因此，修改global变量的方式影响面更大，我不建议你使用。二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么</p>
<p>MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为</p>
<p>readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个</p>
<p>库长时间处于不可写状态，风险较高。业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论</p>
<p>是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍</p>
<p>的表级锁。备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章《事务隔</p>
<p>离：为什么你改了我还看不见？》中的相关内容。表级锁</p>
<p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。表锁的语法是 lock tables … read&#x2F;write。与FTWRL类似，可以用unlock tables主动释放锁，</p>
<p>也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写</p>
<p>外，也限定了本线程接下来的操作对象。举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读</p>
<p>写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操</p>
<p>作。连写t1都不允许，自然也不能访问其他表。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持</p>
<p>行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被</p>
<p>自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个</p>
<p>表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果</p>
<p>跟表结构对不上，肯定是不行的。因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当</p>
<p>要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线</p>
<p>程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看</p>
<p>到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操</p>
<p>作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也</p>
<p>会出问题。我们来看一下下面的操作序列，假设表t是一个小表。备注：这里的实验环境是MySQL 5.6。我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是</p>
<p>MDL读锁，因此可以正常执行。之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写</p>
<p>锁，因此只能被阻塞。如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也</p>
<p>会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被</p>
<p>锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session</p>
<p>再请求的话，这个库的线程很快就会爆满。你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释</p>
<p>放，而会等到整个事务提交后再释放。基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema</p>
<p>库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务</p>
<p>在执行，要考虑先暂停DDL，或者kill掉这个长事务。但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频</p>
<p>繁，而你不得不加个字段，你该怎么做呢？这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面</p>
<p>设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后</p>
<p>面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n</p>
<p>这个语法。小结</p>
<p>今天，我跟你介绍了MySQL的全局锁和表级锁。全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-</p>
<p>transaction参数，对应用会更友好。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock</p>
<p>tables这样的语句，你需要追查一下，比较可能的情况是：</p>
<p>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；</p>
<p>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock</p>
<p>tables 和 unlock tables 改成 begin 和 commit，问题就解决了。MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和</p>
<p>更新。最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction方法做逻</p>
<p>辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从</p>
<p>备库上会看到什么现象呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。说明：这篇文章没有介绍到物理备份，物理备份会有一篇单独的文章。上期问题时间</p>
<p>上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。ALTER TABLE tbl_name NOWAIT add column …</p>
<p>ALTER TABLE tbl_name WAIT N add column … </p>
<p>我直接贴@老杨同志 的回复略作修改如下（我修改的部分用橙色标出）：</p>
<p>表记录</p>
<p>–a–|–b–|–c–|–d–</p>
<p>1 2 3 d</p>
<p>1 3 2 d</p>
<p>1 4 3 d</p>
<p>2 1 3 d</p>
<p>2 2 2 d</p>
<p>2 3 4 d</p>
<p>主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。索引 ca 的组织是先按c排序，再按a排序，同时记录主键</p>
<p>–c–|–a–|–主键部分b– （注意，这里不是ab，而是只有b）</p>
<p>2 1 3</p>
<p>2 2 2</p>
<p>3 1 2</p>
<p>3 1 4</p>
<p>3 2 1</p>
<p>4 2 3</p>
<p>这个跟索引c的数据是一模一样的。索引 cb 的组织是先按c排序，在按b排序，同时记录主键</p>
<p>–c–|–b–|–主键部分a– （同上）</p>
<p>2 2 2</p>
<p>2 3 1</p>
<p>3 1 2</p>
<p>3 2 1</p>
<p>3 4 1</p>
<p>4 3 2</p>
<p>所以，结论是ca可以去掉，cb需要保留。评论区留言点赞：</p>
<p>@浪里白条 帮大家总结了复习要点；</p>
<p>@约书亚 的问题里提到了MRR优化；</p>
<p>@HwangZHen 留言言简意赅。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/a3ee96dd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/a3ee96dd.html" class="post-title-link" itemprop="url">mysql-深入浅出索引（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-06 06:11:42" itemprop="dateCreated datePublished" datetime="2019-11-06T06:11:42+08:00">2019-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>05 | 深入浅出索引（下）</p>
<p>2018-11-23 林晓斌</p>
<p>在上一篇文章中，我和你介绍了InnoDB索引的数据结构模型，今天我们再继续聊聊跟MySQL索</p>
<p>引有关的概念。在开始这篇文章之前，我们先来看一下这个问题：</p>
<p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜</p>
<p>索操作，会扫描多少行？下面是这个表的初始化语句。mysql&gt; create table T (</p>
<p>ID int primary key,</p>
<p>k int NOT NULL DEFAULT 0, </p>
<p>s varchar(16) NOT NULL DEFAULT ‘’,</p>
<p>index k(k))</p>
<p>engine&#x3D;InnoDB;</p>
<p>insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);</p>
<p>图1 InnoDB的索引组织结构</p>
<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li><p>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</p>
</li>
<li><p>再到ID索引树查到ID&#x3D;300对应的R3；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</p>
</li>
<li><p>再回到ID索引树查到ID&#x3D;500对应的R4；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k</p>
</li>
</ol>
<p>索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有</p>
<p>可能经过索引优化，避免回表过程呢？覆盖索引</p>
<p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值</p>
<p>已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，</p>
<p>索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用</p>
<p>的性能优化手段。需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k</p>
<p>上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL</p>
<p>认为扫描行数是2。基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份</p>
<p>证号和名字建立联合索引？假设这个市民表的定义是这样的：</p>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，</p>
<p>我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是</p>
<p>不是浪费空间？如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它</p>
<p>可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑</p>
<p>了。这正是业务DBA，或者称为业务数据架构师的工作。最左前缀原则</p>
<p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》</p>
<p>中，和你详细讨论。CREATE TABLE <code>tuser</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>id_card</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>name</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>age</code> int(11) DEFAULT NULL,</p>
<p>  <code>ismale</code> tinyint(1) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>id_card</code> (<code>id_card</code>),</p>
<p>  KEY <code>name_age</code> (<code>name</code>,<code>age</code>)</p>
<p>) ENGINE&#x3D;InnoDB</p>
<p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现</p>
<p>在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但</p>
<p>总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的</p>
<p>索引又感觉有点浪费。应该怎么做呢？这里，我先和你说结论吧。B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。图2 （name，age）索引示意图</p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有</p>
<p>需要的结果。如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like</p>
<p>‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，</p>
<p>直到不满足条件为止。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左</p>
<p>前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索</p>
<p>引内的字段顺序。这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联</p>
<p>合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可</p>
<p>以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索</p>
<p>引，并用这个索引支持“根据身份证号查询地址”的需求。那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使</p>
<p>用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、</p>
<p>(b) 这两个索引。这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段</p>
<p>大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。索引下推</p>
<p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能</p>
<p>要问，那些不符合最左前缀的部分，会怎么样呢？我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一</p>
<p>个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足</p>
<p>条件的记录ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索</p>
<p>引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。图3和图4，是这两个过程的执行流程图。mysql&gt; select * from tuser where name like ‘张%’ and age&#x3D;10 and ismale&#x3D;1;</p>
<p>图3 无索引下推执行流程</p>
<p>图4 索引下推执行流程</p>
<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，</p>
<p>只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的</p>
<p>记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判</p>
<p>断，就只需要回表2次。小结</p>
<p>今天这篇文章，我和你继续讨论了数据库索引的概念，包括了覆盖索引、前缀索引、索引下推。你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我</p>
<p>们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。接下来我给你留下一个问题吧。实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维</p>
<p>护的库里面，有这么一个表，表结构定义类似这样的：</p>
<p>公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c</p>
<p>上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：</p>
<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为</p>
<p>什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理。在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分</p>
<p>裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样</p>
<p>页面的利用率最高，也就是索引更紧凑、更省空间。这道题目，我给你的“参考答案”是：</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删</p>
<p>除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做</p>
<p>了。这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。在专栏的第12篇文章</p>
<p>CREATE TABLE <code>geek</code> (</p>
<p>  <code>a</code> int(11) NOT NULL,</p>
<p>  <code>b</code> int(11) NOT NULL,</p>
<p>  <code>c</code> int(11) NOT NULL,</p>
<p>  <code>d</code> int(11) NOT NULL,</p>
<p>  PRIMARY KEY (<code>a</code>,<code>b</code>),</p>
<p>  KEY <code>c</code> (<code>c</code>),</p>
<p>  KEY <code>ca</code> (<code>c</code>,<code>a</code>),</p>
<p>  KEY <code>cb</code> (<code>c</code>,<code>b</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select * from geek where c&#x3D;N order by a limit 1;</p>
<p>select * from geek where c&#x3D;N order by b limit 1;</p>
<p>《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。评论区留言中， @壹笙☞漂泊 做了很详细的笔记，@高枕 帮同学解答了问题，@约书亚 提了一</p>
<p>个很不错的面试问题。在这里，我要和你们道一声感谢。PS：如果你在面试中，曾有过被MySQL相关问题难住的经历，也可以把这个问题发到评论区，</p>
<p>我们一起来讨论。如果解答这个问题，需要的篇幅会很长的话，我可以放到答疑文章展开。&#96;&#96;&#96;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/1b52f1b8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/1b52f1b8.html" class="post-title-link" itemprop="url">mysql-深入浅出索引（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-05 06:11:01" itemprop="dateCreated datePublished" datetime="2019-11-05T06:11:01+08:00">2019-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>04 | 深入浅出索引（上）</p>
<p>2018-11-21 林晓斌</p>
<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢，</p>
<p>分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，</p>
<p>索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，</p>
<p>所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识</p>
<p>点，加深你对数据库索引的理解。一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500</p>
<p>页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一</p>
<p>会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。索引的常见模型</p>
<p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模</p>
<p>型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的</p>
<p>数据结构，它们分别是哈希表、有序数组和搜索树。下面我主要从使用的角度，为你简单分析一下这三种模型的区别。哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找</p>
<p>到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个</p>
<p>确定的位置，然后把value放在数组的这个位置。不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方</p>
<p>法是，拉出一个链表。假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应</p>
<p>的哈希索引的示意图如下所示：</p>
<p>图1 哈希表示意图</p>
<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，</p>
<p>这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函</p>
<p>数算出N；然后，按顺序遍历，找到User2。需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会</p>
<p>很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢</p>
<p>的。你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必</p>
<p>须全部扫描一遍了。所以，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引</p>
<p>擎。而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号</p>
<p>查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p>图2 有序数组示意图</p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你</p>
<p>要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的</p>
<p>User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一</p>
<p>个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦</p>
<p>了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎，比如你要保存的是2017年某个城市的所有人口</p>
<p>信息，这类不会再修改的数据。二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二</p>
<p>叉搜索树来实现的话，示意图如下所示：</p>
<p>图3 二叉搜索树示意图</p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查</p>
<p>ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得</p>
<p>到。这个时间复杂度是O(log(N))。当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更</p>
<p>新的时间复杂度也是O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右</p>
<p>递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因</p>
<p>是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在</p>
<p>机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100</p>
<p>万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真</p>
<p>够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该</p>
<p>使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存</p>
<p>1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一</p>
<p>个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内</p>
<p>存中，那么访问磁盘的平均次数就更少了。N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中</p>
<p>了。不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数</p>
<p>据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开</p>
<p>了。你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我</p>
<p>们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能</p>
<p>会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理</p>
<p>数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分</p>
<p>析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。现在，我们一起进入相对偏实战的内容吧。在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索</p>
<p>引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不</p>
<p>同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和</p>
<p>你分析一下其中的索引模型。InnoDB 的索引模型</p>
<p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。这个表的建表语句是：</p>
<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意</p>
<p>图如下。图4 InnoDB的索引组织结构</p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered</p>
<p>index）。非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引</p>
<p>（secondary index）。根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区</p>
<p>mysql&gt; create table T(</p>
<p>id int primary key, </p>
<p>k int not null, </p>
<p>name varchar(16),</p>
<p>index (k))engine&#x3D;InnoDB;</p>
<p>别？如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</p>
<p>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID</p>
<p>的值为500，再到ID索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主</p>
<p>键查询。索引维护</p>
<p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插</p>
<p>入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就</p>
<p>相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的</p>
<p>数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，</p>
<p>整体空间利用率降低大约50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合</p>
<p>并的过程，可以认为是分裂过程的逆过程。基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY</p>
<p>KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条</p>
<p>新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如</p>
<p>字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的</p>
<p>叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无</p>
<p>绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样</p>
<p>的：</p>
<ol>
<li><p>只有一个索引；</p>
</li>
<li><p>该索引必须是唯一索引。你一定看出来了，这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，</p>
</li>
</ol>
<p>可以避免每次查询需要搜索两棵树。小结</p>
<p>今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么</p>
<p>InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的</p>
<p>空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。最后，我给你留下一个问题吧。对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个</p>
<p>SQL语句可以这么写：</p>
<p>如果你要重建主键索引，也可以这么写：</p>
<p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好</p>
<p>的方法是什么？alter table T drop index k;</p>
<p>alter table T add index(k);</p>
<p>alter table T drop primary key;</p>
<p>alter table T add primary key(id);</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章末尾给你留下的问题是：如何避免长事务对业务的影响？这个问题，我们可以从应用开发端和数据库端来看。首先，从应用开发端来看：</p>
<ol>
<li>确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的</li>
</ol>
<p>general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架</p>
<p>如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我</p>
<p>见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务</p>
<p>可以去掉。3. 业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，</p>
<p>来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后</p>
<p>续的文章中会提到这类案例）</p>
<p>其次，从数据库端来看：</p>
<ol>
<li><p>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的</p>
</li>
</ol>
<p>值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。感谢 @壹笙☞漂泊 @王凯 @易翔 留下的高质量评论。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/7433cb2c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7433cb2c.html" class="post-title-link" itemprop="url">mysql-事务隔离：为什么你改了我还看不见</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-04 06:18:35" itemprop="dateCreated datePublished" datetime="2019-11-04T06:18:35+08:00">2019-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>03 | 事务隔离：为什么你改了我还看不见？2018-11-19 林晓斌</p>
<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转</p>
<p>账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必</p>
<p>须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时</p>
<p>间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事</p>
<p>务”这个概念了。简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事</p>
<p>务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引</p>
<p>擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代</p>
<p>的重要原因之一。今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给</p>
<p>出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。隔离性与隔离级别</p>
<p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一</p>
<p>致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-</p>
<p>repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概</p>
<p>念。在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要</p>
<p>在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、</p>
<p>读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐</p>
<p>一为你解释：</p>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一</p>
<p>致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突</p>
<p>的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中</p>
<p>只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。mysql&gt; create table T(c int) engine&#x3D;InnoDB;</p>
<p>insert into T(c) values(1);</p>
<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3</p>
<p>的返回值分别是什么。若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被</p>
<p>A看到了。因此，V2、V3也都是2。若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，</p>
<p>V3的值也是2。若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：</p>
<p>事务在执行期间看到的数据前后必须是一致的。若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，</p>
<p>事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离</p>
<p>级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级</p>
<p>别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离</p>
<p>级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避</p>
<p>免并行访问。我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其</p>
<p>实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，</p>
<p>你一定要记得将MySQL的隔离级别设置为“读提交”。配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用</p>
<p>show variables来查看当前的值。总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时</p>
<p>候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务</p>
<p>更新的影响。mysql&gt; show variables like ‘transaction_isolation’;</p>
<p>+———————–+—————-+</p>
<p>| Variable_name | Value |</p>
<p>+———————–+—————-+</p>
<p>| transaction_isolation | READ-COMMITTED |</p>
<p>+———————–+—————-+</p>
<p>事务隔离的实现</p>
<p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复</p>
<p>读”。在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通</p>
<p>过回滚操作，都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看</p>
<p>到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多</p>
<p>个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前</p>
<p>值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的</p>
<p>事务是不会冲突的。你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数</p>
<p>据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占</p>
<p>用存储空间。在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终</p>
<p>提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终</p>
<p>只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候</p>
<p>展开。事务的启动方式</p>
<p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并</p>
<p>不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是</li>
</ol>
<p>rollback。2. set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个</p>
<p>select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行</p>
<p>commit 或 rollback 语句，或者断开连接。有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的</p>
<p>查询都在事务中，如果是长连接，就导致了意外的长事务。因此，我会建议你总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式</p>
<p>每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾</p>
<p>虑，我建议你使用commit work and chain语法。在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行</p>
<p>commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语</p>
<p>句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查</p>
<p>找持续时间超过60s的事务。select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p>
<p>小结</p>
<p>这篇文章里面，我介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存</p>
<p>在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地</p>
<p>使用MySQL的事务特性。我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也</p>
<p>是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>在上期文章的最后，我给你留下的问题是一天一备跟一周一备的对比。好处是“最长恢复时间”更短。在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，</p>
<p>而要恢复出一个到昨天晚上23点的备份。一周一备最坏情况就要应用一周的binlog了。系统的对应指标就是 @尼古拉斯·赵四 @慕塔 提到的RTO（恢复目标时间）。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来</p>
<p>的，就需要你根据业务重要性来评估了。同时也感谢 @super blue cat、@高枕、@Jason 留下了高质量的评论。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/7470fa8d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7470fa8d.html" class="post-title-link" itemprop="url">mysql-日志系统：一条SQL更新语句是如何执行的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-03 06:15:29" itemprop="dateCreated datePublished" datetime="2019-11-03T06:15:29+08:00">2019-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>02 | 日志系统：一条SQL更新语句是如何执行的？2018-11-16 林晓斌</p>
<p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还</p>
<p>记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后</p>
<p>到达存储引擎。那么，一条更新语句的执行流程又是怎样的呢？之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你</p>
<p>是不是心中也会不免会好奇，这是怎样做到的呢？我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个</p>
<p>整型字段c：</p>
<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>
<p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看</p>
<p>这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。mysql&gt; create table T(ID int primary key, c int);</p>
<p>mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<p>MySQL的逻辑架构图</p>
<p>你执行语句前要先连接数据库，这是连接器的工作。前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会</p>
<p>把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主</p>
<p>角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过</p>
<p>的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有</p>
<p>意思的地方，这些设计思路也可以用到你自己的程序里。重要的日志模块：redo log</p>
<p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记</p>
<p>录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会</p>
<p>有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<p>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</p>
<p>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到</p>
<p>这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老</p>
<p>花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的</p>
<p>帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到</p>
<p>对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问</p>
<p>题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-</p>
<p>Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账</p>
<p>本。具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里</p>
<p>面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作</p>
<p>记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的</p>
<p>事。如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎</p>
<p>么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把</p>
<p>这些记录从粉板上擦掉，为记新账腾出空间。与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是</p>
<p>1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环</p>
<p>写，如下面这个图所示。write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文</p>
<p>件。write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos</p>
<p>追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把</p>
<p>checkpoint推进一下。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个</p>
<p>能力称为crash-safe。要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或</p>
<p>写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板</p>
<p>上的数据明确赊账账目。重要的日志模块：binlog</p>
<p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能</p>
<p>层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是</p>
<p>InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。我想你肯定会问，为什么会有两份日志呢？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有</p>
<p>crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL</p>
<p>的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— —也就是</p>
<p>redo log来实现crash-safe能力。这两种日志有以下三点不同。1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的</p>
<p>是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件</p>
<p>写到一定大小后会切换到下一个，并不会覆盖以前的日志。有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语</p>
<p>句时的内部流程。1. 执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一</p>
<p>行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然</p>
<p>后再返回。2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行</p>
<p>数据，再调用引擎接口写入这行新数据。3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处</p>
<p>于prepare状态。然后告知执行器执行完成了，随时可以提交事务。4. 执行器生成这个操作的binlog，并把binlog写入磁盘。5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更</p>
<p>新完成。这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表</p>
<p>示是在执行器中执行的。update语句执行流程</p>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和</p>
<p>commit，这就是”两阶段提交”。两阶段提交</p>
<p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得</p>
<p>从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承</p>
<p>诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期</p>
<p>做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数</p>
<p>据，那你可以这么做：</p>
<p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备</p>
<p>份恢复到临时库；</p>
<p>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时</p>
<p>刻。这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢</p>
<p>复到线上库去。好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法</p>
<p>来进行解释。由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写</p>
<p>binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语</p>
<p>句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？1. 先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异</p>
<p>常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回</p>
<p>来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份</p>
<p>日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这</p>
<p>个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。2. 先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以</p>
<p>后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日</p>
<p>志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是</p>
<p>1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的</p>
<p>状态不一致。你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再</p>
<p>多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来</p>
<p>实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保</p>
<p>持逻辑上的一致。小结</p>
<p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，</p>
<p>表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证</p>
<p>MySQL异常重启之后数据不丢失。sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建</p>
<p>议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑</p>
<p>一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有</p>
<p>的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或</p>
<p>者说，它影响了这个数据库系统的哪个指标？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">342</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:40</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
