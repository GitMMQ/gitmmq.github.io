<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="recording">
<meta name="keywords" content="Tech;Data;Vision">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/8/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qi">
<meta name="twitter:description" content="recording">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.fastolf.com/page/8/">





  <title>Qi</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">to learn</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-图/" itemprop="url">数据结构-图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T13:12:06+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>图是由顶点集（VertexSet）和边集（EdgeSet）组成，针对图G，顶点集和边集分别记为V(G)和E(G)。依据图的边集是否为有向，可把图分为有向图和无向图，根据图是否有权重，可以分为有权图和无权图</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li>邻接点-在一个无向图中，若存在一条边<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2. 出/入边-在一个有向图张，若存在一条边```&lt;Vi,Vj&gt;```，则称此边为顶点Vi的出边，顶点Vj的一条入边</span><br><span class="line">3. 度/入度/出度-无向图中的度定义为以该顶点为一个端点的边的数目，记为D(V)。有向图的入度定为多少边指向该顶点，出度是该顶点出边的个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 邻接矩阵</span><br><span class="line"></span><br><span class="line">```邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。对于无向图 如果顶点b1和b2是连接的，那么在二维矩阵中matrix[b1,b2]和matrix[b2,b1]位置的值置为1，如果是有向图b1指向b2，那么 matrix[b1,b2]=1,matrix[b2,b1]=0；下面用一个例子表示无向图和有向图的邻接矩阵；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果图是一个带权图，需要把1换为相应边上的权值，把非对角线上的换成一个很大的特定的实数则可，表示相应的边不存在，这个特定的实数通常用无穷大或MaxValue来表示，他要大于图G中所有边的权值</p>
<p><a href="#matrix">代码实现</a></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接矩阵与邻接表相比，它会造成空间的一定损失，它需要为每个顶点都分配n个边的空间，其实有很多边都是不存在边，但是邻接表的实现就不一样，它只关心存在的边，不关心不存在的边。邻接表由数组+链表组成对于上面的无向图，邻接表表示为（由于有向和无向的差别不是太大，所以只是画出了无向的邻接表表示）</p>
<p><a href="#table">代码实现</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><span id="matrix">邻接矩阵实现</span></p>
<pre><code>package Graph;
//边集数组 ，存放边的信息
//邻域数组表示  和 邻域表表示  是两种不同的表示方式
//表示的是插入边的元素，边的起点和终点  边的权重
public class EdgeElement {
    int fromvex;
    int endvex;
    int weight;

    public EdgeElement(int v1,int v2){
        //对于无权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=1;
    }
    public EdgeElement(int v1,int v2,int wgt){
        //对于有权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=wgt;
    }    
}


package Graph;
//可以通过边集来得到一个图的构成
public interface Graph {
    void creatGraph(EdgeElement d[]);        //通过边结点来构建一个图
    GraphType graphType();                //返回图的类型  无向无权图 无向有权图  有向无权图  有向有权图 定义一个枚举变量
    int vertices();                    //返回图的顶点数
    int edges();                    //返回图的边数
    boolean find(int i,int j);            //从图中查找一条边(i,j)是否存在
    void putEdge(EdgeElement theEdge);        //像图中插入一条边 theEdge
    void removeEdge(int i,int j);            //从图中删除一条边
    int degree(int i);                //返回顶点i的度
    int inDegree(int i);                //返回顶点i的入度
    int outDegree(int i);                //返回顶点i的出度
    void output();                    //以图的顶点集和边集的形式输出一个图
    void depthFirstSearch(int v);            //从顶点v开始深度优先搜索整幅图
    void breadthFirstSearch(int v);            //从顶点v开始广度优先搜索整幅图
}

//在邻域数组中写数据
public void creatGraph(EdgeElement[] d) {
    int i;
    for(i=0;i&lt;d.length;i++){
        if(d[i]==null) break;
        int v1,v2;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2){
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        }
        if(type==GraphType.NoDirectionNoWeight){
            a[v1][v2]=a[v2][v1]=1;
        }else if(type==GraphType.NoDirectionWeight){
            a[v1][v2]=a[v2][v1]=d[i].weight;
        }else if(type==GraphType.DirectionNoWeight){
            a[v1][v2]=1;
        }else{
            a[v1][v2]=d[i].weight;
        }
    }
    e=i;            //边的数目
}

public void putEdge(EdgeElement theEdge) {
    int v1,v2;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    }
    if(a[v1][v2]==0 || a[v1][v2]==MaxValue) e++;        //边数e的值加一
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        if(type==GraphType.NoDirectionNoWeight){
            a[v1][v2]=a[v2][v1]=1;
        }else{
            a[v1][v2]=a[v2][v1]=theEdge.weight;
        }
    }else{
        if(type==GraphType.DirectionNoWeight) a[v1][v2]=1;
        else{
            a[v1][v2]=theEdge.weight;
        }
    }
}

public void removeEdge(int i, int j) {
    if(i&lt;0 || i&gt;n-1 || j&lt;0 || j&gt;n-1 || i==j){
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    }
    if(a[i][j]==0 || a[i][j]==MaxValue){
        System.out.println(&quot;要删除的边不存在，退出运行！&quot;);
        System.exit(0);            
    }
    if(type==GraphType.NoDirectionNoWeight){
        a[i][j]=a[j][i]=0;
    }else if(type==GraphType.NoDirectionWeight){
        a[i][j]=a[j][i]=MaxValue;
    }else if(type==GraphType.DirectionNoWeight){
        a[i][j]=0;
    }else a[i][j]=MaxValue;
    e--;
}

//得到该结点的度
public int degree(int i) {
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    int k=0;
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        for(int j=0;j&lt;n;j++){
            if(a[i][j]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;

        }
    }else{
        k = inDegree(i)+outDegree(i);
    }
    return k;
}
//入度
public int inDegree(int i) {                    
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        return -1;
    }
    int k=0;
    for(int j=0;j&lt;n;i++){
        if(a[j][i]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;
    }
    return k;
}
//出度
public int outDegree(int i) {
    if(i&lt;0 || i&gt; n-1){
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    }
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight){
        return -1;
    }
    int k=0;
    for(int j=0;j&lt;n;i++){
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue) k++;
    }
    return k;
}

//输出
public void output() {
    int i,j;
    System.out.print(&quot;V={&quot;);//输出顶点集合
    for(i=0;i&lt;n-1;i++){
        System.out.print(i+&quot;,&quot;);
    }
    System.out.print(n-1+&quot;}&quot;);//输出顶点集合
    //输出边集合
    System.out.print(&quot;E={&quot;);
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.DirectionNoWeight){
        for(i=0;i&lt;n;i++){
            for(j=0;j&lt;n;j++){
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue){
                    if(type==GraphType.NoDirectionNoWeight){
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;),&quot;);
                    }else{
                        System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;);
                    }
                }
            }
        }
    }else{
        for(i=0;i&lt;n;i++){
            for(j=0;j&lt;n;j++){
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue){
                    if(type==GraphType.NoDirectionWeight){
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;+a[i][j]+&quot;,&quot;);
                    }else System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;+a[i][j]+&quot;,&quot;);
                }
            }
        }
    }
    System.out.print(&quot;}&quot;);
}

//深度优先进行搜索   是从哪个顶点开始遍历，这里可以用顶点序号表示顶点
public void depthFirstSearch(int v) {        //驱动函数
    boolean visited[]=new boolean[n];
    for(int i=0;i&lt;n;i++){
        visited[i]=false;
    }
    dfs(v,visited);                            //把每个结点遍历一次。
    System.out.println();
}
//进行深度优先搜索的内部递归方法使用
private void dfs(int i,boolean visited[]){    //工作函数
    System.out.print(i+&quot; &quot;);
    visited[i]=true;
    for(int j=0;j&lt;n;j++){
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue &amp;&amp; !visited[j]){
            dfs(j,visited);
        }
    }
}
</code></pre><p><span id="table">邻接表实现</span></p>
<pre><code>package GraphLink;
//定义邻接表类型
public class EdgeNode{
    //需要一个存储自身结点
    int adjvex;
    int weight;
    EdgeNode next;
    //无权图
    public EdgeNode(int adj,EdgeNode nt){
        this.adjvex=adj;
        this.next=nt;
        this.weight=1;
    }
    //有权图
    public EdgeNode(int adj,int wgt,EdgeNode nt){
        this.adjvex=adj;
        this.weight=wgt;
        this.next=nt;
    }
}

//生成图函数
@Override
public void creatGraph(EdgeElement[] d) {
    int i;
    for(i=0;i&lt;d.length;i++){//处理边集合  如果边集合重复 那程序不就有问题了么  这点要处理
        if(d[i]==null) break;
        int v1,v2,weight;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        weight=d[i].weight;
        if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        }
        if(type==GraphType.NoDirectionNoWeight){//处理无方向 无权重的图
            a[v1]=new EdgeNode(v2,a[v1]);//把边挂载在主干上,a为EdgeNode类型的一维数组
            a[v2]=new EdgeNode(v1,a[v2]);//处理第二条边
        }else if(type==GraphType.NoDirectionWeight){//处理无向有权图
            a[v1]=new EdgeNode(v2,weight,a[v1]);
            a[v2]=new EdgeNode(v1,weight,a[v2]);
        }else if(type==GraphType.DirectionNoWeight){//处理有向无权图
            a[v1]=new EdgeNode(v2,a[v1]);
        }else {
            a[v1]=new EdgeNode(v2,weight,a[v1]);
        }
    }
    e=i;
}

//在图中查找一条边
public boolean find(int v1,int v2){
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1];
    while(p!=null){
        if(p.adjvex==v2){
            return true;
        }
        p=p.next;
    }
    return false;
}

//向图中插入一条边
public void putEdge(EdgeElement theEdge){
    int v1,v2,weight;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    weight=theEdge.weight;
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1];
    while(p!=null){
        if(p.adjvex==v2){
            break;//退出后处理
        }
        p=p.next;
    }
    if(p==null) e++;
    else{
        if(type==GraphType.DirectionWeight || type==GraphType.NoDirectionWeight){
            p.weight=weight;
        }
        if(type==GraphType.NoDirectionWeight){//无向有权重的另一条边也要处理
            EdgeNode q=a[v2];
            while(q!=null){
                if(q.adjvex==v1) break;
                q=q.next;
            }
            q.weight=weight;
        }
        return;
    }
    if(type==GraphType.NoDirectionNoWeight){//如果是无向无权重
        a[v1]=new EdgeNode(v2, a[v1]);
        a[v2]=new EdgeNode(v1, a[v2]);
    }else if(type==GraphType.NoDirectionWeight){//处理无向有权重
        a[v1]=new EdgeNode(v2,weight,a[v1]);
        a[v2]=new EdgeNode(v1,weight,a[v2]);
    }else if(type==GraphType.DirectionNoWeight){//有向无权重
        a[v1]=new EdgeNode(v2,a[v1]);
    }else{
        a[v1]=new EdgeNode(v2, weight,a[v1]);
    }
}

public void removeEdge(int v1,int v2){
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2){
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    }
    EdgeNode p=a[v1],q=null;//拿到主干结点
    while(p!=null){
        if(p.adjvex==v2) break;
        q=p;
        p=p.next;
    }
    if(p==null){
        System.out.println(&quot;要删除的边不存在，程序退出运行&quot;);
        System.exit(0);
    }
    if(q==null){//该结点在表头上 主干的节点就是需要找的结点
        a[v1]=a[v1].next;
    }else{
        q.next=p.next;//嫁接上
    }
    //删除无向图的另一个结点上的边
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        EdgeNode p1=a[v2],q1=null;
        while(p1!=null){
            if(p1.adjvex==v1){
                break;
            }
            q1=p1;
            p1=p1.next;
        }
        if(q1==null){
            a[v2]=a[v2].next;
        }else{
            q1.next=p1.next;
        }
    }
    e--;
}

//返回一个顶点的度，度分为入度和出度，要分别处理
public int degree(int i){
    if(i&lt;0||i&gt;n-1){
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);            
    }
    int k=0;
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        EdgeNode p=a[i];
        while(p!=null){
            k++;
            p=p.next;
        }
        return k;
    }else return inDegree(i)+outDegree(i);
}
//求出并返回一个顶点的入度
public int inDegree(int i){//返回指向该顶点的度，入度，用双循环来实现
    int k=0;//记录入度个数
    if(i&lt;0||i&gt;n-1){
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);            
    }
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight){
        return -1;
    }else{
        for(int j=0;j&lt;n;j++){
            EdgeNode p=a[j];
            while(p!=null){
                if(p.adjvex==i)k++;
                p=p.next;
            }
        }
    }
    return k;
}
//返回一个顶点的出度
public int outDegree(int i){
    int k=0;//记录出度的数目
    EdgeNode p=a[i];
    while(p!=null){
        k++;
        p=p.next;
    }
    return k;
}

//得到邻接矩阵
public int[][] getAdjacencyMatrix(){
    int adjacencyMatrix[][]=new int[n][n];
    if(type==GraphType.DirectionNoWeight||type==GraphType.DirectionWeight){//有向性
        //有向 那不存在的边是存在一个InfinityValue
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                if(i==j) adjacencyMatrix[i][j]=0;
                else adjacencyMatrix[i][j]=InfinityValue;
            }
        }
    }else{
        //无向 都设置为0
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                 adjacencyMatrix[i][j]=0;
            }
        }            
    }
        //遍历整个图
        for(int i=0;i&lt;n;i++){
            EdgeNode p=a[i];
            while(p!=null){
                adjacencyMatrix[i][p.adjvex]=p.weight;
                p=p.next;
            }
        }    
    return adjacencyMatrix;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-矩阵压缩/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-矩阵压缩/" itemprop="url">数据结构-矩阵压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:47:29+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对称矩阵的压缩"><a href="#对称矩阵的压缩" class="headerlink" title="对称矩阵的压缩"></a>对称矩阵的压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    //对称矩阵的压缩算法</span><br><span class="line">    public class SymeMatric &#123;</span><br><span class="line">    </span><br><span class="line">        double[] a;// 矩阵元素</span><br><span class="line">        int n; // 矩阵的阶数</span><br><span class="line">        int m;// 一维数组的元素的个数--长度</span><br><span class="line">    </span><br><span class="line">        public SymeMatric(int n) &#123;</span><br><span class="line">            // 对称矩阵中不重复元素，保存到一维数组中所需要的一维数组的长度</span><br><span class="line">            // 2阶对称矩阵对应(1+2=3)维数组，3阶对称矩阵对应1+2+3=6维数组，</span><br><span class="line">            // 4阶对称矩阵对应1+2+3+4维数组，n阶对称矩阵对应前n项和，</span><br><span class="line">            // 所以一维数组的长度m的值为1,2,3...n的前n项和</span><br><span class="line">            m = n * (n + 1) / 2; </span><br><span class="line">            a = new double[m];</span><br><span class="line">            this.n = n;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 通过一个二维数组来初始化</span><br><span class="line">        public void evalute(double[][] b) &#123;</span><br><span class="line">            int k = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                    // i &gt;= j表示只保存下三角元素</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        a[k++] = b[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 通过一个一维数组来初始化,那么这个一维数组就是对称矩阵元素的一个副本</span><br><span class="line">        public void evalute(double[] b) &#123;</span><br><span class="line">            for (int k = 0; k &lt; m; k++) &#123;</span><br><span class="line">                a[k] = b[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 对称矩阵相加</span><br><span class="line">        public SymeMatric add(SymeMatric b) &#123;</span><br><span class="line">            SymeMatric t = new SymeMatric(n);</span><br><span class="line">            int k;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        k = i * (i - 1) / 2 + j - 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        k = j * (j - 1) / 2 + i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 求和</span><br><span class="line">                    t.a[k] = a[k] + b.a[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 打印对称矩阵，这个才是关键！！</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            int k;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                    if (i &gt;= j) &#123;</span><br><span class="line">                        k = i * (i - 1) / 2 + j - 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        k = j * (j - 1) / 2 + i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(&quot; &quot; + a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三角矩阵的压缩</span><br><span class="line"></span><br><span class="line">```m对角矩阵：非零元素在每行中有m个，一维数组s[k]和A[i][j]的对应关系为：k = m*i+j</span><br></pre></td></tr></table></figure>
<h2 id="稀疏矩阵的压缩"><a href="#稀疏矩阵的压缩" class="headerlink" title="稀疏矩阵的压缩"></a>稀疏矩阵的压缩</h2><p><code>矩阵m*n如果有t个非零元素，那么s = t/m*n称为矩阵的稀疏因子，如果s&lt;=0.05那么矩阵为稀疏矩阵</code></p>
<p>注：三元组顺序表表示，其中三元组格式为(i,j,e)记录了非零元素的行号、列号以及非零元素</p>
<pre><code>inal int _ROWS=5;        //定义行数
final int _COLS=5;        //定义列数
final int _NOTZERO=6;    //定义稀疏矩阵中不为零的个数
int i,j,tmpRW,tmpCL,tmpNZ;
int temp=1;
int Sparse[][]=new int[_ROWS][_COLS];    //声明稀疏矩阵
int Compress[][]=new int[_NOTZERO+1][3];//声明压缩矩阵

for(i=0;i&lt;_ROWS;i++)         //将矩阵初始值都设为0
    for(j=0;j&lt;_COLS;j++)
        Sparse[i][j]=0;

tmpNZ=_NOTZERO;            //产生随机稀疏矩阵
for(i=1;i&lt;tmpNZ+1;i++) {
    tmpRW=(int)(Math.random()*100);
    tmpRW=(tmpRW%_ROWS);
    tmpCL=(int)(Math.random()*100);
    tmpCL=(tmpCL%_COLS);
    if(Sparse[tmpRW][tmpCL]!=0)
        tmpNZ++;
    Sparse[tmpRW][tmpCL]=i;
}

/*开始压缩稀疏矩阵*/
Compress[0][0]=_ROWS;
Compress[0][1]=_COLS;
Compress[0][2]=_NOTZERO;
for(i=0;i&lt;_ROWS;i++) {
    for(j=0;j&lt;_COLS;j++) {
        if(Sparse[i][j]!=0){
            Compress[temp][0]=i;
            Compress[temp][1]=j;
            Compress[temp][2]=Sparse[i][j];
            temp++;
        }
    }
}
</code></pre><p>链接：<a href="https://www.cnblogs.com/gaosheng-221/p/6133443.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosheng-221/p/6133443.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-栈、队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-栈、队列/" itemprop="url">数据结构-栈、队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:27:56+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(LIFO, Last In First Out)</p>
<h3 id="静态栈"><a href="#静态栈" class="headerlink" title="静态栈"></a>静态栈</h3><p>数组 栈大小固定</p>
<h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>链表 栈大小不固定</p>
<pre><code>public class Node {

    //数据域
    public int data;

    //指针域，指向下一个节点
    public Node next;

    public Node() {
    }

    public Node(int data) {
        this.data = data;
    }

    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

}

public class Stack {

    public Node stackTop;//栈顶
    public Node stackBottom;//栈底

    public Stack(Node stackTop, Node stackBottom) {
        this.stackTop = stackTop;
        this.stackBottom = stackBottom;
    }

    public Stack() {
    }


}

/**
 * 进栈
 *
 * @param stack 栈
 * @param value 要进栈的元素
 */
public static void pushStack(Stack stack, int value) {

    // 封装数据成节点
    Node newNode = new Node(value);


    // 栈顶本来指向的节点交由新节点来指向
    newNode.next = stack.stackTop;

    // 栈顶指针指向新节点
    stack.stackTop = newNode;

}


/**
 * 遍历栈(只要栈顶指针不指向栈底指针，就一直输出)
 *
 * @param stack
 */
public static void traverse(Stack stack) {
    Node stackTop = stack.stackTop;

    while (stackTop != stack.stackBottom) {

        System.out.println(&quot;关注公众号：Java3y：&quot; + stackTop.data);

        stackTop = stackTop.next;
    }


}

/**
 * 判断该栈是否为空
 *
 * @param stack
 */
public static void isEmpty(Stack stack) {
    if (stack.stackTop == stack.stackBottom) {

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈为空&quot;);
    } else {

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈不为空&quot;);

    }

}

/**
 * 出栈(将栈顶的指针指向下一个节点)
 * @param stack
 */
public static void popStack(Stack stack) {

    // 栈不为空才能出栈
    if (!isEmpty(stack)) {

        //栈顶元素
        Node top = stack.stackTop;

        // 栈顶指针指向下一个节点
        stack.stackTop = top.next;

        System.out.println(&quot;关注公众号：Java3y----&gt;出栈的元素是：&quot; + top.data);

    }
}

/**
 * 清空栈
 * @param stack
 */
public static void clearStack(Stack stack) {

    stack.stackTop = null;
    stack.stackBottom = stack.stackTop;
}
</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(LILO, Last In Last Out)</p>
<h3 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h3><p>数组实现循环队列，节省内存资源</p>
<pre><code>public class Queue {


    //数组
    public int [] arrays;

    //指向第一个有效的元素
    public int front = 0;

    //指向有效数据的下一个元素(即指向无效的数据)
    public int rear = 0;

}


/**
 * 入队
 *
 * @param queue
 */
public static void enQueue(Queue queue,int value) {

    // 不是满的队列才能入队
    if (!isFull(queue)) {

        // 将新的元素插入到队尾中
        queue.arrays[queue.rear] = value;

        // rear节点移动到新的无效元素位置上
        queue.rear = (queue.rear + 1) % queue.arrays.length;
    }
}

/**
 * 出队
 *
 * @param queue
 */
public static void outQueue(Queue queue) {

    //判断该队列是否为null
    if (!isEmpty(queue)) {


        //不为空才出队
        int value = queue.arrays[queue.front];
        System.out.println(&quot;关注公众号：Java3y---&gt;出队的元素是：&quot; + value);

        // front指针往后面移
        queue.front = (queue.front + 1) % queue.arrays.length;

    }


}

/**
 * 判断队列是否空，front和rear指针相等，就是空了
 * @param queue
 * @return
 */
public static boolean isEmpty(Queue queue) {
    if (queue.rear  == queue.front) {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列空的！&quot;);
        return true;
    } else {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列非空！&quot;);
        return false;
    }
}

/**
 * 判断队列是否满了，front和rear指针紧挨着，就是满了
 * @param queue
 * @return
 */
public static boolean isFull(Queue queue) {
    if ((queue.rear + 1) % queue.arrays.length == queue.front) {

        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列满了！&quot;);
        return true;
    } else {
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列没满了！&quot;);
        return false;
    }
}

/**
 * 遍历队列
 * @param queue
 *
 */
public static void traverseQueue(Queue queue) {

    // front的位置
    int i = queue.front;

    while (i != queue.rear) {

        System.out.println(&quot;关注公众号：Java3y---&gt;&quot; + queue.arrays[i]);

        //移动front
        i = (i + 1) % queue.arrays.length;
    }

}
</code></pre><h3 id="动态队列"><a href="#动态队列" class="headerlink" title="动态队列"></a>动态队列</h3><p>链表实现</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/数据结构-线性表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/数据结构-线性表/" itemprop="url">数据结构-线性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T12:18:54+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>开始节点--&gt;  数据元素 ... --&gt; 终端节点</code></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>clear、isEmpty、length、get、insert、remove、indexOf</p>
<pre><code>public interface IList {
    // 线性表置空操作
    public void clear();

    // 判断线性表是否为空操作
    public boolean isEmpty();

    // 获取线性表中元素的长度操作
    public int length();

    // 获取指定位置上面的元素操作
    public Object get(int i);

    // 在指定位置上面插入元素的操作
    public void insert(int i, Object x);

    // 删除指定位置上面的元素的操作
    public void remove(int i);

    // 查找指定元素的位置首次出现的位置操作
    public int indexOf(Object x);

    // 显示线性表中的内容操作
    public void display();
}
</code></pre><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序存储， 逻辑上相邻的数据元素，在物理存储上也是相邻的。 不便于插入和删除</p>
<pre><code>public class SqList implements IList {
    // 线性表存储空间
    private Object[] listElem;
    // 线性表的当前长度
    private int curLen;

    // 顺序表类的构造函数，构造一个存储空间容量为maxSize的线性表
    public SqList(int maxSize) {
        // TODO Auto-generated constructor stub
        curLen = 0;
        listElem = new Object[maxSize];
    }

    // 将一个已经存在的线性表置成空表
    public void clear() {
        // TODO Auto-generated method stub
        // 置顺序表的当前长度为0
        curLen = 0;
    }

    // 判断线性表中的数据元素的个数是否为0，若为0则返回true，否则返回false
    public boolean isEmpty() {
        // TODO Auto-generated method stub
        return curLen == 0;
    }

    // 求线性表中的数据元素的个数并返回其值
    public int length() {
        // TODO Auto-generated method stub
        // 返回顺序表的当前长度
        return curLen;
    }

    // 读取到线性表中的第i个数据元素并由函数返回其值，其中i的取值范围为0≤i≤length()-1，若i不在此范围则抛出异常
    public Object get(int i) {
        // TODO Auto-generated method stub
        if (i &lt; 0 || i &gt;= curLen) {
            throw new RuntimeException(&quot;第&quot; + i + &quot;个元素不存在&quot;);
        }
        return listElem[i];
    }

    // 在线性表的第i个数据元素之前插入一个值位x的数据元素
    public void insert(int i, Object x) {
        // TODO Auto-generated method stub
        // 判断表是否满了
        if (curLen == listElem.length) {
            throw new RuntimeException(&quot;存储空间已经满了，无法插入新的元素&quot;);
        }
        // 插入的位置不合法
        if (i &lt; 0 || i &gt; curLen) {
            throw new RuntimeException(&quot;插入的位置不合法&quot;);
        }
        // 必须要从最后一个元素开始依次逐个后移动，直到第i个数据元素移动完毕为止。
        for (int j = curLen; j &gt; i; j--) {
            listElem[j] = listElem[j - 1];
        }
        listElem[i] = x;
        curLen++;
    }

    public void remove(int i) {
        // TODO Auto-generated method stub
        if (i &lt; 0 || i &gt; curLen - 1) {
            throw new RuntimeException(&quot;删除的位置不合法&quot;);
        }
        for (int j = i; j &lt; curLen; j++) {
            listElem[j] = listElem[j+1];
        }
        curLen--;
    }

    // 返回线性表中首次出现指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1
    public int indexOf(Object x) {
        // TODO Auto-generated method stub
        for (int i = 0; i &lt; curLen; i++) {
            if (listElem[i].equals(x)) {
                return i;
            }
        }
        return -1;
    }

    // 输出线性表中的数据元素
    public void display() {
        // TODO Auto-generated method stub
        for (int i = 0; i &lt; curLen; i++) {
            System.out.print(listElem[i] + &quot; &quot;);
        }
        System.out.println();
    }

    // 测试
    public static void main(String[] args) {
        SqList sqList = new SqList(10);
        sqList.insert(0, &quot;a&quot;);
        sqList.insert(1, &quot;z&quot;);
        sqList.insert(2, &quot;d&quot;);
        sqList.insert(3, &quot;m&quot;);
        sqList.insert(4, &quot;z&quot;);
        int order = sqList.indexOf(&quot;z&quot;);
        if (order!=-1) {
            System.out.println(&quot;顺序表中第一次出现的值为z的数据元素的位置为：&quot;+order);
        }else {
            System.out.println(&quot;顺序表中不包括z元素&quot;);
        }
    }
}
</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式存储，单向链表，节点保存下一个节点的引用，便于插入和删除</p>
<pre><code>public class Node {
    // 存放结点的值
    private Object data;
    // 后继结点的引用
    private Node next;

    // 无参数时的构造函数
    public Node() {
        // TODO Auto-generated constructor stub
        this(null, null);
    }

    // 带有一个参数时的构造函数
    public Node(Object data) {
        this(data, null);
    }

    // 带有两个参数时的构造函数
    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/31/算法-兔子数列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/算法-兔子数列/" itemprop="url">兔子数列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T11:53:36+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自然界现象抽象化得到的数列模型——斐波那契数列</p>
<ol>
<li>初始状态：一对刚出生的兔子</li>
<li>下一步：生长</li>
<li><figure class="highlight plain"><figcaption><span>一对刚出生的兔子-> 第1步```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">总结： 当月的兔子数=上月兔子数+当月新生兔子  数列的当前列=前两列之和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 递归算法</span><br><span class="line"></span><br><span class="line">指数阶算法，效率较低，时间复杂度爆炸增量</span><br><span class="line"></span><br><span class="line">        Fib1(int n)</span><br><span class="line">        </span><br><span class="line">        &#123; if(n&lt;1)</span><br><span class="line">        </span><br><span class="line">               return -1;</span><br><span class="line">        </span><br><span class="line">          if(n==1||n==2)</span><br><span class="line">        </span><br><span class="line">                return 1;</span><br><span class="line">        </span><br><span class="line">           return Fib1(n-1)+Fib1(n-2);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">## 数组记录先两项值</span><br><span class="line"></span><br><span class="line">时间复杂度从指数阶降到了多项式阶O(n),空间复杂度O(n)</span><br><span class="line"></span><br><span class="line">    Fib2(intn)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;1)</span><br><span class="line">            return-1;</span><br><span class="line">        int[] a=new int[n];</span><br><span class="line">        a[1]=1;</span><br><span class="line">        a[2]=1;</span><br><span class="line">        for(int i=3;i&lt;=n;i++)</span><br><span class="line">            a[i]=a[i-1]+a[i-2];</span><br><span class="line">            return a[n];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">             </span><br><span class="line">        </span><br><span class="line">## 迭代法</span><br><span class="line"></span><br><span class="line">不记录中间结果，只记录中间项，空间复杂度降到O(1)</span><br><span class="line"></span><br><span class="line">    Fib3(intn)</span><br><span class="line">    &#123;</span><br><span class="line">        inti,s1,s2;</span><br><span class="line">        if(n&lt;1)</span><br><span class="line">            return-1;</span><br><span class="line">        if(n==1||n==2)</span><br><span class="line">            return1;</span><br><span class="line">        s1=1;s2=1;</span><br><span class="line">        for(i=3;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2=s1+s2;//辗转相加法</span><br><span class="line">            s1=s2-s1;//记录前一项</span><br><span class="line">        &#125;</span><br><span class="line">        return s2;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">## 矩阵乘法</span><br><span class="line"></span><br><span class="line">```斐波那契数列(F(n),F(n-1))为(1,1)与&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;的n-2次幂的乘积, 可通过递推求证</span><br></pre></td></tr></table></figure>
<pre><code>public static int ValueN(int n){
      if(n&lt;1){
          return 0;
      }
      if(n==1 || n==2){
          return 1;
      }
       int [][] base={{1,1},{1,0}};
       int [][] res=matrixPower(base,n-2);
       return res[0][0]+res[1][0];
    }
    public static int[][] matrixPower(int[][] m,int p){
        if(p==0)
            return null;
        if(p==1)
            return m;
        int[][] res=matrixPower(m,p&gt;&gt;1);
        res=muliMatrix(res,res);
        if((p&amp;1)==1){
            res=muliMatrix(res,m);
        }
        return res;
    }
    //求两个矩阵相乘得到一个新的矩阵
    public static int[][] muliMatrix(int[][] m1,int[][] m2){
        int [][] res=new int[m1.length][m2[0].length];
        for(int i=0;i&lt;m1.length;i++){
            for(int j=0;j&lt;m2[0].length;j++){
                for(int k=0;k&lt;m2.length;k++){
                    res[i][j]+=m1[i][k]*m2[k][j];
                }
            }
        }
        return res;
    }
}
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/22/算法-遗传算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/算法-遗传算法/" itemprop="url">遗传算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T11:25:04+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>遗传算法（Genetic Algorithms ）是基于生物进化理论的原理发展起来的一种广为应用的、高效的随机搜索与优化的方法。其主要特点是群体搜索策略和群体中个体之间的信息交换，搜索不依赖于梯度信息。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>初始化 t←0进化代数计数器；T是最大进化代数；随机生成M个个体作为初始群体P（t）</li>
<li>个体评价 计算P（t）中各个个体的适应度；</li>
<li>选择运算 将选择算子作用于群体；</li>
<li>交叉运算 将交叉算子作用于群体；</li>
<li>变异运算 将变异算子作用于群体，并通过以上运算得到下一代群体P（t + 1）;</li>
<li>终止条件判断  t≦T：t← t+1 转到步骤2；t&gt;T：终止 输出解。</li>
</ol>
<h2 id="模型构成"><a href="#模型构成" class="headerlink" title="模型构成"></a>模型构成</h2><ol>
<li>决策变量及各种约束条件，即个体的表现型X和问题的解空间</li>
<li>目标函数最大OR 最小， 数学描述形式 量化方法</li>
<li>染色体编码方法 （二进制、整数、浮点数）</li>
<li>解码方法</li>
<li>个体适应度的量化评价方法 F(x)  （旅行商问题及最短路径）</li>
<li>设计遗传算子</li>
<li>有关运行参数</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>局部收敛</li>
<li>全局搜索能力不够强</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li>交叉算子</li>
<li>变异算子</li>
<li>选择策略</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;  

import java.io.BufferedReader;  
import java.io.FileInputStream;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.Random;  

public class GA {  

    private int scale;// 种群规模  
    private int cityNum; // 城市数量，染色体长度  
    private int MAX_GEN; // 运行代数  
    private int[][] distance; // 距离矩阵  
    private int bestT;// 最佳出现代数  
    private int bestLength; // 最佳长度  
    private int[] bestTour; // 最佳路径  

    // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段  
    private int[][] oldPopulation;  
    private int[][] newPopulation;// 新的种群，子代种群  
    private int[] fitness;// 种群适应度，表示种群中各个个体的适应度  

    private float[] Pi;// 种群中各个个体的累计概率  
    private float Pc;// 交叉概率  
    private float Pm;// 变异概率  
    private int t;// 当前代数  

    private Random random;  

    public GA() {  

    }  

    /** 
     * constructor of GA 
     *  
     * @param s 
     *            种群规模 
     * @param n 
     *            城市数量 
     * @param g 
     *            运行代数 
     * @param c 
     *            交叉率 
     * @param m 
     *            变异率 
     *  
     **/  
    public GA(int s, int n, int g, float c, float m) {  
        scale = s;  
        cityNum = n;  
        MAX_GEN = g;  
        Pc = c;  
        Pm = m;  
    }  

    // 给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默  
    @SuppressWarnings(&quot;resource&quot;)  
    /** 
     * 初始化GA算法类 
     * @param filename 数据文件名，该文件存储所有城市节点坐标数据 
     * @throws IOException 
     */  
    private void init(String filename) throws IOException {  
        // 读取数据  
        int[] x;  
        int[] y;  
        String strbuff;  
        BufferedReader data = new BufferedReader(new InputStreamReader(  
                new FileInputStream(filename)));  
        distance = new int[cityNum][cityNum];  
        x = new int[cityNum];  
        y = new int[cityNum];  
        for (int i = 0; i &lt; cityNum; i++) {  
            // 读取一行数据，数据格式1 6734 1453  
            strbuff = data.readLine();  
            // 字符分割  
            String[] strcol = strbuff.split(&quot; &quot;);  
            x[i] = Integer.valueOf(strcol[1]);// x坐标  
            y[i] = Integer.valueOf(strcol[2]);// y坐标  
        }  
        // 计算距离矩阵  
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628  
        for (int i = 0; i &lt; cityNum - 1; i++) {  
            distance[i][i] = 0; // 对角线为0  
            for (int j = i + 1; j &lt; cityNum; j++) {  
                double rij = Math  
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])  
                                * (y[i] - y[j])) / 10.0);  
                // 四舍五入，取整  
                int tij = (int) Math.round(rij);  
                if (tij &lt; rij) {  
                    distance[i][j] = tij + 1;  
                    distance[j][i] = distance[i][j];  
                } else {  
                    distance[i][j] = tij;  
                    distance[j][i] = distance[i][j];  
                }  
            }  
        }  
        distance[cityNum - 1][cityNum - 1] = 0;  

        bestLength = Integer.MAX_VALUE;  
        bestTour = new int[cityNum + 1];  
        bestT = 0;  
        t = 0;  

        newPopulation = new int[scale][cityNum];  
        oldPopulation = new int[scale][cityNum];  
        fitness = new int[scale];  
        Pi = new float[scale];  

        random = new Random(System.currentTimeMillis());  
        /* 
         * for(int i=0;i&lt;cityNum;i++) { for(int j=0;j&lt;cityNum;j++) { 
         * System.out.print(distance[i][j]+&quot;,&quot;); } System.out.println(); } 
         */  
        // 初始化种群  

    }  

    // 初始化种群  
    void initGroup() {  
        int i, j, k;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 0; k &lt; scale; k++)// 种群数  
        {  
            oldPopulation[k][0] = random.nextInt(65535) % cityNum;  
            for (i = 1; i &lt; cityNum;)// 染色体长度  
            {  
                oldPopulation[k][i] = random.nextInt(65535) % cityNum;  
                for (j = 0; j &lt; i; j++) {  
                    if (oldPopulation[k][i] == oldPopulation[k][j]) {  
                        break;  
                    }  
                }  
                if (j == i) {  
                    i++;  
                }  
            }  
        }  

        /* 
         * for(i=0;i&lt;scale;i++) { for(j=0;j&lt;cityNum;j++) { 
         * System.out.print(oldPopulation[i][j]+&quot;,&quot;); } System.out.println(); } 
         */  
    }  

    public int evaluate(int[] chromosome) {  
        // 0123  
        int len = 0;  
        // 染色体，起始城市,城市1,城市2...城市n  
        for (int i = 1; i &lt; cityNum; i++) {  
            len += distance[chromosome[i - 1]][chromosome[i]];  
        }  
        // 城市n,起始城市  
        len += distance[chromosome[cityNum - 1]][chromosome[0]];  
        return len;  
    }  

    // 计算种群中各个个体的累积概率，前提是已经计算出各个个体的适应度fitness[max]，作为赌轮选择策略一部分，Pi[max]  
    void countRate() {  
        int k;  
        double sumFitness = 0;// 适应度总和  

        double[] tempf = new double[scale];  

        for (k = 0; k &lt; scale; k++) {  
            tempf[k] = 10.0 / fitness[k];  
            sumFitness += tempf[k];  
        }  

        Pi[0] = (float) (tempf[0] / sumFitness);  
        for (k = 1; k &lt; scale; k++) {  
            Pi[k] = (float) (tempf[k] / sumFitness + Pi[k - 1]);  
        }  

        /* 
         * for(k=0;k&lt;scale;k++) { System.out.println(fitness[k]+&quot; &quot;+Pi[k]); } 
         */  
    }  

    // 挑选某代种群中适应度最高的个体，直接复制到子代中  
    // 前提是已经计算出各个个体的适应度Fitness[max]  
    public void selectBestGh() {  
        int k, i, maxid;  
        int maxevaluation;  

        maxid = 0;  
        maxevaluation = fitness[0];  
        for (k = 1; k &lt; scale; k++) {  
            if (maxevaluation &gt; fitness[k]) {  
                maxevaluation = fitness[k];  
                maxid = k;  
            }  
        }  

        if (bestLength &gt; maxevaluation) {  
            bestLength = maxevaluation;  
            bestT = t;// 最好的染色体出现的代数;  
            for (i = 0; i &lt; cityNum; i++) {  
                bestTour[i] = oldPopulation[maxid][i];  
            }  
        }  

        // System.out.println(&quot;代数 &quot; + t + &quot; &quot; + maxevaluation);  
        // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
        copyGh(0, maxid);// 将当代种群中适应度最高的染色体k复制到新种群中，排在第一位0  
    }  

    // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
    public void copyGh(int k, int kk) {  
        int i;  
        for (i = 0; i &lt; cityNum; i++) {  
            newPopulation[k][i] = oldPopulation[kk][i];  
        }  
    }  

    // 赌轮选择策略挑选  
    public void select() {  
        int k, i, selectId;  
        float ran1;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 1; k &lt; scale; k++) {  
            ran1 = (float) (random.nextInt(65535) % 1000 / 1000.0);  
            // System.out.println(&quot;概率&quot;+ran1);  
            // 产生方式  
            for (i = 0; i &lt; scale; i++) {  
                if (ran1 &lt;= Pi[i]) {  
                    break;  
                }  
            }  
            selectId = i;  
            // System.out.println(&quot;选中&quot; + selectId);  
            copyGh(k, selectId);  
        }  
    }  

    //进化函数，正常交叉变异  
    public void evolution() {  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  

        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  

        // Random random = new Random(System.currentTimeMillis());  
        float r;  

        // 交叉方法  
        for (k = 0; k &lt; scale; k = k + 2) {  
            r = random.nextFloat();// /产生概率  
            // System.out.println(&quot;交叉率...&quot; + r);  
            if (r &lt; Pc) {  
                // System.out.println(k + &quot;与&quot; + k + 1 + &quot;进行交叉...&quot;);  
                //OXCross(k, k + 1);// 进行交叉  
                OXCross1(k, k + 1);  
            } else {  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率1...&quot; + r);  
                // 变异  
                if (r &lt; Pm) {  
                    // System.out.println(k + &quot;变异...&quot;);  
                    OnCVariation(k);  
                }  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率2...&quot; + r);  
                // 变异  
                if (r &lt; Pm) {  
                    // System.out.println(k + 1 + &quot;变异...&quot;);  
                    OnCVariation(k + 1);  
                }  
            }  

        }  
    }  

    //进化函数，保留最好染色体不进行交叉变异  
    public void evolution1() {  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  

        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  

        // Random random = new Random(System.currentTimeMillis());  
        float r;  

        for (k = 1; k + 1 &lt; scale / 2; k = k + 2) {  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pc) {  
                OXCross1(k, k + 1);// 进行交叉  
                //OXCross(k,k+1);//进行交叉  
            } else {  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) {  
                    OnCVariation(k);  
                }  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) {  
                    OnCVariation(k + 1);  
                }  
            }  
        }  
        if (k == scale / 2 - 1)// 剩最后一个染色体没有交叉L-1  
        {  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pm) {  
                OnCVariation(k);  
            }  
        }  

    }  

    // 类OX交叉算子  
    void OXCross(int k1, int k2) {  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  

        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  

        while (ran1 == ran2) {  
            ran2 = random.nextInt(65535) % cityNum;  
        }  

        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        {  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        }  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println();  
        flag = ran2 - ran1 + 1;// 删除重复基因前染色体长度  
        for (i = 0, j = ran1; i &lt; flag; i++, j++) {  
            Gh1[i] = newPopulation[k2][j];  
            Gh2[i] = newPopulation[k1][j];  
        }  
        // 已近赋值i=ran2-ran1个基因  

        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        {  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) {  
                if (Gh1[i] == Gh1[j]) {  
                    break;  
                }  
            }  
            if (i == flag) {  
                j++;  
            }  
        }  

        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        {  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) {  
                if (Gh2[i] == Gh2[j]) {  
                    break;  
                }  
            }  
            if (i == flag) {  
                j++;  
            }  
        }  

        for (i = 0; i &lt; cityNum; i++) {  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        }  

        // System.out.println(&quot;进行交叉--------------------------&quot;);  
        // System.out.println(k1+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) {  
        // System.out.print(newPopulation[k1][i] + &quot;-&quot;);  
        // }  
        // System.out.println();  
        // System.out.println(k2+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) {  
        // System.out.print(newPopulation[k2][i] + &quot;-&quot;);  
        // }  
        // System.out.println();  
        // System.out.println(&quot;交叉完毕--------------------------&quot;);  
    }  

    // 交叉算子,相同染色体交叉产生不同子代染色体  
    public void OXCross1(int k1, int k2) {  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  

        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        while (ran1 == ran2) {  
            ran2 = random.nextInt(65535) % cityNum;  
        }  

        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        {  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        }  

        // 将染色体1中的第三部分移到染色体2的首部  
        for (i = 0, j = ran2; j &lt; cityNum; i++, j++) {  
            Gh2[i] = newPopulation[k1][j];  
        }  

        flag = i;// 染色体2原基因开始位置  

        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        {  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) {  
                if (Gh2[i] == Gh2[j]) {  
                    break;  
                }  
            }  
            if (i == flag) {  
                j++;  
            }  
        }  

        flag = ran1;  
        for (k = 0, j = 0; k &lt; cityNum;)// 染色体长度  
        {  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) {  
                if (newPopulation[k2][i] == Gh1[j]) {  
                    break;  
                }  
            }  
            if (i == flag) {  
                j++;  
            }  
        }  

        flag = cityNum - ran1;  

        for (i = 0, j = flag; j &lt; cityNum; j++, i++) {  
            Gh1[j] = newPopulation[k2][i];  
        }  

        for (i = 0; i &lt; cityNum; i++) {  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        }  
    }  

    // 多次对换变异算子  
    public void OnCVariation(int k) {  
        int ran1, ran2, temp;  
        int count;// 对换次数  

        // Random random = new Random(System.currentTimeMillis());  
        count = random.nextInt(65535) % cityNum;  

        for (int i = 0; i &lt; count; i++) {  

            ran1 = random.nextInt(65535) % cityNum;  
            ran2 = random.nextInt(65535) % cityNum;  
            while (ran1 == ran2) {  
                ran2 = random.nextInt(65535) % cityNum;  
            }  
            temp = newPopulation[k][ran1];  
            newPopulation[k][ran1] = newPopulation[k][ran2];  
            newPopulation[k][ran2] = temp;  
        }  

        /* 
         * for(i=0;i&lt;L;i++) { printf(&quot;%d &quot;,newGroup[k][i]); } printf(&quot;\n&quot;); 
         */  
    }  

    public void solve() {  
        int i;  
        int k;  

        // 初始化种群  
        initGroup();  
        // 计算初始化种群适应度，Fitness[max]  
        for (k = 0; k &lt; scale; k++) {  
            fitness[k] = evaluate(oldPopulation[k]);  
            // System.out.println(fitness[k]);  
        }  
        // 计算初始化种群中各个个体的累积概率，Pi[max]  
        countRate();  
        System.out.println(&quot;初始种群...&quot;);  
        for (k = 0; k &lt; scale; k++) {  
            for (i = 0; i &lt; cityNum; i++) {  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            }  
            System.out.println();  
            System.out.println(&quot;----&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        }  

        for (t = 0; t &lt; MAX_GEN; t++) {  
            //evolution1();  
            evolution();  
            // 将新种群newGroup复制到旧种群oldGroup中，准备下一代进化  
            for (k = 0; k &lt; scale; k++) {  
                for (i = 0; i &lt; cityNum; i++) {  
                    oldPopulation[k][i] = newPopulation[k][i];  
                }  
            }  
            // 计算种群适应度  
            for (k = 0; k &lt; scale; k++) {  
                fitness[k] = evaluate(oldPopulation[k]);  
            }  
            // 计算种群中各个个体的累积概率  
            countRate();  
        }  

        System.out.println(&quot;最后种群...&quot;);  
        for (k = 0; k &lt; scale; k++) {  
            for (i = 0; i &lt; cityNum; i++) {  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            }  
            System.out.println();  
            System.out.println(&quot;---&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        }  

        System.out.println(&quot;最佳长度出现代数：&quot;);  
        System.out.println(bestT);  
        System.out.println(&quot;最佳长度&quot;);  
        System.out.println(bestLength);  
        System.out.println(&quot;最佳路径：&quot;);  
        for (i = 0; i &lt; cityNum; i++) {  
            System.out.print(bestTour[i] + &quot;,&quot;);  
        }  

    }  


    /** 
     * @param args 
     * @throws IOException 
     */  
    public static void main(String[] args) throws IOException {  
        System.out.println(&quot;Start....&quot;);  
        GA ga = new GA(30, 48, 1000, 0.8f, 0.9f);  
        ga.init(&quot;c://data.txt&quot;);  
        ga.solve();  
    }  

}
</code></pre><p>参考：<a href="https://blog.csdn.net/tyhj_sf/article/details/53321527" target="_blank" rel="noopener">https://blog.csdn.net/tyhj_sf/article/details/53321527</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/22/算法-贪心算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/算法-贪心算法/" itemprop="url">贪心算法-旅行商问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T11:06:00+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？</p>
<p>还有 背包、装箱 问题</p>
<p>注： 递归，时间复杂度为n!</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在对问题求解时，总是做出当前情况下的最好选择，否则将来可能会后悔，故名“贪心”。这是一种算法策略，每次选择得到的都是局部最优解。选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p>
<p>求解的问题分成若干个子问题，每一个子问题求解，得到子问题的局部最优解，子问题的局部最优解合成原问题的一个解</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>从某一个城市开始，每次选择一个城市，直到所有的城市被走完。 </li>
<li><p>每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<pre><code>从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    { 
          利用可行的决策，求出可行解的一个解元素；
    }
由所有解元素组合成问题的一个可行解
</code></pre></li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不能保证最终为最优解</li>
<li>不能用来求最大最小解问题</li>
<li>无后效性</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class TxTsp {

    private int cityNum; // 城市数量
    private int[][] distance; // 距离矩阵

    private int[] colable;//代表列，也表示是否走过，走过置0
    private int[] row;//代表行，选过置0

    public TxTsp(int n) {
        cityNum = n;
    }

    private void init(String filename) throws IOException {
        // 读取数据
        int[] x;
        int[] y;
        String strbuff;
        BufferedReader data = new BufferedReader(new InputStreamReader(
                new FileInputStream(filename)));
        distance = new int[cityNum][cityNum];
        x = new int[cityNum];
        y = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            // 读取一行数据，数据格式1 6734 1453
            strbuff = data.readLine();
            // 字符分割
            String[] strcol = strbuff.split(&quot; &quot;);
            x[i] = Integer.valueOf(strcol[1]);// x坐标
            y[i] = Integer.valueOf(strcol[2]);// y坐标
        }
        data.close();

        // 计算距离矩阵
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628
        for (int i = 0; i &lt; cityNum - 1; i++) {
            distance[i][i] = 0; // 对角线为0
            for (int j = i + 1; j &lt; cityNum; j++) {
                double rij = Math
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])
                                * (y[i] - y[j])) / 10.0);
                // 四舍五入，取整
                int tij = (int) Math.round(rij);
                if (tij &lt; rij) {
                    distance[i][j] = tij + 1;
                    distance[j][i] = distance[i][j];
                } else {
                    distance[i][j] = tij;
                    distance[j][i] = distance[i][j];
                }
            }
        }

        distance[cityNum - 1][cityNum - 1] = 0;

        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) {
            colable[i] = 1;
        }

        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            row[i] = 1;
        }

    }

    public void solve(){

        int[] temp = new int[cityNum];
        String path=&quot;0&quot;;

        int s=0;//计算距离
        int i=0;//当前节点
        int j=0;//下一个节点
        //默认从0开始
        while(row[i]==1){
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) {
                temp[k] = distance[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            }
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过

            path+=&quot;--&gt;&quot; + j;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            s = s + distance[i][j];
            i = j;//当前节点指向下一节点
        }
        System.out.println(&quot;路径:&quot; + path);
        System.out.println(&quot;总距离为:&quot; + s);

    }

    public int selectmin(int[] p){
        int j = 0, m = p[0], k = 0;
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) {
            j++;
            //System.out.print(j+&quot; &quot;);
            if(j&gt;=cityNum){
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            }
            else{
                m = p[j];
            }
        }
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) {
            if (colable[j] == 1) {
                if (m &gt;= p[j]) {
                    m = p[j];
                    k = j;
                }
            }
        }
        return k;
    }


    public void printinit() {
        System.out.println(&quot;print begin....&quot;);
        for (int i = 0; i &lt; cityNum; i++) {
            for (int j = 0; j &lt; cityNum; j++) {
                System.out.print(distance[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
        System.out.println(&quot;print end....&quot;);
    }

    public static void main(String[] args) throws IOException {
        System.out.println(&quot;Start....&quot;);
        TxTsp ts = new TxTsp(48);
        ts.init(&quot;c://data.txt&quot;);
        //ts.printinit();
        ts.solve();
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/21/设计模式-原型模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/设计模式-原型模式/" itemprop="url">设计模式-原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:58:50+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用原型对象的方法创建对象的实列，创建的实例equals原型</p>
<p>final 类型修饰的成员变量不能进行深度拷贝</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等</li>
<li>构造对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>工厂模式中使用</li>
<li>共有信息很多</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对象内引用原先原型的对象</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对象内引用也拷贝一份</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package prototype;

//Cloneable 标记对象可拷贝
public class PersonClone implements Cloneable {

    @Override //Override Object方法
    public PersonClone clone(){
        try {
            //clone 不会调用构造方法
            return (PersonClone)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }
}


package prototype;

public class MainClass {
    public static void main(String[] args) {
        PersonClone personClone = new PersonClone();
        PersonClone clone = personClone.clone();
        System.out.println(personClone.hashCode());
        System.out.println(clone.hashCode());
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/21/设计模式-模板方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/设计模式-模板方法/" itemprop="url">设计模式-模板方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T09:57:39+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>流程相同，执行过程中有差别</p>
<p>可用于定义算法骨架，将一些实现放到子类中实现，达到不用改变算法结构，重新实现算法的目的</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package template;

public abstract class Model {
    /**
     * 类似的行为、逻辑
     */
    protected abstract void start();

    protected abstract void stop();

    /**
     * 固定的流程  模板化
     */
    final public void excet(){
        this.start();
        this.stop();
    }
}

package template;

public class Ocar extends Model {
    @Override
    protected void start() {

    }

    @Override
    protected void stop() {

    }
}

package template;

public class Wcar extends Model {
    @Override
    protected void start() {

    }

    @Override
    protected void stop() {

    }
}

package template;

public class Client {
    public static void main(String[] args) {
        Model wcar=new Wcar();
        wcar.excet();

        Model ocar=new Ocar();
        ocar.excet();
    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/19/JAVA-rbac权限管理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/JAVA-rbac权限管理/" itemprop="url">JAVA-rbac权限管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T14:30:37+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RBAC : 基于角色的权限访问控制（Role-Based Access Control）通过角色绑定权限，然后给用户划分角色。在web应用中，可以将权限理解为url，一个权限对应一个url。</p>
<h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><p>用户，角色，权限，权限组，菜单</p>
<p>用户和角色，多对多<br>角色和权限，多对多<br>权限和权限组，多对一<br>权限组和菜单，多对一<br>菜单和菜单，自引用</p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>用户登录后，取出其权限及所属菜单信息，写入session中</p>
<p>自定义中间件，检查用户权限，进行访问控制</p>
<p>参考：<a href="https://www.jianshu.com/p/f45b54768aa9" target="_blank" rel="noopener">https://www.jianshu.com/p/f45b54768aa9</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Meng Qi</p>
              <p class="site-description motion-element" itemprop="description">recording</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
