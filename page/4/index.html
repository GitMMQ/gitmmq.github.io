<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="recording">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/4/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="Tech;Data;Vision">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/34642.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/34642.html" class="post-title-link" itemprop="url">遗传算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-28 14:40:46" itemprop="dateModified" datetime="2022-12-28T14:40:46+08:00">2022-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>遗传算法（Genetic Algorithms ）是基于生物进化理论的原理发展起来的一种广为应用的、高效的随机搜索与优化的方法。其主要特点是群体搜索策略和群体中个体之间的信息交换，搜索不依赖于梯度信息。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>初始化 t←0进化代数计数器；T是最大进化代数；随机生成M个个体作为初始群体P（t）</li>
<li>个体评价 计算P（t）中各个个体的适应度；</li>
<li>选择运算 将选择算子作用于群体；</li>
<li>交叉运算 将交叉算子作用于群体；</li>
<li>变异运算 将变异算子作用于群体，并通过以上运算得到下一代群体P（t + 1）;</li>
<li>终止条件判断  t≦T：t← t+1 转到步骤2；t&gt;T：终止 输出解。</li>
</ol>
<h2 id="模型构成"><a href="#模型构成" class="headerlink" title="模型构成"></a>模型构成</h2><ol>
<li>决策变量及各种约束条件，即个体的表现型X和问题的解空间</li>
<li>目标函数最大OR 最小， 数学描述形式 量化方法</li>
<li>染色体编码方法 （二进制、整数、浮点数）</li>
<li>解码方法</li>
<li>个体适应度的量化评价方法 F(x)  （旅行商问题及最短路径）</li>
<li>设计遗传算子</li>
<li>有关运行参数</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>局部收敛</li>
<li>全局搜索能力不够强</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li>交叉算子</li>
<li>变异算子</li>
<li>选择策略</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;  
  
import java.io.BufferedReader;  
import java.io.FileInputStream;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.Random;  
  
public class GA &#123;  
  
    private int scale;// 种群规模  
    private int cityNum; // 城市数量，染色体长度  
    private int MAX_GEN; // 运行代数  
    private int[][] distance; // 距离矩阵  
    private int bestT;// 最佳出现代数  
    private int bestLength; // 最佳长度  
    private int[] bestTour; // 最佳路径  
  
    // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段  
    private int[][] oldPopulation;  
    private int[][] newPopulation;// 新的种群，子代种群  
    private int[] fitness;// 种群适应度，表示种群中各个个体的适应度  
  
    private float[] Pi;// 种群中各个个体的累计概率  
    private float Pc;// 交叉概率  
    private float Pm;// 变异概率  
    private int t;// 当前代数  
  
    private Random random;  
  
    public GA() &#123;  
  
    &#125;  
  
    /** 
     * constructor of GA 
     *  
     * @param s 
     *            种群规模 
     * @param n 
     *            城市数量 
     * @param g 
     *            运行代数 
     * @param c 
     *            交叉率 
     * @param m 
     *            变异率 
     *  
     **/  
    public GA(int s, int n, int g, float c, float m) &#123;  
        scale = s;  
        cityNum = n;  
        MAX_GEN = g;  
        Pc = c;  
        Pm = m;  
    &#125;  
  
    // 给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默  
    @SuppressWarnings(&quot;resource&quot;)  
    /** 
     * 初始化GA算法类 
     * @param filename 数据文件名，该文件存储所有城市节点坐标数据 
     * @throws IOException 
     */  
    private void init(String filename) throws IOException &#123;  
        // 读取数据  
        int[] x;  
        int[] y;  
        String strbuff;  
        BufferedReader data = new BufferedReader(new InputStreamReader(  
                new FileInputStream(filename)));  
        distance = new int[cityNum][cityNum];  
        x = new int[cityNum];  
        y = new int[cityNum];  
        for (int i = 0; i &lt; cityNum; i++) &#123;  
            // 读取一行数据，数据格式1 6734 1453  
            strbuff = data.readLine();  
            // 字符分割  
            String[] strcol = strbuff.split(&quot; &quot;);  
            x[i] = Integer.valueOf(strcol[1]);// x坐标  
            y[i] = Integer.valueOf(strcol[2]);// y坐标  
        &#125;  
        // 计算距离矩阵  
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628  
        for (int i = 0; i &lt; cityNum - 1; i++) &#123;  
            distance[i][i] = 0; // 对角线为0  
            for (int j = i + 1; j &lt; cityNum; j++) &#123;  
                double rij = Math  
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])  
                                * (y[i] - y[j])) / 10.0);  
                // 四舍五入，取整  
                int tij = (int) Math.round(rij);  
                if (tij &lt; rij) &#123;  
                    distance[i][j] = tij + 1;  
                    distance[j][i] = distance[i][j];  
                &#125; else &#123;  
                    distance[i][j] = tij;  
                    distance[j][i] = distance[i][j];  
                &#125;  
            &#125;  
        &#125;  
        distance[cityNum - 1][cityNum - 1] = 0;  
  
        bestLength = Integer.MAX_VALUE;  
        bestTour = new int[cityNum + 1];  
        bestT = 0;  
        t = 0;  
  
        newPopulation = new int[scale][cityNum];  
        oldPopulation = new int[scale][cityNum];  
        fitness = new int[scale];  
        Pi = new float[scale];  
  
        random = new Random(System.currentTimeMillis());  
        /* 
         * for(int i=0;i&lt;cityNum;i++) &#123; for(int j=0;j&lt;cityNum;j++) &#123; 
         * System.out.print(distance[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125; 
         */  
        // 初始化种群  
  
    &#125;  
  
    // 初始化种群  
    void initGroup() &#123;  
        int i, j, k;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 0; k &lt; scale; k++)// 种群数  
        &#123;  
            oldPopulation[k][0] = random.nextInt(65535) % cityNum;  
            for (i = 1; i &lt; cityNum;)// 染色体长度  
            &#123;  
                oldPopulation[k][i] = random.nextInt(65535) % cityNum;  
                for (j = 0; j &lt; i; j++) &#123;  
                    if (oldPopulation[k][i] == oldPopulation[k][j]) &#123;  
                        break;  
                    &#125;  
                &#125;  
                if (j == i) &#123;  
                    i++;  
                &#125;  
            &#125;  
        &#125;  
  
        /* 
         * for(i=0;i&lt;scale;i++) &#123; for(j=0;j&lt;cityNum;j++) &#123; 
         * System.out.print(oldPopulation[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125; 
         */  
    &#125;  
  
    public int evaluate(int[] chromosome) &#123;  
        // 0123  
        int len = 0;  
        // 染色体，起始城市,城市1,城市2...城市n  
        for (int i = 1; i &lt; cityNum; i++) &#123;  
            len += distance[chromosome[i - 1]][chromosome[i]];  
        &#125;  
        // 城市n,起始城市  
        len += distance[chromosome[cityNum - 1]][chromosome[0]];  
        return len;  
    &#125;  
  
    // 计算种群中各个个体的累积概率，前提是已经计算出各个个体的适应度fitness[max]，作为赌轮选择策略一部分，Pi[max]  
    void countRate() &#123;  
        int k;  
        double sumFitness = 0;// 适应度总和  
  
        double[] tempf = new double[scale];  
  
        for (k = 0; k &lt; scale; k++) &#123;  
            tempf[k] = 10.0 / fitness[k];  
            sumFitness += tempf[k];  
        &#125;  
  
        Pi[0] = (float) (tempf[0] / sumFitness);  
        for (k = 1; k &lt; scale; k++) &#123;  
            Pi[k] = (float) (tempf[k] / sumFitness + Pi[k - 1]);  
        &#125;  
  
        /* 
         * for(k=0;k&lt;scale;k++) &#123; System.out.println(fitness[k]+&quot; &quot;+Pi[k]); &#125; 
         */  
    &#125;  
  
    // 挑选某代种群中适应度最高的个体，直接复制到子代中  
    // 前提是已经计算出各个个体的适应度Fitness[max]  
    public void selectBestGh() &#123;  
        int k, i, maxid;  
        int maxevaluation;  
  
        maxid = 0;  
        maxevaluation = fitness[0];  
        for (k = 1; k &lt; scale; k++) &#123;  
            if (maxevaluation &gt; fitness[k]) &#123;  
                maxevaluation = fitness[k];  
                maxid = k;  
            &#125;  
        &#125;  
  
        if (bestLength &gt; maxevaluation) &#123;  
            bestLength = maxevaluation;  
            bestT = t;// 最好的染色体出现的代数;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                bestTour[i] = oldPopulation[maxid][i];  
            &#125;  
        &#125;  
  
        // System.out.println(&quot;代数 &quot; + t + &quot; &quot; + maxevaluation);  
        // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
        copyGh(0, maxid);// 将当代种群中适应度最高的染色体k复制到新种群中，排在第一位0  
    &#125;  
  
    // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
    public void copyGh(int k, int kk) &#123;  
        int i;  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k][i] = oldPopulation[kk][i];  
        &#125;  
    &#125;  
  
    // 赌轮选择策略挑选  
    public void select() &#123;  
        int k, i, selectId;  
        float ran1;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 1; k &lt; scale; k++) &#123;  
            ran1 = (float) (random.nextInt(65535) % 1000 / 1000.0);  
            // System.out.println(&quot;概率&quot;+ran1);  
            // 产生方式  
            for (i = 0; i &lt; scale; i++) &#123;  
                if (ran1 &lt;= Pi[i]) &#123;  
                    break;  
                &#125;  
            &#125;  
            selectId = i;  
            // System.out.println(&quot;选中&quot; + selectId);  
            copyGh(k, selectId);  
        &#125;  
    &#125;  
  
    //进化函数，正常交叉变异  
    public void evolution() &#123;  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  
  
        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  
  
        // Random random = new Random(System.currentTimeMillis());  
        float r;  
  
        // 交叉方法  
        for (k = 0; k &lt; scale; k = k + 2) &#123;  
            r = random.nextFloat();// /产生概率  
            // System.out.println(&quot;交叉率...&quot; + r);  
            if (r &lt; Pc) &#123;  
                // System.out.println(k + &quot;与&quot; + k + 1 + &quot;进行交叉...&quot;);  
                //OXCross(k, k + 1);// 进行交叉  
                OXCross1(k, k + 1);  
            &#125; else &#123;  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率1...&quot; + r);  
                // 变异  
                if (r &lt; Pm) &#123;  
                    // System.out.println(k + &quot;变异...&quot;);  
                    OnCVariation(k);  
                &#125;  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率2...&quot; + r);  
                // 变异  
                if (r &lt; Pm) &#123;  
                    // System.out.println(k + 1 + &quot;变异...&quot;);  
                    OnCVariation(k + 1);  
                &#125;  
            &#125;  
  
        &#125;  
    &#125;  
  
    //进化函数，保留最好染色体不进行交叉变异  
    public void evolution1() &#123;  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  
  
        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  
  
        // Random random = new Random(System.currentTimeMillis());  
        float r;  
  
        for (k = 1; k + 1 &lt; scale / 2; k = k + 2) &#123;  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pc) &#123;  
                OXCross1(k, k + 1);// 进行交叉  
                //OXCross(k,k+1);//进行交叉  
            &#125; else &#123;  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) &#123;  
                    OnCVariation(k);  
                &#125;  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) &#123;  
                    OnCVariation(k + 1);  
                &#125;  
            &#125;  
        &#125;  
        if (k == scale / 2 - 1)// 剩最后一个染色体没有交叉L-1  
        &#123;  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pm) &#123;  
                OnCVariation(k);  
            &#125;  
        &#125;  
  
    &#125;  
  
    // 类OX交叉算子  
    void OXCross(int k1, int k2) &#123;  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  
  
        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  
  
        while (ran1 == ran2) &#123;  
            ran2 = random.nextInt(65535) % cityNum;  
        &#125;  
  
        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        &#123;  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        &#125;  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println();  
        flag = ran2 - ran1 + 1;// 删除重复基因前染色体长度  
        for (i = 0, j = ran1; i &lt; flag; i++, j++) &#123;  
            Gh1[i] = newPopulation[k2][j];  
            Gh2[i] = newPopulation[k1][j];  
        &#125;  
        // 已近赋值i=ran2-ran1个基因  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh1[i] == Gh1[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh2[i] == Gh2[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        &#125;  
  
        // System.out.println(&quot;进行交叉--------------------------&quot;);  
        // System.out.println(k1+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) &#123;  
        // System.out.print(newPopulation[k1][i] + &quot;-&quot;);  
        // &#125;  
        // System.out.println();  
        // System.out.println(k2+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) &#123;  
        // System.out.print(newPopulation[k2][i] + &quot;-&quot;);  
        // &#125;  
        // System.out.println();  
        // System.out.println(&quot;交叉完毕--------------------------&quot;);  
    &#125;  
  
    // 交叉算子,相同染色体交叉产生不同子代染色体  
    public void OXCross1(int k1, int k2) &#123;  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  
  
        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        while (ran1 == ran2) &#123;  
            ran2 = random.nextInt(65535) % cityNum;  
        &#125;  
  
        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        &#123;  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        &#125;  
  
        // 将染色体1中的第三部分移到染色体2的首部  
        for (i = 0, j = ran2; j &lt; cityNum; i++, j++) &#123;  
            Gh2[i] = newPopulation[k1][j];  
        &#125;  
  
        flag = i;// 染色体2原基因开始位置  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh2[i] == Gh2[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        flag = ran1;  
        for (k = 0, j = 0; k &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (newPopulation[k2][i] == Gh1[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        flag = cityNum - ran1;  
  
        for (i = 0, j = flag; j &lt; cityNum; j++, i++) &#123;  
            Gh1[j] = newPopulation[k2][i];  
        &#125;  
  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        &#125;  
    &#125;  
  
    // 多次对换变异算子  
    public void OnCVariation(int k) &#123;  
        int ran1, ran2, temp;  
        int count;// 对换次数  
  
        // Random random = new Random(System.currentTimeMillis());  
        count = random.nextInt(65535) % cityNum;  
  
        for (int i = 0; i &lt; count; i++) &#123;  
  
            ran1 = random.nextInt(65535) % cityNum;  
            ran2 = random.nextInt(65535) % cityNum;  
            while (ran1 == ran2) &#123;  
                ran2 = random.nextInt(65535) % cityNum;  
            &#125;  
            temp = newPopulation[k][ran1];  
            newPopulation[k][ran1] = newPopulation[k][ran2];  
            newPopulation[k][ran2] = temp;  
        &#125;  
  
        /* 
         * for(i=0;i&lt;L;i++) &#123; printf(&quot;%d &quot;,newGroup[k][i]); &#125; printf(&quot;\n&quot;); 
         */  
    &#125;  
  
    public void solve() &#123;  
        int i;  
        int k;  
  
        // 初始化种群  
        initGroup();  
        // 计算初始化种群适应度，Fitness[max]  
        for (k = 0; k &lt; scale; k++) &#123;  
            fitness[k] = evaluate(oldPopulation[k]);  
            // System.out.println(fitness[k]);  
        &#125;  
        // 计算初始化种群中各个个体的累积概率，Pi[max]  
        countRate();  
        System.out.println(&quot;初始种群...&quot;);  
        for (k = 0; k &lt; scale; k++) &#123;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            &#125;  
            System.out.println();  
            System.out.println(&quot;----&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        &#125;  
          
        for (t = 0; t &lt; MAX_GEN; t++) &#123;  
            //evolution1();  
            evolution();  
            // 将新种群newGroup复制到旧种群oldGroup中，准备下一代进化  
            for (k = 0; k &lt; scale; k++) &#123;  
                for (i = 0; i &lt; cityNum; i++) &#123;  
                    oldPopulation[k][i] = newPopulation[k][i];  
                &#125;  
            &#125;  
            // 计算种群适应度  
            for (k = 0; k &lt; scale; k++) &#123;  
                fitness[k] = evaluate(oldPopulation[k]);  
            &#125;  
            // 计算种群中各个个体的累积概率  
            countRate();  
        &#125;  
  
        System.out.println(&quot;最后种群...&quot;);  
        for (k = 0; k &lt; scale; k++) &#123;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            &#125;  
            System.out.println();  
            System.out.println(&quot;---&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        &#125;  
  
        System.out.println(&quot;最佳长度出现代数：&quot;);  
        System.out.println(bestT);  
        System.out.println(&quot;最佳长度&quot;);  
        System.out.println(bestLength);  
        System.out.println(&quot;最佳路径：&quot;);  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            System.out.print(bestTour[i] + &quot;,&quot;);  
        &#125;  
  
    &#125;  
  
      
    /** 
     * @param args 
     * @throws IOException 
     */  
    public static void main(String[] args) throws IOException &#123;  
        System.out.println(&quot;Start....&quot;);  
        GA ga = new GA(30, 48, 1000, 0.8f, 0.9f);  
        ga.init(&quot;c://data.txt&quot;);  
        ga.solve();  
    &#125;  
  
&#125;
</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tyhj_sf/article/details/53321527">https://blog.csdn.net/tyhj_sf/article/details/53321527</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/25120.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/25120.html" class="post-title-link" itemprop="url">贪心算法-旅行商问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-28 14:40:43" itemprop="dateModified" datetime="2022-12-28T14:40:43+08:00">2022-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？</p>
<p>还有 背包、装箱 问题</p>
<p>注： 递归，时间复杂度为n!</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在对问题求解时，总是做出当前情况下的最好选择，否则将来可能会后悔，故名“贪心”。这是一种算法策略，每次选择得到的都是局部最优解。选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p>
<p>求解的问题分成若干个子问题，每一个子问题求解，得到子问题的局部最优解，子问题的局部最优解合成原问题的一个解</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>从某一个城市开始，每次选择一个城市，直到所有的城市被走完。 </p>
</li>
<li><p>每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<pre><code> 从问题的某一初始解出发；
     while （能朝给定总目标前进一步）
     &#123; 
           利用可行的决策，求出可行解的一个解元素；
     &#125;
 由所有解元素组合成问题的一个可行解
</code></pre>
</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不能保证最终为最优解</li>
<li>不能用来求最大最小解问题</li>
<li>无后效性</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;
 
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class TxTsp &#123;
 
    private int cityNum; // 城市数量
    private int[][] distance; // 距离矩阵
 
    private int[] colable;//代表列，也表示是否走过，走过置0
    private int[] row;//代表行，选过置0
 
    public TxTsp(int n) &#123;
        cityNum = n;
    &#125;
 
    private void init(String filename) throws IOException &#123;
        // 读取数据
        int[] x;
        int[] y;
        String strbuff;
        BufferedReader data = new BufferedReader(new InputStreamReader(
                new FileInputStream(filename)));
        distance = new int[cityNum][cityNum];
        x = new int[cityNum];
        y = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) &#123;
            // 读取一行数据，数据格式1 6734 1453
            strbuff = data.readLine();
            // 字符分割
            String[] strcol = strbuff.split(&quot; &quot;);
            x[i] = Integer.valueOf(strcol[1]);// x坐标
            y[i] = Integer.valueOf(strcol[2]);// y坐标
        &#125;
        data.close();
 
        // 计算距离矩阵
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628
        for (int i = 0; i &lt; cityNum - 1; i++) &#123;
            distance[i][i] = 0; // 对角线为0
            for (int j = i + 1; j &lt; cityNum; j++) &#123;
                double rij = Math
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])
                                * (y[i] - y[j])) / 10.0);
                // 四舍五入，取整
                int tij = (int) Math.round(rij);
                if (tij &lt; rij) &#123;
                    distance[i][j] = tij + 1;
                    distance[j][i] = distance[i][j];
                &#125; else &#123;
                    distance[i][j] = tij;
                    distance[j][i] = distance[i][j];
                &#125;
            &#125;
        &#125;
 
        distance[cityNum - 1][cityNum - 1] = 0;
 
        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) &#123;
            colable[i] = 1;
        &#125;
 
        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) &#123;
            row[i] = 1;
        &#125;
 
    &#125;
    
    public void solve()&#123;
        
        int[] temp = new int[cityNum];
        String path=&quot;0&quot;;
        
        int s=0;//计算距离
        int i=0;//当前节点
        int j=0;//下一个节点
        //默认从0开始
        while(row[i]==1)&#123;
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) &#123;
                temp[k] = distance[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            &#125;
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过
            
            path+=&quot;--&gt;&quot; + j;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            s = s + distance[i][j];
            i = j;//当前节点指向下一节点
        &#125;
        System.out.println(&quot;路径:&quot; + path);
        System.out.println(&quot;总距离为:&quot; + s);
        
    &#125;
    
    public int selectmin(int[] p)&#123;
        int j = 0, m = p[0], k = 0;
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) &#123;
            j++;
            //System.out.print(j+&quot; &quot;);
            if(j&gt;=cityNum)&#123;
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            &#125;
            else&#123;
                m = p[j];
            &#125;
        &#125;
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) &#123;
            if (colable[j] == 1) &#123;
                if (m &gt;= p[j]) &#123;
                    m = p[j];
                    k = j;
                &#125;
            &#125;
        &#125;
        return k;
    &#125;
 
 
    public void printinit() &#123;
        System.out.println(&quot;print begin....&quot;);
        for (int i = 0; i &lt; cityNum; i++) &#123;
            for (int j = 0; j &lt; cityNum; j++) &#123;
                System.out.print(distance[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        System.out.println(&quot;print end....&quot;);
    &#125;
 
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;Start....&quot;);
        TxTsp ts = new TxTsp(48);
        ts.init(&quot;c://data.txt&quot;);
        //ts.printinit();
        ts.solve();
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/1.html" class="post-title-link" itemprop="url">背包问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:08:07" itemprop="dateModified" datetime="2023-08-10T00:08:07+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>613</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>背包问题是动态规划领域中一个重要且经典的问题，涉及在限定容量的背包中如何选择物品，使得物品的总价值最大化或总重量最小化。主要有两类背包问题：0-1背包问题和完全背包问题。</p>
<ol>
<li><p><strong>0-1背包问题</strong>：每个物品要么被选择一次，要么不选。</p>
</li>
<li><p><strong>完全背包问题</strong>：每个物品可以被选择无限次。</p>
</li>
</ol>
<p>以下是背包问题的一般步骤：</p>
<ol>
<li><p><strong>定义状态</strong>：通常使用一个二维数组 <code>dp[i][j]</code>，其中 <code>dp[i][j]</code> 表示前 <code>i</code> 个物品在背包容量为 <code>j</code> 时的最优解（价值或重量）。</p>
</li>
<li><p><strong>状态转移方程</strong>：对于每个物品，可以选择将其放入背包（如果容量允许），也可以选择不放入。状态转移方程通常为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])</span><br></pre></td></tr></table></figure>

<p>其中 <code>weight[i]</code> 表示第 <code>i</code> 个物品的重量，<code>value[i]</code> 表示第 <code>i</code> 个物品的价值。</p>
</li>
<li><p><strong>边界条件</strong>：初始时，当没有物品可选时，<code>dp[0][j]</code> 都应为 0，当背包容量为 0 时，<code>dp[i][0]</code> 也都为 0。</p>
</li>
<li><p><strong>计算顺序</strong>：通常从小规模问题开始，逐步计算出大规模问题的最优解。</p>
</li>
</ol>
<p>下面是一个0-1背包问题的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span>[] values, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> weights.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KnapsackProblem</span> <span class="variable">knapsackProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KnapsackProblem</span>();</span><br><span class="line">        <span class="type">int</span>[] weights = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> knapsackProblem.knapsack(weights, values, capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum value: &quot;</span> + maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用动态规划解决了0-1背包问题。通过遍历每个物品和背包容量，根据状态转移方程计算在当前情况下的最优解。最终，<code>dp[n][capacity]</code> 就是问题的最优解，表示在前 <code>n</code> 个物品中选择放入容量为 <code>capacity</code> 的背包所能获得的最大价值。</p>
<p>请注意，背包问题的动态规划解法也可能因为问题的具体要求而有所变化，但通常都涵盖了上述的状态定义、状态转移方程和边界条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/37887.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/37887.html" class="post-title-link" itemprop="url">线性dp LIS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:07:39" itemprop="dateModified" datetime="2023-08-10T00:07:39+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>579</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线性动态规划（Linear Dynamic Programming）在许多问题中都有广泛的应用，其中一个典型的问题是最长递增子序列（Longest Increasing Subsequence，简称 LIS）问题。LIS 问题的目标是找到一个给定序列中的最长递增子序列的长度，其中递增子序列指的是序列中的元素按照顺序递增排列。</p>
<p>以下是最长递增子序列问题的一般步骤：</p>
<ol>
<li><p><strong>定义状态</strong>：通常使用一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以第 <code>i</code> 个元素为结尾的最长递增子序列的长度。</p>
</li>
<li><p><strong>状态转移方程</strong>：对于第 <code>i</code> 个元素，我们需要找到前面所有比它小的元素中，以它们为结尾的最长递增子序列的最大长度。状态转移方程可以表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[j] + 1), 其中 0 &lt;= j &lt; i 且 nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure>

<p>这意味着我们在计算 <code>dp[i]</code> 时，会考虑前面所有满足条件的 <code>dp[j]</code> 的最大值加 1。</p>
</li>
<li><p><strong>边界条件</strong>：初始时，每个元素自成一个长度为 1 的递增子序列，所以 <code>dp[i] = 1</code>。</p>
</li>
<li><p><strong>计算顺序</strong>：通常从小规模问题开始，逐步计算出大规模问题的最优解。</p>
</li>
</ol>
<p>下面是一个最长递增子序列问题的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestIncreasingSubsequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len : dp) &#123;</span><br><span class="line">            maxLength = Math.max(maxLength, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongestIncreasingSubsequence</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongestIncreasingSubsequence</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> lis.lengthOfLIS(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length of longest increasing subsequence: &quot;</span> + maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用动态规划解决了最长递增子序列问题。通过遍历每个元素，根据状态转移方程计算以当前元素为结尾的最长递增子序列长度。最终，我们在 <code>dp</code> 数组中找到最大的长度，即为最长递增子序列的长度。</p>
<p>请注意，LIS 问题的动态规划解法可能因为问题的具体要求而有所变化，但通常都涵盖了上述的状态定义、状态转移方程和边界条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/11863.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/11863.html" class="post-title-link" itemprop="url">石子合并问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:07:02" itemprop="dateModified" datetime="2023-08-10T00:07:02+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>642</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>石子合并问题是一个经典的动态规划问题，其目标是找到一种合并方式，使得合并石子的总代价最小。在这个问题中，一开始有一排石子，每个石子有一个权值，合并两个相邻的石子可以获得它们的权值之和作为代价。问题的关键在于如何安排合并的顺序，以获得最小的总代价。</p>
<p>下面是石子合并问题的一般步骤：</p>
<ol>
<li><p><strong>定义状态</strong>：通常使用一个二维数组 <code>dp[i][j]</code> 表示合并第 <code>i</code> 到第 <code>j</code> 个石子所需的最小代价。</p>
</li>
<li><p><strong>状态转移方程</strong>：假设要合并第 <code>i</code> 到第 <code>j</code> 个石子，可以将它们分为两部分：第 <code>i</code> 到 <code>k</code> 个石子和第 <code>k+1</code> 到 <code>j</code> 个石子，其中 <code>i &lt;= k &lt; j</code>。那么合并的代价就是将这两部分合并的代价加上这两部分的权值之和。状态转移方程可以表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i][k] + dp[k+1][j] + sum[i][j]), 其中 i &lt;= k &lt; j</span><br></pre></td></tr></table></figure>

<p>其中 <code>sum[i][j]</code> 表示第 <code>i</code> 到第 <code>j</code> 个石子的权值之和。</p>
</li>
<li><p><strong>边界条件</strong>：当 <code>i == j</code> 时，只有一个石子，无需合并，所以 <code>dp[i][i] = 0</code>。</p>
</li>
<li><p><strong>计算顺序</strong>：通常从小规模问题开始，逐步计算出大规模问题的最优解。</p>
</li>
</ol>
<p>下面是一个简单的石子合并问题的 Java 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoneMergeProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeStones</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="type">int</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            prefixSum[i] = prefixSum[i - <span class="number">1</span>] + stones[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + prefixSum[j + <span class="number">1</span>] - prefixSum[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StoneMergeProblem</span> <span class="variable">problem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoneMergeProblem</span>();</span><br><span class="line">        <span class="type">int</span>[] stones = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCost</span> <span class="operator">=</span> problem.mergeStones(stones);</span><br><span class="line">        System.out.println(<span class="string">&quot;Minimum cost to merge stones: &quot;</span> + minCost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了动态规划来解决石子合并问题。首先计算了石子的前缀和，然后使用二维数组 <code>dp</code> 来存储合并石子的最小代价。根据状态转移方程，我们通过计算不同的区间长度和区间起始位置，逐步填充 <code>dp</code> 数组，最终得到合并所有石子的最小代价。</p>
<p>需要注意的是，石子合并问题的动态规划解法通常要结合问题的具体要求来确定状态转移方程，边界条件等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/40386.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/40386.html" class="post-title-link" itemprop="url">环形DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:06:08" itemprop="dateModified" datetime="2023-08-10T00:06:08+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>866</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>环形动态规划（Circular Dynamic Programming）是一种动态规划的应用，适用于解决环形问题，即问题中的元素或状态在某种意义上是循环的，首尾相连的。这类问题在动态规划中需要考虑元素之间的相互关系，以及环形带来的特殊情况。</p>
<p>一般来说，环形动态规划的核心思想是将环形问题转化为线性问题，然后通过适当的状态转移方程和边界条件来求解。以下是环形动态规划的一般步骤：</p>
<ol>
<li><p><strong>问题转化</strong>：将环形问题转化为线性问题。可以通过复制一份原始数据，将环形结构“展开”成线性结构，从而将问题转化为已知的线性动态规划问题。</p>
</li>
<li><p><strong>定义状态</strong>：定义动态规划的状态，通常与问题的特性相关。对于环形问题，需要考虑首尾相连的情况，可能需要多设置一个状态来表示“首尾相连”的状态。</p>
</li>
<li><p><strong>确定状态转移方程</strong>：根据问题的性质，确定状态之间的转移关系。考虑环形结构，需要确保转移关系在环形首尾相连的情况下也能正确地进行。</p>
</li>
<li><p><strong>确定边界条件</strong>：环形问题的边界条件可能相对复杂，需要确保首尾相连的元素能够正确处理。这些边界条件可能需要在状态转移方程中单独处理。</p>
</li>
<li><p><strong>计算顺序</strong>：通常从小规模问题开始，按照线性结构的顺序逐步计算状态，直到计算出整个环形结构的状态。</p>
</li>
</ol>
<p>下面以一个具体问题为例，来说明环形动态规划的应用。假设有一个环形数组，每个元素代表一个房屋，每个房屋中有一定数量的金钱。由于房屋是环形排列的，意味着第一个和最后一个房屋也相邻。要求在不偷相邻房屋的情况下，计算可以偷到的最大金钱数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDPExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Calculate the maximum amount that can be robbed if starting from the first house.</span></span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i - <span class="number">1</span>], dp1[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Calculate the maximum amount that can be robbed if starting from the second house.</span></span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp2[i] = Math.max(dp2[i - <span class="number">1</span>], dp2[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The maximum amount that can be robbed will be the maximum of the two scenarios.</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1[n - <span class="number">2</span>], dp2[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircularDPExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircularDPExample</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxAmount</span> <span class="operator">=</span> example.rob(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum amount that can be robbed: &quot;</span> + maxAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们通过定义两个状态数组 <code>dp1</code> 和 <code>dp2</code>，分别表示从第一个房屋和第二个房屋开始偷窃时的最大金额。通过动态规划的思想，我们逐步计算出每个状态的最大金额，最终得到在不偷相邻房屋的情况下可以偷到的最大金钱数。</p>
<p>请注意，以上仅是环形动态规划的一个简单例子。实际应用中，问题可能会更加复杂，需要根据问题的具体情况来定义状态、状态转移方程和边界条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/55387.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/55387.html" class="post-title-link" itemprop="url">状压DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:04:52" itemprop="dateModified" datetime="2023-08-10T00:04:52+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>351</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>状压动态规划（Bitmask Dynamic Programming，状压DP）是一种优化技巧，通常用于解决组合优化问题，特别是集合的子集问题。以下是一个使用状压DP解决集合的最短路径问题的Java代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitmaskDP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] dist)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalStates</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; n;  <span class="comment">// Total possible subsets</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][totalStates];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// Starting state: only the first city visited</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>; mask &lt; totalStates; mask++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; u)) != <span class="number">0</span>) &#123;  <span class="comment">// Check if u is in the current subset</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v != u &amp;&amp; (mask &amp; (<span class="number">1</span> &lt;&lt; v)) != <span class="number">0</span>) &#123;  <span class="comment">// Check if v is in the current subset and not equal to u</span></span><br><span class="line">                            dp[u][mask] = Math.min(dp[u][mask], dp[v][mask ^ (<span class="number">1</span> &lt;&lt; u)] + dist[v][u]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minPath</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">1</span>; u &lt; n; u++) &#123;</span><br><span class="line">            minPath = Math.min(minPath, dp[u][totalStates - <span class="number">1</span>] + dist[u][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">// Number of cities</span></span><br><span class="line">        <span class="type">int</span>[][] dist = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">25</span>&#125;,</span><br><span class="line">            &#123;<span class="number">15</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">30</span>&#125;,</span><br><span class="line">            &#123;<span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">shortest</span> <span class="operator">=</span> shortestPath(n, dist);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shortest Path: &quot;</span> + shortest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>shortestPath</code> 方法使用状压DP解决了集合的最短路径问题。算法通过构建一个二维数组 <code>dp</code> 来保存状态转移，从而计算最短路径。</p>
<p>请注意，状压DP通常用于解决集合的子集问题，例如在TSP（Traveling Salesman Problem）中寻找最短路径。实际应用中，可能需要根据问题的需求进行适当的修改。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/24306.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/24306.html" class="post-title-link" itemprop="url">深度优先广度优先</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-28 14:40:43" itemprop="dateModified" datetime="2022-12-28T14:40:43+08:00">2022-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>579</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点压入栈中，stack（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）；</p>
</li>
<li><p>将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）；</p>
</li>
<li><p>将E节点弹出，同时将E的子节点I压入，stack（I,C）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void depthFirst() &#123;

    Stack&lt;Map&lt;String, Object&gt;&gt; nodeStack = new Stack&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeStack.add(node);

    while (!nodeStack.isEmpty()) &#123;

        node = nodeStack.pop();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) &#123;

            for (Map child : children) &#123;

                nodeStack.push(child);

            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p> 广度优先遍历各个节点，需要使用到队列（Queue）这种数据结构，queue的特点是先进先出，其实也可以使用双端队列，区别就是双端队列首尾都可以插入和弹出节点。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点插入队列中，queue（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;</p>
</li>
<li><p>将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；</p>
</li>
<li><p>将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void breadthFirst() &#123;

    Deque&lt;Map&lt;String, Object&gt;&gt; nodeDeque = new ArrayDeque&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeDeque.add(node);

    while (!nodeDeque.isEmpty()) &#123;

        node = nodeDeque.peekFirst();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) &#123;

            for (Map child : children) &#123;

                nodeDeque.add(child);

            &#125;

        &#125;

    &#125;

&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/51333.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/51333.html" class="post-title-link" itemprop="url">最长上升子序列最大连续子序列和，最长公共子串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:04:22" itemprop="dateModified" datetime="2023-08-10T00:04:22+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>381</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下面是分别解决最长上升子序列、最大连续子序列和和最长公共子串问题的Java代码示例：</p>
<h3 id="最长上升子序列（Longest-Increasing-Subsequence）："><a href="#最长上升子序列（Longest-Increasing-Subsequence）：" class="headerlink" title="最长上升子序列（Longest Increasing Subsequence）："></a>最长上升子序列（Longest Increasing Subsequence）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestIncreasingSubsequence</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;  <span class="comment">// Minimum length is 1 (the element itself)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lisLength</span> <span class="operator">=</span> lengthOfLIS(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大连续子序列和（Maximum-Subarray-Sum）："><a href="#最大连续子序列和（Maximum-Subarray-Sum）：" class="headerlink" title="最大连续子序列和（Maximum Subarray Sum）："></a>最大连续子序列和（Maximum Subarray Sum）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumSubarraySum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArraySum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            currentSum = Math.max(nums[i], currentSum + nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> maxSubArraySum(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum Subarray Sum: &quot;</span> + maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子串（Longest-Common-Substring）："><a href="#最长公共子串（Longest-Common-Substring）：" class="headerlink" title="最长公共子串（Longest Common Substring）："></a>最长公共子串（Longest Common Substring）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestCommonSubstring</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubstring</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    maxLength = Math.max(maxLength, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;BABCBA&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">commonSubstringLength</span> <span class="operator">=</span> longestCommonSubstring(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length of Longest Common Substring: &quot;</span> + commonSubstringLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些示例分别展示了如何解决最长上升子序列、最大连续子序列和和最长公共子串问题。实际应用中，根据问题的需求可能需要进行适当的修改。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/13990.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/13990.html" class="post-title-link" itemprop="url">数位DP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-27 17:31:27" itemprop="dateCreated datePublished" datetime="2022-12-27T17:31:27+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-10 00:04:13" itemprop="dateModified" datetime="2023-08-10T00:04:13+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algrithom/" itemprop="url" rel="index"><span itemprop="name">algrithom</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>306</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数位动态规划（Digit Dynamic Programming，数位DP）是一种动态规划算法，用于解决涉及数字各位数的组合问题。以下是一个数位DP的Java代码示例，用于计算在区间 [1, N] 内，所有数字的各位之和等于给定值 K 的个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigitDP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countNumbersWithDigitSum</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= d) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - d]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (K &gt;= d) &#123;</span><br><span class="line">                result = (result + dp[N][K - d]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countNumbersWithDigitSum(N, K);</span><br><span class="line">        System.out.println(<span class="string">&quot;Count of numbers with digit sum &quot;</span> + K + <span class="string">&quot; in range [1, &quot;</span> + N + <span class="string">&quot;]: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>countNumbersWithDigitSum</code> 方法使用数位DP解决了计算各个数字各位数之和等于给定值 K 的数字个数问题。算法通过构建一个二维数组 <code>dp</code> 来保存状态转移，从而计算符合条件的数字个数。</p>
<p>这个示例是一个数位DP的实现，实际应用中可能需要根据不同的问题进行适当的修改。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">350</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">320k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:23</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
