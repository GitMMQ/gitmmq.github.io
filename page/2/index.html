<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="recording">
<meta name="keywords" content="Tech;Data;Vision">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/2/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qi">
<meta name="twitter:description" content="recording">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.fastolf.com/page/2/">





  <title>Qi</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">to learn</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/21/设计模式-原型模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/设计模式-原型模式/" itemprop="url">设计模式-原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:58:50+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用原型对象的方法创建对象的实列，创建的实例equals原型</p>
<p>final 类型修饰的成员变量不能进行深度拷贝</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等</li>
<li>构造对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>工厂模式中使用</li>
<li>共有信息很多</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对象内引用原先原型的对象</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对象内引用也拷贝一份</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package prototype;

//Cloneable 标记对象可拷贝
public class PersonClone implements Cloneable {

    @Override //Override Object方法
    public PersonClone clone(){
        try {
            //clone 不会调用构造方法
            return (PersonClone)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }
}


package prototype;

public class MainClass {
    public static void main(String[] args) {
        PersonClone personClone = new PersonClone();
        PersonClone clone = personClone.clone();
        System.out.println(personClone.hashCode());
        System.out.println(clone.hashCode());
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/21/设计模式-模板方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/设计模式-模板方法/" itemprop="url">设计模式-模板方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T09:57:39+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>流程相同，执行过程中有差别</p>
<p>可用于定义算法骨架，将一些实现放到子类中实现，达到不用改变算法结构，重新实现算法的目的</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package template;

public abstract class Model {
    /**
     * 类似的行为、逻辑
     */
    protected abstract void start();

    protected abstract void stop();

    /**
     * 固定的流程  模板化
     */
    final public void excet(){
        this.start();
        this.stop();
    }
}

package template;

public class Ocar extends Model {
    @Override
    protected void start() {

    }

    @Override
    protected void stop() {

    }
}

package template;

public class Wcar extends Model {
    @Override
    protected void start() {

    }

    @Override
    protected void stop() {

    }
}

package template;

public class Client {
    public static void main(String[] args) {
        Model wcar=new Wcar();
        wcar.excet();

        Model ocar=new Ocar();
        ocar.excet();
    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/19/rbac权限管理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/rbac权限管理/" itemprop="url">rbac权限管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T14:30:37+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RBAC : 基于角色的权限访问控制（Role-Based Access Control）通过角色绑定权限，然后给用户划分角色。在web应用中，可以将权限理解为url，一个权限对应一个url。</p>
<h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><p>用户，角色，权限，权限组，菜单</p>
<p>用户和角色，多对多<br>角色和权限，多对多<br>权限和权限组，多对一<br>权限组和菜单，多对一<br>菜单和菜单，自引用</p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>用户登录后，取出其权限及所属菜单信息，写入session中</p>
<p>自定义中间件，检查用户权限，进行访问控制</p>
<p>参考：<a href="https://www.jianshu.com/p/f45b54768aa9" target="_blank" rel="noopener">https://www.jianshu.com/p/f45b54768aa9</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/19/GBDT原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/GBDT原理/" itemprop="url">GBDT原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:30:27+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Gradient Boosting Decision Tree 迭代决策树，泛化能力较强</p>
<p>几乎可用于所有回归问题（线性/非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）。<br>可用于<a href="http://research.microsoft.com/pubs/132652/MSR-TR-2010-82.pdf" title="搜索排序" target="_blank" rel="noopener">搜索排序</a></p>
<h2 id="Regression-Decistion-Tree"><a href="#Regression-Decistion-Tree" class="headerlink" title="Regression Decistion Tree"></a>Regression Decistion Tree</h2><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>C4.5分类树:在每次分枝时，是穷举每一个feature的每一个阈值，找到使得按照feature&lt;=阈值，和feature&gt;阈值分成的两个分枝的熵最大的feature和阈值（熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1），按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。</p>
<h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差–即（每个人的年龄-预测年龄）^2 的总和 / N，或者说是每个人的预测误差平方和 除以 N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。</p>
<p>参考：<a href="http://www.schonlau.net/publication/05stata_boosting.pdf" target="_blank" rel="noopener">http://www.schonlau.net/publication/05stata_boosting.pdf</a></p>
<h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>多棵树来共同决策。GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义，简单吧。</p>
<p>残差： A的预测值 + A的残差 = A的实际值 ，残差为0，极为真实值，（过拟合问题）</p>
<p>优点：Boosting的最大好处在于，每一步的残差计算其实变相地增大了分错instance的权重，而已经分对的instance则都趋向于0。这样后面的树就能越来越专注那些前面被分错的instance。</p>
<p>Adaboost是另一种boost方法，它按分类对错，分配不同的weight，计算cost function时使用这些weight，从而让“错分的样本权重越来越大，使它们更被重视”。Bootstrap也有类似思想，它在每一步迭代时不改变模型本身，也不计算残差，而是从N个instance训练集中按一定概率重新抽取N个instance出来（单个instance可以被重复sample），对着这N个新的instance再训练一轮。由于数据集变了迭代模型训练结果也不一样，而一个instance被前面分错的越厉害，它的概率就被设的越高，这样就能同样达到逐步关注被分错的instance，逐步完善的效果。Adaboost的方法被实践证明是一种很好的防止过拟合的方法，但至于为什么则至今没从理论上被证明。GBDT也可以在使用残差的同时引入Bootstrap re-sampling，GBDT多数实现版本中也增加的这个选项，但是否一定使用则有不同看法。re-sampling一个缺点是它的随机性，即同样的数据集合训练两遍结果是不一样的，也就是模型不可稳定复现，这对评估是很大挑战，比如很难说一个模型变好是因为你选用了更好的feature，还是由于这次sample的随机因素。</p>
<p>参考：<a href="http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting</a></p>
<h2 id="Shrinkage"><a href="#Shrinkage" class="headerlink" title="Shrinkage"></a>Shrinkage</h2><p>每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。</p>
<p>没用Shrinkage时：（yi表示第i棵树上y的预测值， y(1~i)表示前i棵树y的综合预测值）</p>
<p>y(i+1) = 残差(y1~yi)， 其中： 残差(y1~yi) =  y真实值 - y(1 ~ i)</p>
<p>y(1 ~ i) = SUM(y1, …, yi)</p>
<p>Shrinkage不改变第一个方程，只把第二个方程改为： </p>
<p>y(1 ~ i) = y(1 ~ i-1) + step * yi</p>
<p>即Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分（step*残差）逐步逼近目标，step一般都比较小，如0.01~0.001（注意该step非gradient的step），导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。</p>
<h2 id="RankNet"><a href="#RankNet" class="headerlink" title="RankNet"></a>RankNet</h2><p>实际的搜索排序使用的是LambdaMART算法，必须指出的是由于这里要使用排序需要的cost function，LambdaMART迭代用的并不是残差。Lambda在这里充当替代残差的计算方法，它使用了一种类似Gradient*步长模拟残差的方法。这里的MART在求解方法上和之前说的残差略有不同，其区别描述见这里。</p>
<p>就像所有的机器学习一样，搜索排序的学习也需要训练集，这里一般是用人工标注实现，即对每一个(query,doc) pair给定一个分值（如1,2,3,4）,分值越高表示越相关，越应该排到前面。然而这些绝对的分值本身意义不大，例如你很难说1分和2分文档的相关程度差异是1分和3分文档差距的一半。相关度本身就是一个很主观的评判，标注人员无法做到这种定量标注，这种标准也无法制定。但标注人员很容易做到的是”AB都不错，但文档A比文档B更相关，所以A是4分，B是3分“。RankNet就是基于此制定了一个学习误差衡量方法，即cost function。具体而言，RankNet对任意两个文档A,B，通过它们的人工标注分差，用sigmoid函数估计两者顺序和逆序的概率P1。然后同理用机器学习到的分差计算概率P2（sigmoid的好处在于它允许机器学习得到的分值是任意实数值，只要它们的分差和标准分的分差一致，P2就趋近于P1）。这时利用P1和P2求的两者的交叉熵，该交叉熵就是cost function。它越低说明机器学得的当前排序越趋近于标注排序。为了体现NDCG的作用（NDCG是搜索排序业界最常用的评判标准），RankNet还在cost function中乘以了NDCG。</p>
<p>好，现在我们有了cost function，而且它是和各个文档的当前分值yi相关的，那么虽然我们不知道它的全局最优方向，但可以求导求Gradient，Gradient即每个文档得分的一个下降方向组成的N维向量，N为文档个数（应该说是query-doc pair个数）。这里仅仅是把”求残差“的逻辑替换为”求梯度“，可以这样想：梯度方向为每一步最优方向，累加的步数多了，总能走到局部最优点，若该点恰好为全局最优点，那和用残差的效果是一样的。这时套到之前讲的逻辑，GDBT就已经可以上了。那么最终排序怎么产生呢？很简单，每个样本通过Shrinkage累加都会得到一个最终得分，直接按分数从大到小排序就可以了（因为机器学习产生的是实数域的预测分，极少会出现在人工标注中常见的两文档分数相等的情况，几乎不同考虑同分文档的排序方式）</p>
<p>另外，如果feature个数太多，每一棵回归树都要耗费大量时间，这时每个分支时可以随机抽一部分feature来遍历求最优（ELF源码实现方式）。</p>
<p>参考：<a href="https://www.cnblogs.com/pinard/p/6140514.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6140514.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/18/量化交易/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/量化交易/" itemprop="url">量化交易</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T19:58:54+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>投资决策模型化，基于历史数据验证，交易自动执行</p>
<p>股市波动，长期、短期、相对</p>
<h2 id="投资指标"><a href="#投资指标" class="headerlink" title="投资指标"></a>投资指标</h2><h3 id="风险收益率"><a href="#风险收益率" class="headerlink" title="风险收益率"></a>风险收益率</h3><p>夏普率=（收益-无风险利率）/波动率</p>
<h3 id="胜率赔率"><a href="#胜率赔率" class="headerlink" title="胜率赔率"></a>胜率赔率</h3><p>胜率是指出手赚钱次数与总出手次数之比</p>
<p>赔率是指平均每次出手赚到的钱除以平均每次出手赔的钱，也叫做盈亏比</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="阿尔法策略"><a href="#阿尔法策略" class="headerlink" title="阿尔法策略"></a>阿尔法策略</h3><p>优点：不管指数是涨还是下跌，都能赚钱的一种方法，具体的操作思路是找出市场里最优秀的品种，做多这些品种，然后做空相应多的指数，这样就锁定了最优秀的品种带来的收益，而把指数带来的波动进行了平抑。<br>缺点：回撤和收益都比较小的交易策略</p>
<h3 id="程序化CTA"><a href="#程序化CTA" class="headerlink" title="程序化CTA"></a>程序化CTA</h3><p>优点：适合大众使用的程序化交易方法，是指将交易策略的思想设计成完整的逻辑运行体系，然后用合适的计算机语言编写成程序，有计算机进行自动交易。程序化交易的优点是，将交易模式系统化，制度化，排除人性的心理障碍，确保交易策略的执行行。挣的是趋势的钱，挣的是纪律的钱，但因为趋势不常有，所以这是一种低胜率，高赔率的方法。</p>
<p>入场条件、出场条件，品种选择、时机选择，资金管理</p>
<h3 id="统计套利"><a href="#统计套利" class="headerlink" title="统计套利"></a>统计套利</h3><p>通过计算某些关联品种之间出现了价差的扩大，那就可以在品种之间进行配对交易，从而进行套利</p>
<h3 id="低风险套利"><a href="#低风险套利" class="headerlink" title="低风险套利"></a>低风险套利</h3><p>ETF套利也是一种低风险套利，比如某个ETF指数基金现在的价格是2.1，而如果我们用一揽子股票来组成这个ETF指数基金，价格是2块，那么我们就可以在市场上卖出基金，买入股票，来得到这0.1的差价。这些套利比较容易执行，收入也很可观，而且风险很小。</p>
<h3 id="高频交易"><a href="#高频交易" class="headerlink" title="高频交易"></a>高频交易</h3><p>利用计算机处理市场微观结构层面的不均衡性，往往交易次数多，持仓时间短，可能会送大量交易指令，又快速撤单，再反向做交易获得收益，每笔交易平均利润小但稳定。</p>
<p>优点是总收益率极高，当日平仓降低隔夜风险，隔夜资金利息收入降低资金成本，绩效评估周期短。</p>
<h3 id="算法交易"><a href="#算法交易" class="headerlink" title="算法交易"></a>算法交易</h3><p>降低冲击成本的一种被动的程序化交易，通过科学的成本估算模型和交易实施算法，将一个大额的交易拆分成系列小额交易 在合理的时间点分别执行，以此来尽量减少 对市场价格造成的冲击，降低交易成本，而且还能帮助机构投资者快速增加交易量。适合的对象包括大小非减持者，大宗交易接盘出货，“大宗交易-融券卖出”套利者，Alpha套利者，套期保值者，日以上级别程序化交易者等。</p>
<p>参考：<a href="https://www.jianshu.com/p/2c470ef5d083" target="_blank" rel="noopener">https://www.jianshu.com/p/2c470ef5d083</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/数据结构-红黑树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/数据结构-红黑树/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T22:16:48+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>红黑树是特殊的二叉查找树</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 （这里叶子节点，是指为空的叶子节点！）</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注：确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

    }

    ...
}

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

    }

    ...
}

/* 
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                              px
 *     /                               /
 *    x                               y                
 *   /  \      --(左旋)-.           / \                #
 *  lx   y                          x  ry     
 *     /   \                       /  \
 *    ly   ry                     lx  ly  
 *
 *
 */
private void leftRotate(RBTNode&lt;T&gt; x) {
    // 设置x的右孩子为y
    RBTNode&lt;T&gt; y = x.right;

    // 将 “y的左孩子” 设为 “x的右孩子”；
    // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
    x.right = y.left;
    if (y.left != null)
        y.left.parent = x;

    // 将 “x的父亲” 设为 “y的父亲”
    y.parent = x.parent;

    if (x.parent == null) {
        this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
    } else {
        if (x.parent.left == x)
            x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        else
            x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
    }

    // 将 “x” 设为 “y的左孩子”
    y.left = x;
    // 将 “x的父节点” 设为 “y”
    x.parent = y;
}

/* 
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x                  
 *         /  \      --(右旋)-.            /  \                     #
 *        x   ry                           lx   y  
 *       / \                                   / \                   #
 *      lx  rx                                rx  ry
 * 
 */
private void rightRotate(RBTNode&lt;T&gt; y) {
    // 设置x是当前节点的左孩子。
    RBTNode&lt;T&gt; x = y.left;

    // 将 “x的右孩子” 设为 “y的左孩子”；
    // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
    y.left = x.right;
    if (x.right != null)
        x.right.parent = y;

    // 将 “y的父亲” 设为 “x的父亲”
    x.parent = y.parent;

    if (y.parent == null) {
        this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
    } else {
        if (y == y.parent.right)
            y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
        else
            y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
    }

    // 将 “y” 设为 “x的右孩子”
    x.right = y;

    // 将 “y的父节点” 设为 “x”
    y.parent = x;
}

/* 
 * 将结点插入到红黑树中
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的node
 */
private void insert(RBTNode&lt;T&gt; node) {
    int cmp;
    RBTNode&lt;T&gt; y = null;
    RBTNode&lt;T&gt; x = this.mRoot;

    // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
    while (x != null) {
        y = x;
        cmp = node.key.compareTo(x.key);
        if (cmp &lt; 0)
            x = x.left;
        else
            x = x.right;
    }

    node.parent = y;
    if (y!=null) {
        cmp = node.key.compareTo(y.key);
        if (cmp &lt; 0)
            y.left = node;
        else
            y.right = node;
    } else {
        this.mRoot = node;
    }

    // 2. 设置节点的颜色为红色
    node.color = RED;

    // 3. 将它重新修正为一颗二叉查找树
    insertFixUp(node);
}

/* 
 * 新建结点(key)，并将其插入到红黑树中
 *
 * 参数说明：
 *     key 插入结点的键值
 */
public void insert(T key) {
    RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

    // 如果新建结点失败，则返回。
    if (node != null)
        insert(node);
}


/*
 * 红黑树插入修正函数
 *
 * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的z
 */
private void insertFixUp(RBTNode&lt;T&gt; node) {
    RBTNode&lt;T&gt; parent, gparent;

    // 若“父节点存在，并且父节点的颜色是红色”
    while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) {
        gparent = parentOf(parent);

        //若“父节点”是“祖父节点的左孩子”
        if (parent == gparent.left) {
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.right;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            }

            // Case 2条件：叔叔是黑色，且当前节点是右孩子
            if (parent.right == node) {
                RBTNode&lt;T&gt; tmp;
                leftRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是左孩子。
            setBlack(parent);
            setRed(gparent);
            rightRotate(gparent);
        } else {    //若“z的父节点”是“z的祖父节点的右孩子”
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.left;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            }

            // Case 2条件：叔叔是黑色，且当前节点是左孩子
            if (parent.left == node) {
                RBTNode&lt;T&gt; tmp;
                rightRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            // Case 3条件：叔叔是黑色，且当前节点是右孩子。
            setBlack(parent);
            setRed(gparent);
            leftRotate(gparent);
        }
    }

    // 将根节点设为黑色
    setBlack(this.mRoot);
}


/* 
 * 删除结点(node)，并返回被删除的结点
 *
 * 参数说明：
 *     node 删除的结点
 */
private void remove(RBTNode&lt;T&gt; node) {
    RBTNode&lt;T&gt; child, parent;
    boolean color;

    // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
    if ( (node.left!=null) &amp;&amp; (node.right!=null) ) {
        // 被删节点的后继节点。(称为&quot;取代节点&quot;)
        // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
        RBTNode&lt;T&gt; replace = node;

        // 获取后继节点
        replace = replace.right;
        while (replace.left != null)
            replace = replace.left;

        // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
        if (parentOf(node)!=null) {
            if (parentOf(node).left == node)
                parentOf(node).left = replace;
            else
                parentOf(node).right = replace;
        } else {
            // &quot;node节点&quot;是根节点，更新根节点。
            this.mRoot = replace;
        }

        // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
        // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
        child = replace.right;
        parent = parentOf(replace);
        // 保存&quot;取代节点&quot;的颜色
        color = colorOf(replace);

        // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
        if (parent == node) {
            parent = replace;
        } else {
            // child不为空
            if (child!=null)
                setParent(child, parent);
            parent.left = child;

            replace.right = node.right;
            setParent(node.right, replace);
        }

        replace.parent = node.parent;
        replace.color = node.color;
        replace.left = node.left;
        node.left.parent = replace;

        if (color == BLACK)
            removeFixUp(child, parent);

        node = null;
        return ;
    }

    if (node.left !=null) {
        child = node.left;
    } else {
        child = node.right;
    }

    parent = node.parent;
    // 保存&quot;取代节点&quot;的颜色
    color = node.color;

    if (child!=null)
        child.parent = parent;

    // &quot;node节点&quot;不是根节点
    if (parent!=null) {
        if (parent.left == node)
            parent.left = child;
        else
            parent.right = child;
    } else {
        this.mRoot = child;
    }

    if (color == BLACK)
        removeFixUp(child, parent);
    node = null;
}

/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 红黑树的根结点
 *     z 删除的结点
 */
public void remove(T key) {
    RBTNode&lt;T&gt; node; 

    if ((node = search(mRoot, key)) != null)
        remove(node);
}



/*
 * 红黑树删除修正函数
 *
 * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 待修正的节点
 */
private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
    RBTNode&lt;T&gt; other;

    while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) {
        if (parent.left == node) {
            other = parent.right;
            if (isRed(other)) {
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                leftRotate(parent);
                other = parent.right;
            }

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) {
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            } else {

                if (other.right==null || isBlack(other.right)) {
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.left);
                    setRed(other);
                    rightRotate(other);
                    other = parent.right;
                }
                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.right);
                leftRotate(parent);
                node = this.mRoot;
                break;
            }
        } else {

            other = parent.left;
            if (isRed(other)) {
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                rightRotate(parent);
                other = parent.left;
            }

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) {
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            } else {

                if (other.left==null || isBlack(other.left)) {
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.right);
                    setRed(other);
                    leftRotate(other);
                    other = parent.left;
                }

                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.left);
                rightRotate(parent);
                node = this.mRoot;
                break;
            }
        }
    }

    if (node!=null)
        setBlack(node);
}
</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>/**
 * Java 语言: 红黑树
 *
 * @author skywang
 * @date 2013/11/07
 */

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public T getKey() {
            return key;
        }

        public String toString() {
            return &quot;&quot;+key+(this.color==RED?&quot;(R)&quot;:&quot;B&quot;);
        }
    }

    public RBTree() {
        mRoot=null;
    }

    private RBTNode&lt;T&gt; parentOf(RBTNode&lt;T&gt; node) {
        return node!=null ? node.parent : null;
    }
    private boolean colorOf(RBTNode&lt;T&gt; node) {
        return node!=null ? node.color : BLACK;
    }
    private boolean isRed(RBTNode&lt;T&gt; node) {
        return ((node!=null)&amp;&amp;(node.color==RED)) ? true : false;
    }
    private boolean isBlack(RBTNode&lt;T&gt; node) {
        return !isRed(node);
    }
    private void setBlack(RBTNode&lt;T&gt; node) {
        if (node!=null)
            node.color = BLACK;
    }
    private void setRed(RBTNode&lt;T&gt; node) {
        if (node!=null)
            node.color = RED;
    }
    private void setParent(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
        if (node!=null)
            node.parent = parent;
    }
    private void setColor(RBTNode&lt;T&gt; node, boolean color) {
        if (node!=null)
            node.color = color;
    }

    /*
     * 前序遍历&quot;红黑树&quot;
     */
    private void preOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null) {
            System.out.print(tree.key+&quot; &quot;);
            preOrder(tree.left);
            preOrder(tree.right);
        }
    }

    public void preOrder() {
        preOrder(mRoot);
    }

    /*
     * 中序遍历&quot;红黑树&quot;
     */
    private void inOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null) {
            inOrder(tree.left);
            System.out.print(tree.key+&quot; &quot;);
            inOrder(tree.right);
        }
    }

    public void inOrder() {
        inOrder(mRoot);
    }


    /*
     * 后序遍历&quot;红黑树&quot;
     */
    private void postOrder(RBTNode&lt;T&gt; tree) {
        if(tree != null)
        {
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.key+&quot; &quot;);
        }
    }

    public void postOrder() {
        postOrder(mRoot);
    }


    /*
     * (递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; search(RBTNode&lt;T&gt; x, T key) {
        if (x==null)
            return x;

        int cmp = key.compareTo(x.key);
        if (cmp &lt; 0)
            return search(x.left, key);
        else if (cmp &gt; 0)
            return search(x.right, key);
        else
            return x;
    }

    public RBTNode&lt;T&gt; search(T key) {
        return search(mRoot, key);
    }

    /*
     * (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; iterativeSearch(RBTNode&lt;T&gt; x, T key) {
        while (x!=null) {
            int cmp = key.compareTo(x.key);

            if (cmp &lt; 0) 
                x = x.left;
            else if (cmp &gt; 0) 
                x = x.right;
            else
                return x;
        }

        return x;
    }

    public RBTNode&lt;T&gt; iterativeSearch(T key) {
        return iterativeSearch(mRoot, key);
    }

    /* 
     * 查找最小结点：返回tree为根结点的红黑树的最小结点。
     */
    private RBTNode&lt;T&gt; minimum(RBTNode&lt;T&gt; tree) {
        if (tree == null)
            return null;

        while(tree.left != null)
            tree = tree.left;
        return tree;
    }

    public T minimum() {
        RBTNode&lt;T&gt; p = minimum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /* 
     * 查找最大结点：返回tree为根结点的红黑树的最大结点。
     */
    private RBTNode&lt;T&gt; maximum(RBTNode&lt;T&gt; tree) {
        if (tree == null)
            return null;

        while(tree.right != null)
            tree = tree.right;
        return tree;
    }

    public T maximum() {
        RBTNode&lt;T&gt; p = maximum(mRoot);
        if (p != null)
            return p.key;

        return null;
    }

    /* 
     * 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。
     */
    public RBTNode&lt;T&gt; successor(RBTNode&lt;T&gt; x) {
        // 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。
        if (x.right != null)
            return minimum(x.right);

        // 如果x没有右孩子。则x有以下两种可能：
        // (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。
        // (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.right)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /* 
     * 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。
     */
    public RBTNode&lt;T&gt; predecessor(RBTNode&lt;T&gt; x) {
        // 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。
        if (x.left != null)
            return maximum(x.left);

        // 如果x没有左孩子。则x有以下两种可能：
        // (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。
        // (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.left)) {
            x = y;
            y = y.parent;
        }

        return y;
    }

    /* 
     * 对红黑树的节点(x)进行左旋转
     *
     * 左旋示意图(对节点x进行左旋)：
     *      px                              px
     *     /                               /
     *    x                               y                
     *   /  \      --(左旋)-.           / \                #
     *  lx   y                          x  ry     
     *     /   \                       /  \
     *    ly   ry                     lx  ly  
     *
     *
     */
    private void leftRotate(RBTNode&lt;T&gt; x) {
        // 设置x的右孩子为y
        RBTNode&lt;T&gt; y = x.right;

        // 将 “y的左孩子” 设为 “x的右孩子”；
        // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
        x.right = y.left;
        if (y.left != null)
            y.left.parent = x;

        // 将 “x的父亲” 设为 “y的父亲”
        y.parent = x.parent;

        if (x.parent == null) {
            this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
        } else {
            if (x.parent.left == x)
                x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
            else
                x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        }

        // 将 “x” 设为 “y的左孩子”
        y.left = x;
        // 将 “x的父节点” 设为 “y”
        x.parent = y;
    }

    /* 
     * 对红黑树的节点(y)进行右旋转
     *
     * 右旋示意图(对节点y进行左旋)：
     *            py                               py
     *           /                                /
     *          y                                x                  
     *         /  \      --(右旋)-.            /  \                     #
     *        x   ry                           lx   y  
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     * 
     */
    private void rightRotate(RBTNode&lt;T&gt; y) {
        // 设置x是当前节点的左孩子。
        RBTNode&lt;T&gt; x = y.left;

        // 将 “x的右孩子” 设为 “y的左孩子”；
        // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
        y.left = x.right;
        if (x.right != null)
            x.right.parent = y;

        // 将 “y的父亲” 设为 “x的父亲”
        x.parent = y.parent;

        if (y.parent == null) {
            this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
        } else {
            if (y == y.parent.right)
                y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
            else
                y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
        }

        // 将 “y” 设为 “x的右孩子”
        x.right = y;

        // 将 “y的父节点” 设为 “x”
        y.parent = x;
    }

    /*
     * 红黑树插入修正函数
     *
     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的z
     */
    private void insertFixUp(RBTNode&lt;T&gt; node) {
        RBTNode&lt;T&gt; parent, gparent;

        // 若“父节点存在，并且父节点的颜色是红色”
        while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) {
            gparent = parentOf(parent);

            //若“父节点”是“祖父节点的左孩子”
            if (parent == gparent.left) {
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.right;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是右孩子
                if (parent.right == node) {
                    RBTNode&lt;T&gt; tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是左孩子。
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            } else {    //若“z的父节点”是“z的祖父节点的右孩子”
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.left;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) {
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                }

                // Case 2条件：叔叔是黑色，且当前节点是左孩子
                if (parent.left == node) {
                    RBTNode&lt;T&gt; tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }

                // Case 3条件：叔叔是黑色，且当前节点是右孩子。
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            }
        }

        // 将根节点设为黑色
        setBlack(this.mRoot);
    }

    /* 
     * 将结点插入到红黑树中
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的node
     */
    private void insert(RBTNode&lt;T&gt; node) {
        int cmp;
        RBTNode&lt;T&gt; y = null;
        RBTNode&lt;T&gt; x = this.mRoot;

        // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
        while (x != null) {
            y = x;
            cmp = node.key.compareTo(x.key);
            if (cmp &lt; 0)
                x = x.left;
            else
                x = x.right;
        }

        node.parent = y;
        if (y!=null) {
            cmp = node.key.compareTo(y.key);
            if (cmp &lt; 0)
                y.left = node;
            else
                y.right = node;
        } else {
            this.mRoot = node;
        }

        // 2. 设置节点的颜色为红色
        node.color = RED;

        // 3. 将它重新修正为一颗二叉查找树
        insertFixUp(node);
    }

    /* 
     * 新建结点(key)，并将其插入到红黑树中
     *
     * 参数说明：
     *     key 插入结点的键值
     */
    public void insert(T key) {
        RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

        // 如果新建结点失败，则返回。
        if (node != null)
            insert(node);
    }


    /*
     * 红黑树删除修正函数
     *
     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 待修正的节点
     */
    private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) {
        RBTNode&lt;T&gt; other;

        while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) {
            if (parent.left == node) {
                other = parent.right;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.right==null || isBlack(other.right)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node = this.mRoot;
                    break;
                }
            } else {

                other = parent.left;
                if (isRed(other)) {
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) {
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                } else {

                    if (other.left==null || isBlack(other.left)) {
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }

                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node = this.mRoot;
                    break;
                }
            }
        }

        if (node!=null)
            setBlack(node);
    }

    /* 
     * 删除结点(node)，并返回被删除的结点
     *
     * 参数说明：
     *     node 删除的结点
     */
    private void remove(RBTNode&lt;T&gt; node) {
        RBTNode&lt;T&gt; child, parent;
        boolean color;

        // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
        if ( (node.left!=null) &amp;&amp; (node.right!=null) ) {
            // 被删节点的后继节点。(称为&quot;取代节点&quot;)
            // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
            RBTNode&lt;T&gt; replace = node;

            // 获取后继节点
            replace = replace.right;
            while (replace.left != null)
                replace = replace.left;

            // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
            if (parentOf(node)!=null) {
                if (parentOf(node).left == node)
                    parentOf(node).left = replace;
                else
                    parentOf(node).right = replace;
            } else {
                // &quot;node节点&quot;是根节点，更新根节点。
                this.mRoot = replace;
            }

            // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
            // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
            child = replace.right;
            parent = parentOf(replace);
            // 保存&quot;取代节点&quot;的颜色
            color = colorOf(replace);

            // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
            if (parent == node) {
                parent = replace;
            } else {
                // child不为空
                if (child!=null)
                    setParent(child, parent);
                parent.left = child;

                replace.right = node.right;
                setParent(node.right, replace);
            }

            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;

            if (color == BLACK)
                removeFixUp(child, parent);

            node = null;
            return ;
        }

        if (node.left !=null) {
            child = node.left;
        } else {
            child = node.right;
        }

        parent = node.parent;
        // 保存&quot;取代节点&quot;的颜色
        color = node.color;

        if (child!=null)
            child.parent = parent;

        // &quot;node节点&quot;不是根节点
        if (parent!=null) {
            if (parent.left == node)
                parent.left = child;
            else
                parent.right = child;
        } else {
            this.mRoot = child;
        }

        if (color == BLACK)
            removeFixUp(child, parent);
        node = null;
    }

    /* 
     * 删除结点(z)，并返回被删除的结点
     *
     * 参数说明：
     *     tree 红黑树的根结点
     *     z 删除的结点
     */
    public void remove(T key) {
        RBTNode&lt;T&gt; node; 

        if ((node = search(mRoot, key)) != null)
            remove(node);
    }

    /*
     * 销毁红黑树
     */
    private void destroy(RBTNode&lt;T&gt; tree) {
        if (tree==null)
            return ;

        if (tree.left != null)
            destroy(tree.left);
        if (tree.right != null)
            destroy(tree.right);

        tree=null;
    }

    public void clear() {
        destroy(mRoot);
        mRoot = null;
    }

    /*
     * 打印&quot;红黑树&quot;
     *
     * key        -- 节点的键值 
     * direction  --  0，表示该节点是根节点;
     *               -1，表示该节点是它的父结点的左孩子;
     *                1，表示该节点是它的父结点的右孩子。
     */
    private void print(RBTNode&lt;T&gt; tree, T key, int direction) {

        if(tree != null) {

            if(direction==0)    // tree是根节点
                System.out.printf(&quot;%2d(B) is root\n&quot;, tree.key);
            else                // tree是分支节点
                System.out.printf(&quot;%2d(%s) is %2d&apos;s %6s child\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction==1?&quot;right&quot; : &quot;left&quot;);

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        }
    }

    public void print() {
        if (mRoot != null)
            print(mRoot, mRoot.key, 0);
    }
}

/**
 * Java 语言: 二叉查找树
 *
 * @author skywang
 * @date 2013/11/07
 */
public class RBTreeTest {

    private static final int a[] = {10, 40, 30, 60, 90, 70, 20, 50, 80};
    private static final boolean mDebugInsert = false;    // &quot;插入&quot;动作的检测开关(false，关闭；true，打开)
    private static final boolean mDebugDelete = false;    // &quot;删除&quot;动作的检测开关(false，关闭；true，打开)

    public static void main(String[] args) {
        int i, ilen = a.length;
        RBTree&lt;Integer&gt; tree=new RBTree&lt;Integer&gt;();

        System.out.printf(&quot;== 原始数据: &quot;);
        for(i=0; i&lt;ilen; i++)
            System.out.printf(&quot;%d &quot;, a[i]);
        System.out.printf(&quot;\n&quot;);

        for(i=0; i&lt;ilen; i++) {
            tree.insert(a[i]);
            // 设置mDebugInsert=true,测试&quot;添加函数&quot;
            if (mDebugInsert) {
                System.out.printf(&quot;== 添加节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            }
        }

        System.out.printf(&quot;== 前序遍历: &quot;);
        tree.preOrder();

        System.out.printf(&quot;\n== 中序遍历: &quot;);
        tree.inOrder();

        System.out.printf(&quot;\n== 后序遍历: &quot;);
        tree.postOrder();
        System.out.printf(&quot;\n&quot;);

        System.out.printf(&quot;== 最小值: %s\n&quot;, tree.minimum());
        System.out.printf(&quot;== 最大值: %s\n&quot;, tree.maximum());
        System.out.printf(&quot;== 树的详细信息: \n&quot;);
        tree.print();
        System.out.printf(&quot;\n&quot;);

        // 设置mDebugDelete=true,测试&quot;删除函数&quot;
        if (mDebugDelete) {
            for(i=0; i&lt;ilen; i++)
            {
                tree.remove(a[i]);

                System.out.printf(&quot;== 删除节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            }
        }

        // 销毁二叉树
        tree.clear();
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/深度广度优先/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/深度广度优先/" itemprop="url">深度优先广度优先</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T22:12:33+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点压入栈中，stack（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）；</p>
</li>
<li><p>将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）；</p>
</li>
<li><p>将E节点弹出，同时将E的子节点I压入，stack（I,C）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void depthFirst() {

    Stack&lt;Map&lt;String, Object&gt;&gt; nodeStack = new Stack&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeStack.add(node);

    while (!nodeStack.isEmpty()) {

        node = nodeStack.pop();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) {

            for (Map child : children) {

                nodeStack.push(child);

            }

        }

    }

}
</code></pre><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p> 广度优先遍历各个节点，需要使用到队列（Queue）这种数据结构，queue的特点是先进先出，其实也可以使用双端队列，区别就是双端队列首尾都可以插入和弹出节点。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点插入队列中，queue（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;</p>
</li>
<li><p>将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；</p>
</li>
<li><p>将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void breadthFirst() {

    Deque&lt;Map&lt;String, Object&gt;&gt; nodeDeque = new ArrayDeque&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeDeque.add(node);

    while (!nodeDeque.isEmpty()) {

        node = nodeDeque.peekFirst();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) {

            for (Map child : children) {

                nodeDeque.add(child);

            }

        }

    }

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/16/234树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/234树/" itemprop="url">234树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-16T21:57:12+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>平衡树，子节点数目可以达到4个</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p>若父节点中存有1个数据项，则必有2个子节点。</p>
</li>
<li><p>若父节点中存有2个数据项，则必有3个子节点。</p>
</li>
<li><p>若父节点中存有3个数据项，则必有4个子节点。</p>
</li>
</ol>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>插入数据：</p>
<ul>
<li><p>未满节点直接插入</p>
</li>
<li><p>满节点 ABC 分裂 A不变 B到父节点 C到右侧</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Node
{
private static final int ORDER = 4;
private int numItems;//节点中实际存储的数据项数目，其值一定不大于3
private Node parent;
private Node childArray[] = new Node[ORDER];//子节点数组
private DataItem itemArray[] = new DataItem[ORDER-1];//存储数据项数组
//-------------------------------------------------------------
// 把参数中的节点作为子节点，与当前节点进行连接
public void connectChild(int childNum, Node child)
   {
   childArray[childNum] = child;
   if(child != null)
      child.parent = this;//当前节点作为父节点
   }
//-------------------------------------------------------------
// 断开参数确定的节点与当前节点的连接，这个节点一定是当前节点的子节点。
public Node disconnectChild(int childNum)
   {
   Node tempNode = childArray[childNum];
   childArray[childNum] = null; //断开连接
   return tempNode;//返回要这个子节点
   }
//-------------------------------------------------------------
public Node getChild(int childNum)//获取相应的子节点
   { return childArray[childNum]; }
//-------------------------------------------------------------
public Node getParent()//获取父节点
   { return parent; }
//-------------------------------------------------------------
public boolean isLeaf()//是否是叶结点
   { return (childArray[0]==null) ? true : false; }//叶结点没有子节点
//-------------------------------------------------------------
public int getNumItems()//获取实际存储的数据项数目
  { return numItems; }
//-------------------------------------------------------------
public DataItem getItem(int index)   // 获取具体的数据项
   { return itemArray[index]; }
//-------------------------------------------------------------
public boolean isFull()//该节点是否已满
   { return (numItems==ORDER-1) ? true : false; }
//-------------------------------------------------------------
public int findItem(long key)       // 查找
   {                                    
   for(int j=0; j&lt;ORDER-1; j++)         // 遍历数组
      {                                 
      if(itemArray[j] == null)          // 数组未满，未找到
         break;
      else if(itemArray[j].dData == key)
         return j;
      }
   return -1;
   }  // end findItem
//-------------------------------------------------------------
public int insertItem(DataItem newItem)//节点未满的插入
   {
   numItems++;                          
   long newKey = newItem.dData;         // 获得关键字

   for(int j=ORDER-2; j&gt;=0; j--)        // 因为节点未满，所以从倒数第二项向前查找
      {                              
      if(itemArray[j] == null)          // 没存数据
         continue;                      
      else                              
         {                              
         long itsKey = itemArray[j].dData;//获得关键字
         if(newKey &lt; itsKey)            //插入位置在其前面，但未必相邻
            itemArray[j+1] = itemArray[j]; //当前数据项后移
         else
            {
            itemArray[j+1] = newItem;   // 在其后位置插入
            return j+1;                 // 返回插入的位置下标
            }                           //    new item
         }  // end else (not null)
      }  // end for                     // shifted all items,
   //若上述代码没有执行返回操作，那么这是空节点（只有初始时根是这个情况）
   itemArray[0] = newItem;              // insert new item
   return 0;
   }  // end insertItem()
//-------------------------------------------------------------
public DataItem removeItem()        // 移除数据项，从后向前移除
   {
   // 假设节点非空
   DataItem temp = itemArray[numItems-1];  // 要移除的数据项
   itemArray[numItems-1] = null;           // 移除
   numItems--;                             // 数据项数目减一
   return temp;                            // 返回要移除的数据项
   }
//-------------------------------------------------------------
public void displayNode()           // format &quot;/24/56/74/&quot;
   {
   for(int j=0; j&lt;numItems; j++)
      itemArray[j].displayItem();   // &quot;/56&quot;
   System.out.println(&quot;/&quot;);         // final &quot;/&quot;
   }
//-------------------------------------------------------------
}  // end class Node
////////////////////////////////////////////////////////////////


class Tree234
{
private Node root = new Node();            // 创建树的根
//-------------------------------------------------------------
//获取查找的下一个节点
public Node getNextChild(Node theNode, long theValue)
{
int j;
// 假设这个节点不是叶结点
int numItems = theNode.getNumItems();//获得当前节点的数据项数目
for(j=0; j&lt;numItems; j++)          
   {                             
   if( theValue &lt; theNode.getItem(j).dData )
      return theNode.getChild(j);  // 返回相应的节点
   }  // end for                   
return theNode.getChild(j);        // 此时j=numItems
}
//-------------------------------------------------------------
public int find(long key)
   {
   Node curNode = root;
   int childNumber;
   while(true)
      {
      if(( childNumber=curNode.findItem(key) ) != -1)//每次循环这句一定执行
         return childNumber;               // found it
      else if( curNode.isLeaf() )//叶结点上也没找到
         return -1;                        // can&apos;t find it
      else                                 // 不是叶结点，则继续向下查找
         curNode = getNextChild(curNode, key);
      }  // end while
   }
//-------------------------------------------------------------
// 插入数据项
public void insert(long dValue)
   {
   Node curNode = root;//当前节点标志
   DataItem tempItem = new DataItem(dValue);//插入数据项封装

   while(true)
      {
      if( curNode.isFull() )               // 是满节点
         {
         split(curNode);                   // 分裂
         curNode = curNode.getParent();    // 回到分裂出的父节点上
                                           // 继续向下查找
         curNode = getNextChild(curNode, dValue);
         }  // end if(node is full)
//后面的操作中节点都未满，否则先执行上面的代码
      else if( curNode.isLeaf() )          // 是叶结点，非满
         break;                            // 跳出，直接插入

      else
         curNode = getNextChild(curNode, dValue);//向下查找
      }  // end while

   curNode.insertItem(tempItem);       // 此时节点一定不满，直接插入数据项，
   }  // end insert()
//-------------------------------------------------------------
public void split(Node thisNode)     // 分裂
   {
   // 操作中节点一定是满节点，否则不会执行该操作
   DataItem itemB, itemC;
   Node parent, child2, child3;
   int itemIndex;

   itemC = thisNode.removeItem();    // 移除最右边的两个数据项，并保存为B和C
   itemB = thisNode.removeItem();    // 
   child2 = thisNode.disconnectChild(2); // //断开最右边两个子节点的链接
   child3 = thisNode.disconnectChild(3); // 

   Node newRight = new Node();       //新建一个节点，作为当前节点的兄弟节点

   if(thisNode==root)                // 是根
      {
      root = new Node();                // 新建一个根
      parent = root;                    // 把新根设为父节点
      root.connectChild(0, thisNode);   // 连接父节点和子节点
      }
   else                              // 不是根
      parent = thisNode.getParent();    // 获取父节点


   itemIndex = parent.insertItem(itemB); // 把B插入父节点中，返回插入位置
   int n = parent.getNumItems();         // 获得总数据项数目

   for(int j=n-1; j&gt;itemIndex; j--)          //从后向前移除
      {                                    
      Node temp = parent.disconnectChild(j); // 断开连接
      parent.connectChild(j+1, temp);        // 连接到新的位置
      }

   parent.connectChild(itemIndex+1, newRight);//连接到新位置

   // 处理兄弟节点
   newRight.insertItem(itemC);       // 将C放入兄弟节点中
   newRight.connectChild(0, child2); // 把子节点中最右边的两个连接到兄弟节点上
   newRight.connectChild(1, child3); //
   }  // end split()
//-------------------------------------------------------------
// gets appropriate child of node during search for value

public void displayTree()
   {
   recDisplayTree(root, 0, 0);
   }
//-------------------------------------------------------------
private void recDisplayTree(Node thisNode, int level,
                                           int childNumber)
   {
   System.out.print(&quot;level=&quot;+level+&quot; child=&quot;+childNumber+&quot; &quot;);
   thisNode.displayNode();               // display this node

   // call ourselves for each child of this node
   int numItems = thisNode.getNumItems();
   for(int j=0; j&lt;numItems+1; j++)
      {
      Node nextNode = thisNode.getChild(j);
      if(nextNode != null)
         recDisplayTree(nextNode, level+1, j);
      else
         return;
      }
   }  // end recDisplayTree()
//-------------------------------------------------------------\
}  // end class Tree234
////////////////////////////////////////////////////////////////


import java.io.*;

class Tree234App
{
public static void main(String[] args) throws IOException
   {
   long value;
   Tree234 theTree = new Tree234();

   theTree.insert(50);
   theTree.insert(40);
   theTree.insert(60);
   theTree.insert(30);
   theTree.insert(70);

   while(true)
      {
      System.out.print(&quot;Enter first letter of &quot;);
      System.out.print(&quot;show, insert, or find: &quot;);
      char choice = getChar();
      switch(choice)
         {
         case &apos;s&apos;:
            theTree.displayTree();
            break;
         case &apos;i&apos;:
            System.out.print(&quot;Enter value to insert: &quot;);
            value = getInt();
            theTree.insert(value);
            break;
         case &apos;f&apos;:
            System.out.print(&quot;Enter value to find: &quot;);
            value = getInt();
            int found = theTree.find(value);
            if(found != -1)
               System.out.println(&quot;Found &quot;+value);
            else
               System.out.println(&quot;Could not find &quot;+value);
            break;
         default:
            System.out.print(&quot;Invalid entry\n&quot;);
         }  // end switch
      }  // end while
   }  // end main()
//--------------------------------------------------------------
public static String getString() throws IOException
   {
   InputStreamReader isr = new InputStreamReader(System.in);
   BufferedReader br = new BufferedReader(isr);
   String s = br.readLine();
   return s;
   }
//--------------------------------------------------------------
public static char getChar() throws IOException
   {
   String s = getString();
   return s.charAt(0);
   }

//-------------------------------------------------------------
public static int getInt() throws IOException
   {
   String s = getString();
   return Integer.parseInt(s);
   }
//-------------------------------------------------------------
}  // end class Tree234App
////////////////////////////////////////////////////////////////
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/13/中文分词/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/中文分词/" itemprop="url">中文分词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T10:38:02+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>基于字典、词库匹配</li>
<li>基于词频度统计</li>
<li>基于知识理解</li>
</ul>
<h2 id="字典、词库匹配"><a href="#字典、词库匹配" class="headerlink" title="字典、词库匹配"></a>字典、词库匹配</h2><p>中文复杂、丰富，词典、词库匹配无法有效处理大规模文本分词处理</p>
<ol>
<li>逐词遍历法：全字典遍历一遍，效率低，不适用于大系统</li>
<li>机械分词法</li>
</ol>
<h3 id="最大正向匹配法"><a href="#最大正向匹配法" class="headerlink" title="最大正向匹配法"></a>最大正向匹配法</h3><p>假定词典词最大长度为i,被处理文档的当前字串中的前i个字作为匹配字段，匹配成功，则切分出来，匹配失败，则i-1，继续匹配，若成功则i+1，知道文档处理完成</p>
<h3 id="逆向最大匹配法"><a href="#逆向最大匹配法" class="headerlink" title="逆向最大匹配法"></a>逆向最大匹配法</h3><p>文档逆序处理，通过逆序词典匹配，汉语中偏正结构较多，若从后向前匹配，可以适当提高精确度，逆向最大匹配法比正向最大匹配法的误差要小</p>
<h3 id="最少切分法"><a href="#最少切分法" class="headerlink" title="最少切分法"></a>最少切分法</h3><p>使每一句中切出的词数最小</p>
<h3 id="双向匹配法"><a href="#双向匹配法" class="headerlink" title="双向匹配法"></a>双向匹配法</h3><p>将正向最大匹配法与逆向最大匹配法组合，如果两种分词方法得到的匹配结果相同，则认为分词正确，否则，按最小集处理</p>
<h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>考虑到相邻字词关系、词频、共现信息，有较好的实用性</p>
<h3 id="全切分和基于词的频度统计的分词方法"><a href="#全切分和基于词的频度统计的分词方法" class="headerlink" title="全切分和基于词的频度统计的分词方法"></a>全切分和基于词的频度统计的分词方法</h3><p>基于词的频度统计的分词方法是一种全切分方法</p>
<p>全切分要求获得输入序列的所有可接受的切分形式，而部分切分只取得一种或几种可接受的切分形式，由于部分切分忽略了可能的其他切分形式，所以建立在部分切分基础上的分词方法不管采取何种歧义纠正策略，都可能会遗漏正确的切分，造成分词错误或失败。而建立在全切分基础上的分词方法，由于全切分取得了所有可能的切分形式，因而从根本上避免了可能切分形式的遗漏，克服了部分切分方法的缺陷。</p>
<p>问题：</p>
<ol>
<li><p>全切分算法只是能获得正确分词的前提，因为全切分不具有歧义检测功能，最终分词结果的正确性和完全性依赖于独立的歧义处理方法，如果评测有误，也会造成错误的结果。</p>
</li>
<li><p>全切分的切分结果个数随句子长度的增长呈指数增长，一方面将导致庞大的无用数据充斥于存储数据库；另一方面当句长达到一定长度后，由于切分形式过多,造成分词效率严重下降。</p>
</li>
</ol>
<p>解决方案：</p>
<p>基于词的频度统计的分词方法：</p>
<p>这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。</p>
<h2 id="基于知识理解"><a href="#基于知识理解" class="headerlink" title="基于知识理解"></a>基于知识理解</h2><p>基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。</p>
<h2 id="并行分词方法"><a href="#并行分词方法" class="headerlink" title="并行分词方法"></a>并行分词方法</h2><p>并行分词方法：这种分词方法借助于一个含有分词词库的管道进行 ,比较匹配过程是分步进行的 ,每一步可以对进入管道中的词同时与词库中相应的词进行比较 ,由于同时有多个词进行比较匹配 ,因而分词速度可以大幅度提高。这种方法涉及到多级内码理论和管道的词典数据结构。（详细算法可以参考吴胜远的《并行分词方法的研究》。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/2018/12/13/redis统计信息/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/redis统计信息/" itemprop="url">redis统计信息--INFO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T10:14:50+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>显示关于redis服务器的状态报告和统计数值</p>
<pre><code>redis&gt; INFO
# Server
redis_version:2.9.11 //服务器版本
redis_git_sha1:937384d0
redis_git_dirty:0
redis_build_id:8e9509442863f22
redis_mode:standalone  //mode
os:Linux 3.13.0-35-generic x86_64
arch_bits:64
multiplexing_api:epoll //事件处理机制
gcc_version:4.8.2
process_id:4716 //进程ID
run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc  //随机标识符（用于 Sentinel 和集群）
tcp_port:6379   //监听端口号
uptime_in_seconds:362  //启动以来，经过的秒数
uptime_in_days:0  //启动以来，经过的天数
hz:10  //serverCron运行频率，此值越大表示redis对&quot;间歇性task&quot;的执行次数越频繁(次数/秒)
lru_clock:1725349  //以分钟为单位进行自增的时钟，用于 LRU 管理
config_file:

# Clients
connected_clients:1  //已连接客户端的数量（不包括通过从属服务器连接的客户端）
client_longest_output_list:0  //当前连接的客户端当中，最长的输出列表
client_biggest_input_buf:0  //当前连接的客户端当中，最大输入缓存
blocked_clients:0 //正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量

# Memory
used_memory:508536  //由 Redis 分配器分配的内存总量，以字节（byte）为单位
used_memory_human:496.62K  //以人类可读的格式返回 Redis 分配的内存总量
used_memory_rss:7974912  //从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。
//理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿  
//当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片
//当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。
used_memory_peak:508536 //Redis 的内存消耗峰值（以字节为单位）
used_memory_peak_human:496.62K //以人类可读的格式返回 Redis 的内存消耗峰值
used_memory_lua:33792  // Lua 引擎所使用的内存大小（以字节为单位）
mem_fragmentation_ratio:15.68  //used_memory_rss 和 used_memory 之间的比率
mem_allocator:jemalloc-3.2.0  //在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc

# Persistence
loading:0  //一个标志值，记录了服务器是否正在载入持久化文件  
rdb_changes_since_last_save:6 //距离最近一次成功创建持久化文件之后，经过了多少秒
rdb_bgsave_in_progress:0 //一个标志值，记录了服务器是否正在创建 RDB 文件
rdb_last_save_time:1411011131 //最近一次成功创建 RDB 文件的 UNIX 时间戳
rdb_last_bgsave_status:ok //一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败
rdb_last_bgsave_time_sec:-1 //记录了最近一次创建 RDB 文件耗费的秒数
rdb_current_bgsave_time_sec:-1 // 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
aof_enabled:0 //标志值，记录了 AOF 是否处于打开状态。
  //如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：    
  // aof_current_size : AOF 文件目前的大小。
  // aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。
  // aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。
  // aof_buffer_length : AOF 缓冲区的大小。
  // aof_rewrite_buffer_length : AOF 重写缓冲区的大小。
  // aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。
  // aof_delayed_fsync : 被延迟的 fsync 调用数量。
aof_rewrite_in_progress:0 //一个标志值，记录了服务器是否正在创建 AOF 文件。
aof_rewrite_scheduled:0 //一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作
aof_last_rewrite_time_sec:-1 //最近一次创建 AOF 文件耗费的时长。
aof_current_rewrite_time_sec:-1 //如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
aof_last_bgrewrite_status:ok //一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。
aof_last_write_status:ok //

# Stats
total_connections_received:2 //服务器已接受的连接请求数量
total_commands_processed:4 //服务器已执行的命令数量
instantaneous_ops_per_sec:0 //服务器每秒钟执行的命令数量
rejected_connections:0 //因为最大客户端数量限制而被拒绝的连接请求数量
sync_full:0 
sync_partial_ok:0 
sync_partial_err:0
expired_keys:0 //因为过期而被自动删除的数据库键数量
evicted_keys:0 //因为最大内存容量限制而被驱逐（evict）的键数量。
keyspace_hits:0 //查找数据库键成功的次数。
keyspace_misses:0 //查找数据库键失败的次数。
pubsub_channels:0 //目前被订阅的频道数量。
pubsub_patterns:0 //目前被订阅的模式数量。
latest_fork_usec:0 //最近一次 fork() 操作耗费的毫秒数。
migrate_cached_sockets:0

# Replication
role:master //如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:0.21  // Redis 服务器耗费的系统 CPU 。
used_cpu_user:0.17  // Redis 服务器耗费的用户 CPU 。
used_cpu_sys_children:0.00 //后台进程耗费的系统 CPU 。
used_cpu_user_children:0.00 //后台进程耗费的用户 CPU 。

# Cluster
cluster_enabled:0  //一个标志值，记录集群功能是否已经开启

# Keyspace
db0:keys=2,expires=0,avg_ttl=0 //部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Meng Qi</p>
              <p class="site-description motion-element" itemprop="description">recording</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
