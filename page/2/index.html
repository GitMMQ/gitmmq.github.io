<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="recording">
<meta property="og:type" content="website">
<meta property="og:title" content="Qi">
<meta property="og:url" content="https://www.fastolf.com/page/2/index.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="recording">
<meta property="og:locale">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="Tech;Data;Vision">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/14be0fb8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/14be0fb8.html" class="post-title-link" itemprop="url">Dubbo 负载均衡策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:15:43 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:15:43+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>646</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo 是一个基于 Java 的开源分布式服务框架，用于构建高性能和可扩展的分布式应用程序。在 Dubbo 中，负载均衡策略是决定服务消费者如何选择提供该服务的多个提供者之一的机制。Dubbo 提供了多种负载均衡策略，让开发人员可以根据实际需求来选择适合的策略。以下是一些常见的 Dubbo 负载均衡策略及其分析：</p>
<ol>
<li><p><strong>Random Load Balancing（随机负载均衡）</strong>:<br>这种策略会随机选择一个可用的提供者来处理请求。优点是简单且易于实现，但不适合需要考虑服务器性能差异的场景，因为可能会导致请求被分配到性能较差的提供者上。</p>
</li>
<li><p><strong>Round Robin Load Balancing（轮询负载均衡）</strong>:<br>轮询策略会依次轮流选择每个可用的提供者来处理请求。这在提供者性能相对均衡时是一种较好的选择。但如果某些提供者的性能较差，可能会导致性能问题。</p>
</li>
<li><p><strong>Least Active Load Balancing（最小活跃数负载均衡）</strong>:<br>这种策略会优先选择活跃连接数最少的提供者，从而更均衡地分配负载。这对于处理响应时间差异较大的提供者非常有用，因为它可以减少响应时间较短的提供者上的负载。</p>
</li>
<li><p><strong>Weighted Load Balancing（加权负载均衡）</strong>:<br>加权负载均衡允许为每个提供者分配一个权重值，根据权重来决定选择哪个提供者。这对于希望按照性能或其他因素来调整负载分配的场景非常有用。</p>
</li>
<li><p><strong>Consistent Hash Load Balancing（一致性哈希负载均衡）</strong>:<br>这种策略使用一致性哈希算法来选择提供者，从而在提供者数量变化时尽量保持请求的路由稳定性。这对于需要缓存或会话保持的场景可能更加适用。</p>
</li>
</ol>
<p>选择适当的负载均衡策略取决于你的应用场景和需求。例如，如果你的提供者性能相似，可以使用轮询策略；如果你希望优先选择性能较好的提供者，可以使用最小活跃数策略；如果你需要根据不同的情况调整权重，可以选择加权负载均衡等。总之，选择负载均衡策略需要根据你的具体情况进行权衡和决策。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/45253a41.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45253a41.html" class="post-title-link" itemprop="url">Zookeeper功能实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:15:33 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:15:33+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>810</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo是一款高性能、轻量级的分布式服务框架，旨在帮助开发者构建高效可靠的分布式应用。它的设计原理和源码结构涉及多个方面，下面是一个简要的分析和解释：</p>
<p><strong>Dubbo设计原理分析</strong>：</p>
<ol>
<li><p><strong>面向接口的设计</strong>：<br>Dubbo的设计强调面向接口编程，服务提供者和消费者通过共享的接口定义进行交互。这使得服务的调用更加清晰，同时也方便扩展和替换实现。</p>
</li>
<li><p><strong>服务注册与发现</strong>：<br>Dubbo通过注册中心实现服务的注册和发现。服务提供者在启动时将自己注册到注册中心，而消费者从注册中心获取可用的服务提供者列表。这种设计简化了服务的管理和调用。</p>
</li>
<li><p><strong>远程调用</strong>：<br>Dubbo使用自定义的RPC协议实现远程调用。服务消费者将调用请求编码成二进制数据，通过网络传输给服务提供者，后者解码请求并执行相应的方法。然后将执行结果编码传输回给消费者。</p>
</li>
<li><p><strong>容错和负载均衡</strong>：<br>Dubbo提供多种容错和负载均衡策略，确保在系统故障或负载过大时能够保持系统的稳定性。容错策略如Failover、Failfast等，负载均衡策略如RoundRobin、Random等。</p>
</li>
<li><p><strong>动态代理</strong>：<br>Dubbo使用动态代理将服务接口的调用转化为远程调用。这使得服务消费者可以像调用本地方法一样调用远程服务，无需手动编写网络通信代码。</p>
</li>
</ol>
<p><strong>Dubbo源码详解</strong>：</p>
<p>Dubbo的源码非常庞大，由多个模块组成，涉及服务导出、调用、协议、序列化、注册中心、集群等。以下是源码的主要模块和关键概念：</p>
<ol>
<li><p><strong>Provider和Consumer模块</strong>：<br>这两个模块分别代表服务提供者和服务消费者。Provider负责将服务导出，Consumer负责发起服务调用。在代码中，您可以看到服务接口的导出、消费者的动态代理、调用逻辑等。</p>
</li>
<li><p><strong>Protocol和Invoker</strong>：<br>Protocol是Dubbo的协议模块，定义了服务的暴露和引用。Invoker是一个封装了调用信息的对象，用于在调用链中传递和执行。</p>
</li>
<li><p><strong>Cluster模块</strong>：<br>Cluster模块负责将多个Invoker组合成一个可执行的Invoker。这是Dubbo实现负载均衡、容错等特性的关键部分。</p>
</li>
<li><p><strong>Registry模块</strong>：<br>Registry模块用于实现服务的注册和发现。Dubbo支持多种注册中心，如ZooKeeper、Redis、Consul等。您可以在这里看到服务注册、发现和订阅相关的代码。</p>
</li>
<li><p><strong>Serialization模块</strong>：<br>Serialization模块负责服务参数和结果的序列化和反序列化。Dubbo支持多种序列化协议，如Hessian、JSON等。</p>
</li>
</ol>
<p>总之，Dubbo的源码结构和设计原理非常丰富，需要深入的研究和理解。如果您有兴趣深入了解Dubbo的源码，我建议您从Dubbo的GitHub仓库开始，查看各个模块的源代码并阅读相关文档。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/525e6265.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/525e6265.html" class="post-title-link" itemprop="url">Dubbo RPC协议底层原理与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:15:18 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:15:18+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>691</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo作为一个分布式服务框架，使用了自定义的Dubbo RPC（Remote Procedure Call）协议来实现远程调用。下面是Dubbo RPC协议的底层原理和实现细节的解释：</p>
<p><strong>Dubbo RPC协议底层原理</strong>：</p>
<p>Dubbo RPC协议的底层原理是基于网络通信，通过将调用请求编码成字节流，然后通过网络传输到服务提供者，再由服务提供者解码并执行相应的服务方法，最终将结果返回给调用方。</p>
<p>具体步骤如下：</p>
<ol>
<li><p><strong>编码请求参数</strong>：在调用方，Dubbo将调用请求的接口、方法、参数等信息编码成一个二进制字节流。</p>
</li>
<li><p><strong>网络传输</strong>：Dubbo使用底层的通信框架（如Netty）将编码后的字节流通过网络传输到服务提供者。</p>
</li>
<li><p><strong>解码和执行</strong>：在服务提供者，Dubbo根据协议规范，将收到的字节流解码成调用请求的信息，然后调用相应的服务方法，执行业务逻辑。</p>
</li>
<li><p><strong>编码响应结果</strong>：在服务提供者，将调用结果编码成二进制字节流。</p>
</li>
<li><p><strong>网络传输回调结果</strong>：服务提供者将编码后的响应结果通过网络传输回调给调用方。</p>
</li>
<li><p><strong>解码结果</strong>：在调用方，Dubbo根据协议规范，将收到的字节流解码成调用结果，然后返回给调用方的代码。</p>
</li>
</ol>
<p><strong>Dubbo RPC协议实现细节</strong>：</p>
<p>Dubbo RPC协议的实现细节涉及多个组件和步骤：</p>
<ol>
<li><p><strong>序列化和反序列化</strong>：<br>Dubbo使用序列化技术将调用参数和响应结果编码成二进制字节流，以及在服务提供者端将字节流解码为原始对象。Dubbo支持多种序列化协议，如Hessian、JSON、Java原生序列化等。</p>
</li>
<li><p><strong>通信框架</strong>：<br>Dubbo使用网络通信框架来实现底层的网络传输，常用的是Netty。Netty提供了高性能的异步网络通信能力，可以支持大规模的并发连接。</p>
</li>
<li><p><strong>协议拓展</strong>：<br>Dubbo允许用户自定义协议拓展，这就意味着您可以根据自己的需求实现新的协议。Dubbo默认支持多种协议，如dubbo、http、rmi等。</p>
</li>
<li><p><strong>线程池</strong>：<br>在服务提供者端，Dubbo会将请求放入线程池中进行处理，从而保证服务提供者的并发能力和响应速度。</p>
</li>
</ol>
<p>总的来说，Dubbo的RPC协议通过序列化、通信框架和协议拓展等技术，实现了在分布式环境下的远程调用，使得开发者可以像本地调用一样简单地调用远程服务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/a6c7d05a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/a6c7d05a.html" class="post-title-link" itemprop="url">Dubbo 容错机制与高扩展性分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:14:56 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:14:56+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>763</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo作为一款分布式服务框架，具备强大的容错机制和高扩展性。下面分别对Dubbo的容错机制和高扩展性进行详细分析：</p>
<p><strong>Dubbo容错机制</strong>：</p>
<p>Dubbo提供了多种容错策略，以保证在分布式系统中出现故障或异常时能够维持系统的稳定性和可用性。</p>
<ol>
<li><p><strong>Failover（失败自动切换）</strong>：<br>这是Dubbo的默认容错策略。当服务调用失败时，Failover会自动切换到另一个可用的提供者进行调用。可以配置重试次数和超时时间来进行调整。这种方式适用于普通的服务调用，但可能会引入较大的延迟。</p>
</li>
<li><p><strong>Failfast（快速失败）</strong>：<br>如果服务调用失败，Failfast会立即返回错误，不进行重试。这适用于对于某些操作，不能容忍任何延迟的情况。</p>
</li>
<li><p><strong>Failsafe（失败安全）</strong>：<br>Failsafe会在调用失败时，直接忽略错误并返回默认值，不会抛出异常。适用于可忽略的操作，例如记录日志。</p>
</li>
<li><p><strong>Failback（失败自动恢复）</strong>：<br>在调用失败后，Failback会自动记录失败请求，并在后台尝试重发请求，直到成功。适用于一些不需要即时响应的场景。</p>
</li>
<li><p><strong>Forking（并行调用）</strong>：<br>Forking会同时调用多个提供者，返回最快的一个。适用于提高系统的响应速度。</p>
</li>
<li><p><strong>Mock（模拟调用）</strong>：<br>在某些情况下，如果提供者不可用，Dubbo可以使用Mock来返回一个模拟的结果。这可以用于测试或避免因提供者故障而影响整体系统。</p>
</li>
</ol>
<p><strong>Dubbo高扩展性</strong>：</p>
<p>Dubbo的高扩展性表现在以下几个方面：</p>
<ol>
<li><p><strong>SPI机制</strong>：<br>Dubbo使用SPI（Service Provider Interface）机制来实现插件化扩展。通过配置，您可以替换或扩展Dubbo内部的各种组件，如序列化、注册中心、负载均衡等。</p>
</li>
<li><p><strong>Filter机制</strong>：<br>Dubbo的Filter机制允许您在调用链的不同阶段添加自定义的逻辑，例如在调用前后进行日志记录、权限校验等。</p>
</li>
<li><p><strong>Protocol扩展</strong>：<br>Dubbo的协议支持扩展，您可以自定义实现新的协议，以满足特定需求。Dubbo默认支持的协议有dubbo、http、rmi等。</p>
</li>
<li><p><strong>LoadBalance扩展</strong>：<br>Dubbo提供了多种负载均衡策略，您可以根据实际情况自定义扩展负载均衡算法。</p>
</li>
<li><p><strong>Registry扩展</strong>：<br>Dubbo的注册中心也是可扩展的，您可以集成不同的注册中心实现，如ZooKeeper、Consul等。</p>
</li>
<li><p><strong>Cluster扩展</strong>：<br>Dubbo的Cluster机制允许您定制服务提供者的选择策略，支持多种调用方式，如失败自动切换、并行调用等。</p>
</li>
</ol>
<p>总之，Dubbo的容错机制和高扩展性使得开发人员能够根据不同的需求和场景，选择适当的策略和插件，从而构建出稳定、高性能的分布式应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/45253a41.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45253a41.html" class="post-title-link" itemprop="url">Zookeeper功能实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:14:44 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:14:44+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>673</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dubbo是一款开源的分布式服务框架，用于构建高性能、可扩展的分布式应用。它提供了服务注册、发现、远程调用等功能，使得构建分布式系统变得更加简单。以下是Dubbo调用模块的详细解释：</p>
<p>Dubbo的调用模块涉及到服务提供者和服务消费者之间的通信和调用过程。整个过程包括服务的注册、发现、远程通信、负载均衡等。</p>
<ol>
<li><p><strong>服务注册和发现</strong>：<br>在Dubbo中，服务提供者会将自己提供的服务注册到注册中心，而服务消费者则从注册中心获取可用的服务提供者列表。这样，服务消费者就可以知道有哪些服务可供调用。</p>
</li>
<li><p><strong>负载均衡</strong>：<br>当一个服务有多个提供者时，Dubbo提供了多种负载均衡策略，用于在服务消费者之间分配调用请求。这样可以避免某个提供者过载，同时提高整体系统的性能。</p>
</li>
<li><p><strong>远程通信</strong>：<br>当服务消费者调用远程服务时，Dubbo使用网络通信实现远程调用。Dubbo支持多种通信协议，包括dubbo协议、http协议、rmi协议等，可以根据实际需求选择合适的协议。</p>
</li>
<li><p><strong>调用过程</strong>：<br>当服务消费者调用远程服务时，Dubbo会根据服务接口、方法名、参数等信息构建一个调用请求。这个请求会被编码成网络传输格式，然后发送到服务提供者。服务提供者接收到请求后，进行解码并调用相应的服务实现。</p>
</li>
<li><p><strong>超时和容错</strong>：<br>Dubbo支持设置调用超时时间，以避免因为某个提供者的响应时间过长而影响整体性能。另外，Dubbo还提供了容错策略，使得在某个提供者出现问题时，可以快速切换到其他提供者，保证系统的可用性。</p>
</li>
<li><p><strong>异步调用</strong>：<br>Dubbo还支持异步调用，允许服务消费者发送调用请求后不必等待返回结果，而是可以继续处理其他任务。当结果准备好时，Dubbo会通知服务消费者。</p>
</li>
</ol>
<p>需要注意的是，Dubbo的调用模块在整个框架中仅仅是一个组成部分，它与注册中心、序列化、线程池等其他组件紧密配合，共同构建了一个高效、稳定的分布式服务架构。如需更详细的信息，您可以查阅Dubbo的官方文档或阅读Dubbo源代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/7b1c422a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7b1c422a.html" class="post-title-link" itemprop="url">Zookeeper分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:14:22 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:14:22+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>662</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ZooKeeper的迁移、扩容和监控是在维护和管理分布式系统中至关重要的方面。以下是对这些主题的详细解释：</p>
<p><strong>ZooKeeper迁移</strong>：<br>迁移ZooKeeper集群可能涉及以下情况：</p>
<ol>
<li>物理迁移：将ZooKeeper服务器从一个数据中心或机器迁移到另一个。这可能涉及数据备份、迁移、恢复等步骤。</li>
<li>版本迁移：将ZooKeeper集群升级到新版本。这可能需要更新配置、应用程序代码等，确保新版本的兼容性。</li>
</ol>
<p>迁移步骤可能会根据具体情况有所不同，但一般来说，您需要：</p>
<ol>
<li>创建适当的计划，确保在迁移期间不会丢失数据或造成系统停机。</li>
<li>备份数据，以防在迁移过程中发生故障。</li>
<li>验证迁移后的集群是否正常运行，数据是否正确。</li>
</ol>
<p><strong>ZooKeeper扩容</strong>：<br>ZooKeeper的扩容意味着向现有集群添加更多的服务器，以提高容量和性能。扩容ZooKeeper涉及以下步骤：</p>
<ol>
<li>添加新服务器：在现有集群中添加新的ZooKeeper服务器。新服务器将参与选举、数据同步等过程。</li>
<li>配置更新：更新现有服务器的配置，使其知道新服务器的存在，并与其进行通信。</li>
<li>数据同步：新服务器需要从现有服务器同步数据。这可能需要一段时间，具体时间取决于数据量的大小。</li>
<li>验证集群状态：确保新服务器已经成功加入集群，并且集群的状态正常。</li>
</ol>
<p><strong>ZooKeeper监控</strong>：<br>监控ZooKeeper集群对于确保其可用性和性能至关重要。您可以通过以下方式监控集群：</p>
<ol>
<li><strong>指标监控</strong>：监控集群的关键指标，如吞吐量、延迟、请求处理时间等。可以使用监控系统（例如Prometheus、Grafana）来收集、可视化和报告这些指标。</li>
<li><strong>日志监控</strong>：定期检查ZooKeeper服务器的日志，以便发现潜在的问题或错误。</li>
<li><strong>警报和通知</strong>：设置警报，以便在出现问题时及时通知管理员。这可以通过邮件、短信、Slack等方式进行通知。</li>
</ol>
<p>使用专业的监控工具能够更好地管理和维护ZooKeeper集群。另外，了解ZooKeeper的正常运行状态和异常情况，以及如何解决常见问题，都是保持集群健康的关键。可以参考ZooKeeper的官方文档和相关的分布式系统监控实践来获取更多信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/7b1c422a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7b1c422a.html" class="post-title-link" itemprop="url">Zookeeper分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:14:04 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:14:04+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>688</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于ZooKeeper的源码剖析是一个相对复杂的任务，因为ZooKeeper是一个庞大且高度分布式的系统。在这里，我将为您提供一个高层次的概述，帮助您理解其基本结构和关键组件。</p>
<p>ZooKeeper的源码主要分为客户端和服务器两部分。服务器端负责存储和管理分布式数据，而客户端则与服务器交互以访问和修改这些数据。</p>
<p><strong>服务器端源码剖析</strong>：<br>服务器端的源码涉及到ZooKeeper的内部工作机制、数据管理、选举算法等复杂内容。主要组件包括：</p>
<ol>
<li><p><strong>数据模型和存储</strong>：ZooKeeper服务器将数据组织为树状结构，每个节点称为ZNode。源码中涉及ZNode的创建、删除、更新等操作，以及如何将这些操作映射到底层数据存储。</p>
</li>
<li><p><strong>选举算法</strong>：ZooKeeper使用Paxos算法的一种变种来进行Leader选举，确保系统中只有一个Leader服务器。源码涉及如何处理Leader选举、节点宕机等情况。</p>
</li>
<li><p><strong>请求处理</strong>：当客户端发送请求时，服务器需要处理这些请求，例如读取、更新等。源码涉及请求的分发、处理、执行和响应。</p>
</li>
<li><p><strong>Watcher机制</strong>：服务器端需要管理和触发Watcher。Watcher机制涉及如何注册Watcher、如何触发Watcher、如何管理Watcher列表等。</p>
</li>
</ol>
<p><strong>客户端源码剖析</strong>：<br>客户端源码涉及与ZooKeeper集群的通信、数据读写、Watcher注册等内容。主要组件包括：</p>
<ol>
<li><p><strong>会话管理</strong>：客户端需要与服务器建立会话，并在会话超时或过期时进行处理。源码中涉及会话的创建、维护和处理过期。</p>
</li>
<li><p><strong>通信</strong>：客户端需要与服务器进行通信，发送请求并接收响应。源码中涉及底层通信协议、数据序列化等。</p>
</li>
<li><p><strong>操作API</strong>：客户端提供了操作API，用于创建、读取、更新、删除ZNode，注册Watcher等。源码涉及API的实现和与服务器交互。</p>
</li>
<li><p><strong>Watcher处理</strong>：客户端需要处理来自服务器的Watcher通知。源码中涉及如何处理Watcher触发，更新客户端状态等。</p>
</li>
</ol>
<p>要深入了解ZooKeeper的源码，建议您从官方源码库开始，仔细阅读并调试关键部分。源码的理解可能需要涉及分布式系统、并发编程、网络通信等多个领域的知识。同时，也可以参考一些优质的开源项目，如Apache Curator，它是ZooKeeper客户端的高级封装，可以帮助您更好地理解和使用ZooKeeper。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/45253a41.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45253a41.html" class="post-title-link" itemprop="url">Zookeeper功能实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:13:43 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:13:43+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>685</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当谈论ZooKeeper时，以下是一些关键概念的详细解释：</p>
<ol>
<li><p><strong>ZNode（Zookeeper节点）</strong>：<br>ZNode是ZooKeeper中的基本数据单元。可以将其视为类似于文件系统中的文件或目录。每个ZNode都有一个唯一的路径标识，类似于文件系统中的绝对路径。ZNode可以保存数据，并且可以有子节点。ZooKeeper中的所有信息都存储在ZNode中。</p>
</li>
<li><p><strong>Watcher（监视器）</strong>：<br>Watcher是一种机制，用于让客户端能够在ZooKeeper数据发生变化时收到通知。当某个ZNode的状态发生变化（例如数据更新、子节点变化等），注册在该ZNode上的Watcher将被触发，从而通知客户端。这使得客户端能够实时监测和响应数据变化。</p>
</li>
<li><p><strong>ACL（访问控制列表）</strong>：<br>访问控制列表定义了谁有权访问ZooKeeper中的ZNode以及执行什么类型的操作（读、写、创建子节点等）。ZooKeeper使用ACL来保护数据的安全性。每个ZNode都有一个与之关联的ACL，以确定谁可以对该ZNode执行哪些操作。ACL是一个由权限和身份（例如认证的用户）组成的列表。</p>
</li>
<li><p><strong>客户端API</strong>：<br>ZooKeeper提供了多种编程语言的客户端API，使开发人员能够与ZooKeeper集群交互。常用的客户端API有Java、Python、C等。这些API允许客户端连接到ZooKeeper集群，创建、读取、更新和删除ZNode，注册Watcher等操作。</p>
</li>
</ol>
<p>总结一下常见的ZooKeeper操作流程：</p>
<ol>
<li><p><strong>连接到ZooKeeper集群</strong>：<br>客户端使用适当的API连接到ZooKeeper集群。</p>
</li>
<li><p><strong>创建ZNode</strong>：<br>客户端可以创建ZNode，为其指定路径、数据和ACL。</p>
</li>
<li><p><strong>读取和更新ZNode数据</strong>：<br>客户端可以读取和更新ZNode中存储的数据。</p>
</li>
<li><p><strong>注册Watcher</strong>：<br>客户端可以在ZNode上注册Watcher，以便在ZNode的状态发生变化时得到通知。</p>
</li>
<li><p><strong>处理Watcher触发</strong>：<br>当ZNode的状态发生变化时，与之相关的Watcher会被触发，客户端可以在Watcher中定义响应逻辑。</p>
</li>
<li><p><strong>删除ZNode</strong>：<br>客户端可以删除特定的ZNode。</p>
</li>
<li><p><strong>处理会话过期</strong>：<br>客户端会话有时限，如果超过了指定的会话超时时间没有及时与ZooKeeper集群通信，会话将过期。客户端需要处理会话过期的情况。</p>
</li>
</ol>
<p>需要注意的是，这里只是一个概览，ZooKeeper还有更多高级功能，比如临时节点、顺序节点等。此外，ZooKeeper还用于分布式锁、配置管理等场景，使得分布式系统的管理和协调变得更加可靠和简单。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/80270766.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/80270766.html" class="post-title-link" itemprop="url">Zookeeper分布式配置中心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:13:10 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:13:10+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>381</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实现分布式锁是 ZooKeeper 的一个常见应用场景。下面是一个使用 ZooKeeper 实现分布式锁的简单示例，基于 <code>curator</code> 库。</p>
<p>示例代码假设你的项目中引入了 <code>curator</code> 依赖。注意，这个示例只是一个基本的演示，实际生产环境中还需要考虑更多的异常处理、超时控制、死锁处理等情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockPath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedLock</span><span class="params">(String connectString, String lockPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = CuratorFrameworkFactory.newClient(connectString, <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">        <span class="built_in">this</span>.lockPath = lockPath;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, lockPath);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lock.acquire(timeout, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        CloseableUtils.closeQuietly(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;localhost:2181&quot;</span>;  <span class="comment">// ZooKeeper连接地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockPath</span> <span class="operator">=</span> <span class="string">&quot;/myApp/lock&quot;</span>;          <span class="comment">// 锁节点路径</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedLock</span>(connectString, lockPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (distributedLock.acquireLock(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Lock acquired. Doing critical section work...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Failed to acquire lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            distributedLock.releaseLock();</span><br><span class="line">            distributedLock.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>DistributedLock</code> 类封装了分布式锁的基本功能。通过 <code>acquireLock</code> 方法尝试获取锁，在锁获取成功后进入临界区执行工作。<code>releaseLock</code> 方法用于释放锁。</p>
<p>需要注意的是，这只是一个基本的分布式锁实现示例。在实际应用中，你可能需要考虑更复杂的锁策略、超时控制、处理异常情况等。同时，ZooKeeper 还支持其他类型的分布式锁，如 <code>InterProcessSemaphoreMutex</code>、<code>InterProcessReadWriteLock</code> 等，你可以根据需求选择合适的锁类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/7b1c422a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7b1c422a.html" class="post-title-link" itemprop="url">Zookeeper分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-14 23:12:49 / 修改时间：23:28:31" itemprop="dateCreated datePublished" datetime="2023-08-14T23:12:49+08:00">2023-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>447</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分布式配置中心是ZooKeeper的一个常见应用场景，它允许在分布式系统中集中管理配置信息，使得配置的变更能够实时生效，而无需重新部署应用。下面是一个简单的Java代码示例，展示了如何使用ZooKeeper来实现一个基本的分布式配置中心。</p>
<p>示例代码基于<code>curator</code>库来实现，确保你的项目中引入了<code>curator</code>的依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedConfigCenter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String configPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedConfigCenter</span><span class="params">(String connectString, String configPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = CuratorFrameworkFactory.newClient(connectString, <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">        <span class="built_in">this</span>.configPath = configPath;</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = client.getData().forPath(configPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchConfigChanges</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, configPath);</span><br><span class="line">        nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData());</span><br><span class="line">                System.out.println(<span class="string">&quot;Config changed: &quot;</span> + newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        nodeCache.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        CloseableUtils.closeQuietly(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;localhost:2181&quot;</span>;  <span class="comment">// ZooKeeper连接地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configPath</span> <span class="operator">=</span> <span class="string">&quot;/myApp/config&quot;</span>;      <span class="comment">// 配置节点路径</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DistributedConfigCenter</span> <span class="variable">configCenter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedConfigCenter</span>(connectString, configPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> configCenter.getConfigValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;Initial config value: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听配置变更</span></span><br><span class="line">        configCenter.watchConfigChanges();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟配置变更</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        configCenter.client.setData().forPath(configPath, <span class="string">&quot;newConfigValue&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        configCenter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>DistributedConfigCenter</code>类封装了配置中心的基本功能。通过<code>getConfigValue</code>方法获取配置值，通过<code>watchConfigChanges</code>方法监听配置变更。在示例的<code>main</code>方法中，首先创建一个ZooKeeper客户端并初始化配置中心，然后获取初始配置值，并监听配置变更。当配置发生变化时，会输出新的配置值。</p>
<p>请注意，这只是一个简单的示例，实际项目中还需要考虑更多的异常处理、线程安全、定时刷新等问题。同时，还可以根据具体需求扩展更多的功能，如支持不同环境的配置、配置权限控制等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">359</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">324k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:37</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
