<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="问题解析26 | 备库为什么会延迟好几个小时？2019-01-11 林晓斌 在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是 偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都 能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级 别。而且对于一个压力持续比较高的主库来说，备库很可能永">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql-备库为什么会延迟好几个小时">
<meta property="og:url" content="https://www.fastolf.com/posts/8e19404c.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="问题解析26 | 备库为什么会延迟好几个小时？2019-01-11 林晓斌 在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是 偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都 能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级 别。而且对于一个压力持续比较高的主库来说，备库很可能永">
<meta property="og:locale">
<meta property="article:published_time" content="2019-11-30T22:09:43.000Z">
<meta property="article:modified_time" content="2023-01-06T09:44:03.239Z">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/posts/8e19404c.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>mysql-备库为什么会延迟好几个小时 | Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/8e19404c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql-备库为什么会延迟好几个小时
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 06:09:43" itemprop="dateCreated datePublished" datetime="2019-12-01T06:09:43+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>26 | 备库为什么会延迟好几个小时？2019-01-11 林晓斌</p>
<p>在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是</p>
<p>偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都</p>
<p>能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级</p>
<p>别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。这就涉及到今天我要给你介绍的话题：备库并行复制能力。为了便于你理解，我们再一起看一下第24篇文章《MySQL是怎么保证主备一致的？》的主备流</p>
<p>程图。图1 主备流程图</p>
<p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主</p>
<p>库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表</p>
<p>并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都</p>
<p>在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性</p>
<p>能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的</p>
<p>话，就会导致备库应用日志不够快，造成主备延迟。在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重</p>
<p>的主备延迟问题。从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说</p>
<p>MySQL多线程复制的演进过程。其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线</p>
<p>程，也就是都符合下面的这个模型：</p>
<p>图2 多线程模型</p>
<p>图2中，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日</p>
<p>志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数</p>
<p>slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的</p>
<p>情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个</p>
<p>事务分给worker_1，第二个事务发给worker_2呢？其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU</p>
<p>的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的</p>
<p>是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不</p>
<p>一致的问题。接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker</p>
<p>来执行呢？答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分</p>
<p>到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个</p>
<p>查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。2. 同一个事务不能被拆开，必须放到同一个worker中。各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策</li>
</ol>
<p>略。MySQL 5.5版本的并行复制策略</p>
<p>官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了</p>
<p>严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解</p>
<p>MySQL官方版本并行复制策略的迭代。按表分发策略</p>
<p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在</p>
<p>表里的，所以按表分发，可以保证两个worker不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规</p>
<p>则。图3 按表并行复制程模型</p>
<p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事</p>
<p>务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这</p>
<p>个表。在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这</p>
<p>个表会被从hash表中去掉。图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，</p>
<p>有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数</p>
<p>据。假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表</p>
<p>t1和t3。现在我们用事务T的分配流程，来看一下分配规则。1. 由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事</p>
<p>务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。2. 按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲</p>
<p>突。3. 事务T跟多于一个worker冲突，coordinator线程就进入等待。4. 每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务</p>
<p>先执行完成，就会从hash_table_2中把db1.t3这一项去掉。5. 这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给</p>
<p>worker_1。6. coordinator继续读下一个中转日志，继续分配事务。也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p>
<ol>
<li><p>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</p>
</li>
<li><p>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关</p>
</li>
</ol>
<p>系的worker只剩下1个；</p>
<ol start="3">
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的</li>
</ol>
<p>worker。这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如</p>
<p>所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单</p>
<p>线程复制了。按行分发策略</p>
<p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果</p>
<p>两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须</p>
<p>是row。这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改</p>
<p>同一行”。按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按</p>
<p>行分发，这时候的key，就必须是“库名+表名+唯一键的值”。但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，</p>
<p>还有唯一索引a：</p>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<p>图4 唯一键冲突示例</p>
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能</p>
<p>session B的语句先执行。这时候id&#x3D;1的行的a的值还是1，就会报唯一键冲突。因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字</p>
<p>+a的值”。比如，在上面这个例子中，我要在表t1上执行update t1 set a&#x3D;1 where id&#x3D;2语句，在binlog里面</p>
<p>记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p>
<ol>
<li>key&#x3D;hash_func(db1+t1+“PRIMARY”+2), value&#x3D;2; 这里value&#x3D;2是因为修改前后的行id值不</li>
</ol>
<p>变，出现了两次。2. key&#x3D;hash_func(db1+t1+“a”+2), value&#x3D;1，表示会影响到这个表a&#x3D;2的行。3. key&#x3D;hash_func(db1+t1+“a”+1), value&#x3D;1，表示会影响到这个表a&#x3D;1的行。可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的</p>
<p>计算资源。你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必</li>
</ol>
<p>CREATE TABLE t̀1  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;a  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;b  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  UNIQUE KEY &#96;a  ̀(̀ a )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);</p>
<p>须是row；</p>
<ol start="2">
<li><p>表必须有主键；</p>
</li>
<li><p>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准</p>
</li>
</ol>
<p>确。但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所</p>
<p>以这两个并行复制策略在应用上也没有碰到什么麻烦。对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很</p>
<p>多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。2. 耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如</li>
</ol>
<p>果单个事务更新的行数超过10万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样</p>
<p>的：</p>
<ol>
<li><p>coordinator暂时先hold住这个事务；</p>
</li>
<li><p>等待所有worker都执行完成，变成空队列；</p>
</li>
<li><p>coordinator直接执行这个事务；</p>
</li>
<li><p>恢复并行模式。读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其</p>
</li>
</ol>
<p>实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。MySQL 5.6版本的并行复制策略</p>
<p>官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分</p>
<p>发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使</p>
<p>用这个策略的效果会很好。相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构</li>
</ol>
<p>造100万个项这种情况。2. 不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的</p>
<p>热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。MariaDB的并行复制策略</p>
<p>在第23篇文章中，我给你介绍了redo log组提交(group commit)优化， 而MariaDB的并行复制策</p>
<p>略利用的就是这个特性：</p>
<ol>
<li><p>能够在同一组里提交的事务，一定不会修改同一行；</p>
</li>
<li><p>主库上可以并行执行的事务，备库上也一定是可以并行执行的。在实现上，MariaDB是这么做的：</p>
</li>
<li><p>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</p>
</li>
<li><p>commit_id直接写到binlog里面；</p>
</li>
<li><p>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</p>
</li>
<li><p>这一组全部执行完成后，coordinator再去取下一批。当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到</p>
</li>
</ol>
<p>worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组</p>
<p>事务在commit的时候，下一组事务是同时处于“执行中”状态的。如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时</p>
<p>候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进</p>
<p>入commit状态。图5 主库并行事务</p>
<p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。图6 MariaDB 并行复制，备库并行效果</p>
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，</p>
<p>这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时</p>
<p>候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有</p>
<p>一个worker线程在工作，是对资源的浪费。不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很</p>
<p>优雅。MySQL 5.7的并行复制策略</p>
<p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-</p>
<p>parallel-type来控制并行复制策略：</p>
<ol>
<li><p>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</p>
</li>
<li><p>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策</p>
</li>
</ol>
<p>略，针对并行度做了优化。这个优化的思路也很有趣儿。你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？答案是，不能。因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同</p>
<p>的worker，就会出现备库跟主库不一致的情况。而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于</p>
<p>commit状态，表示已经通过了锁冲突的检验了。这时候，你可以再回顾一下两阶段提交，我把前面第23篇文章中介绍过的两阶段提交过程图贴</p>
<p>过来。图7 两阶段提交细化过程图</p>
<p>其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突</p>
<p>的检验了。因此，MySQL 5.7并行复制策略的思想是：</p>
<ol>
<li><p>同时处于prepare状态的事务，在备库执行时是可以并行的；</p>
</li>
<li><p>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p>
</li>
<li><p>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</p>
</li>
<li><p>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL</p>
</li>
</ol>
<p>5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了</p>
<p>备库复制的并行度。也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL</p>
<p>5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。MySQL 5.7.22的并行复制策略</p>
<p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于</p>
<p>WRITESET的并行复制。相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策</p>
<p>略。这个参数的可选值有以下三种。1. COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可</p>
<p>以并行的策略。2. WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合</p>
<p>writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并</p>
<p>行。3. WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程</p>
<p>先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了</p>
<p>有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增</p>
<p>加一个hash值。你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不</p>
<p>过，MySQL官方的这个实现还是有很大的优势：</p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析</li>
</ol>
<p>binlog内容（event里的行数据），节省了很多计算量；</p>
<ol start="2">
<li><p>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</p>
</li>
<li><p>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化</p>
</li>
</ol>
<p>为单线程模型。小结</p>
<p>在今天这篇文章中，我和你介绍了MySQL的各种多线程复制策略。为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大</p>
<p>的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值</p>
<p>越来越大。在介绍完每个并行复制策略后，我还和你分享了不同策略的优缺点：</p>
<p>如果你是DBA，就需要根据不同的业务场景，选择不同的策略；</p>
<p>如果是你业务开发人员，也希望你能从中获取灵感用到平时的开发工作中。从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。官方MySQL5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上</p>
<p>兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。最后，我给你留下一个思考题吧。假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主</p>
<p>库搭建一个相同版本的备库。这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-</p>
<p>tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择</p>
<p>哪一个呢？你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？你可以把你的答案和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，什么情况下，备库的主备延迟会表现为一个45度的线段？评论区有不少同学的</p>
<p>回复都说到了重点：备库的同步在这段时间完全被堵住了。产生这种现象典型的场景主要包括两种：</p>
<p>一种是大事务（包括大表DDL、一个事务操作很多行）；</p>
<p>还有一种情况比较隐蔽，就是备库起了一个长事务，比如</p>
<p>然后就不动了。这时候主库对表t做了一个加字段操作，即使这个表很小，这个DDL在备库应用的时候也会被堵</p>
<p>住，也不能看到这个现象。评论区还有同学说是不是主库多线程、从库单线程，备库跟不上主库的更新节奏导致的？今天这</p>
<p>篇文章，我们刚好讲的是并行复制。所以，你知道了，这种情况会导致主备延迟，但不会表现为</p>
<p>这种标准的呈45度的直线。评论区留言点赞板：</p>
<p>begin; </p>
<p>select * from t limit 1;</p>
<p>@易翔 、 @万勇、@老杨同志 等同学的回复都提到了我们上面说的场景；</p>
<p>@Max 同学提了一个很不错的问题。主备关系里面，备库主动连接，之后的binlog发送是主库</p>
<p>主动推送的。之所以这么设计也是为了效率和实时性考虑，毕竟靠备库轮询，会有时间差。老杨同志   5</p>
<p>尝试回答 慧鑫coming 的问题。老师图片的步骤有下面5步</p>
<p>1 redo log prepare write</p>
<p>2 binlog write</p>
<p>3 redo log prepare fsync</p>
<p>4 binlog fsync</p>
<p>5 redo log commit write</p>
<p>1)如果更新通一条记录是有锁的，只能一个事务执行，其他事务等待锁。2)第4步的时候会因为下面两个参数，等其他没有锁冲突的事务，一起刷盘，此时一起执行的事</p>
<p>务拥有相同的commit_id</p>
<p>binlog_group_commit_sync_delay</p>
<p>binlog_group_commit_sync_no_delay_count</p>
<p>3)执行步骤5后，释放锁，等待锁的事务开始执行。所以对同一行更新的事务，不可能拥有相同的commit_id</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>精选留言</p>
<p> ，你比我回复得详细，顶起</p>
<p>2019-01-11</p>
<p>长杰   2</p>
<p>举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker </p>
<p>的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会</p>
<p>看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。老师这块不太明白，备库有查询会看到更新了一半的结果，t1的worker执行完了更新会commit</p>
<p>吗？如果不commit，备库查询应该看不到吧？如果commit，就破坏了事物的原子性，肯定是</p>
<p>有问题的。2019-01-11</p>
<p> 作者回复</p>
<p>应该是说，它迟早要commit，但是两个worker是两个线程，没办法约好“同时提交”，这样就有</p>
<p>可能出现一个先提交一个后提交。这两个提交之间的时间差，就能被用户看到“一半事务”，好问题</p>
<p>2019-01-11</p>
<p>jike   1</p>
<p>老师您好，开启并行复制后，事务是按照组来提交的，从库也是根据commit_id来回放，如果</p>
<p>从库也开启binlog的话，那是不是存在主从的binlog event写入顺序不一致的情况呢？2019-01-15</p>
<p> 作者回复</p>
<p>是有可能binlog event写入顺序不同的，好问题</p>
<p>2019-01-15</p>
<p>HuaMax   7</p>
<p>课后题。关键点在于主库单线程，针对三种不同的策略，COMMIT_ORDER：没有同时到达re</p>
<p>do log的prepare 状态的事务，备库退化为单线程；WRITESET：通过对比更新的事务是否存在</p>
<p>冲突的行，可以并发执行；WRITE_SESSION：在WRITESET的基础上增加了线程的约束，则</p>
<p>退化为单线程。综上，应选择WRITESET策略</p>
<p>2019-01-12</p>
<p> 作者回复</p>
<p>准确 </p>
<p>2019-01-12</p>
<p>慧鑫coming   2</p>
<p>老师，有个问题，mariadb的并行策略，当同一组中有3个事务，它们都对同一行同一字段值进</p>
<p>行更改，而它们的commit_id相同，可以在从库并行执行，那么3者的先后顺序是怎么保证不影</p>
<p>响该行该字段的最终结果与主库一致？2019-01-11</p>
<p> 作者回复</p>
<p>好问题</p>
<p>不过这个是不可能的哈，对同一行的修改，第一个拿到行锁的事务还没提交前，另外两个会被</p>
<p>行锁堵住的，这两个进入不了commit状态。所以这三个的commit_id不会相同的 </p>
<p>2019-01-11</p>
<p>IceGeek17   1</p>
<p>好文，总结对比不同的并行策略，讲的深入浅出，看完豁然开朗。有看源代码的冲动。2019-01-24</p>
<p> 作者回复</p>
<p>看完分享你的心得哈  </p>
<p>2019-01-24</p>
<p>每天晒白牙   1</p>
<p>我是做java的，看老师的这个专栏，确实挺吃力的，老师专栏的干货太多了，下面的留言也是</p>
<p>相当有水平，质量都很高，互动也好，应该是好多DBA吧，做java的我，看的头大</p>
<p>2019-01-13</p>
<p> 作者回复</p>
<p>这几篇偏深，但确实是大家在使用的时候需要了解的，</p>
<p>到30篇后面的文章会偏应用哈</p>
<p>2019-01-13</p>
<p>某、人   1</p>
<p>总结下多线程复制的流程,有不对之处请老师指出:</p>
<p>双1,配置为logical_clock,假设有三个事务并发执行也已经执行完成(都处于prepare阶段)</p>
<p>1.三个事务把redo log从redo log buffer写到fs page cache中</p>
<p>2.把binlog_cache flush到binlog文件中,最先进入flush队列的为leader,</p>
<p>其它两个事务为follower.把组员编号以及组的编号写进binlog文件中(三个事务为同一组).</p>
<p>3.三个事务的redo log做fsync,binlog做fsync.</p>
<p>4.dump线程从binlog文件里把binlog event发送给从库</p>
<p>5.I&#x2F;O线程接收到binlog event,写到relay log中</p>
<p>6.sql thread读取relay log,判断出这三个事务是处于同一个组,</p>
<p>则把这三个事务的event打包发送给三个空闲的worker线程(如果有)并执行。配置为writeset的多线程复制流程:</p>
<p>1.三个事务把redo log从redo log buffer写到fs page cache中</p>
<p>2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset),</p>
<p>保存到hash表中</p>
<p>判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.</p>
<p>并把把组员编号以及组的编号写进binlog文件中</p>
<p>(不过一个组的事务个数也不是无限大,由参数binlog_transaction_dependency_history_size决定</p>
<p>组内最多事务数)</p>
<p>3.然后做redo log和binlog的fsync</p>
<p>4.dump线程从binlog文件里把binlog event发送给从库</p>
<p>5.I&#x2F;O线程接收到binlog event,写到relay log中</p>
<p>6.sql thread读取relay log,如果是同一个组的事务,则把事务分配到不同的worker线程去应用relay</p>
<p>log.</p>
<p>不同组的事务,需要等到上一个组的事务全部执行完成,才能分配worker线程应用relay log.</p>
<p>老师我有几个问题想请教下:</p>
<p>1.在备库是单线程下,second_behind_master是通过计算T3-T1得到,</p>
<p>在多线程的情况下,是怎么计算出second_behind_master的值？用的是哪一个事务的时间戳?</p>
<p>2.多线程复制下,如果从库宕机了,是不是从库有一个记录表记录那些事务已经应用完成,</p>
<p>恢复的时候,只需要恢复未应用的事务.</p>
<p>3.binlog延迟sync的两个参数,是延迟已经flush未sync时间。意思是让事务组占用flush时间更长,</p>
<p>之后的事务有更多的时间,从binlog cache进入到flush队列,使得组员变多,起到从库并发的目的</p>
<p>因为我理解的是加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flus</p>
<p>h,</p>
<p>未sync,则后面的事务必须等待。不知道理解得对不</p>
<p>2019-01-13</p>
<p> 作者回复</p>
<p>上面的描述部分，writeset的多线程复制流程里面，这段需要修改下：</p>
<p>『2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset</p>
<p>),保存到hash表中</p>
<p>【判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.</p>
<p>并把把组员编号以及组的编号写进binlog文件中】』</p>
<p>上面中括号这段要去掉，</p>
<p>判断writeset之间是否可以并行这个逻辑，是在备库的coordinator线程做的。—-</p>
<ol>
<li><p>在多线程并发的时候，Seconds_behind_master很不准，后面会介绍别的判断方法；</p>
</li>
<li><p>是的,备库有记录，就是show slave status 里面的Relay_Log_File 和 Relay_Log_Pos 这两个</p>
</li>
</ol>
<p>值表示的，好问题</p>
<ol start="3">
<li>”加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flush,未sync,则</li>
</ol>
<p>后面的事务必须等待“ 这句话是对的，但是我没看出这个跟前面提的两个延迟参数作用的关系^</p>
<p>_^</p>
<p>2019-01-13</p>
<p>观弈道人   1</p>
<p>丁老师你好，问个题外问题，mysql已经通过gap锁解决了在rr级别下的幻读问题，那么serializa</p>
<p>ble隔离级别目前还有什么用途，一般文章上说的，serializable 主要是为了解决幻读，谢谢回答</p>
<p>。2019-01-12</p>
<p> 作者回复</p>
<p>serializable隔离级别确实用得很少（我没有见过在生产上使用的哈）</p>
<p>2019-01-12</p>
<p>J!   0</p>
<p>同时处于 prepare 状态的事务，在备库执行时是可以并行.复制的，是这个prepare 就可以生成</p>
<p>了改组的commited Id吗</p>
<p>极客时间版权所有: <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/77083">https://time.geekbang.org/column/article/77083</a></p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>进入prepare 的时候就给这个事务分配 commitid，这个commitid就是当前系统最大的一个com</p>
<p>mitid</p>
<p>2019-02-02</p>
<p>J!   0</p>
<p>5.7 版本的基于组提交的并行复制。last_commitid 是在什么时候生成的？2019-02-01</p>
<p> 作者回复</p>
<p>事务提交的时候</p>
<p>2019-02-02</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>老师您好：</p>
<p>思考题答案的猜测：建议采用 WRITESET。WRITESET_SESSION：因为主库是单线程插入，如果采用WRITESET_SESSION，那么会退</p>
<p>化成单线程主从复制。COMMIT_ORDER：因为是追历史数据，所以会退化成单线程。2019-02-01</p>
<p> 作者回复</p>
<p>对的， </p>
<p>2019-02-02</p>
<p>时隐时现   0</p>
<p>Furthermore, given that changes are propagated and applied in row-based format, this means t</p>
<p>hat they are received in an optimized and compact format, and likely reducing the number of IO </p>
<p>operations required when compared to the originating member.</p>
<p>这个是官档上对MGR的一段解读，我的疑问是：</p>
<p>为何row-base replication在从库回放时会节省大量IO？候选答案：</p>
<p>1、省去了sql解析，直接调用do_command</p>
<p>2、？？可是row复制有其他可能存在的劣势，比如单个大dml会被解析成多个dml_event进行重放，万</p>
<p>一该表没有主键或唯一索引，只能采用二级索引或者全表扫描(开启hash_scan也可以)，所以，</p>
<p>官档上直接说会减少大量IO是不是有点太武断了</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>这个描述应该是主要考虑在有主键的时候，可以通过row里面的信息取出主键直接定位记录。你说的这些其实劣势确实也是存在的  </p>
<p>2019-01-31</p>
<p>牛牛   0</p>
<p>老师、请教两个问题～</p>
<ol>
<li>我在job里按主键删除线上表数据的时候、造成了主从延迟、delete from table where id in…</li>
</ol>
<p>id是主键、每次delete 300条、sleep 500ms、这种延迟可能是什么造成的呢？300条应该不算大</p>
<p>事务？还是说快速的数据删除导致了索引重建？2. 如果一个表快速往里写数据、每次300条、sleep 1s、这个库上的读取会慢吗？多谢老师 ～</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<ol>
<li>delete 300条 ， sleep 500ms已经是很克制的操作了，单线程吗？如果还是单线程，那延迟</li>
</ol>
<p>应该不是这个操作导致的</p>
<ol start="2">
<li>这都是很小的压力，不会读取慢才对</li>
</ol>
<p>2019-02-01</p>
<p>Leon    0</p>
<p>老师，semisync啥时候讲下，昨天面试被问到一脸懵逼</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>semi-sync在第28篇会提到，但是也不是大篇幅介绍</p>
<p>后面可能也不会大篇幅专门介绍了，你说下你的问题哈。2019-01-22</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>关于COMMIT_ORDER的并行复制方案，从库根据 commit_id来判断“处于prepare和commit状</p>
<p>态的事务”。这里我有个很大的疑惑：commit_id是什么时候加入到binlog的，又是在什么时候递</p>
<p>增的？？（</p>
<p>对于我这个问题的进一步解释：</p>
<p>既然commit_id是要被写入到binlog的，那么commit_id毫无疑问就是在write binlog阶段写入的</p>
<p>。我们知道redolog是组提交的，如果只是按照redolog的组提交方式生成commit_id，那么这个co</p>
<p>mmit_id包含的并行事务数量并不够多！因为在binlog write阶段，又有事务进入到redolog prepa</p>
<p>re阶段，他们之间的commit_id是不一样的，但是他们是可以并行的。所以commit_id什么时候递增？这个是非常关键的，我也很疑惑，commit_id到底是根据什么条</p>
<p>件递增的？？）</p>
<p>2019-01-17</p>
<p> 作者回复</p>
<p>可以这么理解，每个事务都有两个数字表示它在执行提交阶段的时间范围, 构成区间(c1, c2).</p>
<p>如果两个事务的区间有交集，就是可以并行的。这里c1是事务启动的时候，当前系统里最大的commit_id；</p>
<p>一个事务提交的时候，commit_id+1.</p>
<p>2019-01-17</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>今天的内容中写到：“外键约束”会导致并行复制退化为单线程。这个地方我就突然联想到，在业务中，类似于“外键”这种关系是一定存在的。但是一般在设计</p>
<p>表的时候，比如：表A的某个唯一键是表B的外键。并不会真正”显示”的在数据库表中创建外键</p>
<p>关系。（查询的时候，查询出A的这个唯一键，然后再根据这个唯一键查询表B的数据，并不会</p>
<p>有真正的外键关系，一次性查出所有关联数据）</p>
<p>这是为什么呢？2019-01-17</p>
<p> 作者回复</p>
<p>我也建议尽量少使用外键，我自己理解的几个原因吧</p>
<ol>
<li><p>这个关系应该维护在开发系统的逻辑中，放在数据库里面，比较隐蔽，容易忘记</p>
</li>
<li><p>外键约束可能会导致有些更新失败</p>
</li>
<li><p>外键约束（尤其是级联更新）容易出现非预期的结果</p>
</li>
</ol>
<p>2019-01-17</p>
<p>亢星东   0</p>
<p>老师好，如何将大事务拆成小事务</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>这个是要结合业务的，比如要删除100万行，改成100个事务，每个事务删除1万行，这样的</p>
<p>2019-01-16</p>
<p>道   0</p>
<p>老师，这段不太理解：“举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新</p>
<p>语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，</p>
<p>备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。”备库</p>
<p>上的查询属于另外一个事务，按照可重复读隔离级别，这个查询不应该看到另外一个事务“更新</p>
<p>了一半的结果”啊。即便是这两条更新语句被分到不同 worker ，也应该保证事务的原子性啊，</p>
<p>难道是技术上有困难吗？2019-01-16</p>
<p> 作者回复</p>
<p>因为这两个worker没办法“约好一起提交”，这个是属于两个线程了</p>
<p>2019-01-16</p>
<p>crazyone   0</p>
<p>“不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁</p>
<p>冲突的检验了。”这句话不怎么理解。事务获取锁是在执行到对应的语句才做检查的，redo log</p>
<p>在事务当中，应该也是一条条操作语句写的吧？难道写完了，才会进入到prepare阶段？这个pr</p>
<p>epare阶段是指事务已经完全扫描执行完所有事务操作，准备写入到redo log文件的阶段?</p>
<p>2019-01-15</p>
<p> 作者回复</p>
<p>就是两阶段提交里的，写redo 的第一阶段</p>
<p>2019-01-16</p>
<pre><code>
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/9d443267.html" rel="prev" title="mysql-MySQL是怎么保证高可用的">
      <i class="fa fa-chevron-left"></i> mysql-MySQL是怎么保证高可用的
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/fc93d163.html" rel="next" title="mysql-主库出问题了从库怎么办">
      mysql-主库出问题了从库怎么办 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">问题解析</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">342</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:40</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
