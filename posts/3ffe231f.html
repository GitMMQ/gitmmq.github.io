<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fastolf.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="问题解析31 | 误删数据后除了跑路，还能怎么办？2019-01-23 林晓斌 今天我要和你讨论的是一个沉重的话题：误删数据。在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误 删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整 个集群的实例都会执行这个命令。虽然我们之前遇到的大多数的数据被删，都是运维同学或者">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql-误删数据后除了跑路还能怎么办">
<meta property="og:url" content="https://www.fastolf.com/posts/3ffe231f.html">
<meta property="og:site_name" content="Qi">
<meta property="og:description" content="问题解析31 | 误删数据后除了跑路，还能怎么办？2019-01-23 林晓斌 今天我要和你讨论的是一个沉重的话题：误删数据。在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误 删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整 个集群的实例都会执行这个命令。虽然我们之前遇到的大多数的数据被删，都是运维同学或者">
<meta property="og:locale">
<meta property="article:published_time" content="2019-12-05T22:02:07.000Z">
<meta property="article:modified_time" content="2023-01-06T09:44:03.227Z">
<meta property="article:author" content="Meng Qi">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fastolf.com/posts/3ffe231f.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <title>mysql-误删数据后除了跑路还能怎么办 | Qi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
<a target="_blank" rel="noopener" href="https://github.com/gitmmq" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito ergo sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fastolf.com/posts/3ffe231f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Meng Qi">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql-误删数据后除了跑路还能怎么办
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 06:02:07" itemprop="dateCreated datePublished" datetime="2019-12-06T06:02:07+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:44:03" itemprop="dateModified" datetime="2023-01-06T17:44:03+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>31 | 误删数据后除了跑路，还能怎么办？2019-01-23 林晓斌</p>
<p>今天我要和你讨论的是一个沉重的话题：误删数据。在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误</p>
<p>删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整</p>
<p>个集群的实例都会执行这个命令。虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数</p>
<p>据操作权限的同学，都有可能踩到误删数据这条线。今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来</p>
<p>的损失。为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p>
<ol>
<li><p>使用delete语句误删数据行；</p>
</li>
<li><p>使用drop table或者truncate table语句误删数据表；</p>
</li>
<li><p>使用drop database语句误删数据库；</p>
</li>
<li><p>使用rm命令误删整个MySQL实例。误删行</p>
</li>
</ol>
<p>在第24篇文章中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪</p>
<p>回把数据恢复回来。Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提</p>
<p>是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event</li>
</ol>
<p>即可；</p>
<ol start="2">
<li><p>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</p>
</li>
<li><p>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的</p>
</li>
</ol>
<p>位置即可。如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务：</p>
<p>现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库</p>
<p>的命令是：</p>
<p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要说明的是，我不建议你直接在主库上执行这些操作。恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执</p>
<p>行这些操作，然后再将确认过的临时库的数据，恢复回主库。为什么要这么做呢？这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问</p>
<p>题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数</p>
<p>据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破</p>
<p>(A)delete …</p>
<p>(B)insert …</p>
<p>(C)update …</p>
<p>(reverse C)update …</p>
<p>(reverse B)delete …</p>
<p>(reverse A)insert …</p>
<p>坏。当然，我们不止要说误删数据的事后处理办法，更重要是要做到事前预防。我有以下两个建</p>
<p>议：</p>
<ol>
<li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写</li>
</ol>
<p>where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。2. 代码上线前，必须经过SQL审计。你可能会说，设置了sql_safe_updates&#x3D;on，如果我真的要把一个小表的数据全部删掉，应该怎</p>
<p>么办呢？如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id&gt;&#x3D;0。但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，</p>
<p>你应该优先考虑使用truncate table或者drop table命令。使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate &#x2F;drop table和drop</p>
<p>database命令删除的数据，就没办法通过Flashback来恢复了。为什么呢？这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是</p>
<p>statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？误删库&#x2F;表</p>
<p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有</p>
<p>定期的全量备份，并且实时备份binlog。在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li><p>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</p>
</li>
<li><p>用备份恢复出一个临时库；</p>
</li>
<li><p>从日志备份里面，取出凌晨0点之后的日志；</p>
</li>
<li><p>把这些日志，除了误删除数据的语句外，全部应用到临时库。这个流程的示意图如下所示：</p>
</li>
</ol>
<p>图1 数据恢复流程-mysqlbinlog方法</p>
<p>关于这个过程，我需要和你说明如下几点：</p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加</li>
</ol>
<p>上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用</p>
<p>其他库日志的情况。2. 在应用日志的时候，需要跳过12点误操作的那个语句的binlog：</p>
<p>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–</p>
<p>stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日</p>
<p>志继续执行；</p>
<p>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要</p>
<p>执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后</p>
<p>按顺序执行binlog的时候，就会自动跳过误操作的语句。不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工</li>
</ol>
<p>具并不能指定只解析一个表的日志；</p>
<ol start="2">
<li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在第26篇文章中介</li>
</ol>
<p>绍的那些并行复制的方法，在这里都用不上。一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，</p>
<p>这样：</p>
<ol>
<li>在start slave之前，先通过执行</li>
</ol>
<p>change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以让临时库只同步误操</p>
<p>作的表；</p>
<ol start="2">
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。这个过程的示意图如下所示。图2 数据恢复流程-master-slave方法</li>
</ol>
<p>可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删</p>
<p>除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库</p>
<p>中。假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show</p>
<p>binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就</p>
<p>需要去binlog备份系统中找到这两个文件。把之前删掉的binlog放回备库的操作步骤，是这样的：</p>
<ol>
<li><p>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</p>
</li>
<li><p>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是</p>
</li>
</ol>
<p>“.&#x2F;master.000005”和“.&#x2F;master.000006”;</p>
<ol start="3">
<li><p>重启备库，目的是要让备库重新识别这两个日志文件；</p>
</li>
<li><p>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个</p>
</li>
</ol>
<p>方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方</p>
<p>式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除</p>
<p>之前已经做了备份。但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留</p>
<p>的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就</p>
<p>表示备份系统保留的日志时间就至少是半个月。另外，我建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿</p>
<p>出来演练。为什么这么说呢？这里的原因，主要包括两个方面：</p>
<ol>
<li>虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失</li>
</ol>
<p>降到最小，也应该不用跑路了。2. 而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过</p>
<p>去了。延迟复制备库</p>
<p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可</p>
<p>控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的</p>
<p>实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天</p>
<p>来计算的。那么，我们有什么方法可以缩短恢复数据需要的时间呢？如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑搭建延迟复制的备库。这个功</p>
<p>能是MySQL 5.6版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有</p>
<p>从库，进而导致所有从库的数据表也都一起被误删了。延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，</p>
<p>可以指定这个备库持续保持跟主库有N秒的延迟。比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误</p>
<p>操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop</p>
<p>slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也</p>
<p>就缩短了整个数据恢复需要的时间。预防误删库&#x2F;表的方法</p>
<p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你</p>
<p>一些减少误删操作风险的建议。第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p>
<p>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需</p>
<p>求的话，也可以通过开发管理系统得到支持。即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账</p>
<p>号。第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p>
<p>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后</p>
<p>再删除这张表。改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须</p>
<p>通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。rm删除数据</p>
<p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意</p>
<p>地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一</p>
<p>个新的主库，从而保证整个集群的正常工作。这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批</p>
<p>量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。小结</p>
<p>今天，我和你讨论了误删数据的几种可能，以及误删后的处理方法。但，我要强调的是，预防远比处理的意义来得大。另外，在MySQL的集群方案中，会时不时地用到备份来恢复实例，因此定期检查备份的有效性</p>
<p>也很有必要。如果你是业务开发同学，你可以用show grants命令查看账户的权限，如果权限过大，可以建议</p>
<p>DBA同学给你分配权限低一些的账号；你也可以评估业务的重要性，和DBA商量备份的周期、</p>
<p>是否有必要创建延迟复制的备库等等。数据和服务的可靠性不止是运维团队的工作，最终是各个环节一起保障的结果。今天的课后话题是，回忆下你亲身经历过的误删数据事件吧，你用了什么方法来恢复数据呢？你</p>
<p>在这个过程中得到的经验又是什么呢？你可以把你的经历和经验写在留言区，我会在下一篇文章的末尾选取有趣的评论和你一起讨论。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章给你留的问题，是关于空表的间隙的定义。一个空表就只有一个间隙。比如，在空表上执行：</p>
<p>这个查询语句加锁的范围就是next-key lock (-∞, supremum]。验证方法的话，你可以使用下面的操作序列。你可以在图4中看到显示的结果。begin;</p>
<p>select * from t where id&gt;1 for update;</p>
<p>图3 复现空表的next-key lock</p>
<p>图4 show engine innodb status 部分结果</p>
<p>评论区留言点赞板：</p>
<p>赞这些思考和反馈。@老杨同志 给出了正确的分析和SQL语句验证方法；</p>
<p>@库淘淘 指出了show engine innodb status验证结论。苍茫   3</p>
<p>有一次，我维护一张表，需要手动修改大量数据的状态，sql就很多，然后我保存到txt文件中以</p>
<p>附件的形式发给部门老大审批，部门老大审批后转发邮件给运维，然后运维这哥们用的是360</p>
<p>浏览器，他预览的sql，然后全部复制到客户端执行，但是问题也在这，360浏览器预览的时候</p>
<p>由于文本偏长，到了某一条语句只有前半部分的update语句，没有后面的条件，然后就悲剧了</p>
<p>。全表的状态都变成同一个。然后我就特别莫名其妙，还被老大批了一顿。说我写的脚本有问</p>
<p>题。这锅我可不背，我把脚本在本地备份库跑了一遍又一遍就是没有问题。然后我再去运维哥</p>
<p>们那，叫他再复制一下脚本就发现问题了。好在执行脚本前进行了表备份。扩展一下，如果你</p>
<p>用谷歌浏览器就不会出现这种问题！发现问题后，立马恢复了数据</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>  这个是血泪经验</p>
<p>拷贝文本执行，这个操作还可能存在字符集隐患。这个事情更深一层逻辑，是你做了创造性的事情，非常优秀 。而这个运维同学认为他只是一个”复制粘贴执行的人”， 这种思路下是迟早会出问题的。2019-01-24</p>
<p>linhui0705   1</p>
<p>对生产数据库操作，公司DBA提出的编写脚本方法，个人觉得还是值得分享，虽说可能大部分</p>
<p>公司也可能有这样的规范。修改生产的数据，或者添加索引优化，都要先写好四个脚本：备份脚本、执行脚本、验证脚本</p>
<p>和回滚脚本。备份脚本是对需要变更的数据备份到一张表中，固定需要操作的数据行，以便误</p>
<p>操作或业务要求进行回滚；执行脚本就是对数据变更的脚本，为防Update错数据，一般连备份</p>
<p>表进行Update操作；验证脚本是验证数据变更或影响行数是否达到预期要求效果；回滚脚本就</p>
<p>是将数据回滚到修改前的状态。虽说分四步骤写脚本可能会比较繁琐，但是这能够很大程度避免数据误操作。2019-01-23</p>
<p> 作者回复</p>
<p>  非常好的经验</p>
<p>如果能够切实执行，即使有出问题，也是可以很快恢复的</p>
<p>把这些脚本当做开发代码来维护，是一个很好的实践</p>
<p>2019-01-23</p>
<p>某、人   9</p>
<p>总结下今天的知识点:</p>
<p>我觉得DBA的最核心的工作就是保证数据的完整性</p>
<p>今天老师也讲到了先要做好预防,预防的话大概是通过这几个点：</p>
<p>1.权限控制与分配(数据库和服务器权限)</p>
<p>精选留言</p>
<p>2.制作操作规范</p>
<p>3.定期给开发进行培训</p>
<p>4.搭建延迟备库</p>
<p>5.做好sql审计,只要是对线上数据有更改操作的语句(DML和DDL)都需要进行审核</p>
<p>6.做好备份。备份的话又分为两个点.</p>
<p>(1)如果数据量比较大,用物理备份xtrabackup。定期对数据库进行全量备份,也可以做增量备份。(2)如果数据量较少,用mysqldump或者mysqldumper。再利用binlog来恢复或者搭建主从的方式</p>
<p>来恢复数据。定期备份binlog文件也是很有必要的</p>
<p>还需要定期检查备份文件是否可用,如果真的发生了误操作,需要恢复数据的时候,发生备份文件</p>
<p>不可用,那就更悲剧了</p>
<p>如果发生了数据删除的操作,又可以从以下几个点来恢复:</p>
<p>1.DML误操作语句造成数据不完整或者丢失。可以通过flashback,不过我们目前用的是美团的m</p>
<p>yflash,也是一个不错的工具，本质都差不多.都是先解析binlog event,然后在进行反转。把delete</p>
<p>反转为insert,insert反转为delete,update前后image对调。所以必须设置binlog_format&#x3D;row 和 bi</p>
<p>nlog_row_image&#x3D;full.</p>
<p>切记恢复数据的时候,应该先恢复到临时的实例,然后在恢复回主库上。2.DDL语句误操作(truncate和drop),由于DDL语句不管binlog_format是row还是statement.在binl</p>
<p>og里都只记录语句,不记录image所以恢复起来相对要麻烦得多。只能通过全量备份+应用binlog</p>
<p>的方式来恢复数据。一旦数据量比较大,那么恢复时间就特别长,</p>
<p>对业务是个考验。所以就涉及到老师在第二讲提到的问题了，全量备份的周期怎么去选择</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-23</p>
<p>亮   2</p>
<p>CREATE TABLE <code>t</code> (</p>
<p><code>id</code> int(11) NOT NULL,</p>
<p><code>city</code> varchar(16) NOT NULL,</p>
<p><code>name</code> varchar(16) NOT NULL,</p>
<p><code>age</code> int(11) NOT NULL,</p>
<p><code>addr</code> varchar(128) DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>city</code> (<code>city</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>老师请教您16章的问题，您提到“city、name、age 这三个字段的定义总长度是36”，这个是怎</p>
<p>么算出来的呢，varchar(16)是可以保存16个字符，占用了49个字节（utf8），所以我没想明白3</p>
<p>6是怎么来的。第二个问题是max_length_for_sort_data参数系统默认是1024，是1024个字节的意思吗？2019-01-23</p>
<p>  作者回复</p>
<ol>
<li><p>age(11)其实是4个字节哈</p>
</li>
<li><p>对，单位是字节</p>
</li>
</ol>
<p>谢谢老师，不过还是没明白，age是4个字节，city和name分别是49个字节，49+49+4&#x3D;102字节</p>
<p>，36是怎么来的呢？再次感谢</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>哦 抱歉哈，我这边验证的时候默认用的latin1，是16+16+4</p>
<p>2019-01-23</p>
<p>技术人成长   1</p>
<p>我只想说，作者功力过于深厚了！</p>
<p>2019-01-25</p>
<p>Cranliu   1</p>
<p>个人觉得，预防同样很重要，一般的dml操作，我是先ctas要操作的数据，drop&#x2F;truncate 的时候</p>
<p>先逻辑备份。2019-01-23</p>
<p> 作者回复</p>
<p>对的，备份的意识很重要。不过“drop&#x2F;truncate 的时候先逻辑备份”这么做的不多^_^ </p>
<p>主要的原因是逻辑备份可能会对系统有额外消耗。（全表扫描）</p>
<p>2019-01-23</p>
<p>511   1</p>
<p>早~</p>
<p>2019-01-23</p>
<p>Long   0</p>
<p>又到了讲故事(事故)的时候了，历史上遇到过很多次事故。全表误删除，误更新不下于8次，有</p>
<p>MySQL 的DB也有memory DB. 有一次同事比较搞笑的是，有一次一张重要的权限控制表更新</p>
<p>，由于用的是workbench 界面工具当时写了where条件，但是在选中执行行的时候where条件在</p>
<p>第二行，没选中，还在执行前的时候手动把session 级的sql_safe_updates&#x3D;0了，也没有点开那</p>
<p>个autocommit取消的按钮。然后一执行，全表更新了，导致全网只有一个用户可以正常登录。还有其他的误操作，总结历史遇到过的这类问题基本就是几类</p>
<ol>
<li>登错环境，以为是测试环境，一顿操作猛如虎，一看环境是生产，回头一看，表已经drop了</li>
</ol>
<p>……</p>
<ol start="2">
<li>sql写的有问题，逻辑错误，或者条件缺失，常见的如不带where；or关键字的逻辑没有用括</li>
</ol>
<p>号括好</p>
<ol start="3">
<li>还有一些奇葩的，比如where 字段1&#x3D;字段2写成了字段1+字段2，逻辑等于判断变成了是否为</li>
</ol>
<p>1的判断了，大概率全表更新了。错误解决大部分都是用备份恢复或者根据错误的逻辑来逻辑恢复。还有一个，最近在尝试的，就是ibd文件中有坏页，只要一读到那个坏页，就会crash，报错spa</p>
<p>ceid page no should be多少多少，尝试了copy frm, ibd，ibdata, iblogfile这些表结构，数据文件</p>
<p>，数据字典，undo redo 日志，也尝试用了undrop的工具也解析不出来。这个表比较特殊，是</p>
<p>一个特殊库，没备份，表没有索引没法通过走索引跳过那个坏页的那些行，现在的状态是，只</p>
<p>能用nysqldump恢复一部分数据。 我想通过16进制，自己慢慢找到那个脏写的数据，然后修改</p>
<p>一下文件……</p>
<p>老师有什么比较好的建议吗？或者后面会说到ibd文件的物理结构之类的吗？ 感谢</p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p>感谢你的分享，都是血泪教训。。我看有几个是用的可视化工具导致的，后面还是尽量用MySQL客户端敲命令吧 </p>
<p>ibd文件坏页我之前有回答过其他同学的，看下这个</p>
<p><a target="_blank" rel="noopener" href="https://weibo.com/1933424965/H3qIu0JYo?from=page_1005051933424965_profile&wvr=6&mo">https://weibo.com/1933424965/H3qIu0JYo?from=page_1005051933424965_profile&amp;wvr=6&amp;mo</a></p>
<p>d&#x3D;weibotime</p>
<p>2019-01-28</p>
<p>PengfeiWang   0</p>
<p>老师，您好，有个问题请教一下：</p>
<p>关于MySQL备份有效性的验证，你有什么好的方法可以推荐吗？目前只能通过不定期的备份恢</p>
<p>复来验证。2019-01-25</p>
<p> 作者回复</p>
<p>大家都是这么做的 </p>
<p>2019-01-25</p>
<p>AI杜嘉嘉   0</p>
<p>老师，接着上面问题。是删表，线上rename，有什么风险吗？需要注意什么？rename是不是d</p>
<p>dl操作</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>是，不过rename的执行速度很快</p>
<p>2019-01-25</p>
<p>还一棵树   0</p>
<p>我遇到过一个线上误truncate表的，最终选择的处理过程如下：</p>
<p>1、创建一个同版本的空mysql实例，建一个名字+结构一模一样的表</p>
<p>2、discard这个表的tablespace</p>
<p>3、从之前的备份集中 innobackupex –apply-log 并记录binlog位置（用innobackupex备份的）</p>
<p>。还原后找到误操作表的.ibd文件，copy到新实例对应的位置</p>
<p>4、在之前创建的mysql实例上import tablespace</p>
<p>5、利用mysqlbinlog 处理增量数据</p>
<p>6、最后导出 再导入</p>
<p>2019-01-24</p>
<p> 作者回复</p>
<p> </p>
<p>这基本上是最快的恢复步骤了</p>
<p>2019-01-24</p>
<p>苍茫   0</p>
<p>有一次我在查询数据倒数报表给业务方，那个脚本是我写的，关联了很多表，还跨了库，一个</p>
<p>主表有一万多条纪录，关联另一张操作记录表好像是10万条数据。因为要统计多步操作步骤，</p>
<p>所以每一步的操作记录我就得按照不同的条件关联产生临时表（关联中有group 还有max（）</p>
<p>聚合函数，这个是需求导致的），一开始写好的查询很快有了结果。那天11点多的时候，我执</p>
<p>行那个脚本，发现很慢没有反应，然后我就把连接关了，重复几次操作，然后生产库就被我搞</p>
<p>挂了。后面运维的同学操作了一波才恢复过来。这次也是运维同学背的锅。后面，还把我的操</p>
<p>作给贴出来了，做通报批评。我想问下为啥会出现这种情况呢？后续我的组长对我写的sql进行了优化，主要是把联表操作需要的信息放在子查询中，然后再操</p>
<p>作记录表中加了索引，有了备份库，每次执行脚本导出数据都是在备份库中导出，就再也没有</p>
<p>发生这个问题了。2019-01-24</p>
<p> 作者回复</p>
<p>后面有一篇专门说这个，敬请期待哈</p>
<p>2019-01-24</p>
<p>xishuai   0</p>
<p>老师，麻烦问一下，5.7.21上innodb的表两列（有中文有英文）建的全文索引，最小分词1，按</p>
<p>中文可以查询，按英文有些查询不出来，您知道原因吗？2019-01-24</p>
<p> 作者回复</p>
<p>全文索引有stop words的，你看看是不是落在stop words里了</p>
<p>2019-01-24</p>
<p>catalina   0</p>
<p>老师，我们现在需要将一个库下面的所有表的数据同步到另外一个库，每个表有几百万数据吧</p>
<p>，大约十多张表。有什么好的方法吗？2019-01-24</p>
<p> 作者回复</p>
<p>原库的这几个表还会继续更新吗？ 如果会继续更新，就用搭主备的方法；</p>
<p>如果没更新了，后面有一个文章专门讲这个问题哈</p>
<p>2019-01-24</p>
<p>hua168   0</p>
<p>大神，有亲戚小公司搞DBA一年，我想问一下：</p>
<p>1.DBA一般发展方向是怎样的呀？运维和开发我了解，DBA没接触过，无法给建议，一般的升</p>
<p>级过程是怎样的？2.以后发展方向是怎样？现在都是开源、大数据时代时代，阿里又搞“去IOE”，一般oracle DBA</p>
<p>发展前景不好吧？能帮指一个大概的方向吗？谢谢~~</p>
<p>2019-01-24</p>
<p>aliang   0</p>
<p>老师好。这是第6讲评论区Tony Du的评论：</p>
<p>session A: begin; select * from t limit 1; 最先启动sessionA</p>
<p>session B: begin; select * from t limit 1; 紧接着启动sessionB</p>
<p>session C: alter table t add f int; 然后再是启动sessionC</p>
<p>session D: begin; select * from t limit 1; 最后是启动sessionD</p>
<p>他说session C会被A和B阻塞，D会被C阻塞；当A和B提交后，D是可以继续执行得到查询结果</p>
<p>的，但是C仍然被阻塞，只有D提交后C才能执行成功。我自己在5.6和5.7按他的步骤做了试验</p>
<p>，结果和他一样。然后我再做了一次试验，这次把D的begin;去掉，变成了：</p>
<p>session A: begin; select * from t limit 1; 最先启动sessionA</p>
<p>session B: begin; select * from t limit 1; 紧接着启动sessionB</p>
<p>session C: alter table t add f int; 然后再是启动sessionC</p>
<p>session D: select * from t limit 1; 最后是启动sessionD</p>
<p>结果是当A和B提交后，D和C都能执行成功了（和老师的结果一样）。我的问题是：为什么第</p>
<p>一次session D显式开启事务，和第二次不显式开启的结果不一样呢？2019-01-24</p>
<p> 作者回复</p>
<p>可否贴一下你的show variables 的结果，我这边验证（不论D有没有加begin）的效果都是你说</p>
<p>的第二次的情况哦</p>
<p>2019-02-04</p>
<p>太福   0</p>
<p>因为时间原因，前面的课程没跟上，在这里请教个最近线上mysql遇到的问题：</p>
<p>一个从库mysql5.6版本,正常情况下只有3到5个并发sql在查询，每分钟用下面的sql查看一次检</p>
<p>测到的</p>
<p>SELECT t1.* FROM information_schema.<code>PROCESSLIST</code> t1 WHERE info is not null ORDER</p>
<p>BY time desc;</p>
<p>前一次检测还是几个sql在查询，下1分钟查到2000多个sql在跑，很多堆积了几十秒的sql，状态</p>
<p>“Sending data” “Creating sort index”</p>
<p>，而这些sql在正常情况下是不到1秒就查到结果了的，且cpu使用率与io很低，看起来mysql僵</p>
<p>死的了。有两个问题：1）问题突然出现</p>
<p>2）大量sql在跑，而cpu与磁盘io反而比正常下降；这是从库，写只有主从同步，其它都是读查</p>
<p>询。配置：64G内存，bp分配40G，io使用不高</p>
<p>,业务量没大变动，也没新版本发布，大体排除业务并发加大导致的。2019-01-24</p>
<p> 作者回复</p>
<p>这个不算突然出现吧，你两次检测之间是1分钟是吧？你这样说我看不太明白，可否给一个当时的show processlist的截图；</p>
<p>你还能执行show processlist，就不能算”僵死“；</p>
<p>io的状态如果有保存，也贴一下当时的iostat的结果；</p>
<p>可以发个微博附图，然后地址发到评论区哈</p>
<p>2019-02-01</p>
<p>风二中   0</p>
<p>老师，您好。如何设置binlog 的备份时间呢，感觉RPO 时间总是不能为零，如果是informix 可</p>
<p>以只丢一个逻辑日志。对于需要保证mysql恢复 RPO 时间为零，有什么建议吗？备库延迟1小</p>
<p>时，加每小时备份一次binlog 。2019-01-23</p>
<p> 作者回复</p>
<p>嗯 对于核心业务，使用延迟复制的备份</p>
<p>RPO时间为0？有这么凶残的业务需求吗。。我能想到的就是多套延迟备份的库。比如开3个， 一个是10分钟，一个20分钟，一个30分钟（主要考虑成本）</p>
<p>RPO这么敏感的，应该有对应敏感的监控，误操作要是30分钟还不能发现，可以挑战一下，这</p>
<p>个业务是不是值得这么高的指标^_^</p>
<p>2019-01-23</p>
<p>700   0</p>
<p>老师，请教。假如我有数据库的物理备份和逻辑备份（mydumper），因为 mydumper 导出的</p>
<p>数据是按表名分开存放的，那么表误删数据的时候优先考虑逻辑备份（误删数据表的备份集）</p>
<p>+binlog 恢复比物理备份恢复会快点？基于此，我总感觉物理备份只是在要恢复整个实例时才会</p>
<p>优先考虑，而恢复整个实例的场景又是比较少的，毕竟一般大家的线上架构至少都是主从模式</p>
<p>。所以逻辑备份被物理备份更实用。这种想法算是说得通吗？2019-01-23</p>
<p> 作者回复</p>
<p>其实是要看表的大小</p>
<p>如果是一个大表，逻辑恢复还是比较慢的，毕竟用物理备份来恢复出实例，相对会快些。当然如果你已经有了一个成熟系统用逻辑恢复来实现，也不用改它，主要关注一下是否满足SL</p>
<p>A就可以了^_^</p>
<p>facebook就是主要用逻辑备份的</p>
<p>2019-01-23</p>
<p>高强   0</p>
<p>老师你好，问个带子查询的delete&#x2F;update&#x2F;insert问题，Delete from A where name in( </p>
<p>Select name from B where time&lt;’2019-01-23 11:11:12’ </p>
<p>) 这条语句删除A表记录之前是不是也会把表 B满足条件的记录也会给锁住呢?</p>
<p>我试验了一下会锁住B表记录的，有没有其他办法不让锁B表呢?</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>改成RC隔离级别试试</p>
<p>2019-01-23</p>
<pre><code>
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/90c350b7.html" rel="prev" title="mysql-答疑文章（二）：用动态的观点看加锁">
      <i class="fa fa-chevron-left"></i> mysql-答疑文章（二）：用动态的观点看加锁
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/11e721ea.html" rel="next" title="mysql-为什么还有kill不掉的语句">
      mysql-为什么还有kill不掉的语句 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">问题解析</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Meng Qi</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">342</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Qi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:40</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

<div>
<span id="timeDate">loading...</span><span id="times">loading...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("1/1/2018 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
