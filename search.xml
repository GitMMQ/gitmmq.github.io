<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>234树</title>
    <url>/posts/32086.html</url>
    <content><![CDATA[<p>平衡树，子节点数目可以达到4个</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p>若父节点中存有1个数据项，则必有2个子节点。</p>
</li>
<li><p>若父节点中存有2个数据项，则必有3个子节点。</p>
</li>
<li><p>若父节点中存有3个数据项，则必有4个子节点。</p>
</li>
</ol>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>插入数据：</p>
<ul>
<li><p>未满节点直接插入</p>
</li>
<li><p>满节点 ABC 分裂 A不变 B到父节点 C到右侧</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Node
&#123;
private static final int ORDER = 4;
private int numItems;//节点中实际存储的数据项数目，其值一定不大于3
private Node parent;
private Node childArray[] = new Node[ORDER];//子节点数组
private DataItem itemArray[] = new DataItem[ORDER-1];//存储数据项数组
//-------------------------------------------------------------
// 把参数中的节点作为子节点，与当前节点进行连接
public void connectChild(int childNum, Node child)
   &#123;
   childArray[childNum] = child;
   if(child != null)
      child.parent = this;//当前节点作为父节点
   &#125;
//-------------------------------------------------------------
// 断开参数确定的节点与当前节点的连接，这个节点一定是当前节点的子节点。
public Node disconnectChild(int childNum)
   &#123;
   Node tempNode = childArray[childNum];
   childArray[childNum] = null; //断开连接
   return tempNode;//返回要这个子节点
   &#125;
//-------------------------------------------------------------
public Node getChild(int childNum)//获取相应的子节点
   &#123; return childArray[childNum]; &#125;
//-------------------------------------------------------------
public Node getParent()//获取父节点
   &#123; return parent; &#125;
//-------------------------------------------------------------
public boolean isLeaf()//是否是叶结点
   &#123; return (childArray[0]==null) ? true : false; &#125;//叶结点没有子节点
//-------------------------------------------------------------
public int getNumItems()//获取实际存储的数据项数目
  &#123; return numItems; &#125;
//-------------------------------------------------------------
public DataItem getItem(int index)   // 获取具体的数据项
   &#123; return itemArray[index]; &#125;
//-------------------------------------------------------------
public boolean isFull()//该节点是否已满
   &#123; return (numItems==ORDER-1) ? true : false; &#125;
//-------------------------------------------------------------
public int findItem(long key)       // 查找
   &#123;                                    
   for(int j=0; j&lt;ORDER-1; j++)         // 遍历数组
      &#123;                                 
      if(itemArray[j] == null)          // 数组未满，未找到
         break;
      else if(itemArray[j].dData == key)
         return j;
      &#125;
   return -1;
   &#125;  // end findItem
//-------------------------------------------------------------
public int insertItem(DataItem newItem)//节点未满的插入
   &#123;
   numItems++;                          
   long newKey = newItem.dData;         // 获得关键字
 
   for(int j=ORDER-2; j&gt;=0; j--)        // 因为节点未满，所以从倒数第二项向前查找
      &#123;                              
      if(itemArray[j] == null)          // 没存数据
         continue;                      
      else                              
         &#123;                              
         long itsKey = itemArray[j].dData;//获得关键字
         if(newKey &lt; itsKey)            //插入位置在其前面，但未必相邻
            itemArray[j+1] = itemArray[j]; //当前数据项后移
         else
            &#123;
            itemArray[j+1] = newItem;   // 在其后位置插入
            return j+1;                 // 返回插入的位置下标
            &#125;                           //    new item
         &#125;  // end else (not null)
      &#125;  // end for                     // shifted all items,
   //若上述代码没有执行返回操作，那么这是空节点（只有初始时根是这个情况）
   itemArray[0] = newItem;              // insert new item
   return 0;
   &#125;  // end insertItem()
//-------------------------------------------------------------
public DataItem removeItem()        // 移除数据项，从后向前移除
   &#123;
   // 假设节点非空
   DataItem temp = itemArray[numItems-1];  // 要移除的数据项
   itemArray[numItems-1] = null;           // 移除
   numItems--;                             // 数据项数目减一
   return temp;                            // 返回要移除的数据项
   &#125;
//-------------------------------------------------------------
public void displayNode()           // format &quot;/24/56/74/&quot;
   &#123;
   for(int j=0; j&lt;numItems; j++)
      itemArray[j].displayItem();   // &quot;/56&quot;
   System.out.println(&quot;/&quot;);         // final &quot;/&quot;
   &#125;
//-------------------------------------------------------------
&#125;  // end class Node
////////////////////////////////////////////////////////////////


class Tree234
&#123;
private Node root = new Node();            // 创建树的根
//-------------------------------------------------------------
//获取查找的下一个节点
public Node getNextChild(Node theNode, long theValue)
&#123;
int j;
// 假设这个节点不是叶结点
int numItems = theNode.getNumItems();//获得当前节点的数据项数目
for(j=0; j&lt;numItems; j++)          
   &#123;                             
   if( theValue &lt; theNode.getItem(j).dData )
      return theNode.getChild(j);  // 返回相应的节点
   &#125;  // end for                   
return theNode.getChild(j);        // 此时j=numItems
&#125;
//-------------------------------------------------------------
public int find(long key)
   &#123;
   Node curNode = root;
   int childNumber;
   while(true)
      &#123;
      if(( childNumber=curNode.findItem(key) ) != -1)//每次循环这句一定执行
         return childNumber;               // found it
      else if( curNode.isLeaf() )//叶结点上也没找到
         return -1;                        // can&#39;t find it
      else                                 // 不是叶结点，则继续向下查找
         curNode = getNextChild(curNode, key);
      &#125;  // end while
   &#125;
//-------------------------------------------------------------
// 插入数据项
public void insert(long dValue)
   &#123;
   Node curNode = root;//当前节点标志
   DataItem tempItem = new DataItem(dValue);//插入数据项封装
 
   while(true)
      &#123;
      if( curNode.isFull() )               // 是满节点
         &#123;
         split(curNode);                   // 分裂
         curNode = curNode.getParent();    // 回到分裂出的父节点上
                                           // 继续向下查找
         curNode = getNextChild(curNode, dValue);
         &#125;  // end if(node is full)
//后面的操作中节点都未满，否则先执行上面的代码
      else if( curNode.isLeaf() )          // 是叶结点，非满
         break;                            // 跳出，直接插入
   
      else
         curNode = getNextChild(curNode, dValue);//向下查找
      &#125;  // end while
 
   curNode.insertItem(tempItem);       // 此时节点一定不满，直接插入数据项，
   &#125;  // end insert()
//-------------------------------------------------------------
public void split(Node thisNode)     // 分裂
   &#123;
   // 操作中节点一定是满节点，否则不会执行该操作
   DataItem itemB, itemC;
   Node parent, child2, child3;
   int itemIndex;
 
   itemC = thisNode.removeItem();    // 移除最右边的两个数据项，并保存为B和C
   itemB = thisNode.removeItem();    // 
   child2 = thisNode.disconnectChild(2); // //断开最右边两个子节点的链接
   child3 = thisNode.disconnectChild(3); // 
 
   Node newRight = new Node();       //新建一个节点，作为当前节点的兄弟节点
 
   if(thisNode==root)                // 是根
      &#123;
      root = new Node();                // 新建一个根
      parent = root;                    // 把新根设为父节点
      root.connectChild(0, thisNode);   // 连接父节点和子节点
      &#125;
   else                              // 不是根
      parent = thisNode.getParent();    // 获取父节点
 
  
   itemIndex = parent.insertItem(itemB); // 把B插入父节点中，返回插入位置
   int n = parent.getNumItems();         // 获得总数据项数目
 
   for(int j=n-1; j&gt;itemIndex; j--)          //从后向前移除
      &#123;                                    
      Node temp = parent.disconnectChild(j); // 断开连接
      parent.connectChild(j+1, temp);        // 连接到新的位置
      &#125;
                           
   parent.connectChild(itemIndex+1, newRight);//连接到新位置
 
   // 处理兄弟节点
   newRight.insertItem(itemC);       // 将C放入兄弟节点中
   newRight.connectChild(0, child2); // 把子节点中最右边的两个连接到兄弟节点上
   newRight.connectChild(1, child3); //
   &#125;  // end split()
//-------------------------------------------------------------
// gets appropriate child of node during search for value
 
public void displayTree()
   &#123;
   recDisplayTree(root, 0, 0);
   &#125;
//-------------------------------------------------------------
private void recDisplayTree(Node thisNode, int level,
                                           int childNumber)
   &#123;
   System.out.print(&quot;level=&quot;+level+&quot; child=&quot;+childNumber+&quot; &quot;);
   thisNode.displayNode();               // display this node
 
   // call ourselves for each child of this node
   int numItems = thisNode.getNumItems();
   for(int j=0; j&lt;numItems+1; j++)
      &#123;
      Node nextNode = thisNode.getChild(j);
      if(nextNode != null)
         recDisplayTree(nextNode, level+1, j);
      else
         return;
      &#125;
   &#125;  // end recDisplayTree()
//-------------------------------------------------------------\
&#125;  // end class Tree234
////////////////////////////////////////////////////////////////


import java.io.*;
 
class Tree234App
&#123;
public static void main(String[] args) throws IOException
   &#123;
   long value;
   Tree234 theTree = new Tree234();
 
   theTree.insert(50);
   theTree.insert(40);
   theTree.insert(60);
   theTree.insert(30);
   theTree.insert(70);
 
   while(true)
      &#123;
      System.out.print(&quot;Enter first letter of &quot;);
      System.out.print(&quot;show, insert, or find: &quot;);
      char choice = getChar();
      switch(choice)
         &#123;
         case &#39;s&#39;:
            theTree.displayTree();
            break;
         case &#39;i&#39;:
            System.out.print(&quot;Enter value to insert: &quot;);
            value = getInt();
            theTree.insert(value);
            break;
         case &#39;f&#39;:
            System.out.print(&quot;Enter value to find: &quot;);
            value = getInt();
            int found = theTree.find(value);
            if(found != -1)
               System.out.println(&quot;Found &quot;+value);
            else
               System.out.println(&quot;Could not find &quot;+value);
            break;
         default:
            System.out.print(&quot;Invalid entry\n&quot;);
         &#125;  // end switch
      &#125;  // end while
   &#125;  // end main()
//--------------------------------------------------------------
public static String getString() throws IOException
   &#123;
   InputStreamReader isr = new InputStreamReader(System.in);
   BufferedReader br = new BufferedReader(isr);
   String s = br.readLine();
   return s;
   &#125;
//--------------------------------------------------------------
public static char getChar() throws IOException
   &#123;
   String s = getString();
   return s.charAt(0);
   &#125;
 
//-------------------------------------------------------------
public static int getInt() throws IOException
   &#123;
   String s = getString();
   return Integer.parseInt(s);
   &#125;
//-------------------------------------------------------------
&#125;  // end class Tree234App
////////////////////////////////////////////////////////////////
</code></pre>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/posts/61466.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>AVL树</title>
    <url>/posts/54793.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>树</title>
    <url>/posts/23384.html</url>
    <content><![CDATA[<p>树由根节点(root)和若干子树(T1,T2, … Tm-1)构成的具有层次关系的数据结构。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>节点的度 : 该节点子树个数，度为0的节点为叶子节点，度不为0的节点为分支节点</p>
<p>树的度 : 树中的节点的度最大值为树的度</p>
<p>节点的层次 : 根为第一层，往下依次递增</p>
<p>树的深度 : 节点层次最大值为树的深度</p>
<p>森林 : n棵不相交的树的集合为森林</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>常用于实现二叉查找树、二叉堆</p>
<ul>
<li><p>每个节点至多有两颗子树（树的度&lt;&#x3D;2）,子树分左右</p>
</li>
<li><p>第i层至多有2i-1个节点，深度为k的二叉树，最多节点数2^k-1个节点（具有最多节点的称作满二叉树），其中每个节点都与深度k满二叉树中1-n节点对应，则为完全二叉树</p>
</li>
</ul>
<p><img src="http://thyrsi.com/t6/626/1544146169x2890211738.jpg" alt="满二叉树"></p>
<p><img src="http://thyrsi.com/t6/626/1544146212x2890211738.jpg" alt="完全二叉树"></p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><ul>
<li>左子树所有节点值小于根节点，右子树所有节点值大于根节点值</li>
<li>左右子树都是二叉排序树</li>
</ul>
<h2 id="二叉平衡树-AVL"><a href="#二叉平衡树-AVL" class="headerlink" title="二叉平衡树 AVL"></a>二叉平衡树 AVL</h2><ul>
<li>左右子树深度差不超过1</li>
<li>左右子树都是二叉平衡树</li>
</ul>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>最优二叉树</p>
<p><a href="#hafman">代码实现</a></p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>解决报文编码的问题，将字符串转换为唯一的二进制码，且二进制码的长度最小</p>
<p>每个字符在字符串中出现频率为W，其编码长度为L，编码字符n个，则编码后二进制码的总长度为W1L1+W2L2+…+WnLn，利用哈夫曼树特性求总长最小编码</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>平衡的多路查找树</p>
<p>B树的阶：所有孩子节点树的最大值（m叉树：每个节点最多m棵子树）</p>
<p>分支节点最少有两颗子树</p>
<p>分支节点包含信息（n，A0，K1，A1，K2，A2，…，Kn，An），其中，n为结点中的关键字树，A为指向子树根结点的指针，K为关键字，且Ai-1所指子树中所有结点的关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn；</p>
<p>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶B+树和m阶的B-树的差异在于</p>
<ol>
<li><p>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点；</p>
</li>
<li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</p>
</li>
</ol>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似于平衡的。树中每个结点包含5个属性：color、key、left、right和p。如果一个结点没有子节点或父节点，则该结点相应的指针属性值为NIL，我们可以把这些NIL视为指向二叉搜索树的叶节点（外部结点）的指针，而把带关键字的结点视为树的内部结点。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>每个结点或是红色的，或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的</li>
<li>如果一个结点是红色的，则它的两个子结点都是黑色的</li>
<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>
<li>虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</li>
</ol>
<h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p>如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树或字符树，来表示这样的字符串的集合。键树的结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A，B，C，…，Z的单词所在页，再对各部分标出第二字母为A，B，C，…，Z的单词所在的页等等。<br>键树是一种特殊的查找树，它是一棵度大于等于2的树，树中的每个节点不是包含一个或几个关键字，而是只含有组成关键字的符号。<br>比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。 </p>
<p>键树的存储通常有两种方式： </p>
<ol>
<li>用树的孩子兄弟链来表示键树，称为双链树；每个Node有三个域：symbol域：存储关键字的一个字符；son域：存储指向第一棵子树的根的指针；brother域：存储指向右兄弟的指针。 </li>
<li>用多重链表来表示键树，称为Trie树或字典树。</li>
</ol>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>如果以树的多重链表来表示键树，则树的每个结点应包含d个（d为关键字符的基，如：字符集由英文大写字母构成时，则d&#x3D;26）指针域，此时的键树又称为字典树。<br>字典树典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　<br>Tire树的三个基本性质： </p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符； </li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； </li>
<li>每个节点的所有子节点包含的字符都不相同。<br>Tire树的应用： </li>
<li>串的快速检索<br>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。 </li>
<li>“串”排序<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。 </li>
<li>最长公共前缀</li>
</ol>
<h2 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h2><p>所谓后缀树，就是包含一则字符串所有后缀的压缩了的字典树。先说说后缀的定义。给定一长度为n的字符串S&#x3D;S1S2..Si..Sn，和整数i，1 &lt;&#x3D; i &lt;&#x3D; n，子串SiSi+1…Sn都是字符串S的后缀。以字符串S&#x3D;XMADAMYX为例，它的长度为8，所以S[1..8],S[2..8], … , S[8..8]都算S的后缀，我们一般还把空字串也算成后缀。这样，我们一共有如下后缀。对于后缀S[i..n]，我们说这项后缀起始于i。<br>键树只适合前缀匹配和全字匹配，并不适合后缀和子串匹配，而后缀树在这方面则非常合适。它与键树的最大不同在于，后缀树的单词集合是由指定字符串的后缀子串构成。</p>
<h2 id="区间树与线段树"><a href="#区间树与线段树" class="headerlink" title="区间树与线段树"></a>区间树与线段树</h2><p>区间树是在红黑树基础上进行扩展得到的支持以区间为元素的动态集合的操作，其中每个节点的关键值是区间的左端点。通过建立这种特定的结构，可是使区间的元素的查找和插入都可以在O(lgn)的时间内完成。相比于基础的红黑树数据结构，增加了一个max[x]，即以x为根的子树中所有区间的端点的最大值。<br>线段树是一种平衡二叉查找树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。主要的处理思想是基于分治的思想。<br>设根节点的区间为[a,b),区间长度为L &#x3D; b - a，线段树的性质：<br>1）线段树是一个平衡树，树的高度为log(L)；<br>2）线段树把区间上的任意长度为L的线段都分成不超过2log(L)线段。</p>
<h2 id="败者树与胜者树"><a href="#败者树与胜者树" class="headerlink" title="败者树与胜者树"></a>败者树与胜者树</h2><p>胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。在胜者树、败者树中，每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树中的每个非终端结点均表示其左、右孩子结点中的“胜者”；而在败者树中，父结点中记下刚进行完的这场比赛中的败者，而让胜者去参加更高一层的比赛</p>
<p><span id="hafman">哈夫曼树代码实现</span></p>
<pre><code>import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
 
public class HuffmanTree &#123;
 
    public static class Node&lt;E&gt; &#123;
        E data;
        double weight;
        Node leftChild;
        Node rightChild;
 
        public Node(E data, double weight) &#123;
            super();
            this.data = data;
            this.weight = weight;
        &#125;
 
        public String toString() &#123;
            return &quot;Node[data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;;
        &#125;
    &#125;
 
    public static void main(String[] args) &#123;
        List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();
 
        nodes.add(new Node(&quot;A&quot;, 40.0));
        nodes.add(new Node(&quot;B&quot;, 8.0));
        nodes.add(new Node(&quot;C&quot;, 10.0));
        nodes.add(new Node(&quot;D&quot;, 30.0));
        nodes.add(new Node(&quot;E&quot;, 10.0));
        nodes.add(new Node(&quot;F&quot;, 2.0));
        
        Node root = HuffmanTree.createTree(nodes);
        
        System.out.println(breadthFirst(root));
 
    &#125;
 
    /**
     * 构造哈夫曼树
     * 
     * @param nodes
     *            节点集合
     * @return 构造出来的哈夫曼树的根节点
     */
    private static Node createTree(List&lt;Node&gt; nodes) &#123;
        // 只要nodes数组中还有2个以上的节点
        while (nodes.size() &gt; 1) &#123;
            quickSort(nodes);
            //获取权值最小的两个节点
            Node left = nodes.get(nodes.size()-1);
            Node right = nodes.get(nodes.size()-2);
            
            //生成新节点，新节点的权值为两个子节点的权值之和
            Node parent = new Node(null, left.weight + right.weight);
            
            //让新节点作为两个权值最小节点的父节点
            parent.leftChild = left;
            parent.rightChild = right;
            
            //删除权值最小的两个节点
            nodes.remove(nodes.size()-1);
            nodes.remove(nodes.size()-1);
            
            //将新节点加入到集合中
            nodes.add(parent);
        &#125;
        
        return nodes.get(0);
    &#125;
 
    /**
     * 将指定集合中的i和j索引处的元素交换
     * 
     * @param nodes
     * @param i
     * @param j
     */
    private static void swap(List&lt;Node&gt; nodes, int i, int j) &#123;
        Node tmp;
        tmp = nodes.get(i);
        nodes.set(i, nodes.get(j));
        nodes.set(j, tmp);
    &#125;
 
    /**
     * 实现快速排序算法，用于对节点进行排序
     * 
     * @param nodes
     * @param start
     * @param end
     */
    private static void subSort(List&lt;Node&gt; nodes, int start, int end) &#123;
        if (start &lt; end) &#123;
            // 以第一个元素作为分界值
            Node base = nodes.get(start);
            // i从左边搜索，搜索大于分界值的元素的索引
            int i = start;
            // j从右边开始搜索，搜索小于分界值的元素的索引
            int j = end + 1;
            while (true) &#123;
                // 找到大于分界值的元素的索引，或者i已经到了end处
                while (i &lt; end &amp;&amp; nodes.get(++i).weight &gt;= base.weight)
                    ;
                // 找到小于分界值的元素的索引，或者j已经到了start处
                while (j &gt; start &amp;&amp; nodes.get(--j).weight &lt;= base.weight)
                    ;
 
                if (i &lt; j) &#123;
                    swap(nodes, i, j);
                &#125; else &#123;
                    break;
                &#125;
            &#125;
 
            swap(nodes, start, j);
 
            //递归左边子序列
            subSort(nodes, start, j - 1);
            //递归右边子序列
            subSort(nodes, j + 1, end);
        &#125;
    &#125;
    
    public static void quickSort(List&lt;Node&gt; nodes)&#123;
        subSort(nodes, 0, nodes.size()-1);
    &#125;
    
    //广度优先遍历
    public static List&lt;Node&gt; breadthFirst(Node root)&#123;
        Queue&lt;Node&gt; queue = new ArrayDeque&lt;Node&gt;();
        List&lt;Node&gt; list = new ArrayList&lt;Node&gt;();
        
        if(root!=null)&#123;
            //将根元素加入“队列”
            queue.offer(root);
        &#125;
        
        while(!queue.isEmpty())&#123;
            //将该队列的“队尾”元素加入到list中
            list.add(queue.peek());
            Node p = queue.poll();
            
            //如果左子节点不为null，将它加入到队列
            if(p.leftChild != null)&#123;
                queue.offer(p.leftChild);
            &#125;
            
            //如果右子节点不为null，将它加入到队列
            if(p.rightChild != null)&#123;
                queue.offer(p.rightChild);
            &#125;
        &#125;
        
        return list;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-栈、队列</title>
    <url>/posts/12863.html</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(LIFO, Last In First Out)</p>
<h3 id="静态栈"><a href="#静态栈" class="headerlink" title="静态栈"></a>静态栈</h3><p>数组 栈大小固定</p>
<h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>链表 栈大小不固定</p>
<pre><code>public class Node &#123;

    //数据域
    public int data;

    //指针域，指向下一个节点
    public Node next;

    public Node() &#123;
    &#125;

    public Node(int data) &#123;
        this.data = data;
    &#125;

    public Node(int data, Node next) &#123;
        this.data = data;
        this.next = next;
    &#125;
    
&#125;

public class Stack &#123;

    public Node stackTop;//栈顶
    public Node stackBottom;//栈底

    public Stack(Node stackTop, Node stackBottom) &#123;
        this.stackTop = stackTop;
        this.stackBottom = stackBottom;
    &#125;

    public Stack() &#123;
    &#125;


&#125;

/**
 * 进栈
 *
 * @param stack 栈
 * @param value 要进栈的元素
 */
public static void pushStack(Stack stack, int value) &#123;

    // 封装数据成节点
    Node newNode = new Node(value);


    // 栈顶本来指向的节点交由新节点来指向
    newNode.next = stack.stackTop;

    // 栈顶指针指向新节点
    stack.stackTop = newNode;

&#125;


/**
 * 遍历栈(只要栈顶指针不指向栈底指针，就一直输出)
 *
 * @param stack
 */
public static void traverse(Stack stack) &#123;
    Node stackTop = stack.stackTop;

    while (stackTop != stack.stackBottom) &#123;

        System.out.println(&quot;关注公众号：Java3y：&quot; + stackTop.data);

        stackTop = stackTop.next;
    &#125;


&#125;

/**
 * 判断该栈是否为空
 *
 * @param stack
 */
public static void isEmpty(Stack stack) &#123;
    if (stack.stackTop == stack.stackBottom) &#123;

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈为空&quot;);
    &#125; else &#123;

        System.out.println(&quot;关注公众号：Java3y----&gt;该栈不为空&quot;);

    &#125;

&#125;

/**
 * 出栈(将栈顶的指针指向下一个节点)
 * @param stack
 */
public static void popStack(Stack stack) &#123;

    // 栈不为空才能出栈
    if (!isEmpty(stack)) &#123;

        //栈顶元素
        Node top = stack.stackTop;

        // 栈顶指针指向下一个节点
        stack.stackTop = top.next;

        System.out.println(&quot;关注公众号：Java3y----&gt;出栈的元素是：&quot; + top.data);

    &#125;
&#125;

/**
 * 清空栈
 * @param stack
 */
public static void clearStack(Stack stack) &#123;

    stack.stackTop = null;
    stack.stackBottom = stack.stackTop;
&#125;
</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(LILO, Last In Last Out)</p>
<h3 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h3><p>数组实现循环队列，节省内存资源</p>
<pre><code>public class Queue &#123;


    //数组
    public int [] arrays;

    //指向第一个有效的元素
    public int front = 0;

    //指向有效数据的下一个元素(即指向无效的数据)
    public int rear = 0;

&#125;


/**
 * 入队
 *
 * @param queue
 */
public static void enQueue(Queue queue,int value) &#123;

    // 不是满的队列才能入队
    if (!isFull(queue)) &#123;

        // 将新的元素插入到队尾中
        queue.arrays[queue.rear] = value;

        // rear节点移动到新的无效元素位置上
        queue.rear = (queue.rear + 1) % queue.arrays.length;
    &#125;
&#125;

/**
 * 出队
 *
 * @param queue
 */
public static void outQueue(Queue queue) &#123;

    //判断该队列是否为null
    if (!isEmpty(queue)) &#123;


        //不为空才出队
        int value = queue.arrays[queue.front];
        System.out.println(&quot;关注公众号：Java3y---&gt;出队的元素是：&quot; + value);

        // front指针往后面移
        queue.front = (queue.front + 1) % queue.arrays.length;

    &#125;


&#125;

/**
 * 判断队列是否空，front和rear指针相等，就是空了
 * @param queue
 * @return
 */
public static boolean isEmpty(Queue queue) &#123;
    if (queue.rear  == queue.front) &#123;
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列空的！&quot;);
        return true;
    &#125; else &#123;
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列非空！&quot;);
        return false;
    &#125;
&#125;
        
/**
 * 判断队列是否满了，front和rear指针紧挨着，就是满了
 * @param queue
 * @return
 */
public static boolean isFull(Queue queue) &#123;
    if ((queue.rear + 1) % queue.arrays.length == queue.front) &#123;

        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列满了！&quot;);
        return true;
    &#125; else &#123;
        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列没满了！&quot;);
        return false;
    &#125;
&#125;

/**
 * 遍历队列
 * @param queue
 *
 */
public static void traverseQueue(Queue queue) &#123;

    // front的位置
    int i = queue.front;

    while (i != queue.rear) &#123;

        System.out.println(&quot;关注公众号：Java3y---&gt;&quot; + queue.arrays[i]);

        //移动front
        i = (i + 1) % queue.arrays.length;
    &#125;

&#125;
    
</code></pre>
<h3 id="动态队列"><a href="#动态队列" class="headerlink" title="动态队列"></a>动态队列</h3><p>链表实现</p>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>树堆</title>
    <url>/posts/46674.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>树链</title>
    <url>/posts/38791.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-矩阵压缩</title>
    <url>/posts/44076.html</url>
    <content><![CDATA[<h2 id="对称矩阵的压缩"><a href="#对称矩阵的压缩" class="headerlink" title="对称矩阵的压缩"></a>对称矩阵的压缩</h2><p><code>n阶对称矩阵：只存储上三角或者下三角矩阵中的元素，把原来需要存储n*n个元素压缩至n*(n-1)/2个元素</code></p>
<pre><code>//对称矩阵的压缩算法
public class SymeMatric &#123;

    double[] a;// 矩阵元素
    int n; // 矩阵的阶数
    int m;// 一维数组的元素的个数--长度

    public SymeMatric(int n) &#123;
        // 对称矩阵中不重复元素，保存到一维数组中所需要的一维数组的长度
        // 2阶对称矩阵对应(1+2=3)维数组，3阶对称矩阵对应1+2+3=6维数组，
        // 4阶对称矩阵对应1+2+3+4维数组，n阶对称矩阵对应前n项和，
        // 所以一维数组的长度m的值为1,2,3...n的前n项和
        m = n * (n + 1) / 2; 
        a = new double[m];
        this.n = n;
    &#125;

    // 通过一个二维数组来初始化
    public void evalute(double[][] b) &#123;
        int k = 0;
        for (int i = 0; i &lt; n; i++) &#123;
            for (int j = 0; j &lt; n; j++) &#123;
                // i &gt;= j表示只保存下三角元素
                if (i &gt;= j) &#123;
                    a[k++] = b[i][j];
                &#125;
            &#125;
        &#125;
    &#125;

    // 通过一个一维数组来初始化,那么这个一维数组就是对称矩阵元素的一个副本
    public void evalute(double[] b) &#123;
        for (int k = 0; k &lt; m; k++) &#123;
            a[k] = b[k];
        &#125;
    &#125;

    // 对称矩阵相加
    public SymeMatric add(SymeMatric b) &#123;
        SymeMatric t = new SymeMatric(n);
        int k;
        for (int i = 1; i &lt;= n; i++) &#123;
            for (int j = 1; j &lt;= n; j++) &#123;
                if (i &gt;= j) &#123;
                    k = i * (i - 1) / 2 + j - 1;
                &#125; else &#123;
                    k = j * (j - 1) / 2 + i - 1;
                &#125;
                // 求和
                t.a[k] = a[k] + b.a[k];
            &#125;
        &#125;
        return t;
    &#125;

    // 打印对称矩阵，这个才是关键！！
    public void print() &#123;
        int k;
        for (int i = 1; i &lt;= n; i++) &#123;
            for (int j = 1; j &lt;= n; j++) &#123;
                if (i &gt;= j) &#123;
                    k = i * (i - 1) / 2 + j - 1;
                &#125; else &#123;
                    k = j * (j - 1) / 2 + i - 1;
                &#125;
                System.out.print(&quot; &quot; + a[k]);
            &#125;
            System.out.println();
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="三角矩阵的压缩"><a href="#三角矩阵的压缩" class="headerlink" title="三角矩阵的压缩"></a>三角矩阵的压缩</h2><p><code>m对角矩阵：非零元素在每行中有m个，一维数组s[k]和A[i][j]的对应关系为：k = m*i+j</code></p>
<h2 id="稀疏矩阵的压缩"><a href="#稀疏矩阵的压缩" class="headerlink" title="稀疏矩阵的压缩"></a>稀疏矩阵的压缩</h2><p><code>矩阵m*n如果有t个非零元素，那么s = t/m*n称为矩阵的稀疏因子，如果s&lt;=0.05那么矩阵为稀疏矩阵</code></p>
<p>注：三元组顺序表表示，其中三元组格式为(i,j,e)记录了非零元素的行号、列号以及非零元素</p>
<pre><code>inal int _ROWS=5;		//定义行数
final int _COLS=5;		//定义列数
final int _NOTZERO=6;	//定义稀疏矩阵中不为零的个数
int i,j,tmpRW,tmpCL,tmpNZ;
int temp=1;
int Sparse[][]=new int[_ROWS][_COLS];	//声明稀疏矩阵
int Compress[][]=new int[_NOTZERO+1][3];//声明压缩矩阵
    
for(i=0;i&lt;_ROWS;i++) 		//将矩阵初始值都设为0
    for(j=0;j&lt;_COLS;j++)
        Sparse[i][j]=0;

tmpNZ=_NOTZERO;			//产生随机稀疏矩阵
for(i=1;i&lt;tmpNZ+1;i++) &#123;
    tmpRW=(int)(Math.random()*100);
    tmpRW=(tmpRW%_ROWS);
    tmpCL=(int)(Math.random()*100);
    tmpCL=(tmpCL%_COLS);
    if(Sparse[tmpRW][tmpCL]!=0)
        tmpNZ++;
    Sparse[tmpRW][tmpCL]=i;
&#125;

/*开始压缩稀疏矩阵*/
Compress[0][0]=_ROWS;
Compress[0][1]=_COLS;
Compress[0][2]=_NOTZERO;
for(i=0;i&lt;_ROWS;i++) &#123;
    for(j=0;j&lt;_COLS;j++) &#123;
        if(Sparse[i][j]!=0)&#123;
            Compress[temp][0]=i;
            Compress[temp][1]=j;
            Compress[temp][2]=Sparse[i][j];
            temp++;
        &#125;
    &#125;
&#125;
    
</code></pre>
<p>链接：<a href="https://www.cnblogs.com/gaosheng-221/p/6133443.html">https://www.cnblogs.com/gaosheng-221/p/6133443.html</a></p>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/posts/23014.html</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>开始节点--&gt;  数据元素 ... --&gt; 终端节点</code></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>clear、isEmpty、length、get、insert、remove、indexOf</p>
<pre><code>public interface IList &#123;
    // 线性表置空操作
    public void clear();

    // 判断线性表是否为空操作
    public boolean isEmpty();

    // 获取线性表中元素的长度操作
    public int length();

    // 获取指定位置上面的元素操作
    public Object get(int i);

    // 在指定位置上面插入元素的操作
    public void insert(int i, Object x);

    // 删除指定位置上面的元素的操作
    public void remove(int i);

    // 查找指定元素的位置首次出现的位置操作
    public int indexOf(Object x);

    // 显示线性表中的内容操作
    public void display();
&#125;
</code></pre>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序存储， 逻辑上相邻的数据元素，在物理存储上也是相邻的。 不便于插入和删除</p>
<pre><code>   public class SqList implements IList &#123;
       // 线性表存储空间
       private Object[] listElem;
       // 线性表的当前长度
       private int curLen;
   
       // 顺序表类的构造函数，构造一个存储空间容量为maxSize的线性表
       public SqList(int maxSize) &#123;
           // TODO Auto-generated constructor stub
           curLen = 0;
           listElem = new Object[maxSize];
       &#125;
   
       // 将一个已经存在的线性表置成空表
       public void clear() &#123;
           // TODO Auto-generated method stub
           // 置顺序表的当前长度为0
           curLen = 0;
       &#125;
   
       // 判断线性表中的数据元素的个数是否为0，若为0则返回true，否则返回false
       public boolean isEmpty() &#123;
           // TODO Auto-generated method stub
           return curLen == 0;
       &#125;
   
       // 求线性表中的数据元素的个数并返回其值
       public int length() &#123;
           // TODO Auto-generated method stub
           // 返回顺序表的当前长度
           return curLen;
       &#125;
   
       // 读取到线性表中的第i个数据元素并由函数返回其值，其中i的取值范围为0≤i≤length()-1，若i不在此范围则抛出异常
       public Object get(int i) &#123;
           // TODO Auto-generated method stub
           if (i &lt; 0 || i &gt;= curLen) &#123;
               throw new RuntimeException(&quot;第&quot; + i + &quot;个元素不存在&quot;);
           &#125;
           return listElem[i];
       &#125;
   
       // 在线性表的第i个数据元素之前插入一个值位x的数据元素
       public void insert(int i, Object x) &#123;
           // TODO Auto-generated method stub
           // 判断表是否满了
           if (curLen == listElem.length) &#123;
               throw new RuntimeException(&quot;存储空间已经满了，无法插入新的元素&quot;);
           &#125;
           // 插入的位置不合法
           if (i &lt; 0 || i &gt; curLen) &#123;
               throw new RuntimeException(&quot;插入的位置不合法&quot;);
           &#125;
           // 必须要从最后一个元素开始依次逐个后移动，直到第i个数据元素移动完毕为止。
           for (int j = curLen; j &gt; i; j--) &#123;
               listElem[j] = listElem[j - 1];
           &#125;
           listElem[i] = x;
           curLen++;
       &#125;
   
       public void remove(int i) &#123;
           // TODO Auto-generated method stub
           if (i &lt; 0 || i &gt; curLen - 1) &#123;
               throw new RuntimeException(&quot;删除的位置不合法&quot;);
           &#125;
           for (int j = i; j &lt; curLen; j++) &#123;
               listElem[j] = listElem[j+1];
           &#125;
           curLen--;
       &#125;
   
       // 返回线性表中首次出现指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1
       public int indexOf(Object x) &#123;
           // TODO Auto-generated method stub
           for (int i = 0; i &lt; curLen; i++) &#123;
               if (listElem[i].equals(x)) &#123;
                   return i;
               &#125;
           &#125;
           return -1;
       &#125;
   
       // 输出线性表中的数据元素
       public void display() &#123;
           // TODO Auto-generated method stub
           for (int i = 0; i &lt; curLen; i++) &#123;
               System.out.print(listElem[i] + &quot; &quot;);
           &#125;
           System.out.println();
       &#125;
   
       // 测试
       public static void main(String[] args) &#123;
           SqList sqList = new SqList(10);
           sqList.insert(0, &quot;a&quot;);
           sqList.insert(1, &quot;z&quot;);
           sqList.insert(2, &quot;d&quot;);
           sqList.insert(3, &quot;m&quot;);
           sqList.insert(4, &quot;z&quot;);
           int order = sqList.indexOf(&quot;z&quot;);
           if (order!=-1) &#123;
               System.out.println(&quot;顺序表中第一次出现的值为z的数据元素的位置为：&quot;+order);
           &#125;else &#123;
               System.out.println(&quot;顺序表中不包括z元素&quot;);
           &#125;
       &#125;
   &#125;
</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式存储，单向链表，节点保存下一个节点的引用，便于插入和删除</p>
<pre><code>public class Node &#123;
    // 存放结点的值
    private Object data;
    // 后继结点的引用
    private Node next;

    // 无参数时的构造函数
    public Node() &#123;
        // TODO Auto-generated constructor stub
        this(null, null);
    &#125;

    // 带有一个参数时的构造函数
    public Node(Object data) &#123;
        this(data, null);
    &#125;

    // 带有两个参数时的构造函数
    public Node(Object data, Node next) &#123;
        this.data = data;
        this.next = next;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

    public Node getNext() &#123;
        return next;
    &#125;

    public void setNext(Node next) &#123;
        this.next = next;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线段树</title>
    <url>/posts/93732293.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>data</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/posts/b76ba195.html</url>
    <content><![CDATA[<p>LF和CRLF其实都是换行符。</p>
<p>LF是linux和Unix系统的换行符，CRLF是window系统的换行符。</p>
<p>Git提供了换行符自动转换的功能，默认开启，自动把代码里换行的方式转换成当前系统的换行方式。提交代码时，Git就会提示 LF will be replaced by CRLF in。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config core.autocrlf false</span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>warning</tag>
      </tags>
  </entry>
  <entry>
    <title>Permission denied publickey</title>
    <url>/posts/81df75d5.html</url>
    <content><![CDATA[<h2 id="查看全局配置"><a href="#查看全局配置" class="headerlink" title="查看全局配置"></a>查看全局配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;email@email.com&quot;</span><br></pre></td></tr></table></figure>


<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email@email.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; <span class="built_in">cat</span> /c/Users/Alan/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>

<h2 id="配置github授权"><a href="#配置github授权" class="headerlink" title="配置github授权"></a>配置github授权</h2><p>GitHub—&gt;setting—&gt;SSH and GPG keys—&gt;SSH keys </p>
<h2 id="测试是否生效"><a href="#测试是否生效" class="headerlink" title="测试是否生效"></a>测试是否生效</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>设置代理</title>
    <url>/posts/6e63a28a.html</url>
    <content><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks://127.0.0.1:10808</span><br><span class="line">git config --global http.proxy http://127.0.0.1:10809</span><br><span class="line">git config --global http.proxy https://127.0.0.1:10808</span><br></pre></td></tr></table></figure>

<h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>安装git</title>
    <url>/posts/8d39085b.html</url>
    <content><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-asset-image问题修改</title>
    <url>/posts/d35bf8ef.html</url>
    <content><![CDATA[<h2 id="修改更新url的代码"><a href="#修改更新url的代码" class="headerlink" title="修改更新url的代码"></a>修改更新url的代码</h2><p>node_modules&#x2F;hexo-asset-image&#x2F;index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">           srcArray.<span class="title function_">shift</span>();</span><br><span class="line">           src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">           $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, <span class="string">&quot;/img/&quot;</span> + src);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+<span class="string">&quot;/img/&quot;</span> + src);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-asset-image</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo自定义菜单</title>
    <url>/posts/bd184e2.html</url>
    <content><![CDATA[<h2 id="nodejs-版本"><a href="#nodejs-版本" class="headerlink" title="nodejs 版本"></a>nodejs 版本</h2><p>需要考虑主题支持的版本范围，最好应大于10 小于 15，推荐使用12</p>
<p>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">安装前提</a></p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install -g hexo </span><br><span class="line">环境变量配置 全局安装的目录</span><br></pre></td></tr></table></figure>

<h2 id="启动一个blog项目"><a href="#启动一个blog项目" class="headerlink" title="启动一个blog项目"></a>启动一个blog项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo new &quot;postName&quot;</span><br><span class="line">hexo new page &quot;pageName&quot;</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h2 id="菜单项配置"><a href="#菜单项配置" class="headerlink" title="菜单项配置"></a>菜单项配置</h2><h3 id="新增页面"><a href="#新增页面" class="headerlink" title="新增页面"></a>新增页面</h3><p>source 目录下新建 tags、categories、about文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<h3 id="博文的头部"><a href="#博文的头部" class="headerlink" title="博文的头部"></a>博文的头部</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2022/3/26 00:00:00</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">	-</span> Java</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">	-</span> Web</span><br><span class="line"><span class="section">	- Server</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>

<h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>theme&#x2F;next&#x2F;_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<h2 id="定制页面"><a href="#定制页面" class="headerlink" title="定制页面"></a>定制页面</h2><p>Hexo的scripts目录下新增customcategory.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredCategory = <span class="string">&#x27;分析&#x27;</span>;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">generator</span>.<span class="title function_">register</span>(<span class="string">&#x27;customcategory&#x27;</span>, <span class="keyword">function</span>(<span class="params">locals</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> analysisPosts = locals.<span class="property">posts</span>.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="property">categories</span>.<span class="property">data</span>[<span class="number">0</span>].<span class="property">name</span> == filteredCategory;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(<span class="string">&#x27;analysis&#x27;</span>, analysisPosts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;customcategory&#x27;</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://github.com/hexojs/hexo-pagination#hexo-pagination">hexo-pagination</a> 的使用方式</p>
<h2 id="定制模板"><a href="#定制模板" class="headerlink" title="定制模板"></a>定制模板</h2><p>theme&#x2F;next&#x2F;layout 下新增 customcategory.swig</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125;</span><br><span class="line">&#123;% import &#x27;_macro/post-collapse.swig&#x27; as post_template with context %&#125;</span><br><span class="line">&#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template with context %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; __(&#x27;title.category&#x27;) &#125;&#125;: &#123;&#123; page.category &#125;&#125; | &#123;&#123; title &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block class %&#125;category&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &#123;### CATEGORY BLOCK ###&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &lt;div class=&quot;post-block&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;posts-collapse&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class="line">        &lt;h2 class=&quot;collection-header&quot;&gt;</span><br><span class="line">          &#123;&#123;- page.category &#125;&#125;</span><br><span class="line">          &lt;small&gt;&#123;&#123; __(&#x27;title.category&#x27;) &#125;&#125;&lt;/small&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &#123;&#123; post_template.render(page.posts) &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">  &#123;### END CATEGORY BLOCK ###&#125;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% include &#x27;_partials/pagination.swig&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br><span class="line">hexo deploy</span><br><span class="line">(新版本支持首字母缩写命令，如 hexo g -&gt; hexo generate)</span><br></pre></td></tr></table></figure>

<h2 id="hexo常用插件"><a href="#hexo常用插件" class="headerlink" title="hexo常用插件"></a>hexo常用插件</h2><p>插件地址: <a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;hexo&quot;: &quot;^5.4.2&quot;,</span><br><span class="line">&quot;hexo-cake-moon-menu&quot;: &quot;^2.5.0&quot;,</span><br><span class="line">&quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">&quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;hexo-auto-category&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">&quot;hexo-calendar&quot;: &quot;^1.0.6&quot;,</span><br><span class="line">&quot;hexo-cli&quot;: &quot;^4.3.0&quot;,</span><br><span class="line">&quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">&quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">&quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;,</span><br><span class="line">&quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">&quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">&quot;hexo-generator-search&quot;: &quot;^2.4.3&quot;,</span><br><span class="line">&quot;hexo-generator-searchdb&quot;: &quot;^1.4.1&quot;,</span><br><span class="line">&quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">&quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">&quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">&quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">&quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">&quot;hexo-renderer-swig&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-server&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">&quot;hexo-theme-next&quot;: &quot;^8.14.0&quot;,</span><br><span class="line">&quot;hexo-word-counter&quot;: &quot;^0.1.0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-note用法"><a href="#hexo-note用法" class="headerlink" title="hexo note用法"></a>hexo note用法</h2><p><a href="https://hexo.io/zh-cn/docs/tag-plugins">https://hexo.io/zh-cn/docs/tag-plugins</a></p>
<h3 id="配置部分"><a href="#配置部分" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment">#false时PC端不显示图标，但移动端仍会显示，故需要在标签语句中手动no-icon进行标注</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">note.js</span><br><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br><span class="line">All parameters are optional.</span><br></pre></td></tr></table></figure>

<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">#### Default Header</span><br><span class="line">Welcome to [Hexo!](https://hexo.io)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-tabs用法"><a href="#hexo-tabs用法" class="headerlink" title="hexo tabs用法"></a>hexo tabs用法</h2><h3 id="配置部分-1"><a href="#配置部分-1" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">next/_config.yml</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="执行模板-1"><a href="#执行模板-1" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span><br><span class="line">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span><br><span class="line">                Only for current url of post/page must be unique!</span><br><span class="line">[index]       : Index number of active tab.</span><br><span class="line">                If not specified, first tab (1) will be selected.</span><br><span class="line">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span><br><span class="line">                Optional parameter.</span><br><span class="line">[Tab caption] : Caption of current tab.</span><br><span class="line">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span><br><span class="line">                If not caption specified, but specified icon, caption will empty.</span><br><span class="line">                Optional parameter.</span><br><span class="line">[@icon]       : FontAwesome icon name (without &#x27;fa-&#x27; at the begining).</span><br><span class="line">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span><br><span class="line">                Optional parameter.</span><br></pre></td></tr></table></figure>

<h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-pdf用法"><a href="#hexo-pdf用法" class="headerlink" title="hexo pdf用法"></a>hexo pdf用法</h2><h3 id="配置部分-2"><a href="#配置部分-2" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">next/_config.yml</span></span><br><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br></pre></td></tr></table></figure>

<h3 id="执行模板-2"><a href="#执行模板-2" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdf.js</span><br><span class="line">&#123;% pdf url [height] %&#125;</span><br><span class="line">[url]    : Relative path to PDF file.</span><br><span class="line">[height] : Optional. Height of the PDF display element, e.g. 800px.</span><br></pre></td></tr></table></figure>
<h3 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% pdf https://example.com/sample.pdf %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-video用法"><a href="#hexo-video用法" class="headerlink" title="hexo video用法"></a>hexo video用法</h2><h3 id="执行模板-3"><a href="#执行模板-3" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">video.js</span><br><span class="line">&#123;% video url %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="example-3"><a href="#example-3" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% video /path/to/your/video.mp4 %&#125;</span><br><span class="line">&#123;% video https://example.com/sample.mp4 %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-Group-pictures用法"><a href="#hexo-Group-pictures用法" class="headerlink" title="hexo Group-pictures用法"></a>hexo Group-pictures用法</h2><h3 id="执行模板-4"><a href="#执行模板-4" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group-pictures.js</span><br><span class="line">&#123;% grouppicture [group]-[layout] %&#125;&#123;% endgrouppicture %&#125;</span><br><span class="line">&#123;% gp [group]-[layout] %&#125;&#123;% endgp %&#125;</span><br><span class="line">[group]  : Total number of pictures to add in the group.</span><br><span class="line">[layout] : Default picture under the group to show.</span><br></pre></td></tr></table></figure>
<h3 id="example-4"><a href="#example-4" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% grouppicture 7-5%&#125;</span><br><span class="line">  ![](https://suncos-01-1254144885.cos.ap-shanghai.myqcloud.com/%E6%89%8B%E6%9C%BA/IMG_20160720_192243_AO_HDR.jpg)</span><br><span class="line">  ![](https://suncos-01-1254144885.cos.ap-shanghai.myqcloud.com/%E6%89%8B%E6%9C%BA/IMG_20160817_185254_AO_HDR.jpg)</span><br><span class="line">&#123;% endgrouppicture %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-写作模板"><a href="#hexo-写作模板" class="headerlink" title="hexo 写作模板"></a>hexo 写作模板</h2><p><a href="https://www.bas369.com/more/learning_notes/2020/03/14/Markdown%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/">https://www.bas369.com/more/learning_notes/2020/03/14/Markdown%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/</a></p>
<h2 id="hexo-资源文件夹"><a href="#hexo-资源文件夹" class="headerlink" title="hexo 资源文件夹"></a>hexo 资源文件夹</h2><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p>
<h2 id="github-svg-corner"><a href="#github-svg-corner" class="headerlink" title="github svg corner"></a>github svg corner</h2><p><a href="https://tholman.com/github-corners/">https://tholman.com/github-corners/</a></p>
<h2 id="githubPage访问地址问题"><a href="#githubPage访问地址问题" class="headerlink" title="githubPage访问地址问题"></a>githubPage访问地址问题</h2><p>repository名称需要与githubPage名称保持一致<br>域名在github repository setting中配置，每次上传被覆盖<br>需要配置cname文件</p>
<p><img src="/img/gitio_custom_domain_20221228193328.png" alt="GithubPage"></p>
<h2 id="cname-重定向"><a href="#cname-重定向" class="headerlink" title="cname 重定向"></a>cname 重定向</h2><p>hexo 站点配置文件 _config.yml中设置url为域名<br>githubPage 重定向机制 source目录新建CNAME文件，添加域名地址<br>如果你的 CNAME 文件为 example.com，那么 <a href="http://www.example.com/">www.example.com</a> 会定向到 example.com。<br>如果你的 CNAME 文件为 <a href="http://www.example.com,那么/">www.example.com，那么</a> example.com 会定向到 <a href="http://www.example.com/">www.example.com</a></p>
<p><img src="/img/ali_dns_config_20221228164219.png" alt="阿里DNS配置"></p>
<h2 id="hexo配置文件说明"><a href="#hexo配置文件说明" class="headerlink" title="hexo配置文件说明"></a>hexo配置文件说明</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<h2 id="hexo-语言"><a href="#hexo-语言" class="headerlink" title="hexo 语言"></a>hexo 语言</h2><p>站点配置文件 language: zh-Hans &#x2F;&#x2F; 这里设置语言 简体中文<br>对应主题语言目录中的 文件名 需要保持一致</p>
<h2 id="hexo-问题处理"><a href="#hexo-问题处理" class="headerlink" title="hexo 问题处理"></a>hexo 问题处理</h2><p><a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a></p>
<h3 id="访问页面直接显示未经过渲染的模板"><a href="#访问页面直接显示未经过渲染的模板" class="headerlink" title="访问页面直接显示未经过渲染的模板"></a>访问页面直接显示未经过渲染的模板</h3><p>hexo在5.0版本以上移除了swig</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-swig --save</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.eson.org/categories/">https://blog.eson.org/categories/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>theme配置</title>
    <url>/posts/f80e45ab.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">git clone --branch v6.0.0 https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>hexo _config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1 Solution</title>
    <url>/posts/a9ea619c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//定义返回结果</span></span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//缓存出现过的数&lt;数字和下标&gt;</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//另一个数字之前出现过</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(target -nums[i] )) &#123;</span><br><span class="line">                ret[<span class="number">0</span>] = cache.get(target -nums[i]);</span><br><span class="line">                ret[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没出现过则缓存下来</span></span><br><span class="line">                cache.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Solution</span>().twoSum(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 10 Solution</title>
    <url>/posts/2a4e0cd9.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#x27;.&#x27; 和 &#x27;*&#x27; 的正则表达式匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;.&#x27; 匹配任意单个字符</span></span><br><span class="line"><span class="comment"> * &#x27;*&#x27; 匹配零个或多个前面的那一个元素</span></span><br><span class="line"><span class="comment"> * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/regular-expression-matching</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] = f[i][j] || f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j)) &#123;</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String s, String p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 100 Solution</title>
    <url>/posts/2c7b1dab.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s100;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相同的树</span></span><br><span class="line"><span class="comment"> * 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 101 Solution</title>
    <url>/posts/c3b97695.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s101;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对称二叉树</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ， 检查它是否轴对称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 102 Solution</title>
    <url>/posts/288ecd96.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s102;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 104 Solution</title>
    <url>/posts/2590bdd1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s104;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的最大深度</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最大深度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明: 叶子节点是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * 给定二叉树 [3,9,20,null,null,15,7]，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     3</span></span><br><span class="line"><span class="comment"> *    / \</span></span><br><span class="line"><span class="comment"> *   9  20</span></span><br><span class="line"><span class="comment"> *     /  \</span></span><br><span class="line"><span class="comment"> *    15   7</span></span><br><span class="line"><span class="comment"> * 返回它的最大深度 3 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//到叶子节点结束</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左子树最大深度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="comment">//右子树最大深度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="comment">//最大值</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 103 Solution</title>
    <url>/posts/c74ca6a8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s103;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的锯齿形层序遍历</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//定义返回结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//放入根节点</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">//定义顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">zig</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从队列取值</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//每层单独存放到对应的链表中，头插尾插 根据zig区分</span></span><br><span class="line">            Deque&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="comment">//队列取值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zig) &#123;</span><br><span class="line">                    level.offerLast(cur.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    level.offerFirst(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前节点不为null，取下一层，从左往右</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每下层更新下 zig</span></span><br><span class="line">            zig = !zig;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(level));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 105 Solution</title>
    <url>/posts/ca52d6ef.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s105;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从前序与中序遍历序列构造二叉树</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; inorder.length;i++) &#123;</span><br><span class="line">            cache.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(cache, preorder, inorder, <span class="number">0</span>, preorder.length, <span class="number">0</span>, inorder.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">( Map&lt;Integer, Integer&gt; cache, <span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> pres, <span class="type">int</span> pree, <span class="type">int</span> inos, <span class="type">int</span> inoe)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pres &gt;= pree) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cache.get(preorder[pres]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pres]);</span><br><span class="line">        node.left =  buildTree(cache, preorder, inorder, pres+<span class="number">1</span>, pres+<span class="number">1</span> + index-inos, inos, index);</span><br><span class="line">        node.right =  buildTree(cache, preorder, inorder, pres+<span class="number">1</span> + index-inos, pree,  index+<span class="number">1</span>, inoe);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 106 Solution</title>
    <url>/posts/21656dec.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s106;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从中序与后序遍历序列构造二叉树</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="literal">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> inorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">postorderVal</span> <span class="operator">=</span> postorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 107 Solution</title>
    <url>/posts/cea706d2.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s107;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历 II</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelOrder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> levelOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left, right = node.right;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelOrder.add(<span class="number">0</span>, level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> levelOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 108 Solution</title>
    <url>/posts/3fac5d5f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s108;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 109 Solution</title>
    <url>/posts/d06e3661.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s109;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有序链表转换二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> getMedian(left, right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right = buildTree(mid.next, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMedian</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (fast != right &amp;&amp; fast.next != right) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 11 Solution</title>
    <url>/posts/c58c67e7.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 盛最多水的容器</span></span><br><span class="line"><span class="comment"> * 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/container-with-most-water</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 110 Solution</title>
    <url>/posts/edf5c26b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s110;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平衡二叉树</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，判断它是否是高度平衡的二叉树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中，一棵高度平衡二叉树定义为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//如果等于-1就表示不是平衡的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNBALANCED</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root) != UNBALANCED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左子节点不是平衡二叉树，直接返回UNBALANCED</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == UNBALANCED)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果右子节点不是平衡二叉树，直接返回UNBALANCED</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == UNBALANCED)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左右子节点都是平衡二叉树，但他们的高度相差大于1，</span></span><br><span class="line">        <span class="comment">//直接返回UNBALANCED</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则就返回二叉树中节点的最大高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 111 Solution</title>
    <url>/posts/237a955.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s111;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的最小深度</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最小深度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：叶子节点是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min_depth</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 112 Solution</title>
    <url>/posts/e9001256.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s112;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径总和</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历树时存放节点用</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存放当前路径值</span></span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//从root开始遍历</span></span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val);</span><br><span class="line">        <span class="comment">//遍历Queue中节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">now</span> <span class="operator">=</span> queNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queVal.poll();</span><br><span class="line">            <span class="comment">//深度遍历终止条件，左右子树为null，存入的长度 == sum</span></span><br><span class="line">            <span class="keyword">if</span> (now.left == <span class="literal">null</span> &amp;&amp; now.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左子树不为null</span></span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.left);</span><br><span class="line">                queVal.offer(now.left.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右子树不为null</span></span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.right);</span><br><span class="line">                queVal.offer(now.right.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 113 Solution</title>
    <url>/posts/6c27968.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s113;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径总和 II</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/path-sum-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义结果list</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//定义路径</span></span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//深度遍历</span></span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历到叶子节点结束</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把遍历路径的值存到队列中</span></span><br><span class="line">        path.offerLast(root.val);</span><br><span class="line">        <span class="comment">//目标值减小</span></span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="comment">//直到没有叶子节点了，或者 目标值为0 也就是 路径和 == targetSum了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//把队列的路径存到结果list中</span></span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度遍历左子树</span></span><br><span class="line">        dfs(root.left, targetSum);</span><br><span class="line">        <span class="comment">//深度遍历右子树</span></span><br><span class="line">        dfs(root.right, targetSum);</span><br><span class="line">        <span class="comment">//把路径中的值弹出</span></span><br><span class="line">        path.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 114 Solution</title>
    <url>/posts/e41e6211.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s114;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树展开为链表</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根结点 root ，请你将它展开为一个单链表：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</span></span><br><span class="line"><span class="comment"> * 展开后的单链表应该与二叉树 先序遍历 顺序相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/flatten-binary-tree-to-linked-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.get(i - <span class="number">1</span>), curr = list.get(i);</span><br><span class="line">            prev.left = <span class="literal">null</span>;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1143 Solution</title>
    <url>/posts/523dbc44.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s1143;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。</span></span><br><span class="line"><span class="comment"> * 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-common-subsequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建二维数组 m n  做动态规划</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果对应位置字符相同，增对应位置值 为 前一位置（i-1,j -1）值 + 1</span></span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则取其中前面(i-1,j) 或者（i, j-1）最大的那个值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 116 Solution</title>
    <url>/posts/e0ebb22c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s116;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充每个节点的下一个右侧节点指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, Node _left, Node _right, Node _next)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列同时将第一层节点加入队列中，即根节点</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层的 while 循环迭代的是层数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录当前队列大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历这一层的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从队首取出元素</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    node.next = queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拓展下一层节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 115 Solution</title>
    <url>/posts/bdc092f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s115;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的子序列</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&quot;ACE&quot; 是 &quot;ABCDE&quot; 的一个子序列，而 &quot;AEC&quot; 不是）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据保证答案符合 32 位带符号整数范围。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/distinct-subsequences</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">sChar</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tChar</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (sChar == tChar) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 119 Solution</title>
    <url>/posts/11e0e9a1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s119;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杨辉三角 II</span></span><br><span class="line"><span class="comment"> * 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在「杨辉三角」中，每个数是它左上方和右上方的数的和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(C.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + C.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            C.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 117 Solution</title>
    <url>/posts/f29d912.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s117;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充每个节点的下一个右侧节点指针 II</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   Node *left;</span></span><br><span class="line"><span class="comment"> *   Node *right;</span></span><br><span class="line"><span class="comment"> *   Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 初始状态下，所有 next 指针都被设置为 NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进阶：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能使用常量级额外空间。</span></span><br><span class="line"><span class="comment"> * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, Node _left, Node _right, Node _next)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (f.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(f.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(f.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">                    last.next = f;</span><br><span class="line">                &#125;</span><br><span class="line">                last = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 118 Solution</title>
    <url>/posts/fe22829f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s118;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杨辉三角</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在「杨辉三角」中，每个数是它左上方和右上方的数的和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 12 Solution</title>
    <url>/posts/2ebbdce4.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s12;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数转罗马数字</span></span><br><span class="line"><span class="comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment"> * 给你一个整数，将其转为罗马数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/integer-to-roman</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> symbols[i];</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 120 Solution</title>
    <url>/posts/7417a46a.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s120;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三角形最小路径和</span></span><br><span class="line"><span class="comment"> * 给定一个三角形 triangle ，找出自顶向下的最小路径和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/triangle</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> i % <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">1</span> - curr;</span><br><span class="line">            f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[curr][j] = Math.min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTotal</span> <span class="operator">=</span> f[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, f[(n - <span class="number">1</span>) % <span class="number">2</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 121 Solution</title>
    <url>/posts/9bd5cf54.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s121;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机</span></span><br><span class="line"><span class="comment"> * 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//设置最小金额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minBuy</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//设置最大利润</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//买入的最小金额</span></span><br><span class="line">            minBuy = Math.min(minBuy, prices[i]);</span><br><span class="line">            <span class="comment">//卖出的最大金额</span></span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minBuy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 122 Solution</title>
    <url>/posts/70e27457.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s122;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 你能获得的 最大 利润 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//构建dp数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//买入股票的成本</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//前一天卖出，或者今天卖出</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">//前一天买入，或者今天买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 124 Solution</title>
    <url>/posts/7dfc0410.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s124;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中的最大路径和</span></span><br><span class="line"><span class="comment"> * 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 路径和 是路径中各节点值的总和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，返回其 最大路径和 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewpath</span> <span class="operator">=</span> node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 123 Solution</title>
    <url>/posts/9f201f69.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment"> * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 125 Solution</title>
    <url>/posts/923e6f2e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证回文串</span></span><br><span class="line"><span class="comment"> * 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lowerCase</span> <span class="operator">=</span> s.toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> lowerCase.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 指针left小于指针right且当前考察的字符不是字母或数字，指针left向左移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针left小于指针right且当前考察的字符不是字母或数字，指针right向右移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果指针left指向的字符与指针right指向的字符不同，则不是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (lowerCase.charAt(left) != lowerCase.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针left左移，指针right右移，继续考察下一对字符</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 126 Solution</title>
    <url>/posts/7909d42d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s126;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词接龙 II</span></span><br><span class="line"><span class="comment"> * 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk 这样的单词序列，并满足：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每对相邻的单词之间仅有单个字母不同。</span></span><br><span class="line"><span class="comment"> * 转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</span></span><br><span class="line"><span class="comment"> * sk == endWord</span></span><br><span class="line"><span class="comment"> * 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-ladder-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="comment">// 特殊用例判断</span></span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dict.remove(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：广度优先遍历建图</span></span><br><span class="line">        <span class="comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span></span><br><span class="line">        Map&lt;String, Integer&gt; steps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        steps.put(beginWord, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; from = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> beginWord.length();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">char</span>[] charArray = currWord.toCharArray();</span><br><span class="line">                <span class="comment">// 将每一位替换成 26 个小写英文字母</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> charArray[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        charArray[j] = c;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                        <span class="keyword">if</span> (steps.containsKey(nextWord) &amp;&amp; step == steps.get(nextWord)) &#123;</span><br><span class="line">                            from.get(nextWord).add(currWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!dict.contains(nextWord)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span></span><br><span class="line">                        dict.remove(nextWord);</span><br><span class="line">                        <span class="comment">// 这一层扩展出的单词进入队列</span></span><br><span class="line">                        queue.offer(nextWord);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 记录 nextWord 从 currWord 而来</span></span><br><span class="line">                        from.putIfAbsent(nextWord, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                        from.get(nextWord).add(currWord);</span><br><span class="line">                        <span class="comment">// 记录 nextWord 的 step</span></span><br><span class="line">                        steps.put(nextWord, step);</span><br><span class="line">                        <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                            found = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charArray[j] = origin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            path.add(endWord);</span><br><span class="line">            dfs(from, path, beginWord, endWord, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; from, Deque&lt;String&gt; path, String beginWord, String cur, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(beginWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String precursor : from.get(cur)) &#123;</span><br><span class="line">            path.addFirst(precursor);</span><br><span class="line">            dfs(from, path, beginWord, precursor, res);</span><br><span class="line">            path.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 127 Solution</title>
    <url>/posts/96cbbf13.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s127;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词接龙</span></span><br><span class="line"><span class="comment"> * 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一对相邻的单词只差一个字母。</span></span><br><span class="line"><span class="comment"> *  对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。</span></span><br><span class="line"><span class="comment"> * sk == endWord</span></span><br><span class="line"><span class="comment"> * 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-ladder</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">            addEdge(word);</span><br><span class="line">        &#125;</span><br><span class="line">        addEdge(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        que.offer(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it : edge.get(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        addWord(word);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">        <span class="type">char</span>[] array = word.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            addWord(newWord);</span><br><span class="line">            <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">            edge.get(id1).add(id2);</span><br><span class="line">            edge.get(id2).add(id1);</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class="line">            wordId.put(word, nodeNum++);</span><br><span class="line">            edge.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 128 Solution</title>
    <url>/posts/67c0e49e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s128;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长连续序列</span></span><br><span class="line"><span class="comment"> * 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-consecutive-sequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//数字集合</span></span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            num_set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最长序列长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="comment">//找到最小的数字开始</span></span><br><span class="line">            <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//找更大的数字是否存在，并统计连续数字序列长度</span></span><br><span class="line">                <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//比较最长的序列</span></span><br><span class="line">                longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 129 Solution</title>
    <url>/posts/88028fa0.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s129;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求根节点到叶节点数字之和</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</span></span><br><span class="line"><span class="comment"> * 每条从根节点到叶节点的路径都代表一个数字：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</span></span><br><span class="line"><span class="comment"> * 计算从根节点到叶节点生成的 所有数字之和 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//深度遍历 累加数字</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> prevSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//累加数字，每位进10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevSum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="comment">//左右子树为null 则返回和</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//继续深度遍历</span></span><br><span class="line">            <span class="keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 13 Solution</title>
    <url>/posts/c179b7da.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 罗马数字转整数</span></span><br><span class="line"><span class="comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment"> * 给定一个罗马数字，将其转换成整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/roman-to-integer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 130 Solution</title>
    <url>/posts/b5997baa.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s130;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被围绕的区域</span></span><br><span class="line"><span class="comment"> * 给你一个 m x n 的矩阵 board ，由若干字符 &#x27;X&#x27; 和 &#x27;O&#x27; ，找到所有被 &#x27;X&#x27; 围绕的区域，并将这些区域里所有的 &#x27;O&#x27; 用 &#x27;X&#x27; 填充。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 131 Solution</title>
    <url>/posts/5a5b1094.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s131;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割回文串</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回文串 是正着读和反着读都一样的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] f;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(f[i], <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                ans.add(s.substring(i, j + <span class="number">1</span>));</span><br><span class="line">                dfs(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.remove(ans.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 132 Solution</title>
    <url>/posts/b16cab97.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s132;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割回文串 II</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回符合要求的 最少分割次数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] g = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(g[i], <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                f[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[j + <span class="number">1</span>][i]) &#123;</span><br><span class="line">                        f[i] = Math.min(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 133 Solution</title>
    <url>/posts/5eaec0a9.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s133;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 克隆图</span></span><br><span class="line"><span class="comment"> * 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * class Node &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/clone-graph</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt;&gt; ();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cloneNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        <span class="comment">// 哈希表存储</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor: node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 134 Solution</title>
    <url>/posts/bc72dbd0.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s134;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加油站</span></span><br><span class="line"><span class="comment"> * 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/gas-station</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumOfGas</span> <span class="operator">=</span> <span class="number">0</span>, sumOfCost = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (i + cnt) % n;</span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                sumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span> (sumOfCost &gt; sumOfGas) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + cnt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 135 Solution</title>
    <url>/posts/53b0b0ee.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s135;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发糖果</span></span><br><span class="line"><span class="comment"> * n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你需要按照以下要求，给这些孩子分发糖果：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个孩子至少分配到 1 个糖果。</span></span><br><span class="line"><span class="comment"> * 相邻两个孩子评分更高的孩子会获得更多的糖果。</span></span><br><span class="line"><span class="comment"> * 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/candy</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//从左到右发，最少给1个 分高就比右边多给一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右向左，保证左侧分高的能多分一个糖</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += Math.max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 136 Solution</title>
    <url>/posts/b8870bed.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s136;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/single-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashMap</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="comment">//将其存入哈希表中，含义为，若该元素不存在则存入表中，并计数为1，若已经存在获取次数并加1.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            map.put(x , map.getOrDefault(x,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历出出现次数为1的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(y) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 137 Solution</title>
    <url>/posts/574560d3.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s137;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//最终的结果值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int类型有32位，统计每一位1的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//统计第i位中1的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oneCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                oneCount += (nums[j] &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果1的个数不是3的倍数，说明那个只出现一次的数字</span></span><br><span class="line">            <span class="comment">//的二进制位中在这一位是1</span></span><br><span class="line">            <span class="keyword">if</span> (oneCount % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 138 Solution</title>
    <url>/posts/a64e3b5e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s138;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制带随机指针的链表</span></span><br><span class="line"><span class="comment"> * 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回复制链表的头节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * val：一个表示 Node.val 的整数。</span></span><br><span class="line"><span class="comment"> * random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</span></span><br><span class="line"><span class="comment"> * 你的代码 只 接受原链表的头节点 head 作为传入参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/copy-list-with-random-pointer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//节点缓存到map</span></span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果已经缓存说明节点已存在，则不用复制</span></span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class="line">            <span class="comment">//复制节点值</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            <span class="comment">//缓存新旧节点</span></span><br><span class="line">            cachedNode.put(head, headNew);</span><br><span class="line">            <span class="comment">//新节点next指向下一个新节点</span></span><br><span class="line">            headNew.next = copyRandomList(head.next);</span><br><span class="line">            <span class="comment">//新节点random指向下一个新节点</span></span><br><span class="line">            headNew.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 139 Solution</title>
    <url>/posts/498c5060.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s139;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词拆分</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-break</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Set&lt;Integer&gt; wordLength = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            wordLength.add(word.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单词去重</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        Set&lt;String&gt; wrongSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> matchWords(s, dict, wordLength, wrongSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchWords</span><span class="params">(String s, Set&lt;String&gt; dict, Set&lt;Integer&gt; wordLength, Set&lt;String&gt; wrongSet)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(s) || dict.contains(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历单词所有字符</span></span><br><span class="line">        <span class="keyword">for</span>(Integer j : wordLength) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; s.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="comment">//截取字符串，找到单词表中存在的子串</span></span><br><span class="line">            <span class="keyword">if</span>(dict.contains(sub)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subEnd</span> <span class="operator">=</span> s.substring(j);</span><br><span class="line">                <span class="keyword">if</span>(!wrongSet.contains(subEnd) &amp;&amp; matchWords(subEnd, dict, wordLength, wrongSet)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wrongSet.add(subEnd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 14 Solution</title>
    <url>/posts/23a5aca3.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长公共前缀</span></span><br><span class="line"><span class="comment"> * 编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不存在公共前缀，返回空字符串 &quot;&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取第一个数组做对比</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">//字符串个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="comment">//遍历字符串字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="comment">//对比其他字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="comment">//达到其他字符串最大长度 或者 字符匹配不上，则终止</span></span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 140 Solution</title>
    <url>/posts/9ca26e29.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s140;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词拆分 II</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：词典中的同一个单词可能在分段中被重复使用多次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-break-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(wordDict), <span class="number">0</span>, map);</span><br><span class="line">        List&lt;String&gt; breakList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; wordBreak : wordBreaks) &#123;</span><br><span class="line">            breakList.add(String.join(<span class="string">&quot; &quot;</span>, wordBreak));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> breakList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> length, Set&lt;String&gt; wordSet, <span class="type">int</span> index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(index)) &#123;</span><br><span class="line">            List&lt;List&lt;String&gt;&gt; wordBreaks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">                wordBreaks.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(index, i);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(word)) &#123;</span><br><span class="line">                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);</span><br><span class="line">                    <span class="keyword">for</span> (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;</span><br><span class="line">                        LinkedList&lt;String&gt; wordBreak = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(nextWordBreak);</span><br><span class="line">                        wordBreak.offerFirst(word);</span><br><span class="line">                        wordBreaks.add(wordBreak);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(index, wordBreaks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 141 Solution</title>
    <url>/posts/73600517.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s141;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/linked-list-cycle</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//下一步不为null</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//快指针走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">//慢指针走一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//快慢相遇则出现环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 142 Solution</title>
    <url>/posts/9857be14.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s142;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形链表 II</span></span><br><span class="line"><span class="comment"> * 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不允许修改 链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/linked-list-cycle-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快慢指针，快指针走两步，慢指针走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//快慢指针都走完结束</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//快慢指针相遇</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="comment">//快慢指针相遇后，此时慢指针走到链表环开始节点的距离，刚好等于head节点到链表环开始节点的距离</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 144 Solution</title>
    <url>/posts/9549ce53.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s144;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的前序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//定义结果list</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义队列 遍历时存放当前节点用</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(stack.size() != <span class="number">0</span> || node!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="comment">//先当前节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//后left节点</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后右节点</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 143 Solution</title>
    <url>/posts/7795d52a.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s143;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重排链表</span></span><br><span class="line"><span class="comment"> * 给定一个单链表 L 的头节点 head ，单链表 L 表示为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L0 → L1 → … → Ln - 1 → Ln</span></span><br><span class="line"><span class="comment"> * 请将其重新排列后变为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span></span><br><span class="line"><span class="comment"> * 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reorder-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找链表中间点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMid(head);</span><br><span class="line">        <span class="comment">//拆分成前后两个链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//翻转后面的链表</span></span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        <span class="comment">//两个链表合并</span></span><br><span class="line">        mergeList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next!= <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间点</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l1_tmp</span> <span class="operator">=</span> l1.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l2_tmp</span> <span class="operator">=</span> l2.next;</span><br><span class="line">            <span class="comment">//l1 指向 l2</span></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            <span class="comment">//l2 要指向 l1.next 也就是未修改指向的l1_tmp</span></span><br><span class="line">            l2.next = l1_tmp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一步</span></span><br><span class="line">            l1 = l1_tmp;</span><br><span class="line">            l2 = l2_tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 145 Solution</title>
    <url>/posts/7a8ba56d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s145;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的后序遍历</span></span><br><span class="line"><span class="comment"> * 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">//先左孩子入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">//右孩子入栈</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 146 Solution</title>
    <url>/posts/91bc1e6e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s146;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU 缓存</span></span><br><span class="line"><span class="comment"> * 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</span></span><br><span class="line"><span class="comment"> * 实现 LRUCache 类：</span></span><br><span class="line"><span class="comment"> * LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</span></span><br><span class="line"><span class="comment"> * int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> * void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</span></span><br><span class="line"><span class="comment"> * 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/lru-cache</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LRU队列中的元素定义 双向链表存储 方便随机访问 删除 添加操作</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="comment">//缓存key</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="comment">//缓存值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">//队列前一个节点</span></span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        <span class="comment">//队列后一个节点</span></span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LRU缓存map&lt;缓存的值, 缓存的元素&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="comment">//缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//缓存容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">//头结点 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line">    <span class="comment">//缓存初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//使用伪头部和伪尾部节点 方便尾部查询，头部删除</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//先从map中取</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 key 存在，先通过哈希表定位，再移到头部， 头插尾删。</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//先从map中取</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            <span class="comment">//记录元素个数</span></span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *头插</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该节点</span></span><br><span class="line"><span class="comment">     * 并把该节点移动到头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾部节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 147 Solution</title>
    <url>/posts/7e7e7550.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s147;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail) &#123;</span><br><span class="line">            fast  = fast.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">m</span> <span class="operator">=</span> sortList(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> sortList(mid, tail);</span><br><span class="line">        <span class="keyword">return</span> mergeList(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 != <span class="literal">null</span> &amp;&amp; tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1.val &lt; tmp2.val) &#123;</span><br><span class="line">                tmp.next = tmp1;</span><br><span class="line">                tmp1 = tmp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = tmp2;</span><br><span class="line">                tmp2 = tmp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 148 Solution</title>
    <url>/posts/8f752edd.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s148;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail) &#123;</span><br><span class="line">            fast  = fast.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">m</span> <span class="operator">=</span> sortList(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> sortList(mid, tail);</span><br><span class="line">        <span class="keyword">return</span> mergeList(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 != <span class="literal">null</span> &amp;&amp; tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1.val &lt; tmp2.val) &#123;</span><br><span class="line">                tmp.next = tmp1;</span><br><span class="line">                tmp1 = tmp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = tmp2;</span><br><span class="line">                tmp2 = tmp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 15 Solution</title>
    <url>/posts/cc67c79d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数之和</span></span><br><span class="line"><span class="comment"> * 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/3sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//结果list</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//判断入参</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">//排序数据，方便设置左右边界 遍历</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//先定义一个元素遍历，作为三个中最小的一个值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt; nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//判断终止条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="comment">//忽略到相同的值</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//第二个元素 取区间左边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第三个元素 取区间右边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果左右边界重合 则停止</span></span><br><span class="line">            <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">                <span class="comment">//如果三数和为0</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[L] + nums[R] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//记录三个数</span></span><br><span class="line">                    <span class="type">List</span> <span class="variable">numbers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                    numbers.add(nums[i]);</span><br><span class="line">                    numbers.add(nums[L]);</span><br><span class="line">                    numbers.add(nums[R]);</span><br><span class="line">                    ret.add(numbers);</span><br><span class="line">                    <span class="comment">//基于已有的和为0 左右移动边界 寻找其他的记录</span></span><br><span class="line">                    <span class="keyword">while</span>(L&lt; R &amp;&amp; (nums[L] == nums[L+<span class="number">1</span>])) &#123;</span><br><span class="line">                        <span class="comment">//忽略相同的数值 左边界右移</span></span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(R &gt; L &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">//忽略相同的数值 右边界左移</span></span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//移动左右边界</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 和小于0  左边界右移</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 和大于0  右边界左移</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 151 Solution</title>
    <url>/posts/b2eedad7.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，颠倒字符串中 单词 的顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-words-in-a-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 155 Solution</title>
    <url>/posts/bb057aad.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 MinStack 类:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MinStack() 初始化堆栈对象。</span></span><br><span class="line"><span class="comment"> * void push(int val) 将元素val推入堆栈。</span></span><br><span class="line"><span class="comment"> * void pop() 删除堆栈顶部的元素。</span></span><br><span class="line"><span class="comment"> * int top() 获取堆栈顶部的元素。</span></span><br><span class="line"><span class="comment"> * int getMin() 获取堆栈中的最小元素。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/min-stack</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line">    <span class="comment">//最小栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        data.push(val);</span><br><span class="line">        <span class="keyword">if</span>(minStack.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//最小值存栈顶，如果不是最小，取栈顶的最小值再存一次，保证pop后 最小值还在栈顶</span></span><br><span class="line">            minStack.push(Math.min(val, minStack.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 160 Solution</title>
    <url>/posts/c4ced7e8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s160;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">         next = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 16 Solution</title>
    <url>/posts/27507c9e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最接近的三数之和</span></span><br><span class="line"><span class="comment"> * 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回这三个数的和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假定每组输入只存在恰好一个解。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/3sum-closest</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k0</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">j0</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 165 Solution</title>
    <url>/posts/22e71cac.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s165;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个版本号 version1 和 version2 ，请你比较它们。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 版本号由一个或多个修订号组成，各修订号由一个 &#x27;.&#x27; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回规则如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 version1 &gt; version2 返回 1，</span></span><br><span class="line"><span class="comment"> * 如果 version1 &lt; version2 返回 -1，</span></span><br><span class="line"><span class="comment"> * 除此之外返回 0。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/compare-version-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        String[] v1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] v2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v1.length||i&lt;v2.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v1.length) &#123;</span><br><span class="line">                x = Integer.parseInt(v1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v2.length) &#123;</span><br><span class="line">                y = Integer.parseInt(v2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 169 Solution</title>
    <url>/posts/38dbfc22.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s169;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/majority-element</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">countNums</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!counts.containsKey(num)) &#123;</span><br><span class="line">                counts.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(num, counts.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = countNums(nums);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (majorityEntry == <span class="literal">null</span> || entry.getValue() &gt; majorityEntry.getValue()) &#123;</span><br><span class="line">                majorityEntry = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 17 Solution</title>
    <url>/posts/c89217a0.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电话号码的字母组合</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/letter-combinations-of-a-phone-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 18 Solution</title>
    <url>/posts/39994c2d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s18;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四数之和</span></span><br><span class="line"><span class="comment"> * 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 &lt;= a, b, c, d &lt; n</span></span><br><span class="line"><span class="comment"> * a、b、c 和 d 互不相同</span></span><br><span class="line"><span class="comment"> * nums[a] + nums[b] + nums[c] + nums[d] == target</span></span><br><span class="line"><span class="comment"> * 你可以按 任意顺序 返回答案 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/4sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 19 Solution</title>
    <url>/posts/d65b2713.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s19;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表的倒数第 N 个结点</span></span><br><span class="line"><span class="comment"> * 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = dum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt; cnt-n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 199 Solution</title>
    <url>/posts/ab2308e4.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s199;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_dep</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右分支视图按层输出</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; rightViewAtDepth = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//节点压栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        <span class="comment">//深度压栈</span></span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(nodeStack.size() != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//节点弹栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeStack.pop();</span><br><span class="line">            <span class="comment">//深度弹栈</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">dep</span> <span class="operator">=</span> depthStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//最大深度</span></span><br><span class="line">                max_dep = Math.max(dep, max_dep);</span><br><span class="line">                <span class="comment">//右视图未遍历到该层，第一次遍历到的一定是右节点</span></span><br><span class="line">                <span class="keyword">if</span>(!rightViewAtDepth.containsKey(dep)) &#123;</span><br><span class="line">                    <span class="comment">//存入视图</span></span><br><span class="line">                    rightViewAtDepth.put(dep, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左节点压栈</span></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                <span class="comment">//右节点压栈</span></span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                <span class="comment">//层数存入深度栈</span></span><br><span class="line">                depthStack.push(dep + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//层数存入深度栈</span></span><br><span class="line">                depthStack.push(dep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历深度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt;= max_dep; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> rightViewAtDepth.get(i);</span><br><span class="line">            ret.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 2 Solution</title>
    <url>/posts/42ddda9f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-two-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//新建结果链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//记录当前节点 方便后面移动</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//相加 &gt; 10 进一位 进位的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断结束条件</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carray!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对应位相加的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//l1各位已经加完了， l2 还没有结束</span></span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                <span class="comment">//l2各位已经加完了， l1 还没有结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="literal">null</span> &amp;&amp; l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                <span class="comment">//l1 l2 对应位置有值则相加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 != <span class="literal">null</span> &amp;&amp; l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                sum = l1.val + l2.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接到结果链表链表后面</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>((sum + carray) % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">//需要进一位的保存在变量carray</span></span><br><span class="line">            carray = (sum + carray) / <span class="number">10</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 20 Solution</title>
    <url>/posts/b3ac6ad8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效的括号</span></span><br><span class="line"><span class="comment"> * 给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有效字符串需满足：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment"> * 左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-parentheses</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//根据入参判断 不能为奇数</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//符号对</span></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        pairs.put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="comment">//字符串转字符数组</span></span><br><span class="line">        <span class="type">char</span>[] charr =s.toCharArray();</span><br><span class="line">        <span class="comment">//放入栈中判断</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; charr.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//如果为左侧符号， 符号对key中一定存在，则压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pairs.containsKey(charr[i])) &#123;</span><br><span class="line">                stack.push(pairs.get(charr[i]));</span><br><span class="line">                <span class="comment">//如果符号对key中不存在，栈中有元素，且栈顶符号等于当前符号，则弹栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stack.size()!=<span class="number">0</span> &amp;&amp; stack.peek() == charr[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 200 Solution</title>
    <url>/posts/5be5cf5b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s200;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 206 Solution</title>
    <url>/posts/56fbbf1c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s206;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 206. 反转链表</span></span><br><span class="line"><span class="comment"> * 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//前置节点 后一个节点指向的节点，初始的前置节点为null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//当前节点，从head开始遍历</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//当前节点不为null</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//下一个节点先存中间变量</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//下一个节点指向前一个节点</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">//当前节点称为前置节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//下一个节点为当前节点</span></span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 21 Solution</title>
    <url>/posts/5c6e01e6.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s21;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序链表</span></span><br><span class="line"><span class="comment"> * 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从小到大排列</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val) &#123;</span><br><span class="line">            <span class="comment">//合并子链表</span></span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list2.next, list1);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 215 Solution</title>
    <url>/posts/7c42dbdf.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s215;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 215. 数组中的第K个最大元素</span></span><br><span class="line"><span class="comment"> * 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/kth-largest-element-in-an-array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//定义堆的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//初始构建大顶堆，大小为全部的数组长度</span></span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//大顶堆每次去掉最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//去掉最大元素</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            <span class="comment">//构建一个次小堆</span></span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//复杂度 heapSize / 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//左子节点  右子节点， 根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//堆 大小范围内， 如果 左子节点 &gt; 根</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            <span class="comment">// 根为左子节点</span></span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆 大小范围内， 如果 右子节点 &gt; 根</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            <span class="comment">// 根为右子节点</span></span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根被替换</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="comment">// 执行移动操作</span></span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//重新构建</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 22 Solution</title>
    <url>/posts/b759bae5.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号生成</span></span><br><span class="line"><span class="comment"> * 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//定义结果list</span></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//回溯法</span></span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">//如果长度够了 就添加到list 返回  max是括号对数</span></span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//open 左括号个数 close 右括号个数</span></span><br><span class="line">        <span class="comment">//如果 左括号个数没有到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            <span class="comment">//就再拼接一个左括号</span></span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//递归 继续拼接</span></span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            <span class="comment">//开始回溯 每次减去一个左括号</span></span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 右括号个数没有到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            <span class="comment">//开始回溯 每次减去一个左括号</span></span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 221 Solution</title>
    <url>/posts/ec4b1da4.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s221;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个由 &#x27;0&#x27; 和 &#x27;1&#x27; 组成的二维矩阵内，找到只包含 &#x27;1&#x27; 的最大正方形，并返回其面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//新建一个dp二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">        <span class="comment">//遇到1的情况 考虑动态转移方程</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//边界的情况，初始化为1</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//左侧、上侧、左上侧 三个 最大值加1</span></span><br><span class="line">        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大值 正方形长度</span></span><br><span class="line">        maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算面积</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSquare</span> <span class="operator">=</span> maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 226 Solution</title>
    <url>/posts/e9706dd.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s226;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">                root.left = right;</span><br><span class="line">                root.right = left;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 23 Solution</title>
    <url>/posts/589bd1db.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s23;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并K个升序链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表数组，每个链表都已经按升序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge2Lists</span><span class="params">(ListNode lista, ListNode listb)</span> &#123;</span><br><span class="line">        <span class="comment">//哑巴节点方便返回链表head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//遍历链表 cur 为当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历完lista</span></span><br><span class="line">            <span class="keyword">if</span>(lista == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = listb;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历完listb</span></span><br><span class="line">            <span class="keyword">if</span>(listb == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = lista;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照升序排列链表</span></span><br><span class="line">            <span class="keyword">if</span>(lista.val &lt;= listb.val) &#123;</span><br><span class="line">                cur.next = lista;</span><br><span class="line">                lista = lista.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = listb;</span><br><span class="line">                listb = listb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//链表节点后移一位</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个链表合并，变为两两合并</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//多个链表两两合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i &lt; lists.length; i ++) &#123;</span><br><span class="line">            dum = merge2Lists(dum, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 232 Solution</title>
    <url>/posts/c6f27967.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s232;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 MyQueue 类：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * void push(int x) 将元素 x 推到队列的末尾</span></span><br><span class="line"><span class="comment"> * int pop() 从队列的开头移除并返回元素</span></span><br><span class="line"><span class="comment"> * int peek() 返回队列开头的元素</span></span><br><span class="line"><span class="comment"> * boolean empty() 如果队列为空，返回 true ；否则，返回 false</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</span></span><br><span class="line"><span class="comment"> * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-queue-using-stacks</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//两个栈 一个入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="comment">//两个栈 一个出栈</span></span><br><span class="line">    Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//push进inStack</span></span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果outStack为空</span></span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//将inStack写入到outStack</span></span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从outStack读出</span></span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从outStack取栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//inStack、outStack都为空</span></span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//inStack写入outStack</span></span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 234 Solution</title>
    <url>/posts/cbec0920.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s234;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                        fast = fast.next.next;</span><br><span class="line">                        tmp.next = pre;</span><br><span class="line">                        pre = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fast != <span class="literal">null</span>) &#123;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(pre != <span class="literal">null</span> &amp;&amp; slow != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(pre.val != slow.val) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pre = pre.next;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 236 Solution</title>
    <url>/posts/cf19d91d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s236;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图示两个链表在节点 c1 开始相交：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据 保证 整个链式结构中不存在环。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，函数返回结果后，链表必须 保持其原始结构 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义评测：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 评测系统 的输入如下（你设计的程序 不适用 此输入）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</span></span><br><span class="line"><span class="comment"> * listA - 第一个链表</span></span><br><span class="line"><span class="comment"> * listB - 第二个链表</span></span><br><span class="line"><span class="comment"> * skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</span></span><br><span class="line"><span class="comment"> * skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</span></span><br><span class="line"><span class="comment"> * 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/intersection-of-two-linked-lists</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 239 Solution</title>
    <url>/posts/3e128290.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s239;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sliding-window-maximum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                <span class="comment">//非最大值出队列</span></span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到k个最大值 对应的下标放到队列中</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义结果数组</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//前面找到的那个第一次窗口k个最大值 放入数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = nums[deque.peekFirst()];</span><br><span class="line">        <span class="comment">//继续遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">//如果超过当前窗口范围 移出窗口</span></span><br><span class="line">            <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把窗口最后一次的最大值放到结果数组中</span></span><br><span class="line">            ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 24 Solution</title>
    <url>/posts/ba47caa2.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s24;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两两交换链表中的节点</span></span><br><span class="line"><span class="comment"> * 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//新建哑巴节点，存放头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="comment">//从哑巴节点开始 往后找到后两个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换节点</span></span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 25 Solution</title>
    <url>/posts/5585a19c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s25;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * K 个一组翻转链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-nodes-in-k-group</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定一个数据结构，存放链表 分组</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pharse</span> &#123;</span><br><span class="line">        <span class="comment">//链表开始节点</span></span><br><span class="line">        ListNode begin;</span><br><span class="line">        <span class="comment">//链表开始节点</span></span><br><span class="line">        ListNode end;</span><br><span class="line">        <span class="comment">//链表是否需要翻转</span></span><br><span class="line">        <span class="type">boolean</span> reverse;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pharse</span><span class="params">(ListNode begin, ListNode end, <span class="type">boolean</span> reverse)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.begin = begin;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.reverse = reverse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseSubGroup</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//前置节点都未null</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//当前节点为begin</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> begin;</span><br><span class="line">            <span class="comment">//开始翻转</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="comment">//需要判断翻转结束条件</span></span><br><span class="line">                <span class="keyword">if</span>(cur == end || tmp == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转向后给出新的交换后的 begin end</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> begin;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//判断入参</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//一个元素直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哑巴节点，标记头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//当前节点从head开始</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始位置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//链表分组</span></span><br><span class="line">        List&lt;Pharse&gt; pharses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表开始</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//链表结束</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//开始分组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; cur != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//k个元素 开始的位置</span></span><br><span class="line">            <span class="keyword">if</span>(i % k == <span class="number">0</span> &amp;&amp; !flag) &#123;</span><br><span class="line">                start = cur;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//区间就一个元素了，开始即是结束</span></span><br><span class="line">                <span class="keyword">if</span>(cur.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                    end = cur;</span><br><span class="line">                    pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">false</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//k个元素后 结束的位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((i + <span class="number">1</span>) % k == <span class="number">0</span> &amp;&amp; flag) &#123;</span><br><span class="line">                end = cur;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">true</span>));</span><br><span class="line">                <span class="comment">//区间没有满k个元素，提前结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                end = cur;</span><br><span class="line">                pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一个元素</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ph</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(Pharse pharse : pharses) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pharse.reverse) &#123;</span><br><span class="line">                <span class="comment">//每个区间内翻转</span></span><br><span class="line">                pharse.reverseSubGroup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多个区间指针反向修改</span></span><br><span class="line">            ph.next = pharse.begin;</span><br><span class="line">            ph = pharse.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 26 Solution</title>
    <url>/posts/beb21a9f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s26;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  删除有序数组中的重复项</span></span><br><span class="line"><span class="comment"> *  给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将最终结果插入 nums 的前 k 个位置后返回 k 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判题标准:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 系统会用下面的代码来测试你的题解:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 27 Solution</title>
    <url>/posts/517071a1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s27;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为什么返回数值是整数，但输出的答案是数组呢?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以想象内部操作如下:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="comment"> * int len = removeElement(nums, val);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"> * // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> *     print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-element</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 28 Solution</title>
    <url>/posts/a07b2a2c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s28;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> * 实现 strStr()</span></span><br><span class="line"><span class="comment"> * 实现 strStr() 函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-strstr</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 29 Solution</title>
    <url>/posts/4fb94112.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s29;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两数相除</span></span><br><span class="line"><span class="comment"> * 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回被除数 dividend 除以除数 divisor 得到的商。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/divide-two-integers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == -<span class="number">2147483648</span> &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">2147483647</span> &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="comment">// 对两种特殊情况的快速处理，大概算是偷鸡了吧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNeg</span> <span class="operator">=</span> (dividend &lt; <span class="number">0</span> ^ divisor &lt; <span class="number">0</span>); <span class="comment">// 异或运算确定结果正负性</span></span><br><span class="line">        dividend = -Math.abs(dividend);</span><br><span class="line">        divisor = -Math.abs(divisor);</span><br><span class="line">        <span class="comment">// 使用绝对值再取负，全部转化为负数进行运算</span></span><br><span class="line">        <span class="comment">// 特别的，在int范围内，-2147483648的正负数都是其自身，因此不会出错</span></span><br><span class="line">        <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> divisor; <span class="comment">// d为本轮所用的除数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// cnt表示d为原除数的cnt倍</span></span><br><span class="line">            <span class="keyword">while</span> (dividend &lt;= d &amp;&amp; d &gt;= -<span class="number">1073741824</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次对d和cnt都进行翻倍，快速到达大于被除数的最小除数</span></span><br><span class="line">                <span class="comment">// 等效d=d*2，但题目禁用乘法，且位运算左移速度更快</span></span><br><span class="line">                d = d &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                cnt = cnt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当 dividend &gt; d 时，表明此时d已经小于被除数了，不能继续</span></span><br><span class="line">            <span class="comment">// 当 d &lt; -1073741824 时，表明此时d再翻倍会造成溢出，不能继续</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dividend &lt;= d) &#123;</span><br><span class="line">                <span class="comment">// 此时说明上一步d再翻倍会造成溢出</span></span><br><span class="line">                <span class="comment">// 可知d已经是大于被除数的最小除数，直接使用即可</span></span><br><span class="line">                dividend -= d;</span><br><span class="line">                result += cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时d是小于被除数的最大除数，需要右移补回一次</span></span><br><span class="line">                <span class="comment">// 才能成为大于被除数的最小除数，再进行使用</span></span><br><span class="line">                dividend -= d &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                result += cnt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNeg ? -result : result;</span><br><span class="line">        <span class="comment">// result为所有倍数的和，需要补充正负性再返回</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 3 Solution</title>
    <url>/posts/ad1fb1a1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串 字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//游标 子串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//子串最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//出现字符 及对应的下标&lt;字符， 最近一次出现的下标&gt;</span></span><br><span class="line">        Map&lt;Character, Integer&gt; cs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="comment">//子串中字符上次出现位置</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">lastExist</span> <span class="operator">=</span> cs.get(chars[i]);</span><br><span class="line">            <span class="comment">//如果已经出现过该字符且在子串中</span></span><br><span class="line">            <span class="keyword">if</span>(lastExist!=<span class="literal">null</span> &amp;&amp; lastExist &gt;= start) &#123;</span><br><span class="line">                <span class="comment">// 则从字符出现重复后端下一个位置开始</span></span><br><span class="line">                start = lastExist + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果字符长度大于目前记录的最大长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i - start + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                <span class="comment">//则更新最大长度记录</span></span><br><span class="line">                max = i - start + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次遍历把字符 及出现的下标记录下来</span></span><br><span class="line">            cs.put(chars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 30 Solution</title>
    <url>/posts/7222b518.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s30;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串联所有单词的子串</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/substring-with-concatenation-of-all-words</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">one_word</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">word_num</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">all_len</span> <span class="operator">=</span> one_word * word_num;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - all_len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + all_len);</span><br><span class="line">            HashMap&lt;String, Integer&gt; tmp_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; all_len; j += one_word) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> tmp.substring(j, j + one_word);</span><br><span class="line">                tmp_map.put(w, tmp_map.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.equals(tmp_map)) res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 300 Solution</title>
    <url>/posts/c0408334.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s300;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-increasing-subsequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//严格递增子序列数组</span></span><br><span class="line">        <span class="type">int</span>[] sub = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第0个节点</span></span><br><span class="line">        sub[size] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//前一个小于后一个节点时，记录到sub数组</span></span><br><span class="line">        <span class="keyword">if</span>(sub[size] &lt; nums[i]) &#123;</span><br><span class="line">        sub[++size] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//重置sub数组，分左右两个指针判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="comment">//如果sub中找不到比nums[i]小的元素则从0开始替换</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移动两边指针</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//取中间点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//因为sub已经有序，所以二分法，找到满足升序的中间点pos，更新sub数组</span></span><br><span class="line">        <span class="keyword">if</span>(sub[mid] &lt;  nums[i]) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">        pos = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新sub数组</span></span><br><span class="line">        sub[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 31 Solution</title>
    <url>/posts/9de0de26.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s31;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个排列</span></span><br><span class="line"><span class="comment"> * 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span></span><br><span class="line"><span class="comment"> * 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span></span><br><span class="line"><span class="comment"> * 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span></span><br><span class="line"><span class="comment"> * 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，找出 nums 的下一个排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 必须 原地 修改，只允许使用额外常数空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/next-permutation</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//从右到左找出开始递增的位置  1612354 中 3 就是</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了，再从右到左找出第一个大于nums[i]的值  1612354 中 4 就是</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换两个数字位置 1612453</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转 i + 1 到 结束 也就是  53 变成 35</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 32 Solution</title>
    <url>/posts/76d76525.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长有效括号</span></span><br><span class="line"><span class="comment"> * 给你一个只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建一个栈 用来从左到右存括号字符串</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//压一个初始长度-1</span></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果是左括号 就压栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//右括号就弹出</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//弹出后如果空了就压当前i的值，表示有效子串开始的位置</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不为空就比较下 有效子串是否为最长 ，更新maxans</span></span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 322 Solution</title>
    <url>/posts/9cd9eac8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s322;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以认为每种硬币的数量是无限的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/coin-change</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="title class_">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> rem, <span class="type">int</span>[] count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rem ==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> coinChange(coins, rem - coin, count);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min) &#123;</span><br><span class="line">                min = <span class="number">1</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[rem - <span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min;</span><br><span class="line">        <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 33 Solution</title>
    <url>/posts/99150e1b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s33;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * 整数数组 nums 按升序排列，数组中的值 互不相同 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-in-rotated-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//数组大小判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个值情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二分法 左右边界和中间值</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            mid = (i + j) /<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果中间值 就是target 则返回mid</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果0 ~mid 为上升，则mid在左升区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//如果 target 在i ~ mid之间</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// target 在mid ~ j之间</span></span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果0 ~mid 为下降，则mid在右降区间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果 target 在i ~ mid之间</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j = mid -<span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 34 Solution</title>
    <url>/posts/7bc91562.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s34;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="comment"> * 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果数组中不存在目标值 target，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; left &lt;= nums.length-<span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; left &lt;= nums.length-<span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">            res[<span class="number">1</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 35 Solution</title>
    <url>/posts/940b7e5c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s35;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索插入位置</span></span><br><span class="line"><span class="comment"> * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请必须使用时间复杂度为 O(log n) 的算法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-insert-position</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 36 Solution</title>
    <url>/posts/7f3cc55f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s36;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效的数独</span></span><br><span class="line"><span class="comment"> * 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一行只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一列只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个有效的数独（部分已被填充）不一定是可解的。</span></span><br><span class="line"><span class="comment"> * 只需要根据以上规则，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment"> * 空白格用 &#x27;.&#x27; 表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-sudoku</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">// init data</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] rows = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] columns = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] boxes = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            rows[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            columns[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            boxes[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// validate a board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>)num;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">box_index</span> <span class="operator">=</span> (i / <span class="number">3</span> ) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// keep the current cell value</span></span><br><span class="line">                    rows[i].put(n, rows[i].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    columns[j].put(n, columns[j].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// check if this value has been already seen before</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i].get(n) &gt; <span class="number">1</span> || columns[j].get(n) &gt; <span class="number">1</span> || boxes[box_index].get(n) &gt; <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 37 Solution</title>
    <url>/posts/90feae61.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s37;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解数独</span></span><br><span class="line"><span class="comment"> * 编写一个程序，通过填充空格来解决数独问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数独的解法需 遵循如下规则：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一行只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一列只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span></span><br><span class="line"><span class="comment"> * 数独部分空格内已填入了数字，空白格用 &#x27;.&#x27; 表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sudoku-solver</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] line = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] column = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][][] block = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt; spaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.size()) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] space = spaces.get(pos);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> space[<span class="number">0</span>], j = space[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = (<span class="type">char</span>) (digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">                dfs(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 38 Solution</title>
    <url>/posts/61f5f5ec.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s38;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观数列</span></span><br><span class="line"><span class="comment"> * 给定一个正整数 n ，输出外观数列的第 n 项。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以将其视作是由递归公式定义的数字字符串序列：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * countAndSay(1) = &quot;1&quot;</span></span><br><span class="line"><span class="comment"> * countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/count-and-say</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lastStr</span> <span class="operator">=</span> countAndSay(n - <span class="number">1</span>); <span class="comment">// 1 2 1 1</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, len = lastStr.length();</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastStr.charAt(i) != lastStr.charAt(j)) &#123;</span><br><span class="line">                    ans.append(j - i).append(lastStr.charAt(i));</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(j - i).append(lastStr.charAt(i));</span><br><span class="line">            <span class="keyword">return</span> ans.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 39 Solution</title>
    <url>/posts/8e379ed2.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s39;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合总和</span></span><br><span class="line"><span class="comment"> * 给你一个 无重复元素 的整数数组candidates 和一个目标整数target，找出candidates中可以使数字和为目标数target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于给定的输入，保证和为target 的不同组合数少于 150 个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/combination-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 4 Solution</title>
    <url>/posts/4fc3aad8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法的时间复杂度应该为 O(log (m+n)) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/median-of-two-sorted-arrays</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.length &gt; nums2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m;</span><br><span class="line">            <span class="comment">// i + j = m-i + n -j -1  j = m+n+1/2 -i m&lt;n</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">median1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">median2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mediana1</span> <span class="operator">=</span> (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i-<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">mediana2</span> <span class="operator">=</span> (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">medianb1</span> <span class="operator">=</span> (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">medianb2</span> <span class="operator">=</span> (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line">                <span class="keyword">if</span>(mediana1 &lt;= medianb2) &#123;</span><br><span class="line">                    median1 = Math.max(mediana1, medianb1);</span><br><span class="line">                    median2 = Math.min(mediana2, medianb2);</span><br><span class="line">                    left = i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right  = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ( m + n) %<span class="number">2</span>==<span class="number">0</span>? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 40 Solution</title>
    <url>/posts/5b19a09b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s40;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合总和 II</span></span><br><span class="line"><span class="comment"> * 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * candidates 中的每个数字在每个组合中只能使用 一次 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：解集不能包含重复的组合。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/combination-sum-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; freq = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; sequence = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : candidates) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> freq.size();</span><br><span class="line">            <span class="keyword">if</span> (freq.isEmpty() || num != freq.get(size - <span class="number">1</span>)[<span class="number">0</span>]) &#123;</span><br><span class="line">                freq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.get(size - <span class="number">1</span>)[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(sequence));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.size() || rest &lt; freq.get(pos)[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">most</span> <span class="operator">=</span> Math.min(rest / freq.get(pos)[<span class="number">0</span>], freq.get(pos)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.add(freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">            dfs(pos + <span class="number">1</span>, rest - i * freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.remove(sequence.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 41 Solution</title>
    <url>/posts/b4dbcba5.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s41;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缺失的第一个正数</span></span><br><span class="line"><span class="comment"> * 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//处理下负的值，把对应的值改成一个大于n的数字，因为找第一个正数，所以n+1 后面遍历会被忽略掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把存在于 0 -n 之间的值 填到对应的下标处 也变成负值（表示未缺失），后面统计正的数就可以了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到第一个&gt;0 数字的下标就是 第一个缺失的正数了，因为上一步已经把存在的值标记到对应下标的位置了（负的值表示存在）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 415 Solution</title>
    <url>/posts/937f7e3f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s415;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串拼接 StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        <span class="comment">//num1 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="comment">//num2 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i + j &lt;= m + n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numa</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">                numa = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numa = num1.charAt(m - i++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; n) &#123;</span><br><span class="line">                numb = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numb = num2.charAt(n - j++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右向左 逐位数字相加</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numa + numb + carray;</span><br><span class="line">            <span class="comment">//满10 进一位</span></span><br><span class="line">            carray = sum / <span class="number">10</span>;</span><br><span class="line">            builder.append(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次相加后 如果有进位 则拼接到字符串</span></span><br><span class="line">        <span class="keyword">if</span>(carray != <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(carray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 42 Solution</title>
    <url>/posts/5fec70a6.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s42;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接雨水</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左侧开始找最大值</span></span><br><span class="line">        <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            maxLeft[i] = Math.max(maxLeft[i-<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右侧开始找最大值</span></span><br><span class="line">        <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        maxRight[height.length -<span class="number">1</span>] = height[height.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = Math.max(maxRight[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计所有雨水小矩形的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//左右侧最大值的最小值累加</span></span><br><span class="line">            sum += Math.min(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 43 Solution</title>
    <url>/posts/b02e1b98.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s43;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串相乘</span></span><br><span class="line"><span class="comment"> * 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/multiply-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊值 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建一个结果数据，存放临时结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="comment">//遍历字符串num1每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//转换成数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//遍历字符串num1每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//转换成数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//计算乘积</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                <span class="comment">//满10进1</span></span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结果数组 合并为字符串结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == <span class="number">0</span> &amp;&amp; result.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(res[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 45 Solution</title>
    <url>/posts/bd306bdf.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s45;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏 II</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设你总是可以到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/jump-game-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    steps++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 44 Solution</title>
    <url>/posts/52f200e1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s44;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通配符匹配</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#x27;?&#x27; 和 &#x27;*&#x27; 的通配符匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;?&#x27; 可以匹配任何单个字符。</span></span><br><span class="line"><span class="comment"> * &#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。</span></span><br><span class="line"><span class="comment"> * 两个字符串完全匹配才算匹配成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="comment"> * p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/wildcard-matching</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;?&#x27;</span> || s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 46 Solution</title>
    <url>/posts/5607d0dc.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s46;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//参数结果定义</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//排列结果</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="comment">//初始数组列表</span></span><br><span class="line">            numbers.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯 填空， 从 0 开始 填写  numbers.size() 个数字，结果写到 ret</span></span><br><span class="line">        backtrack(numbers, ret, numbers.size(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> n, <span class="type">int</span> try1)</span> &#123;</span><br><span class="line">        <span class="comment">//填完n个数后</span></span><br><span class="line">        <span class="keyword">if</span> (try1 == n) &#123;</span><br><span class="line">            <span class="comment">//记录到res</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> try1; i&lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//将i填写到try1位置</span></span><br><span class="line">            Collections.swap(output, i, try1);</span><br><span class="line">            <span class="comment">//将i填写到try1 + 1位置</span></span><br><span class="line">            backtrack(output, res, n, try1 + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//还原tray1位置的值，从i+1位置开始重新试填</span></span><br><span class="line">            Collections.swap(output, try1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 47 Solution</title>
    <url>/posts/b9c5bbe2.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s47;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列 II</span></span><br><span class="line"><span class="comment"> * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//对原数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//从下标0开始 回溯nums 中间结果存perm， 最终结果放到ans</span></span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="type">int</span> idx, List&lt;Integer&gt; perm)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            <span class="comment">//回溯过得本地不再回溯</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            <span class="comment">//第二次开始重置为false</span></span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 470 Solution</title>
    <url>/posts/9de37f38.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s470;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-rand10-using-rand7</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span> % <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机产生01</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">random01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rand7();</span><br><span class="line">        <span class="comment">//通过4分割 123 -&gt; 0 ;567 -&gt; 1 如果刚好是4 就重来</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( i &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> random01();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机10 通过4位二进制标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> random01();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 &lt;&lt; i; <span class="comment">//左移i位</span></span><br><span class="line">            x = x + i2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果超出了 [1, 10] 重新来</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rand10();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 48 Solution</title>
    <url>/posts/48cee06f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s48;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  旋转图像</span></span><br><span class="line"><span class="comment"> *  给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/rotate-image</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix.length != matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums - i; ++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[nums - <span class="number">1</span> - j][nums - <span class="number">1</span> - i];</span><br><span class="line">                matrix[nums - <span class="number">1</span> - j][nums - <span class="number">1</span> - i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (nums &gt;&gt; <span class="number">1</span>); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums; ++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[nums - <span class="number">1</span> - i][j];</span><br><span class="line">                matrix[nums - <span class="number">1</span> - i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 49 Solution</title>
    <url>/posts/a70c8b51.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s49;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母异位词分组</span></span><br><span class="line"><span class="comment"> * 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/group-anagrams</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 5 Solution</title>
    <url>/posts/a001c1e6.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长回文子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//定义回文子串的起始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历字符串字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//以当前字符为中心点扩展</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">//以当前字符和下一个字符为中心点扩展</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//取两种方式扩展最大长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(max &gt; end -start + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//-1防止 当前字符和下一个字符为中心点扩展 导致的问题</span></span><br><span class="line">                start = i - (max-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + max /<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,  end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//左右相等则扩展</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left --;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回扩展的子串长度</span></span><br><span class="line">        <span class="keyword">return</span> right - left -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 50 Solution</title>
    <url>/posts/9a977f5b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s50;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pow(x, n)</span></span><br><span class="line"><span class="comment"> * 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//基数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">base</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">//判断n 小于0 基数特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            base = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数次</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans * base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            base = base * base;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 51 Solution</title>
    <url>/posts/75551465.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s51;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * N 皇后</span></span><br><span class="line"><span class="comment"> *按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/n-queens</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solutions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] queens = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        backtrack(solutions, queens, n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; solutions, <span class="type">int</span>[] queens, <span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generateBoard(queens, n);</span><br><span class="line">            solutions.add(board);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                backtrack(solutions, queens, n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateBoard</span><span class="params">(<span class="type">int</span>[] queens, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 52 Solution</title>
    <url>/posts/9e62af66.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s52;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * N皇后 II</span></span><br><span class="line"><span class="comment"> * n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/n-queens-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">return</span> backtrack(n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                count += backtrack(n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 53 Solution</title>
    <url>/posts/71a0c458.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s53;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大子数组和</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//假定第一个是最大子元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//设置一个和参数，默认0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//累计的和大于0，则继续累计</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//累计和不大于0 ，重新开始累计</span></span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求最大和</span></span><br><span class="line">            max = Math.max(sum, max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 54 Solution</title>
    <url>/posts/937cdf21.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s54;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 螺旋矩阵</span></span><br><span class="line"><span class="comment"> * 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length ==<span class="number">0</span> || matrix[<span class="number">0</span>].length ==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断需要旋转的几个方向</span></span><br><span class="line">        <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">//列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] visited = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">//方向</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">directions</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; m*n; cnt++) &#123;</span><br><span class="line">            <span class="comment">//已访问</span></span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            ret.add(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一个节点对应的行  遍历的方向 dirs[directions][0] 控制</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nexti</span> <span class="operator">=</span> i + dirs[directions][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//下一个节点对应的列  遍历的方向 dirs[directions][1] 控制</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextj</span> <span class="operator">=</span> j + dirs[directions][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">if</span>(nexti &lt; <span class="number">0</span> || nexti &gt; m-<span class="number">1</span> || nextj &lt; <span class="number">0</span> ||nextj &gt; n-<span class="number">1</span> || visited[nexti][nextj] == <span class="number">1</span> ) &#123;</span><br><span class="line">                directions = (directions+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//行数变更 + 1 或者 不变</span></span><br><span class="line">            i = i + dirs[directions][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//列数变更 + 1 或者 不变</span></span><br><span class="line">            j = j + dirs[directions][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 543 Solution</title>
    <url>/posts/7493ee55.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s543;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">            <span class="comment">//遍历树</span></span><br><span class="line">            deep(root);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deep</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//到叶子节点返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> deep(root.left);</span><br><span class="line">        <span class="comment">//右子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> deep(root.right);</span><br><span class="line">        <span class="comment">// 左右子树深度和</span></span><br><span class="line">        ans = Math.max(ans, l + r);</span><br><span class="line">        <span class="comment">//加上根节点自身 就是直径</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 55 Solution</title>
    <url>/posts/7cbeb41f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s55;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判断你是否能够到达最后一个下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">                rightmost = Math.max(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 56 Solution</title>
    <url>/posts/97890f1c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s56;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并区间</span></span><br><span class="line"><span class="comment"> * 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/merge-intervals</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 57 Solution</title>
    <url>/posts/784b6422.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s57;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  插入区间</span></span><br><span class="line"><span class="comment"> * 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/insert-interval</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">placed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ansList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 58 Solution</title>
    <url>/posts/89403faf.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s58;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一个单词的长度</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/length-of-last-word</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">&#x27; &#x27;</span>) start--;</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 6 Solution</title>
    <url>/posts/4b367ae5.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Z 字形变换</span></span><br><span class="line"><span class="comment"> * 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/zigzag-conversion</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cycleLen</span> <span class="operator">=</span> <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + i &lt; n; j += cycleLen) &#123;</span><br><span class="line">                ret.append(s.charAt(j + i));</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; j + cycleLen - i &lt; n)</span><br><span class="line">                    ret.append(s.charAt(j + cycleLen - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 60 Solution</title>
    <url>/posts/375195a.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s60;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排列序列</span></span><br><span class="line"><span class="comment"> * 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;123&quot;</span></span><br><span class="line"><span class="comment"> * &quot;132&quot;</span></span><br><span class="line"><span class="comment"> * &quot;213&quot;</span></span><br><span class="line"><span class="comment"> * &quot;231&quot;</span></span><br><span class="line"><span class="comment"> * &quot;312&quot;</span></span><br><span class="line"><span class="comment"> * &quot;321&quot;</span></span><br><span class="line"><span class="comment"> * 给定 n 和 k，返回第 k 个排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/permutation-sequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] factorial = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span>[] valid = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(valid, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                order -= valid[j];</span><br><span class="line">                <span class="keyword">if</span> (order == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append(j);</span><br><span class="line">                    valid[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= factorial[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 59 Solution</title>
    <url>/posts/66825491.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s59;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 螺旋矩阵 II</span></span><br><span class="line"><span class="comment"> * 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//返回值数组</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 右下左上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">directionIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNum &lt;= maxNum) &#123;</span><br><span class="line">            matrix[row][column] = curNum;</span><br><span class="line">            curNum++;</span><br><span class="line">            <span class="comment">//行</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextRow</span> <span class="operator">=</span> row + directions[directionIndex][<span class="number">0</span>],</span><br><span class="line">                    <span class="comment">//列</span></span><br><span class="line">                    nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//行列边界判断，需要调整方向</span></span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 顺时针旋转至下一个方向</span></span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 61 Solution</title>
    <url>/posts/ecb77264.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s61;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span>  head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算断开的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> n - k % n;</span><br><span class="line">        <span class="comment">//特殊情况也就是链表不变的情况</span></span><br><span class="line">        <span class="keyword">if</span>(y == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾部连接到链表头</span></span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">while</span>(y -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照计算的断开位置断开链表</span></span><br><span class="line">        head = cur.next;</span><br><span class="line">        cur.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 62 Solution</title>
    <url>/posts/780c967.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s62;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同路径</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 问总共有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/unique-paths</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//新建dp二维数组，记录每步状态</span></span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化边界情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历行列，补全其他状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">//动态转移方程</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 63 Solution</title>
    <url>/posts/e842a259.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s63;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同路径 II</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 网格中的障碍物和空位置分别用 1 和 0 来表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/unique-paths-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    f[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] += f[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 64 Solution</title>
    <url>/posts/a9eb920.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小路径和</span></span><br><span class="line"><span class="comment"> * 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：每次只能向下或者向右移动一步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/minimum-path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 65 Solution</title>
    <url>/posts/e55cd21e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s65;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效数字</span></span><br><span class="line"><span class="comment"> * 有效数字（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个 小数 或者 整数</span></span><br><span class="line"><span class="comment"> * （可选）一个 &#x27;e&#x27; 或 &#x27;E&#x27; ，后面跟着一个 整数</span></span><br><span class="line"><span class="comment"> * 小数（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （可选）一个符号字符（&#x27;+&#x27; 或 &#x27;-&#x27;）</span></span><br><span class="line"><span class="comment"> * 下述格式之一：</span></span><br><span class="line"><span class="comment"> * 至少一位数字，后面跟着一个点 &#x27;.&#x27;</span></span><br><span class="line"><span class="comment"> * 至少一位数字，后面跟着一个点 &#x27;.&#x27; ，后面再跟着至少一位数字</span></span><br><span class="line"><span class="comment"> * 一个点 &#x27;.&#x27; ，后面跟着至少一位数字</span></span><br><span class="line"><span class="comment"> * 整数（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （可选）一个符号字符（&#x27;+&#x27; 或 &#x27;-&#x27;）</span></span><br><span class="line"><span class="comment"> * 至少一位数字</span></span><br><span class="line"><span class="comment"> * 部分有效数字列举如下：[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 部分无效数字列举如下：[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> State.STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">CharType</span> <span class="variable">type</span> <span class="operator">=</span> toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CharType <span class="title function_">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 66 Solution</title>
    <url>/posts/e6b691d.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s66;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制求和</span></span><br><span class="line"><span class="comment"> * 给你两个二进制字符串，返回它们的和（用二进制表示）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入为 非空 字符串且只包含数字 1 和 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(a.length(), b.length()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.append((<span class="type">char</span>) (carry % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 67 Solution</title>
    <url>/posts/e1a90223.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s67;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x 的平方根</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sqrtx</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//中间值 二分法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左右移动 l  r</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(tmp == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">                ret = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 68 Solution</title>
    <url>/posts/10a259ae.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s68;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本左右对齐</span></span><br><span class="line"><span class="comment"> * 给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 &#x27; &#x27; 填充，使得每行恰好有 maxWidth 个字符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 文本的最后一行应为左对齐，且单词之间不插入额外的空格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词是指由非空格字符组成的字符序列。</span></span><br><span class="line"><span class="comment"> * 每个单词的长度大于 0，小于等于 maxWidth。</span></span><br><span class="line"><span class="comment"> * 输入单词数组 words 至少包含一个单词。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/text-justification</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span> &#123;</span><br><span class="line">        <span class="comment">//定义0-maxWidth个空格字符串，方便之后直接调用</span></span><br><span class="line">        <span class="keyword">final</span> String[] space = <span class="keyword">new</span> <span class="title class_">String</span>[maxWidth+<span class="number">1</span>];</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;maxWidth+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            space[i] = s.toString();</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建List，用来存最后的结果。</span></span><br><span class="line">        List&lt;String&gt; pWords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历整个words，一行一行的排版</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;words.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curlen</span> <span class="operator">=</span> words[i].length();</span><br><span class="line">            <span class="comment">//记录当前已读取单词的长度，当&gt;=maxWidth时进行排版</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//记录本次读取单词的起点</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; words.length-<span class="number">1</span> &amp;&amp; curlen&lt;maxWidth)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                curlen = curlen+words[i].length()+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 每多读一个单词都要加一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curlen&gt;maxWidth)&#123;</span><br><span class="line">                <span class="comment">//当前长度&gt;maxWidth，说明已经多读取了一个单词</span></span><br><span class="line">                curlen = curlen-words[i].length()-<span class="number">1</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一行一行的排版</span></span><br><span class="line">            pWords.add(processCurline(words,startI,i,curlen,maxWidth,space));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pWords;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processCurline</span><span class="params">(String[] words,<span class="type">int</span> si,<span class="type">int</span> ei,<span class="type">int</span> curlen,<span class="type">int</span> maxWidth,String[] space)</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();   <span class="comment">//用来进行排版</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">map</span> <span class="operator">=</span> ei-si;                   <span class="comment">// 记录单词之间的有几个间隙</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addSpace</span> <span class="operator">=</span> maxWidth - curlen+map;   <span class="comment">//记录这一行总共有多少个空格</span></span><br><span class="line">        <span class="keyword">if</span>(map==<span class="number">0</span>)&#123;               <span class="comment">//间隙为0，证明只有一个单词</span></span><br><span class="line">            sb.append(words[ei]);</span><br><span class="line">            sb.append(space[addSpace]);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ei == words.length-<span class="number">1</span>)&#123;            <span class="comment">//证明要排版最后一行了，格式特殊</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>si;i&lt;ei;i++)&#123;</span><br><span class="line">                sb.append(words[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(words[ei]);             <span class="comment">//最后一个单词不用加空格</span></span><br><span class="line">            sb.append(space[addSpace-map]);   <span class="comment">//如果还有多余空格，一起加上</span></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">allAddSpace</span> <span class="operator">=</span> addSpace/map;     <span class="comment">//所有的空格数 / 间隙 = 每个间隙必加的空格数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> addSpace % map + si;     <span class="comment">//多出来的空格要从si开始，依次加在间隙中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> si;i&lt;ei;i++)&#123;</span><br><span class="line">            sb.append(words[i]).append(space[allAddSpace]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; left) sb.append(<span class="string">&quot; &quot;</span>);     <span class="comment">// &lt;left就要多加一个空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(words[ei]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 69 Solution</title>
    <url>/posts/ff603290.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s69;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x平方根</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sqrtx</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//中间值 二分法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左右移动 l  r</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(tmp == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">                ret = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 70 Solution</title>
    <url>/posts/c2fbc69a.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s70;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 爬楼梯</span></span><br><span class="line"><span class="comment"> * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//倒推 func(n) = func(n-1) + func(n-2)</span></span><br><span class="line">        <span class="comment">//边界 func(3) = func(2) + func(1)</span></span><br><span class="line">        <span class="comment">// func(2) = 2</span></span><br><span class="line">        <span class="comment">// func(1) = 1</span></span><br><span class="line">        <span class="comment">// func(0) = 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 7 Solution</title>
    <url>/posts/a4f411db.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数反转</span></span><br><span class="line"><span class="comment"> * 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设环境不允许存储 64 位整数（有符号或无符号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-integer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数字拆分</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; Integer.MIN_VALUE/<span class="number">10</span> || res &gt; Integer.MAX_VALUE/<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 704 Solution</title>
    <url>/posts/caad1831.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s704;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串拼接 StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        <span class="comment">//num1 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="comment">//num2 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i + j &lt;= m + n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numa</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">                numa = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numa = num1.charAt(m - i++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; n) &#123;</span><br><span class="line">                numb = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numb = num2.charAt(n - j++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右向左 逐位数字相加</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numa + numb + carray;</span><br><span class="line">            <span class="comment">//满10 进一位</span></span><br><span class="line">            carray = sum / <span class="number">10</span>;</span><br><span class="line">            builder.append(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次相加后 如果有进位 则拼接到字符串</span></span><br><span class="line">        <span class="keyword">if</span>(carray != <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(carray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 71 Solution</title>
    <url>/posts/2d39ada4.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s71;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化路径</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &#x27;/&#x27; 开头），请你将其转化为更加简洁的规范路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&#x27;//&#x27;）都被视为单个斜杠 &#x27;/&#x27; 。 对于此问题，任何其他格式的点（例如，&#x27;...&#x27;）均被视为文件/目录名称。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，返回的 规范路径 必须遵循下述格式：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 始终以斜杠 &#x27;/&#x27; 开头。</span></span><br><span class="line"><span class="comment"> * 两个目录名之间必须只有一个斜杠 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment"> * 最后一个目录名（如果存在）不能 以 &#x27;/&#x27; 结尾。</span></span><br><span class="line"><span class="comment"> * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &#x27;.&#x27; 或 &#x27;..&#x27;）。</span></span><br><span class="line"><span class="comment"> * 返回简化后得到的 规范路径 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/simplify-path</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 双端队列</span></span><br><span class="line">        Deque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 分割字符</span></span><br><span class="line">        String[] res = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> res[i];</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;.&quot;</span>) || s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.offer(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            sb.append(queue.poll());</span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(<span class="string">&quot;&quot;</span>) ? <span class="string">&quot;/&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 718 Solution</title>
    <url>/posts/111f277f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s718;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.length &lt; B.length ? findMax(A, B) : findMax(B, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">an</span> <span class="operator">=</span> A.length, bn = B.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>; len &lt;= an; len++) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, <span class="number">0</span>, B, bn - len, len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bn-an; j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, <span class="number">0</span>, B, j, an));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;an;i++) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, i, B, <span class="number">0</span>, an - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span>[] b, <span class="type">int</span> j, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+k] == b[j+k]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max, count);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span> ? Math.max(max, count) : max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 72 Solution</title>
    <url>/posts/c60e16a7.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s72;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编辑距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m + n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//j == 0 也就是 words2 长度为0时，编辑距离 完全取决于words1长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i == 0 也就是 words1 长度为0时，编辑距离 完全取决于words2长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">//字符相等 则编辑距离不变</span></span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取决于前者编辑距离的最小值 + 1</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 73 Solution</title>
    <url>/posts/29cc7d99.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s73;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵置零</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;给定一个&amp;nbsp;&lt;code&gt;&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;&lt;/code&gt; 的矩阵，如果一个元素为 &lt;strong&gt;0 &lt;/strong&gt;，则将其所在行和列的所有元素都设为 &lt;strong&gt;0&lt;/strong&gt; 。请使用 &lt;strong&gt;&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 算法&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 74 Solution</title>
    <url>/posts/cb1066e0.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s74;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;编写一个高效的算法来判断 &lt;code&gt;m x n&lt;/code&gt; 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * 	&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * 	&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowIndex</span> <span class="operator">=</span> binarySearchFirstColumn(matrix, target);</span><br><span class="line">        <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">1</span>, high = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>[] row, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = row.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 75 Solution</title>
    <url>/posts/24d20dde.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s75;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;给定一个包含红色、白色和蓝色、共&amp;nbsp;&lt;code&gt;n&lt;/code&gt;&lt;em&gt; &lt;/em&gt;个元素的数组&lt;meta charset=&quot;UTF-8&quot; /&gt;&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;，&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;我们使用整数 &lt;code&gt;0&lt;/code&gt;、&amp;nbsp;&lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 分别表示红色、白色和蓝色。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 76 Solution</title>
    <url>/posts/cfe5b6dd.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s76;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小覆盖子串</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment"> * 如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/minimum-window-substring</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//t 中每个字符出现的次数 存到 ori中</span></span><br><span class="line">    Map&lt;Character, Integer&gt; ori = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="comment">//记录字符串 s 子串中字符出现次数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="comment">//遍历t 统计出 ori</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            ori.put(c, ori.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//子字符串长度len</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE, ansL = -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">//子字符串从 0 开始 到 r</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; sLen) &#123;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="comment">//如果 s字符串的字符出现了 t总字符</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                <span class="comment">//则累加值 放到cnt中计数</span></span><br><span class="line">                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果满足要求了，尝试缩短子串</span></span><br><span class="line">            <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="comment">//如果比当前最小长度len 还小 则 更新len</span></span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// l 左移 对应统计cnt中字符数字也要减1</span></span><br><span class="line">                <span class="keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ansL 存在 则返回 子字符串</span></span><br><span class="line">        <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否完全满足 t的字符及出现次数要求</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> ori.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(key, <span class="number">0</span>) &lt; val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 77 Solution</title>
    <url>/posts/2027dde3.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s77;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合</span></span><br><span class="line"><span class="comment"> * 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以按 任何顺序 返回答案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 78 Solution</title>
    <url>/posts/d12c866e.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s78;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    t.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 79 Solution</title>
    <url>/posts/3eeeed50.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s79;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词搜索</span></span><br><span class="line"><span class="comment"> * 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-search</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> board.length, w = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[h][w];</span><br><span class="line">        <span class="comment">//遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="comment">//检查单词是否存在</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, i, j, word, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//对比字符，到达字符长度，递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记为已访问过</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上下左右四个方向查找</span></span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="comment">//没有访问过的网格，继续递归查找</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, newi, newj, s, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到则标记为没有访问过，下次有可能组成新的单词时，再次访问</span></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 8 Solution</title>
    <url>/posts/55ff4a56.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转换整数 (atoi)</span></span><br><span class="line"><span class="comment"> * 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数 myAtoi(string s) 的算法如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读入字符串并丢弃无用的前导空格</span></span><br><span class="line"><span class="comment"> * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</span></span><br><span class="line"><span class="comment"> * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</span></span><br><span class="line"><span class="comment"> * 将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</span></span><br><span class="line"><span class="comment"> * 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</span></span><br><span class="line"><span class="comment"> * 返回整数作为最终结果。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中的空白字符只包括空格字符 &#x27; &#x27; 。</span></span><br><span class="line"><span class="comment"> * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/string-to-integer-atoi</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 自动机</span></span><br><span class="line">        HashMap&lt;String, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;signed&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;number&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//第一步开始</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">step</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length() &amp;&amp; !step.equals(<span class="string">&quot;end&quot;</span>); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getChar(ch);</span><br><span class="line">            <span class="comment">//下一步，根据上一步和当前字符 匹配 自动机 得出</span></span><br><span class="line">            step = map.get(step)[n];</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;number&quot;</span>.equals(step)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                num = sign == <span class="number">1</span> ? Math.min(num, (<span class="type">long</span>)Integer.MAX_VALUE) : Math.min(num, -<span class="number">1</span> * (<span class="type">long</span>)Integer.MIN_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;signed&quot;</span>.equals(step)) &#123;</span><br><span class="line">                sign = (ch == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;signed&quot;</span>.equals(step)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * (<span class="type">int</span>)num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getChar</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span> == ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;+&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> &lt;= ch-<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch-<span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 80 Solution</title>
    <url>/posts/5103325c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s80;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除有序数组中的重复项 II</span></span><br><span class="line"><span class="comment"> * 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 81 Solution</title>
    <url>/posts/bec15962.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s81;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组 II</span></span><br><span class="line"><span class="comment"> * 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须尽可能减少整个操作步骤。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-in-rotated-sorted-array-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] == nums[mid]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//target在前半部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则，去后半部分找</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//后半部分有序</span></span><br><span class="line">                <span class="comment">//target在后半部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则，去后半部分找</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一直没找到，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 82 Solution</title>
    <url>/posts/55f6e261.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s82;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除排序链表中的重复元素 II</span></span><br><span class="line"><span class="comment"> * 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dum.next = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 83 Solution</title>
    <url>/posts/ba34895f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s83;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除排序链表中的重复元素</span></span><br><span class="line"><span class="comment"> * 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 84 Solution</title>
    <url>/posts/58e89226.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s84;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 柱状图中最大的矩形</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 求在该柱状图中，能够勾勒出来的矩形的最大面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 85 Solution</title>
    <url>/posts/b72af918.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s85;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大矩形</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] left = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span> : left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">            <span class="type">int</span>[] up = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">            <span class="type">int</span>[] down = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stack.isEmpty() ? m : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> down[i] - up[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> height * left[i][j];</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 86 Solution</title>
    <url>/posts/5c1d421b.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s86;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分隔链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你应当 保留 两个分区中每个节点的初始相对位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/partition-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode() &#123;&#125;</span><br><span class="line">     ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lessHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">moreHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curLess</span> <span class="operator">=</span> lessHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curMore</span> <span class="operator">=</span> moreHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                curLess.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.val);</span><br><span class="line">                curLess = curLess.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curMore.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.val);</span><br><span class="line">                curMore = curMore.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLess.next = moreHead.next;</span><br><span class="line">        <span class="keyword">return</span> lessHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 88 Solution</title>
    <url>/posts/42d472a8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s88;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组</span></span><br><span class="line"><span class="comment"> * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/merge-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//定义新数组</span></span><br><span class="line">        <span class="type">int</span>[] all = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> cur;</span><br><span class="line">            <span class="comment">//num1遍历完了，遍历num2</span></span><br><span class="line">            <span class="keyword">if</span>(i == m) &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">                <span class="comment">//num2遍历完了，遍历num1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == n) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">                <span class="comment">//小的元素先排上</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;= nums2[j]) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            all[i+j-<span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组元素再放到num1中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t&lt; n + m; t++) &#123;</span><br><span class="line">            nums1[t] = all[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 87 Solution</title>
    <url>/posts/b3df2925.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s87;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扰乱字符串</span></span><br><span class="line"><span class="comment"> * 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</span></span><br><span class="line"><span class="comment"> * 如果字符串的长度为 1 ，算法停止</span></span><br><span class="line"><span class="comment"> * 如果字符串的长度 &gt; 1 ，执行下述步骤：</span></span><br><span class="line"><span class="comment"> * 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。</span></span><br><span class="line"><span class="comment"> * 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。</span></span><br><span class="line"><span class="comment"> * 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。</span></span><br><span class="line"><span class="comment"> * 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/scramble-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记忆化搜索存储状态的数组</span></span><br><span class="line">    <span class="comment">// -1 表示 false，1 表示 true，0 表示未计算</span></span><br><span class="line">    <span class="type">int</span>[][][] memo;</span><br><span class="line">    String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="built_in">this</span>.memo = <span class="keyword">new</span> <span class="title class_">int</span>[length][length][length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.s1 = s1;</span><br><span class="line">        <span class="built_in">this</span>.s2 = s2;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i1][i2][length] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个子串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span></span><br><span class="line">        <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;</span><br><span class="line">            memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举分割位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 不交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfSimilar</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; freq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s2.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 89 Solution</title>
    <url>/posts/ad161996.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s89;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格雷编码</span></span><br><span class="line"><span class="comment"> * n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：</span></span><br><span class="line"><span class="comment"> * 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）</span></span><br><span class="line"><span class="comment"> * 第一个整数是 0</span></span><br><span class="line"><span class="comment"> * 一个整数在序列中出现 不超过一次</span></span><br><span class="line"><span class="comment"> * 每对 相邻 整数的二进制表示 恰好一位不同 ，且</span></span><br><span class="line"><span class="comment"> * 第一个 和 最后一个 整数的二进制表示 恰好一位不同</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/gray-code</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123; add(<span class="number">0</span>); &#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 9 Solution</title>
    <url>/posts/ba3d2168.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s9;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文数</span></span><br><span class="line"><span class="comment"> * 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，121 是回文，而 123 不是。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/palindrome-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 90 Solution</title>
    <url>/posts/908ded9c.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s90;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/subsets-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (mask &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 91 Solution</title>
    <url>/posts/7f4f86a2.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s91;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  解码方法</span></span><br><span class="line"><span class="comment"> *  一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;A&#x27; -&gt; &quot;1&quot;</span></span><br><span class="line"><span class="comment"> * &#x27;B&#x27; -&gt; &quot;2&quot;</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &#x27;Z&#x27; -&gt; &quot;26&quot;</span></span><br><span class="line"><span class="comment"> * 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;AAJF&quot; ，将消息分组为 (1 1 10 6)</span></span><br><span class="line"><span class="comment"> * &quot;KJF&quot; ，将消息分组为 (11 10 6)</span></span><br><span class="line"><span class="comment"> * 注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据保证答案肯定是一个 32 位 的整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/decode-ways</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 92 Solution</title>
    <url>/posts/94783da1.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s92;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-linked-list-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//哑结点，方便返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//记录翻转链表区间的前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//指针移动到left-1位置，记为pre</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left位置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">// cur节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//记录翻转链表区间的前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从left 到 right 范围链表翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//当前节点指向前置节点</span></span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            <span class="comment">//翻转链表区间的前置节点 指向当前的节点，随着当前节点后移</span></span><br><span class="line">            pre.next=cur;</span><br><span class="line">            <span class="comment">//遍历时移动到下一个节点</span></span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点不为空时，也就是没有遍历到最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//原先left位置节点指向下一个节点</span></span><br><span class="line">            start.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 94 Solution</title>
    <url>/posts/99664de6.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s94;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈 存节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//由根节点开始遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// 当前节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//遍历左节点 节点压栈</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遍历完左分支，把左分支弹出遍历右分支</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                <span class="comment">//遍历右分支</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 93 Solution</title>
    <url>/posts/7bba569f.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s93;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复原 IP 地址</span></span><br><span class="line"><span class="comment"> * 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#x27;.&#x27; 分隔。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span></span><br><span class="line"><span class="comment"> * 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#x27;.&#x27; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/restore-ip-addresses</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//按. 分割 有4段数字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEG_COUNT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//定义结果list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span>[] segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line">        <span class="comment">//把ip地址当做4层树，深度遍历</span></span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> segId, <span class="type">int</span> segStart)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT) &#123;</span><br><span class="line">            <span class="comment">//如果遍历到最后一段了，就全部拼起来 组成新的ip</span></span><br><span class="line">            <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">ipAddr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                    ipAddr.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                        ipAddr.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ipAddr.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(segStart) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">segEnd</span> <span class="operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 95 Solution</title>
    <url>/posts/76a426d8.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s95;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的二叉搜索树 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">currTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 96 Solution</title>
    <url>/posts/9d939ddb.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s96;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 97 Solution</title>
    <url>/posts/7251f6e5.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s97;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交错字符串</span></span><br><span class="line"><span class="comment"> * 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = s1 + s2 + ... + sn</span></span><br><span class="line"><span class="comment"> * t = t1 + t2 + ... + tm</span></span><br><span class="line"><span class="comment"> * |n - m| &lt;= 1</span></span><br><span class="line"><span class="comment"> * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</span></span><br><span class="line"><span class="comment"> * 注意：a + b 意味着字符串 a 和 b 连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/interleaving-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 98 Solution</title>
    <url>/posts/835aad68.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s98;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有效 二叉搜索树定义如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line"><span class="comment"> * 节点的右子树只包含 大于 当前节点的数。</span></span><br><span class="line"><span class="comment"> * 所有左子树和右子树自身必须也是二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/validate-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个边界Long.MIN_VALUE, Long.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line">        <span class="comment">//节点的右子树只包含 大于 当前节点的数</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有左子树和右子树自身必须也是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 99 Solution</title>
    <url>/posts/6c98c656.html</url>
    <content><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s99;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>, y = <span class="literal">null</span>, pred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;</span><br><span class="line">                y = root;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x = pred;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode x, TreeNode y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>加密-md5</title>
    <url>/posts/29014.html</url>
    <content><![CDATA[<p>MD5 和SHA-1 是目前使用比较广泛的散列(Hash)函数，也是在消息认证和数字签名中普遍使用的两种加密算法。本文基于AVR 高速嵌入式单片机，实现了MD5和SHA-1 两种加密算法的比较，并对算法进行了汇编语言的优化和改进。根据实验结果，对两种算法的优缺点进行了比较和分析。 0 引言 随着信息技术和Internet 的迅速发展，信息安全和可靠性问题越来越重要。现在信息安全面临两大基本攻击：被动式攻击（获取消息的内容、业务流分析）和主动攻击（假冒、消息的篡改、业务拒绝）。前者主要靠加密和解密技术进行有效处理，而后者就要靠消息认证来处理。在金融交易、电子商务、电子信件、手机用户信息的确认等领域，数据完整性确认和数据来源的真伪鉴定都是很重要的安全服务。实现这些安全服务的最好方法就是使用加密函数中的单项散列（Hash）函数。单项散列（Hash）函数是一种单项密码体制，它是一个从明文到密文的不可逆函数，也就是说，是无法解密的。通常应用在只需要加密、不需要解密的特殊应用场合。单项散列（Hash）函数H(M)作用于一任意长度的消息M，它返回一固定长度的散列值h:h&#x3D;H(M)作为初始消息的独一无二的“数字指纹”，从而能保证数据的完整性和惟一性。 3.1 MD5 与SHA-1 的比较 由于MD5 与SHA-1均是从MD4 发展而来，它们的结构和强度等特性有很多相似之处，表（1）是对MD5 与SHA-1 的结构比较。SHA-1与MD5 的最大区别在于其摘要比MD5 摘要长 32 比特。对于强行攻击，产生任何一个报文使之摘要等于给定报文摘要的难度：MD5 是2128 数量级的操作，SHA-1 是2160 数量级的操作。产生具有相同摘要的两个报文的难度：MD5是 264 是数量级的操作，SHA-1 是280 数量级的操作。因而,SHA-1 对强行攻击的强度更大。但由于SHA-1 的循环步骤比MD5 多（80:64）且要处理的缓存大（160 比特:128 比特），SHA-1 的运行速度比MD5 慢。 5 结束语 MD5 和SHA-1 是单项散列函数的典型代表，它们广泛地应用在信息安全和数字签名等各个领域。从而有效地抗击了信息的主动式攻击，本文基于AVR 单片机实现了这两种算法，并结合汇编语言尽心了优化，取得了较好的效果。根据信息安全的要求的不同层次可以灵活选择这两种算法从而达到实际目的。</p>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-基数排序</title>
    <url>/posts/26468.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-快速排序</title>
    <url>/posts/63169.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-希尔排序</title>
    <url>/posts/59015.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-选择排序</title>
    <url>/posts/4840.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-快速排序</title>
    <url>/posts/63170.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/22315.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-桶排序</title>
    <url>/posts/37369.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-计数排序</title>
    <url>/posts/14338.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>排序-归并排序</title>
    <url>/posts/8756.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>DP 树的最小支配集，最小点覆盖与最大独立集</title>
    <url>/posts/145.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>EM算法</title>
    <url>/posts/55519.html</url>
    <content><![CDATA[<p>极大似然估计：应用广泛的参数估计方法</p>
<p>链接：<a href="https://www.cnblogs.com/bigmoyan/p/4550375.html">EM算法详细推导和讲解</a></p>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/35921.html</url>
    <content><![CDATA[<p>KMP算法解决的是字符串模式匹配定位问题</p>
<p>主串：  ABACBFG  —i<br>模式串：ABAD     —j</p>
<h2 id="简单算法："><a href="#简单算法：" class="headerlink" title="简单算法："></a>简单算法：</h2><p>从左到右一个一个匹配，遇到不匹配，i回到i-j+1,j回到0，重新匹配（不考虑模式串本身特性–最大前后缀数）</p>
<pre><code>/**

 * @param ts 主串

 * @param ps 模式串

 * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1

 */

public static int bf(String ts, String ps) &#123;

    char[] t = ts.toCharArray();

    char[] p = ps.toCharArray();

    int i = 0; // 主串的位置

    int j = 0; // 模式串的位置

    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;

       if (t[i] == p[j]) &#123; // 当两个字符相同，就比较下一个

           i++;

           j++;

       &#125; else &#123;

           i = i - j + 1; // 一旦不匹配，i后退

           j = 0; // j归0

       &#125;

    &#125;

    if (j == p.length) &#123;

       return i - j;

    &#125; else &#123;

       return -1;

    &#125;

&#125;
</code></pre>
<p>优化：考虑先前匹配的结果和模式串的特点（最长前缀），i可以不动，只移动j，到位置k</p>
<h2 id="寻找k"><a href="#寻找k" class="headerlink" title="寻找k"></a>寻找k</h2><p>规律： 最前面的k个字符和j之前的最后k个字符是一样的</p>
<p> <img src="http://thyrsi.com/t6/625/1543997868x1822611383.jpg" alt="alt text" title="示例"></p>
<h2 id="推导："><a href="#推导：" class="headerlink" title="推导："></a>推导：</h2><pre><code>T[i] != P[j] 
T[i-j ~ i-1] == P[0 ~ j-1] 
P[0 ~ k-1] == P[j-k ~ j-1]
==&gt; T[i-k ~ i-1] == P[0 ~ k-1]
</code></pre>
<h3 id="由于每个j对应的k都可能不同，可以找到一个j-k对应关系-next-j-k"><a href="#由于每个j对应的k都可能不同，可以找到一个j-k对应关系-next-j-k" class="headerlink" title="由于每个j对应的k都可能不同，可以找到一个j~k对应关系 next[j] = k"></a>由于每个j对应的k都可能不同，可以找到一个j~k对应关系 <code>next[j] = k</code></h3><h2 id="四个规则"><a href="#四个规则" class="headerlink" title="四个规则"></a>四个规则</h2><ol>
<li>j在最左边了，匹配失败，i指针后移</li>
<li><code>P[0 ~ k-1] == p[j-k ~ j-1] 且 P[k] == P[j]时，next[j+1] == k + 1 == next[j] + 1，找到最大公共前后缀数</code></li>
<li><code>P[0 ~ k-1] == p[j-k ~ j-1] 且 P[k] != P[j]时，k=next[k]（在位置k不匹配了，往下找不到更长的前缀字串了，但可以根据k找到最长前后缀数）</code></li>
</ol>
<blockquote>
<p>递归思想: 不匹配，递归找不匹配位置k前面有没有相同前缀后缀，一直找到next[0]&#x3D;-1为止，此时next[j]&#x3D;k+1&#x3D;-1+1&#x3D;0</p>
</blockquote>
<p><img src="http://thyrsi.com/t6/625/1543997916x1822611383.jpg" alt="alt text"></p>
<pre><code>public static int[] getNext(String ps) &#123;

    char[] p = ps.toCharArray();

    int[] next = new int[p.length];

    next[0] = -1;

    int j = 0;

    int k = -1;

    while (j &lt; p.length - 1) &#123;

       if (k == -1 || p[j] == p[k]) &#123;

           next[++j] = ++k;

       &#125; else &#123;

           k = next[k];

       &#125;

    &#125;

    return next;

&#125;
</code></pre>
<h3 id="当P-j-x3D-x3D-P-next-j-已经与主串不匹配-96"><a href="#当P-j-x3D-x3D-P-next-j-已经与主串不匹配-96" class="headerlink" title="当P[j] &#x3D;&#x3D; P[next[j]],已经与主串不匹配&#96;"></a>当P[j] &#x3D;&#x3D; P[next[j]],已经与主串不匹配&#96;</h3><pre><code>public static int[] getNext(String ps) &#123;

    char[] p = ps.toCharArray();

    int[] next = new int[p.length];

    next[0] = -1;

    int j = 0;

    int k = -1;

    while (j &lt; p.length - 1) &#123;

       if (k == -1 || p[j] == p[k]) &#123;

           if (p[++j] == p[++k]) &#123; // 当两个字符相等时要跳过

              next[j] = next[k];

           &#125; else &#123;

              next[j] = k;

           &#125;

       &#125; else &#123;

           k = next[k];

       &#125;

    &#125;

    return next;

&#125;
</code></pre>
<h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><pre><code>public static int KMP(String ts, String ps) &#123;

    char[] t = ts.toCharArray();

    char[] p = ps.toCharArray();

    int i = 0; // 主串的位置

    int j = 0; // 模式串的位置

    int[] next = getNext(ps);

    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;

       if (j == -1 || t[i] == p[j]) &#123; // 当j为-1时，要移动的是i，当然j也要归0

           i++;

           j++;

       &#125; else &#123;

           // i不需要回溯了

           // i = i - j + 1;

           j = next[j]; // j回到指定位置

       &#125;

    &#125;

    if (j == p.length) &#123;

       return i - j;

    &#125; else &#123;

       return -1;

    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>LCA最近公共祖先算法</title>
    <url>/posts/53370.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>RMQ算法</title>
    <url>/posts/56550.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>Prim算法</title>
    <url>/posts/46211.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/42877.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>倍增</title>
    <url>/posts/47317.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>兔子数列</title>
    <url>/posts/43734.html</url>
    <content><![CDATA[<p>自然界现象抽象化得到的数列模型——斐波那契数列</p>
<ol>
<li>初始状态：一对刚出生的兔子</li>
<li>下一步：生长</li>
<li><code>繁殖得到 一对刚出生的兔子-&gt; 第1步</code></li>
</ol>
<p>总结： 当月的兔子数&#x3D;上月兔子数+当月新生兔子  数列的当前列&#x3D;前两列之和</p>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>指数阶算法，效率较低，时间复杂度爆炸增量</p>
<pre><code>    Fib1(int n)
    
    &#123; if(n&lt;1)
    
           return -1;
    
      if(n==1||n==2)
    
            return 1;
    
       return Fib1(n-1)+Fib1(n-2);
    
    &#125;
    
</code></pre>
<h2 id="数组记录先两项值"><a href="#数组记录先两项值" class="headerlink" title="数组记录先两项值"></a>数组记录先两项值</h2><p>时间复杂度从指数阶降到了多项式阶O(n),空间复杂度O(n)</p>
<pre><code>Fib2(intn)
&#123;
    if(n&lt;1)
        return-1;
    int[] a=new int[n];
    a[1]=1;
    a[2]=1;
    for(int i=3;i&lt;=n;i++)
        a[i]=a[i-1]+a[i-2];
        return a[n];
     &#125;
&#125;
         
    
</code></pre>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>不记录中间结果，只记录中间项，空间复杂度降到O(1)</p>
<pre><code>Fib3(intn)
&#123;
    inti,s1,s2;
    if(n&lt;1)
        return-1;
    if(n==1||n==2)
        return1;
    s1=1;s2=1;
    for(i=3;i&lt;=n;i++)
    &#123;
        s2=s1+s2;//辗转相加法
        s1=s2-s1;//记录前一项
    &#125;
    return s2;
 &#125;
 
</code></pre>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p><code>斐波那契数列(F(n),F(n-1))为(1,1)与&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;的n-2次幂的乘积, 可通过递推求证</code></p>
<pre><code>   public static int ValueN(int n)&#123;
         if(n&lt;1)&#123;
             return 0;
         &#125;
         if(n==1 || n==2)&#123;
             return 1;
         &#125;
          int [][] base=&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;
          int [][] res=matrixPower(base,n-2);
          return res[0][0]+res[1][0];
       &#125;
       public static int[][] matrixPower(int[][] m,int p)&#123;
           if(p==0)
               return null;
           if(p==1)
               return m;
           int[][] res=matrixPower(m,p&gt;&gt;1);
           res=muliMatrix(res,res);
           if((p&amp;1)==1)&#123;
               res=muliMatrix(res,m);
           &#125;
           return res;
       &#125;
       //求两个矩阵相乘得到一个新的矩阵
       public static int[][] muliMatrix(int[][] m1,int[][] m2)&#123;
           int [][] res=new int[m1.length][m2[0].length];
           for(int i=0;i&lt;m1.length;i++)&#123;
               for(int j=0;j&lt;m2[0].length;j++)&#123;
                   for(int k=0;k&lt;m2.length;k++)&#123;
                       res[i][j]+=m1[i][k]*m2[k][j];
                   &#125;
               &#125;
           &#125;
           return res;
       &#125;
   &#125;
  
</code></pre>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/posts/40091.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>关键路径算法</title>
    <url>/posts/24685.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>单调队列优化</title>
    <url>/posts/4900.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/posts/42854.html</url>
    <content><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/**
 * 无向图
 */
public class NoDirectionGraph &#123;
 
    private int mMaxSize; //图中包含的最大顶点数
    private GraphVertex[] vertexList; //顶点数组
    private int[][] indicatorMat; //指示顶点之间的连通关系的邻接矩阵
    private int nVertex; //当前实际保存的顶点数目
    
    
    public NoDirectionGraph(int maxSize) &#123;
        mMaxSize = maxSize;
        vertexList = new GraphVertex[mMaxSize];
        indicatorMat = new int[mMaxSize][mMaxSize];
        nVertex = 0;
        //初始化邻接矩阵元素为0
        for(int j=0;j&lt;mMaxSize;j++) &#123;
            for(int k=0;k&lt;mMaxSize;k++) &#123;
                indicatorMat[j][k] = 0;
            &#125;
        &#125;
    &#125;
    
    
    public void addVertex(GraphVertex v) &#123;
        if(nVertex &lt; mMaxSize) &#123;
            vertexList[nVertex++] = v;
            
        &#125; else &#123;
            System.out.println(&quot;---插入失败，顶点数量已达上限!&quot;);
        &#125;
    &#125;
    
    /**
     * 修改邻接矩阵，添加新的边
     * @param start
     * @param end
     */
    public void addEdge(int start,int end) &#123;
        indicatorMat[start][end] = 1;
        indicatorMat[end][start] = 1;
    &#125;
    
    /**
     * 打印邻接矩阵
     */
    public void printIndicatorMat() &#123;
        
        for(int[] line:indicatorMat) &#123;
            for(int i:line) &#123;
                System.out.print(i + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
    
    /**
     * 深度优先遍历
     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数
     */
    public void DFS(int vertexIndex) &#123;
        ArrayStack stack = new ArrayStack();
        //1.添加检索元素到栈中
        vertexList[vertexIndex].setVisited(true);
        stack.push(vertexIndex);
        int nextVertexIndex = getNextVertexIndex(vertexIndex);
        while(!stack.isEmpty()) &#123; //不断地压栈、出栈，直到栈为空(检索元素也没弹出了栈)为止
            if(nextVertexIndex != -1) &#123;
                vertexList[nextVertexIndex].setVisited(true);
                stack.push(nextVertexIndex);
                stack.printElems();
            &#125; else &#123;
                stack.pop();
            &#125;
            //检索当前栈顶元素是否包含其他未遍历过的节点
            if(!stack.isEmpty()) &#123;
                nextVertexIndex = getNextVertexIndex(stack.peek()); 
            &#125;
        &#125;
    &#125;
    
    /**
     * 得到当前顶点的下一个顶点所在行
     * @param column
     * @return
     */
    public int getNextVertexIndex(int column) &#123;
        for(int i=0;i&lt;indicatorMat[column].length;i++) &#123;
            if(indicatorMat[column][i] == 1 &amp;&amp; !vertexList[i].isVisited()) &#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
    
    /**
     * 广度优先遍历
     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数
     */
    public void BFS(int vertexIndex) &#123;
        ChainQueue queue = new ChainQueue();
        vertexList[vertexIndex].setVisited(true);
        queue.insert(new QueueNode(vertexIndex));
        int nextVertexIndex = getNextVertexIndex(vertexIndex);
        while(!queue.isEmpty()) &#123;
            if(nextVertexIndex != -1) &#123;
                vertexList[nextVertexIndex].setVisited(true);
                queue.insert(new QueueNode(nextVertexIndex));
            &#125; else &#123;
                queue.remove();
            &#125;
            if(!queue.isEmpty()) &#123;
                nextVertexIndex = getNextVertexIndex(queue.peek().data);
                queue.printElems();
            &#125;
        &#125;
    &#125;
&#125;



 
/**
 * 使用数组实现栈结构
 */
public class ArrayStack &#123;
 
    private int[] tArray; 
    private int topIndex = -1; //表示当前栈顶元素的索引位置
    private int CAPACITY_STEP = 12; //数组容量扩展步长
    
    
    public ArrayStack() &#123;
        /***创建泛型数组的一种方法***/
        tArray = new int[CAPACITY_STEP]; 
    &#125;
    
    /**
     * 弹出栈顶元素方法
     * @return
     */
    public int pop() &#123;
        if(isEmpty()) &#123;
            System.out.println(&quot;错误，栈中元素为空，不能pop&quot;);
            return -1;
        &#125; else &#123;
            int i = tArray[topIndex];
            tArray[topIndex--] = -1; //擦除pop元素
            return i;
        &#125;
    &#125;
    
    /**
     * 向栈中插入一个元素
     * @param t
     */
    public void push(int t) &#123;
        //检查栈是否已满
        if(topIndex == (tArray.length-1)) &#123;
            //扩展容量
            int[] tempArray = new int[tArray.length + CAPACITY_STEP];
            for(int i=0;i&lt;tArray.length;i++) &#123;
                tempArray[i] = tArray[i];
            &#125;
            tArray = tempArray;
            tempArray = null;
        &#125; else &#123;
            topIndex ++;
            tArray[topIndex] = t;
        &#125;
    &#125;
    
    /**
     * 得到栈顶元素，但不弹出
     * @return
     */
    public int peek() &#123;
        if(isEmpty()) &#123;
            System.out.println(&quot;错误，栈中元素为空，不能peek&quot;);
            return -1;
        &#125; else &#123;
            return tArray[topIndex];
        &#125;
    &#125;
    
    /**
     * 判断当前栈是否为空
     * @return
     */
    public boolean isEmpty() &#123;
        return (topIndex &lt; 0);
    &#125;
    
    /**
     * 打印栈中元素
     */
    public void printElems() &#123;
        for(int i=0;i&lt;=topIndex;i++) &#123;
            System.out.print(tArray[i] + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
&#125;


/**
 * 使用链表实现队列
 */
public class ChainQueue &#123;
    private QueueNode head; // 指向队列头节点
    private QueueNode tail; // 指向队列尾节点
    private int size = 0; // 队列尺寸
 
    public ChainQueue() &#123;
 
    &#125;
 
    /**
     * 插入新节点到队列尾
     */
    public void insert(QueueNode node) &#123;
 
        // 当然也可以这么写,添加tail.prev = node
        if (head == null) &#123;
            head = node;
            tail = head;
        &#125; else &#123;
            node.next = tail;
            tail.prev = node; // 双向连接，确保head.prev不为空
            tail = node;
        &#125;
        size++;
    &#125;
 
    /**
     * 移除队列首节点
     */
    public QueueNode remove() &#123;
        if (!isEmpty()) &#123;
            QueueNode temp = head;
            head = head.prev;
            size--;
            return temp;
        &#125; else &#123;
            System.out.println(&quot;异常操作，当前队列为空!&quot;);
            return null;
        &#125;
    &#125;
 
    /**
     * 队列是否为空
     * 
     * @return
     */
    public boolean isEmpty() &#123;
        if (size &gt; 0) &#123;
            return false;
        &#125; else &#123;
            return true;
        &#125;
    &#125;
 
    /**
     * 返回队列首节点，但不移除
     */
    public QueueNode peek() &#123;
        if (!isEmpty()) &#123;
            return head;
        &#125; else &#123;
            System.out.println();
            System.out.println(&quot;异常操作，当前队列为空!&quot;);
            return null;
        &#125;
    &#125;
 
    /**
     * 返回队列大小
     * 
     * @return
     */
    public int size() &#123;
        return size;
    &#125;
    
    /**
     * 打印队列中的元素
     */
    public void printElems() &#123;
        QueueNode tempNode = head;
        while(tempNode != null) &#123;
            System.out.print(tempNode.data + &quot; &quot;);
            tempNode = tempNode.prev;
        &#125;
        System.out.println();
    &#125;
&#125;
 
/**
 * 节点类
 * 
 * @author wly
 * 
 */
class QueueNode &#123;
    QueueNode prev;
    QueueNode next;
 
    int data;
 
    public QueueNode(int data) &#123;
        this.data = data;
    &#125;
 
    public int getData() &#123;
        return data;
    &#125;
 
    public void setData(int data) &#123;
        this.data = data;
    &#125;
 
    @Override
    public String toString() &#123;
        // TODO Auto-generated method stub
        super.toString();
        return data + &quot;&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>插头DP</title>
    <url>/posts/58609.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>拉格朗日乘子法</title>
    <url>/posts/18339.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/posts/13990.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>最长上升子序列最大连续子序列和，最长公共子串</title>
    <url>/posts/51333.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/posts/55387.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>深度优先广度优先</title>
    <url>/posts/24306.html</url>
    <content><![CDATA[<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点压入栈中，stack（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）；</p>
</li>
<li><p>将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）；</p>
</li>
<li><p>将E节点弹出，同时将E的子节点I压入，stack（I,C）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void depthFirst() &#123;

    Stack&lt;Map&lt;String, Object&gt;&gt; nodeStack = new Stack&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeStack.add(node);

    while (!nodeStack.isEmpty()) &#123;

        node = nodeStack.pop();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) &#123;

            for (Map child : children) &#123;

                nodeStack.push(child);

            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p> 广度优先遍历各个节点，需要使用到队列（Queue）这种数据结构，queue的特点是先进先出，其实也可以使用双端队列，区别就是双端队列首尾都可以插入和弹出节点。整个遍历过程如下：</p>
<ol>
<li><p>首先将A节点插入队列中，queue（A）;</p>
</li>
<li><p>将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；</p>
</li>
<li><p>将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;</p>
</li>
<li><p>将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；</p>
</li>
<li><p>将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；</p>
</li>
</ol>
<p>…依次往下，最终遍历完成</p>
<pre><code>public void breadthFirst() &#123;

    Deque&lt;Map&lt;String, Object&gt;&gt; nodeDeque = new ArrayDeque&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();

    nodeDeque.add(node);

    while (!nodeDeque.isEmpty()) &#123;

        node = nodeDeque.peekFirst();

        System.out.println(node);

        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点

        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);

        if (children != null &amp;&amp; !children.isEmpty()) &#123;

            for (Map child : children) &#123;

                nodeDeque.add(child);

            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>环形DP</title>
    <url>/posts/40386.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>线性dp LIS</title>
    <url>/posts/37887.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>石子合并问题</title>
    <url>/posts/11863.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/posts/1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法-旅行商问题</title>
    <url>/posts/25120.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？</p>
<p>还有 背包、装箱 问题</p>
<p>注： 递归，时间复杂度为n!</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在对问题求解时，总是做出当前情况下的最好选择，否则将来可能会后悔，故名“贪心”。这是一种算法策略，每次选择得到的都是局部最优解。选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p>
<p>求解的问题分成若干个子问题，每一个子问题求解，得到子问题的局部最优解，子问题的局部最优解合成原问题的一个解</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>从某一个城市开始，每次选择一个城市，直到所有的城市被走完。 </p>
</li>
<li><p>每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<pre><code> 从问题的某一初始解出发；
     while （能朝给定总目标前进一步）
     &#123; 
           利用可行的决策，求出可行解的一个解元素；
     &#125;
 由所有解元素组合成问题的一个可行解
</code></pre>
</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不能保证最终为最优解</li>
<li>不能用来求最大最小解问题</li>
<li>无后效性</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;
 
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
 
public class TxTsp &#123;
 
    private int cityNum; // 城市数量
    private int[][] distance; // 距离矩阵
 
    private int[] colable;//代表列，也表示是否走过，走过置0
    private int[] row;//代表行，选过置0
 
    public TxTsp(int n) &#123;
        cityNum = n;
    &#125;
 
    private void init(String filename) throws IOException &#123;
        // 读取数据
        int[] x;
        int[] y;
        String strbuff;
        BufferedReader data = new BufferedReader(new InputStreamReader(
                new FileInputStream(filename)));
        distance = new int[cityNum][cityNum];
        x = new int[cityNum];
        y = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) &#123;
            // 读取一行数据，数据格式1 6734 1453
            strbuff = data.readLine();
            // 字符分割
            String[] strcol = strbuff.split(&quot; &quot;);
            x[i] = Integer.valueOf(strcol[1]);// x坐标
            y[i] = Integer.valueOf(strcol[2]);// y坐标
        &#125;
        data.close();
 
        // 计算距离矩阵
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628
        for (int i = 0; i &lt; cityNum - 1; i++) &#123;
            distance[i][i] = 0; // 对角线为0
            for (int j = i + 1; j &lt; cityNum; j++) &#123;
                double rij = Math
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])
                                * (y[i] - y[j])) / 10.0);
                // 四舍五入，取整
                int tij = (int) Math.round(rij);
                if (tij &lt; rij) &#123;
                    distance[i][j] = tij + 1;
                    distance[j][i] = distance[i][j];
                &#125; else &#123;
                    distance[i][j] = tij;
                    distance[j][i] = distance[i][j];
                &#125;
            &#125;
        &#125;
 
        distance[cityNum - 1][cityNum - 1] = 0;
 
        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) &#123;
            colable[i] = 1;
        &#125;
 
        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) &#123;
            row[i] = 1;
        &#125;
 
    &#125;
    
    public void solve()&#123;
        
        int[] temp = new int[cityNum];
        String path=&quot;0&quot;;
        
        int s=0;//计算距离
        int i=0;//当前节点
        int j=0;//下一个节点
        //默认从0开始
        while(row[i]==1)&#123;
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) &#123;
                temp[k] = distance[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            &#125;
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过
            
            path+=&quot;--&gt;&quot; + j;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            s = s + distance[i][j];
            i = j;//当前节点指向下一节点
        &#125;
        System.out.println(&quot;路径:&quot; + path);
        System.out.println(&quot;总距离为:&quot; + s);
        
    &#125;
    
    public int selectmin(int[] p)&#123;
        int j = 0, m = p[0], k = 0;
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) &#123;
            j++;
            //System.out.print(j+&quot; &quot;);
            if(j&gt;=cityNum)&#123;
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            &#125;
            else&#123;
                m = p[j];
            &#125;
        &#125;
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) &#123;
            if (colable[j] == 1) &#123;
                if (m &gt;= p[j]) &#123;
                    m = p[j];
                    k = j;
                &#125;
            &#125;
        &#125;
        return k;
    &#125;
 
 
    public void printinit() &#123;
        System.out.println(&quot;print begin....&quot;);
        for (int i = 0; i &lt; cityNum; i++) &#123;
            for (int j = 0; j &lt; cityNum; j++) &#123;
                System.out.print(distance[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        System.out.println(&quot;print end....&quot;);
    &#125;
 
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;Start....&quot;);
        TxTsp ts = new TxTsp(48);
        ts.init(&quot;c://data.txt&quot;);
        //ts.printinit();
        ts.solve();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-EL-Spring 表达式语言</title>
    <url>/posts/21202.html</url>
    <content><![CDATA[<p>EL-Spring 表达式语言，支持xml和注解中使用表达式，类似JSP 的EL 表达式，可以实现普通文件、网址、配置文件、系统环境变量的注入</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>@PropertySource(&quot;classpath:application.properties&quot;)

@Value(&quot;This is common string&quot;) // 注入普通字符串
private String normal;

@Value(&quot;#&#123;systemProperties[&#39;os.name&#39;]&#125;&quot;) // 注入操作系统属性
private String osName;

@Value(&quot;#&#123;T(java.lang.Math).random()*100.0&#125;&quot;) // 注入表达式结果
private double randomNumber;

@Value(&quot;#&#123;anotherService.property&#125;&quot;) // 注入其他Bean属性
private String propfromAnother;

@Value(&quot;#&#123;T(com.demo.el.spring_el_demo.DemoService).getCalc()*100&#125;&quot;) // 注入类static方法结果,支持运算处理
private double result;

@Value(&quot;classpath:test.txt&quot;) // 注入文件资源
private Resource testFile;

@Value(&quot;http://www.baidu.com&quot;) // 注入网址资源
private Resource testUrl;

@Value(&quot;$&#123;book.name&#125;&quot;) // 注入配置文件
private String bookName;

@Autowired
private Environment environment;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-JDK动态代理或CGLIB</title>
    <url>/posts/37039.html</url>
    <content><![CDATA[<h1 id="使用JDK动态代理"><a href="#使用JDK动态代理" class="headerlink" title="使用JDK动态代理"></a>使用JDK动态代理</h1><p>Spring AOP默认使用JDK动态代理（基于接口的代理）。</p>
<p>如果被代理的目标对象已经实现了接口，则使用JDK动态代理。如果目标对象未实现任何接口，则会创建CGLIB代理。</p>
<h1 id="使用CGLIB代理注意"><a href="#使用CGLIB代理注意" class="headerlink" title="使用CGLIB代理注意"></a>使用CGLIB代理注意</h1><ul>
<li>final方法不建议使用，因为它们无法被覆盖。</li>
<li>除非强制使用CGLIB，需要将元素 <code>&lt;</code>aop:config<code>&gt;</code> 的属性proxy-target-class值设置为true。</li>
<li>需要CGLIB库，找不到CGLIB库类时，Spring会发出警告。</li>
<li>代理对象的构造函数将被调用两次。这是因为CGLIB代理会为每个代理对象生成子类。构造函数中只做赋值和初始化，不能实现其他的逻辑。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-java8语法</title>
    <url>/posts/22404.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-JVM内存模型</title>
    <url>/posts/1252.html</url>
    <content><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p><img src="/img/jvm_memory_20221229161909.png" alt="JVM内存模型"></p>
<h2 id="指令重排-编译器、运行时"><a href="#指令重排-编译器、运行时" class="headerlink" title="指令重排(编译器、运行时)"></a>指令重排(编译器、运行时)</h2><p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<pre><code>编译器优化重排序
指令级并行重排序
内存系统重排序
</code></pre>
<h2 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p>
<h2 id="指令级并行重排序"><a href="#指令级并行重排序" class="headerlink" title="指令级并行重排序"></a>指令级并行重排序</h2><p>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>指令级并行的重排序：现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<h2 id="内存系统重排序"><a href="#内存系统重排序" class="headerlink" title="内存系统重排序"></a>内存系统重排序</h2><p>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行(强调的是内存缓存)。<br>在虚拟机层面，为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><h3 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h3><ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li>
</ul>
<h3 id="基于保守策略的JMM内存屏障插入策略："><a href="#基于保守策略的JMM内存屏障插入策略：" class="headerlink" title="基于保守策略的JMM内存屏障插入策略："></a>基于保守策略的JMM内存屏障插入策略：</h3><ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/posts/35077.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-java8语法</title>
    <url>/posts/22405.html</url>
    <content><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="stream-forEach-循环处理"><a href="#stream-forEach-循环处理" class="headerlink" title="stream().forEach()循环处理"></a>stream().forEach()循环处理</h3><pre><code>List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList();
list.add(&quot;1&quot;);
list.add(&quot;2&quot;);
list.add(&quot;3&quot;);

list.stream().forEach(string -&gt;&#123;
    System.out.println(string);
&#125;);
</code></pre>
<h3 id="stream-map-处理集合，collect-Collectors-toList-结果输出为List"><a href="#stream-map-处理集合，collect-Collectors-toList-结果输出为List" class="headerlink" title="stream().map()处理集合，collect(Collectors.toList())结果输出为List"></a>stream().map()处理集合，collect(Collectors.toList())结果输出为List</h3><pre><code>List&lt;String&gt; list1 = Lists.newArrayList();
list1.add(&quot;1&quot;);
list1.add(&quot;2&quot;);
list1.add(&quot;3&quot;);

List&lt;String&gt; list2 = list1.stream().map(string -&gt; &#123;
    return &quot;stream().map()处理之后：&quot; + string;
&#125;).collect(Collectors.toList());

System.out.println(list2.toString());
</code></pre>
<h3 id="stream-filter-过滤集合"><a href="#stream-filter-过滤集合" class="headerlink" title="stream().filter()过滤集合"></a>stream().filter()过滤集合</h3><pre><code>List&lt;String&gt; list1 = Lists.newArrayList();
list1.add(&quot;1&quot;);
list1.add(&quot;1&quot;);
list1.add(&quot;2&quot;);
list1.add(&quot;3&quot;);

List&lt;String&gt; list2 = list1.stream().filter(s -&gt; !s.equals(&quot;1&quot;)).collect(Collectors.toList());
System.out.println(list2.toString());
</code></pre>
<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>一个只包含一个方法的接口,可以使用Lambda表达式作为参数</p>
<pre><code>new Thread(() -&gt; System.out.println(&quot;Hello World!&quot;));

public interface Interface1 &#123;
     void test();
&#125;

private void func(Interface1 interface1) &#123;
    interface1.test();
&#125;

func(() -&gt; System.out.println(&quot;Hello World&quot;));

//有参数，参数知名类型更规范
func((Integer x) -&gt; System.out.println(&quot;Hello World&quot; + x));

//有参数，有返回值
func((Integer x) -&gt; &#123;
    System.out.println(&quot;Hello World&quot; + x);
    return true;
&#125;);
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-rbac权限管理</title>
    <url>/posts/43300.html</url>
    <content><![CDATA[<p>RBAC : 基于角色的权限访问控制（Role-Based Access Control）通过角色绑定权限，然后给用户划分角色。在web应用中，可以将权限理解为url，一个权限对应一个url。</p>
<h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><p>用户，角色，权限，权限组，菜单</p>
<p>用户和角色，多对多<br>角色和权限，多对多<br>权限和权限组，多对一<br>权限组和菜单，多对一<br>菜单和菜单，自引用</p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>用户登录后，取出其权限及所属菜单信息，写入session中</p>
<p>自定义中间件，检查用户权限，进行访问控制</p>
<p>参考：<a href="https://www.jianshu.com/p/f45b54768aa9">https://www.jianshu.com/p/f45b54768aa9</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-同步锁-synchronized</title>
    <url>/posts/22933.html</url>
    <content><![CDATA[<p>控制Java多线程环境下的线程同步</p>
<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>synchronized修饰方法或者代码块</p>
<h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>synchronized修饰静态方法或者代码块</p>
<h2 id="方法锁（对象锁）"><a href="#方法锁（对象锁）" class="headerlink" title="方法锁（对象锁）"></a>方法锁（对象锁）</h2><p>synchronized修饰方法，锁住的也是这个对象</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public class SynchronizeTest &#123;
    static class S&#123;
        String name;
        public void setName(String name) throws InterruptedException &#123;
            synchronized (this) &#123;
                System.out.println(&quot;..........&quot;);
                Thread.sleep(1000*5L);
                this.name = name;
            &#125;
        &#125;
        public void print()&#123;
            synchronized (this)&#123;
                System.out.println(name);
            &#125;
        &#125;
        public synchronized void doSomething1()&#123;
            System.out.println(&quot;doSomething1&quot;);
            try &#123;
                Thread.sleep(1000*5L);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        public synchronized void doSomething2()&#123;
            System.out.println(name);
        &#125;
    &#125;
    public static void main(String[] args) throws Exception&#123;
        S s = new S();
//        Thread t1 = new Thread(() -&gt; &#123;
//            try &#123;
//                s.setName(&quot;hello&quot;);
//            &#125; catch (InterruptedException e) &#123;
//                e.printStackTrace();
//            &#125;
//        &#125;);
//        t1.start();
//        Thread t2 = new Thread(() -&gt; &#123;
//                s.print();
//        &#125;);
//        t2.start();
//        t1.join();
//        t2.join();
        Thread t1 = new Thread(() -&gt; &#123;
             s.doSomething1();
        &#125;);
        t1.start();
        Thread t2 = new Thread(() -&gt; &#123;
            s.doSomething2();
        &#125;);
        t2.start();
        t1.join();
        t2.join();

    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-volatile关键字</title>
    <url>/posts/23a4cdd8.html</url>
    <content><![CDATA[<h1 id="Volatile是Java虚拟机提供的-轻量级-的同步机制"><a href="#Volatile是Java虚拟机提供的-轻量级-的同步机制" class="headerlink" title="Volatile是Java虚拟机提供的**轻量级**的同步机制"></a>Volatile是Java虚拟机提供的**<code>轻量级</code>**的同步机制</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile修饰的变量，不拷贝副本到工作内存，直接操作主内存，任何修改都可以其他线程读取到。<br>volatile的可以保证写入和读取 64 位值（long类型和double类型 ）的原子性。</p>
<p>单例中 volatile  + synchronized 的作用</p>
<pre><code>volatile 可见性、禁止指令重排
synchronized保证操作的原子性、一致性和可见性。
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/posts/40836.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/posts/36750.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>哈希表HashMap</title>
    <url>/posts/24972.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>排序-并查集</title>
    <url>/posts/59655.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/posts/5009.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-跳表</title>
    <url>/posts/63989.html</url>
    <content><![CDATA[<p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。<br>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。<br>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p>
<p>Key-Value数据结构<br>目前常用的key-value数据结构有三种：Hash表、红黑树、SkipList，它们各自有着不同的优缺点（不考虑删除操作）：<br>Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。<br>红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。<br>SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</p>
<p>如果要实现一个key-value结构，需求的功能有插入、查找、迭代、修改，那么首先Hash表就不是很适合了，因为迭代的时间复杂度比较高；而红黑树的插入很可能会涉及多个结点的旋转、变色操作，因此需要在外层加锁，这无形中降低了它可能的并发度。而SkipList底层是用链表实现的，可以实现为lock free，同时它还有着不错的性能（单线程下只比红黑树略慢），非常适合用来实现我们需求的那种key-value结构。<br>LevelDB、Reddis的底层存储结构就是用的SkipList。</p>
<h2 id="基于锁的并发"><a href="#基于锁的并发" class="headerlink" title="基于锁的并发"></a>基于锁的并发</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>编程模型简单，如果小心控制上锁顺序，一般来说不会有死锁的问题；</li>
<li>可以通过调节锁的粒度来调节性能。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>所有基于锁的算法都有死锁的可能；</li>
<li>上锁和解锁时进程要从用户态切换到内核态，并可能伴随有线程的调度、上下文切换等，开销比较重；</li>
<li>对共享数据的读与写之间会有互斥。</li>
</ol>
<h2 id="无锁编程（lock-free）"><a href="#无锁编程（lock-free）" class="headerlink" title="无锁编程（lock free）"></a>无锁编程（lock free）</h2><p>常见的lock free编程一般是基于CAS(Compare And Swap)操作：<code>CAS(void *ptr, Any oldValue, Any newValue);</code><br>即查看内存地址ptr处的值，如果为oldValue则将其改为newValue，并返回true，否则返回false。X86平台上的CAS操作一般是通过CPU的CMPXCHG指令来完成的。CPU在执行此指令时会首先锁住CPU总线，禁止其它核心对内存的访问，然后再查看或修改*ptr的值。简单的说CAS利用了CPU的硬件锁来实现对共享资源的串行使用。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>开销较小：不需要进入内核，不需要切换线程；</li>
<li>没有死锁：总线锁最长持续为一次read+write的时间；</li>
<li>只有写操作需要使用CAS，读操作与串行代码完全相同，可实现读写不互斥。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>编程非常复杂，两行代码之间可能发生任何事，很多常识性的假设都不成立。</li>
<li>CAS模型覆盖的情况非常少，无法用CAS实现原子的复数操作。</li>
</ol>
<p>而在性能层面上，CAS与mutex&#x2F;readwrite lock各有千秋，简述如下：</p>
<ol>
<li>单线程下CAS的开销大约为10次加法操作，mutex的上锁+解锁大约为20次加法操作，而readwrite lock的开销则更大一些。</li>
<li>CAS的性能为固定值，而mutex则可以通过改变临界区的大小来调节性能；</li>
<li>如果临界区中真正的修改操作只占一小部分，那么用CAS可以获得更大的并发度。</li>
<li>多核CPU中线程调度成本较高，此时更适合用CAS。<br>跳表和红黑树的性能相当，最主要的优势就是当调整(插入或删除)时，红黑树需要使用旋转来维护平衡性，这个操作需要动多个节点，在并发时候很难控制。而跳表插入或删除时只需定位后插入，插入时只需添加插入的那个节点及其多个层的复制，以及定位和插入的原子性维护。所以它更加可以利用CAS操作来进行无锁编程。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>markdown 公式编辑</title>
    <url>/posts/57926.html</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>文本中加入公式  <code>$ 数学公式 $</code></p>
<p>单独加入公式 <code>$$ 数学公式 $$</code></p>
<pre><code>\begin&#123;equation&#125;
数学公式
\label&#123;eq:当前公式名&#125;
\end&#123;equation&#125;
自动编号后的公式可在全文任意处使用 \eqref&#123;eq:公式名&#125; 语句引用。
</code></pre>
<p><code>$ J_\alpha(x) = \sum_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha + 1)&#125; &#123;\left(&#123; \frac&#123;x&#125;&#123;2&#125; &#125;\right)&#125;^&#123;2m + \alpha&#125; \text &#123;，行内公式示例&#125;</code></p>
<p>示例： $ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p>
<p><code>$$ J_\alpha(x) = \sum_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha + 1)&#125; &#123;\left(&#123; \frac&#123;x&#125;&#123;2&#125; &#125;\right)&#125;^&#123;2m + \alpha&#125; \text &#123;，独立公式示例&#125; $$</code></p>
<p>示例：$$ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$ </p>
<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><code>^</code>表示上标, <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>&#123;&#125;</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用</p>
<p><code>$$ x^&#123;y^z&#125;=(1+&#123;\rm e&#125;^x)^&#123;-2xy^w&#125; $$</code></p>
<p>$$ x^{y^z}&#x3D;(1+{\rm e}^x)^{-2xy^w} $$</p>
<p>左右两边都有上下标，可以用<code>\sideset</code> 命令</p>
<p><code>$$ \sideset&#123;^1_2&#125;&#123;^3_4&#125;\bigotimes $$</code></p>
<p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p>
<h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\&#123;\&#125;</code> 来表示 <code>&#123;&#125;</code>。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令</p>
<p><code>$$\langle表达式\rangle$$</code></p>
<p>$$\langle表达式\rangle$$</p>
<p><code>$$\lceil表达式\rceil$$</code></p>
<p>$$\lceil表达式\rceil$$</p>
<p><code>$$\lfloor表达式\rfloor$$</code></p>
<p>$$\lfloor表达式\rfloor$$</p>
<p><code>$$\lbrace表达式\rbrace$$</code></p>
<p>$$\lbrace表达式\rbrace$$</p>
<p><code>$$ f(x,y,z) = 3y^2z \left( 3+\frac&#123;7x+5&#125;&#123;1+y^2&#125; \right) $$</code></p>
<p>$$ f(x,y,z) &#x3D; 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p>
<h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 命令产生一个分数\frac {分子} {分母}，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层</p>
<p><code>$$\frac&#123;a-1&#125;&#123;b-1&#125; \quad and \quad &#123;a+1\over b+1&#125;$$</code></p>
<p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p>
<h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] &#123;被开方数&#125;</code>命令输入开方。</p>
<p><code>$$\sqrt&#123;2&#125; \quad and \quad \sqrt[n]&#123;3&#125;$$</code></p>
<p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号</p>
<p><code>$$f(x_1,x_2,\underbrace&#123;\ldots&#125;_&#123;\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \underbrace&#123;\cdots&#125;_&#123;\rm cdots&#125; + x_n^2$$</code></p>
<p>$$f(x_1,x_2,\underbrace{\ldots}<em>{\rm ldots} ,x_n) &#x3D; x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2$$</p>
<h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec&#123;矢量&#125;</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号</p>
<p><code>$$\vec&#123;a&#125; \cdot \vec&#123;b&#125;=0$$</code></p>
<p>$$\vec{a} \cdot \vec{b}&#x3D;0$$</p>
<p><code>$$\overleftarrow&#123;xy&#125; \quad and \quad \overleftrightarrow&#123;xy&#125; \quad and \quad \overrightarrow&#123;xy&#125;$$</code></p>
<p>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_</code>积分下限^积分上限  <code>&#123;被积表达式&#125;</code> 来输入一个积分</p>
<p><code>$$\int_0^1 &#123;x^2&#125; \,&#123;\rm d&#125;x$$</code></p>
<p>$$\int_0^1 {x^2} ,{\rm d}x$$</p>
<h2 id="极限运算"><a href="#极限运算" class="headerlink" title="极限运算"></a>极限运算</h2><p>使用<code>\lim_&#123;变量 \to 表达式&#125;</code> 表达式 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号</p>
<p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p>
<p><code>$$ \lim_&#123;n \to +\infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125; \quad and \quad \lim_&#123;x\leftarrow&#123;示例&#125;&#125; \frac&#123;1&#125;&#123;n(n+1)&#125; $$</code></p>
<h2 id="累加、累乘运算"><a href="#累加、累乘运算" class="headerlink" title="累加、累乘运算"></a>累加、累乘运算</h2><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code>来输入一个累加。<br>与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>此类符号在行内显示时上下标表达式将会移至右上角和右下角</p>
<p><code>$$\sum_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \prod_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \bigcup_&#123;i=1&#125;^&#123;2&#125; R$$</code></p>
<p>$$\sum_{i&#x3D;1}^n \frac{1}{i^2} \quad and \quad \prod_{i&#x3D;1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i&#x3D;1}^{2} R$$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code>和<code>\首字母大写希腊字母英文全称</code>来分别输入小写和大写希腊字母。</p>
<table>
<thead>
<tr>
<th align="right">输入</th>
<th align="right">显示</th>
<th align="right">输入</th>
<th align="right">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\alpha</td>
<td align="right">α</td>
<td align="right">A</td>
<td align="right">A</td>
</tr>
<tr>
<td align="right">\beta</td>
<td align="right">β</td>
<td align="right">B</td>
<td align="right">B</td>
</tr>
<tr>
<td align="right">\gamma</td>
<td align="right">γ</td>
<td align="right">\Gamma</td>
<td align="right">Γ</td>
</tr>
<tr>
<td align="right">\delta</td>
<td align="right">δ</td>
<td align="right">\Delta</td>
<td align="right">Δ</td>
</tr>
<tr>
<td align="right">\epsilon</td>
<td align="right">ϵ</td>
<td align="right">E</td>
<td align="right">E</td>
</tr>
<tr>
<td align="right">\zeta</td>
<td align="right">ζ</td>
<td align="right">Z</td>
<td align="right">Z</td>
</tr>
<tr>
<td align="right">\eta</td>
<td align="right">η</td>
<td align="right">H</td>
<td align="right">H</td>
</tr>
<tr>
<td align="right">\theta</td>
<td align="right">θ</td>
<td align="right">\Theta</td>
<td align="right">Θ</td>
</tr>
<tr>
<td align="right">\iota</td>
<td align="right">ι</td>
<td align="right">I</td>
<td align="right">I</td>
</tr>
<tr>
<td align="right">\kappa</td>
<td align="right">κ</td>
<td align="right">K</td>
<td align="right">K</td>
</tr>
<tr>
<td align="right">\lambda</td>
<td align="right">λ</td>
<td align="right">\Lambda</td>
<td align="right">Λ</td>
</tr>
<tr>
<td align="right">\nu</td>
<td align="right">ν</td>
<td align="right">N</td>
<td align="right">N</td>
</tr>
<tr>
<td align="right">\mu</td>
<td align="right">μ</td>
<td align="right">M</td>
<td align="right">M</td>
</tr>
<tr>
<td align="right">\xi</td>
<td align="right">ξ</td>
<td align="right">\Xi</td>
<td align="right">Ξ</td>
</tr>
<tr>
<td align="right">o</td>
<td align="right">o</td>
<td align="right">O</td>
<td align="right">O</td>
</tr>
<tr>
<td align="right">\pi</td>
<td align="right">π</td>
<td align="right">\Pi</td>
<td align="right">Π</td>
</tr>
<tr>
<td align="right">\rho</td>
<td align="right">ρ</td>
<td align="right">P</td>
<td align="right">P</td>
</tr>
<tr>
<td align="right">\sigma</td>
<td align="right">σ</td>
<td align="right">\Sigma</td>
<td align="right">Σ</td>
</tr>
<tr>
<td align="right">\tau</td>
<td align="right">τ</td>
<td align="right">T</td>
<td align="right">T</td>
</tr>
<tr>
<td align="right">\upsilon</td>
<td align="right">υ</td>
<td align="right">\Upsilon</td>
<td align="right">Υ</td>
</tr>
<tr>
<td align="right">\phi</td>
<td align="right">ϕ</td>
<td align="right">\Phi</td>
<td align="right">Φ</td>
</tr>
<tr>
<td align="right">\chi</td>
<td align="right">χ</td>
<td align="right">X</td>
<td align="right">X</td>
</tr>
<tr>
<td align="right">\psi</td>
<td align="right">ψ</td>
<td align="right">\Psi</td>
<td align="right">Ψ</td>
</tr>
<tr>
<td align="right">\omega</td>
<td align="right">ω</td>
<td align="right">\Omega</td>
<td align="right">Ω</td>
</tr>
</tbody></table>
<h2 id="大括号和行标的使用"><a href="#大括号和行标的使用" class="headerlink" title="大括号和行标的使用"></a>大括号和行标的使用</h2><p>使用 <code>\left</code>和 <code>\right</code>来创建自动匹配高度的 <code>(圆括号)，[方括号] 和 &#123;花括号&#125; </code>。<br>在每个公式末尾前使用<code>\tag&#123;行标&#125;</code>来实现行标。</p>
<pre><code>$$
f\left(
   \left[ 
     \frac&#123;
       1+\left\&#123;x,y\right\&#125;
     &#125;&#123;
       \left(
          \frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;
       \right)
       \left(u+1\right)
     &#125;+a
   \right]^&#123;3/2&#125;
\right)
\tag&#123;行标&#125;
$$
</code></pre>
<p>$$<br>f\left(<br>   \left[<br>     \frac{<br>       1+\left{x,y\right}<br>     }{<br>       \left(<br>          \frac{x}{y}+\frac{y}{x}<br>       \right)<br>       \left(u+1\right)<br>     }+a<br>   \right]^{3&#x2F;2}<br>\right)<br>\tag{行标}<br>$$</p>
<p><code>$\smash&#123;\displaystyle\max_&#123;0 \leq q \leq n-1&#125;&#125; f(q) \le n$</code></p>
<p>$\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$</p>
<p><code>$f(x + \epsilon) \approx f(x) + f&#39;(x) \epsilon + \mathcal&#123;O&#125;(\epsilon^2).$</code></p>
<p>$f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$</p>
<p><code>$\text&#123;d&#125;x$</code></p>
<p>$\text{d}x$</p>
<p>链接：<a href="https://www.cnblogs.com/q735613050/p/7253073.html">Markdown公式编辑学习笔记</a><br>链接：<a href="https://www.arxiv-vanity.com/papers/1712.01208/">The Case for Learned Index Structures</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title>markdown常用语法</title>
    <url>/posts/43275.html</url>
    <content><![CDATA[<p>markdown优点是<em>易读易写</em>。格式化编辑，纯文本发布，无标签，但支持html标签。</p>
<h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><p>   段落前后需要空行，若使用换行符<code>&lt;br/&gt;</code>，前面至少两个以上空格才会生效</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote>
<p>Setext 底线形式</p>
</blockquote>
<p>高阶标题\次阶标题,大于等于2个&#x3D;-</p>
<pre><code>This is Setext H1
=================
This is Setext H2
-----------------
</code></pre>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>[TOC] 目录 Markdown语法书写的话，可以自动生成层级目录
</code></pre>
<p>六级标题</p>
<blockquote>
<p>atx 井号 1-6个</p>
</blockquote>
<pre><code># This is H1
## This is H2
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>可以加在每一行，也可以加在段落第一行，可以嵌套使用</p>
<p><code>&gt; 引用文本-一级引用</code>  <br><br><code>&gt;&gt; 引用文本-二级引用</code> <br><br><code>&gt;&gt;&gt; 引用文本-三级引用</code> <br></p>
<blockquote>
<p>引用文本-一级引用</p>
<blockquote>
<p>引用文本-二级引用</p>
<blockquote>
<p>引用文本-三级引用</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>引用文本-一级引用</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序、有序  <code>&lt;br/&gt;</code><br>无序列表 使用 <code>*、+、-  &lt;br/&gt;</code><br>有序列表 使用 数字+英文句点</p>
<h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>缩进4个空格或1个制表符 或<code>&lt;pre&gt;、&lt;code&gt;</code>标签</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上*、-、_</p>
<h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><p>语法：行内式、参考式语法：行内式、参考式 [方括号]标记</p>
<p>This is <a href="https://www.baidu.com/" title="title">百度</a>  <br><br>    <code>This is [百度](https://www.baidu.com/ &quot;title&quot;)</code> </p>
<p>This is <a href="/about" title="about">关于</a>  <br><br>    <code>This is [关于](/about &quot;about&quot;)</code></p>
<p>This is <a href="https://www.baidu.com/" title="title">百度</a>  <br></p>
<pre><code>This is [百度][1]  &lt;br&gt;
[1]:https://www.baidu.com/ &quot;title&quot;
OR: [1]:&lt;https://www.baidu.com/&gt; &quot;title&quot;
</code></pre>
<h2 id="隐式链接标记"><a href="#隐式链接标记" class="headerlink" title="隐式链接标记"></a>隐式链接标记</h2><p><a href="https://www.google.com/">Google</a></p>
<pre><code>[Google][]
[Google]:https://www.google.com/
</code></pre>
<p><em>参考式：更易读</em></p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>使用 * 或者底线 _  <code>&lt;strong&gt;</code></p>
<p><em>this is strong</em> &#x2F;&#x2F;*两侧不能有空白</p>
<pre><code>*this is strong* //*两侧不能有空白
</code></pre>
<h2 id="行内代码标记"><a href="#行内代码标记" class="headerlink" title="行内代码标记"></a>行内代码标记</h2><p>反引号&#96;&#96;&#96;&#96;&#96;</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>行内式 参考式    <code>&lt;img&gt;</code></p>
<pre><code>![alt text](/img/img1.jpg &quot;title&quot;)
</code></pre>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th align="right">状态集</th>
<th align="right">A</th>
<th align="right">B</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="right">43</td>
<td align="right">33</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">33</td>
</tr>
<tr>
<td align="right">3</td>
<td align="right">130</td>
<td align="right">118</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">5</td>
<td align="right">17</td>
<td align="right">6</td>
</tr>
<tr>
<td align="right">6</td>
<td align="right">180</td>
<td align="right">111</td>
</tr>
<tr>
<td align="right">总数</td>
<td align="right">370</td>
<td align="right">225</td>
</tr>
</tbody></table>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签: MARKDOWN</p>
<p>Tags: MARKDOWN</p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除线</del></p>
<h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>这是一个注脚<a href="%E6%8F%8F%E8%BF%B0">^1</a></p>
<h2 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h2><p><span id="jump">跳转</span></p>
<p><a href="#jump">你好</a></p>
<h2 id="github文件"><a href="#github文件" class="headerlink" title="github文件"></a>github文件</h2><p>github文件地址格式</p>
<p><a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/repository%E4%BB%93%E5%BA%93%E5%90%8D/raw/%E5%88%86%E6%94%AF%E5%90%8Dmaster/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0/%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0">https://github.com/用户名/repository仓库名/raw/分支名master/图片文件夹名称/图片名称</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow安装</title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>你可以使用我们提供的 Pip, Docker, Virtualenv, Anaconda 或 源码编译的方法安装 TensorFlow.<br>Pip 安装<br>Pip 是一个 Python 的软件包安装与管理工具.<br>在安装 TensorFlow 过程中要涉及安装或升级的包详见 列表<br>首先安装 pip (或 Python3 的 pip3 ):</p>
<h1 id="Ubuntu-x2F-Linux-64-bit"><a href="#Ubuntu-x2F-Linux-64-bit" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit"></a>Ubuntu&#x2F;Linux 64-bit</h1><p>$ sudo apt-get install python-pip python-dev</p>
<h1 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><p>$ sudo easy_install pip<br>安装 TensorFlow :</p>
<h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:</h1><p>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl</a></p>
<h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below"><a href="#For-other-versions-see-“Install-from-sources”-below" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl</a></p>
<h1 id="Mac-OS-X-CPU-only"><a href="#Mac-OS-X-CPU-only" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>$ sudo easy_install –upgrade six<br>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py2-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py2-none-any.whl</a><br>如果是 Python3 :</p>
<h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:</h1><p>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl</a></p>
<h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-1"><a href="#For-other-versions-see-“Install-from-sources”-below-1" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl</a></p>
<h1 id="Mac-OS-X-CPU-only-1"><a href="#Mac-OS-X-CPU-only-1" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>$ sudo easy_install –upgrade six<br>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py3-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py3-none-any.whl</a><br>备注：如果之前安装过 TensorFlow &lt; 0.7.1 的版本,应该先使用 pip uninstall 卸载 TensorFlow 和 protobuf ,保证获取的是一个最新 protobuf 依赖下的安装包.<br>之后可以测试一下.<br>基于 Docker 的安装<br>我们也支持通过 Docker 运行 TensorFlow. 该方式的优点是不用操心软件依赖问题.<br>首先, 安装 Docker. 一旦 Docker 已经启动运行, 可以通过命令启动一个容器:<br>$ docker run -it b.gcr.io&#x2F;tensorflow&#x2F;tensorflow<br>该命令将启动一个已经安装好 TensorFlow 及相关依赖的容器.<br>其它镜像<br>默认的 Docker 镜像只包含启动和运行 TensorFlow 所需依赖库的一个最小集. 我们额外提供了 下面的容器, 该容器同样可以通过上述 docker run 命令安装:<br>b.gcr.io&#x2F;tensorflow&#x2F;tensorflow-full: 镜像中的 TensorFlow 是从源代码完整安装的, 包含了编译和运行 TensorFlow 所需的全部工具. 在该镜像上, 可以直接使用源代码进行实验, 而不需要再安装上述的任何依赖.<br>基于 VirtualEnv 的安装<br>我们推荐使用 virtualenv 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.<br>首先, 安装所有必备工具:</p>
<h1 id="在-Linux-上"><a href="#在-Linux-上" class="headerlink" title="在 Linux 上:"></a>在 Linux 上:</h1><p>$ sudo apt-get install python-pip python-dev python-virtualenv</p>
<h1 id="在-Mac-上"><a href="#在-Mac-上" class="headerlink" title="在 Mac 上:"></a>在 Mac 上:</h1><p>$ sudo easy_install pip  # 如果还没有安装 pip<br>$ sudo pip install –upgrade virtualenv<br>接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~&#x2F;tensorflow 目录下, 执行:<br>$ virtualenv –system-site-packages ~&#x2F;tensorflow<br>$ cd ~&#x2F;tensorflow<br>然后, 激活 virtualenv:<br>$ source bin&#x2F;activate  # 如果使用 bash<br>$ source bin&#x2F;activate.csh  # 如果使用 csh<br>(tensorflow)$  # 终端提示符应该发生变化<br>在 virtualenv 内, 安装 TensorFlow:<br>(tensorflow)$ pip install –upgrade &lt;$url_to_binary.whl&gt;<br>接下来, 使用类似命令运行 TensorFlow 程序:<br>(tensorflow)$ cd tensorflow&#x2F;models&#x2F;image&#x2F;mnist<br>(tensorflow)$ python convolutional.py</p>
<h1 id="当使用完-TensorFlow"><a href="#当使用完-TensorFlow" class="headerlink" title="当使用完 TensorFlow"></a>当使用完 TensorFlow</h1><p>(tensorflow)$ deactivate  # 停用 virtualenv</p>
<p>$  # 你的命令提示符会恢复原样<br>基于 Anaconda 的安装<br>Anaconda 是一个集成许多第三方科学计算库的 Python 科学计算环境,Anaconda 使用 conda 作为自己的包管理工具,同时具有自己的计算环境,类似 Virtualenv.<br>和 Virtualenv 一样,不同 Python 工程需要的依赖包,conda 将他们存储在不同的地方。 TensorFlow 上安装的 Anaconda 不会对之前安装的 Python 包进行覆盖.<br>安装 Anaconda<br>建立一个 conda 计算环境<br>激活环境,使用 conda 安装 TensorFlow<br>安装成功后,每次使用 TensorFlow 的时候需要激活 conda 环境<br>安装 Anaconda :<br>参考 Anaconda 的下载页面的指导<br>建立一个 conda 计算环境名字叫tensorflow:</p>
<h1 id="Python-2-7"><a href="#Python-2-7" class="headerlink" title="Python 2.7"></a>Python 2.7</h1><p>$ conda create -n tensorflow python&#x3D;2.7</p>
<h1 id="Python-3-4"><a href="#Python-3-4" class="headerlink" title="Python 3.4"></a>Python 3.4</h1><p>$ conda create -n tensorflow python&#x3D;3.4<br>激活tensorflow环境,然后使用其中的 pip 安装 TensorFlow. 当使用easy_install使用–ignore-installed标记防止错误的产生。<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change</p>
<h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7-1"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</a></p>
<h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-2"><a href="#For-other-versions-see-“Install-from-sources”-below-2" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</a></p>
<h1 id="Mac-OS-X-CPU-only-2"><a href="#Mac-OS-X-CPU-only-2" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py2-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py2-none-any.whl</a><br>对于 Python 3.x :<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change</p>
<h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4-1"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</a></p>
<h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-3"><a href="#For-other-versions-see-“Install-from-sources”-below-3" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</a></p>
<h1 id="Mac-OS-X-CPU-only-3"><a href="#Mac-OS-X-CPU-only-3" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl</a><br>conda 环境激活后,你可以测试<br>当你不用 TensorFlow 的时候,关闭环境:<br>(tensorflow)$ source deactivate</p>
<p>$  # Your prompt should change back<br>再次使用的时候再激活 :-)<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change.</p>
<h1 id="Run-Python-programs-that-use-TensorFlow"><a href="#Run-Python-programs-that-use-TensorFlow" class="headerlink" title="Run Python programs that use TensorFlow."></a>Run Python programs that use TensorFlow.</h1><p>…</p>
<h1 id="When-you-are-done-using-TensorFlow-deactivate-the-environment"><a href="#When-you-are-done-using-TensorFlow-deactivate-the-environment" class="headerlink" title="When you are done using TensorFlow, deactivate the environment."></a>When you are done using TensorFlow, deactivate the environment.</h1><p>(tensorflow)$ source deactivate</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<hr>
<h2 id="title-主成分分析"><a href="#title-主成分分析" class="headerlink" title="title:主成分分析"></a>title:主成分分析</h2><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>主成分分析能降低所研究的数据空间的维数。即用研究m维的Y空间代替p维的X空间(m&lt;p)，而低维的Y空间代替高维的x空间所损失的信息很少。即：使只有一个主成分Yl(即 m&#x3D;1)时，这个Yl仍是使用全部X变量(p个)得到的。例如要计算Yl的均值也得使用全部x的均值。在所选的前m个主成分中，如果某个Xi的系数全部近似于零的话，就可以把这个Xi删除，这也是一种删除多余变量的方法。</p>
<h2 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h2><p>有时可通过因子负荷aij的结论，弄清X变量间的某些关系。</p>
<h2 id="图形分析"><a href="#图形分析" class="headerlink" title="图形分析"></a>图形分析</h2><p>多维数据的一种图形表示方法。我们知道当维数大于3时便不能画出几何图形，多元统计研究的问题大都多于3个变量。要把研究的问题用图形表示出来是不可能的。然而，经过主成分分析后，我们可以选取前两个主成分或其中某两个主成分，根据主成分的得分，画出n个样品在二维平面上的分布况，由图形可直观地看出各样品在主分量中的地位，进而还可以对样本进行分类处理，可以由图形发现远离大多数样本点的离群点。</p>
<h2 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h2><p>由主成分分析法构造回归模型。即把各主成分作为新自变量代替原来自变量x做回归分析。</p>
<h2 id="降低计算量"><a href="#降低计算量" class="headerlink" title="降低计算量"></a>降低计算量</h2><p>用主成分分析筛选回归变量。回归变量的选择有着重的实际意义，为了使模型本身易于做结构分析、控制和预报，好从原始变量所构成的子集合中选择最佳变量，构成最佳变量集合。用主成分分析筛选变量，可以用较少的计算量来选择量，获得选择最佳变量子集合的效果。</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/2.html</url>
    <content><![CDATA[<hr>
<h2 id="title-机器学习-GAN"><a href="#title-机器学习-GAN" class="headerlink" title="title:机器学习-GAN"></a>title:机器学习-GAN</h2><p>Generative Adversarial Network，就是大家耳熟能详的 GAN，由 Ian Goodfellow 首先提出，在这两年更是深度学习中最热门的东西，仿佛什么东西都能由 GAN 做出来。我最近刚入门 GAN，看了些资料，做一些笔记。</p>
<p>1.Generation<br>什么是生成（generation）？就是模型通过学习一些数据，然后生成类似的数据。让机器看一些动物图片，然后自己来产生动物的图片，这就是生成。</p>
<p>以前就有很多可以用来生成的技术了，比如 auto-encoder（自编码器）</p>
<p>你训练一个 encoder，把 input 转换成 code，然后训练一个 decoder，把 code 转换成一个 image，然后计算得到的 image 和 input 之间的 MSE（mean square error），训练完这个 model 之后，取出后半部分 NN Decoder，输入一个随机的 code，就能 generate 一个 image。</p>
<p>但是 auto-encoder 生成 image 的效果，当然看着很别扭啦，一眼就能看出真假。所以后来还提出了比如VAE这样的生成模型，我对此也不是很了解，在这就不细说。</p>
<p>上述的这些生成模型，其实有一个非常严重的弊端。比如 VAE，它生成的 image 是希望和 input 越相似越好，但是 model 是如何来衡量这个相似呢？model 会计算一个 loss，采用的大多是 MSE，即每一个像素上的均方差。loss 小真的表示相似嘛？</p>
<p><a href="https://www.cnblogs.com/bonelee/p/9166084.html" title="gan">gan</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>GBDT原理</title>
    <url>/posts/134.html</url>
    <content><![CDATA[<p>Gradient Boosting Decision Tree 迭代决策树，泛化能力较强</p>
<p>几乎可用于所有回归问题（线性&#x2F;非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）。<br>可用于<a href="http://research.microsoft.com/pubs/132652/MSR-TR-2010-82.pdf" title="搜索排序">搜索排序</a></p>
<h2 id="Regression-Decistion-Tree"><a href="#Regression-Decistion-Tree" class="headerlink" title="Regression Decistion Tree"></a>Regression Decistion Tree</h2><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>C4.5分类树:在每次分枝时，是穷举每一个feature的每一个阈值，找到使得按照feature&lt;&#x3D;阈值，和feature&gt;阈值分成的两个分枝的熵最大的feature和阈值（熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1），按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。</p>
<h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差–即（每个人的年龄-预测年龄）^2 的总和 &#x2F; N，或者说是每个人的预测误差平方和 除以 N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。</p>
<p>参考：<a href="http://www.schonlau.net/publication/05stata_boosting.pdf">http://www.schonlau.net/publication/05stata_boosting.pdf</a></p>
<h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>多棵树来共同决策。GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义，简单吧。</p>
<p>残差： A的预测值 + A的残差 &#x3D; A的实际值 ，残差为0，极为真实值，（过拟合问题）</p>
<p>优点：Boosting的最大好处在于，每一步的残差计算其实变相地增大了分错instance的权重，而已经分对的instance则都趋向于0。这样后面的树就能越来越专注那些前面被分错的instance。</p>
<p>Adaboost是另一种boost方法，它按分类对错，分配不同的weight，计算cost function时使用这些weight，从而让“错分的样本权重越来越大，使它们更被重视”。Bootstrap也有类似思想，它在每一步迭代时不改变模型本身，也不计算残差，而是从N个instance训练集中按一定概率重新抽取N个instance出来（单个instance可以被重复sample），对着这N个新的instance再训练一轮。由于数据集变了迭代模型训练结果也不一样，而一个instance被前面分错的越厉害，它的概率就被设的越高，这样就能同样达到逐步关注被分错的instance，逐步完善的效果。Adaboost的方法被实践证明是一种很好的防止过拟合的方法，但至于为什么则至今没从理论上被证明。GBDT也可以在使用残差的同时引入Bootstrap re-sampling，GBDT多数实现版本中也增加的这个选项，但是否一定使用则有不同看法。re-sampling一个缺点是它的随机性，即同样的数据集合训练两遍结果是不一样的，也就是模型不可稳定复现，这对评估是很大挑战，比如很难说一个模型变好是因为你选用了更好的feature，还是由于这次sample的随机因素。</p>
<p>参考：<a href="http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting">http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting</a></p>
<h2 id="Shrinkage"><a href="#Shrinkage" class="headerlink" title="Shrinkage"></a>Shrinkage</h2><p>每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。</p>
<p>没用Shrinkage时：（yi表示第i棵树上y的预测值， y(1~i)表示前i棵树y的综合预测值）</p>
<p>y(i+1) &#x3D; 残差(y1<del>yi)， 其中： 残差(y1</del>yi) &#x3D;  y真实值 - y(1 ~ i)</p>
<p>y(1 ~ i) &#x3D; SUM(y1, …, yi)</p>
<p>Shrinkage不改变第一个方程，只把第二个方程改为： </p>
<p>y(1 ~ i) &#x3D; y(1 ~ i-1) + step * yi</p>
<p>即Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分（step*残差）逐步逼近目标，step一般都比较小，如0.01~0.001（注意该step非gradient的step），导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。</p>
<h2 id="RankNet"><a href="#RankNet" class="headerlink" title="RankNet"></a>RankNet</h2><p>实际的搜索排序使用的是LambdaMART算法，必须指出的是由于这里要使用排序需要的cost function，LambdaMART迭代用的并不是残差。Lambda在这里充当替代残差的计算方法，它使用了一种类似Gradient*步长模拟残差的方法。这里的MART在求解方法上和之前说的残差略有不同，其区别描述见这里。</p>
<p>就像所有的机器学习一样，搜索排序的学习也需要训练集，这里一般是用人工标注实现，即对每一个(query,doc) pair给定一个分值（如1,2,3,4）,分值越高表示越相关，越应该排到前面。然而这些绝对的分值本身意义不大，例如你很难说1分和2分文档的相关程度差异是1分和3分文档差距的一半。相关度本身就是一个很主观的评判，标注人员无法做到这种定量标注，这种标准也无法制定。但标注人员很容易做到的是”AB都不错，但文档A比文档B更相关，所以A是4分，B是3分“。RankNet就是基于此制定了一个学习误差衡量方法，即cost function。具体而言，RankNet对任意两个文档A,B，通过它们的人工标注分差，用sigmoid函数估计两者顺序和逆序的概率P1。然后同理用机器学习到的分差计算概率P2（sigmoid的好处在于它允许机器学习得到的分值是任意实数值，只要它们的分差和标准分的分差一致，P2就趋近于P1）。这时利用P1和P2求的两者的交叉熵，该交叉熵就是cost function。它越低说明机器学得的当前排序越趋近于标注排序。为了体现NDCG的作用（NDCG是搜索排序业界最常用的评判标准），RankNet还在cost function中乘以了NDCG。</p>
<p>好，现在我们有了cost function，而且它是和各个文档的当前分值yi相关的，那么虽然我们不知道它的全局最优方向，但可以求导求Gradient，Gradient即每个文档得分的一个下降方向组成的N维向量，N为文档个数（应该说是query-doc pair个数）。这里仅仅是把”求残差“的逻辑替换为”求梯度“，可以这样想：梯度方向为每一步最优方向，累加的步数多了，总能走到局部最优点，若该点恰好为全局最优点，那和用残差的效果是一样的。这时套到之前讲的逻辑，GDBT就已经可以上了。那么最终排序怎么产生呢？很简单，每个样本通过Shrinkage累加都会得到一个最终得分，直接按分数从大到小排序就可以了（因为机器学习产生的是实数域的预测分，极少会出现在人工标注中常见的两文档分数相等的情况，几乎不同考虑同分文档的排序方式）</p>
<p>另外，如果feature个数太多，每一棵回归树都要耗费大量时间，这时每个分支时可以随机抽一部分feature来遍历求最优（ELF源码实现方式）。</p>
<p>参考：<a href="https://www.cnblogs.com/pinard/p/6140514.html">https://www.cnblogs.com/pinard/p/6140514.html</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>GMM模型</title>
    <url>/posts/35874.html</url>
    <content><![CDATA[<p>高斯混合模型是一种混合模型，混合的基本分布是高斯分布</p>
<p>参考《统计学习方法》</p>
<p>链接：<a href="https://www.cnblogs.com/mmziscoming/p/5750849.html">浅显易懂的GMM模型及其训练过程</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习-ResNet</title>
    <url>/posts/28677.html</url>
    <content><![CDATA[<p>深度残差网络（Deep residual network, ResNet）的提出是CNN图像史上的一件里程碑事件</p>
<p>从经验来看，网络的深度对模型的性能至关重要，当增加网络层数后，网络可以进行更加复杂的特征模式的提取，所以当模型更深时理论上可以取得更好的结果，从图2中也可以看出网络越深而效果越好的一个实践证据。但是更深的网络其性能一定会更好吗？实验发现深度网络出现了退化问题（Degradation problem）：网络深度增加时，网络准确度出现饱和，甚至出现下降。这个现象可以在图3中直观看出来：56层的网络比20层网络效果还要差。这不会是过拟合问题，因为56层网络的训练误差同样高。我们知道深层网络存在着梯度消失或者爆炸的问题，这使得深度学习模型很难训练。但是现在已经存在一些技术手段如BatchNorm来缓解这个问题。因此，出现深度网络的退化问题是非常令人诧异的。</p>
<p>深度网络的退化问题至少说明深度网络不容易训练。但是我们考虑这样一个事实：现在你有一个浅层网络，你想通过向上堆积新层来建立深层网络，一个极端情况是这些增加的层什么也不学习，仅仅复制浅层网络的特征，即这样新层是恒等映射（Identity mapping）。在这种情况下，深层网络应该至少和浅层网络性能一样，也不应该出现退化现象。好吧，你不得不承认肯定是目前的训练方法有问题，才使得深层网络很难去找到一个好的参数。</p>
<p>这个有趣的假设让何博士灵感爆发，他提出了残差学习来解决退化问题。对于一个堆积层结构（几层堆积而成）当输入为时其学习到的特征记为，现在我们希望其可以学习到残差，这样其实原始的学习特征是。之所以这样是因为残差学习相比原始特征直接学习更容易。当残差为0时，此时堆积层仅仅做了恒等映射，至少网络性能不会下降，实际上残差不会为0，这也会使得堆积层在输入特征基础上学习到新的特征，从而拥有更好的性能。残差学习的结构如图4所示。这有点类似与电路中的“短路”，所以是一种短路连接（shortcutconnection）。</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>softmax回归</title>
    <url>/posts/27391.html</url>
    <content><![CDATA[<p>可以看作是逻辑回归的推广</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>baggging</title>
    <url>/posts/2664.html</url>
    <content><![CDATA[<p>又放回采样</p>
<p>OOB数据</p>
<p>测试误差</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>hinge损失函数</title>
    <url>/posts/6463.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>svm</title>
    <url>/posts/22038.html</url>
    <content><![CDATA[<p>在特征空间上找到最佳的分离超平面使得训练集上正负样本间隔最大</p>
<p>用来解决二分类问题的有监督学习算法</p>
<p>引入了核方法之后SVM也可以用来解决非线性问题</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。</li>
<li>软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。</li>
<li>非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。</li>
</ul>
<p>参考: <a href="https://blog.csdn.net/liugan528/article/details/79448379" title="svm">svm</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>xgboost</title>
    <url>/posts/50689.html</url>
    <content><![CDATA[<p>参考: [博客 xgboost原理]( <a href="https://www.cnblogs.com/zhouxiaohui888/p/6008368.html">https://www.cnblogs.com/zhouxiaohui888/p/6008368.html</a> “xgboost”）</p>
<p>参考: <a href="https://github.com/dmlc/xgboost" title="xgboost">github xgboost学习</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>中文分词</title>
    <url>/posts/742.html</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>基于字典、词库匹配</li>
<li>基于词频度统计</li>
<li>基于知识理解</li>
</ul>
<h2 id="字典、词库匹配"><a href="#字典、词库匹配" class="headerlink" title="字典、词库匹配"></a>字典、词库匹配</h2><p>中文复杂、丰富，词典、词库匹配无法有效处理大规模文本分词处理</p>
<ol>
<li>逐词遍历法：全字典遍历一遍，效率低，不适用于大系统</li>
<li>机械分词法</li>
</ol>
<h3 id="最大正向匹配法"><a href="#最大正向匹配法" class="headerlink" title="最大正向匹配法"></a>最大正向匹配法</h3><p>假定词典词最大长度为i,被处理文档的当前字串中的前i个字作为匹配字段，匹配成功，则切分出来，匹配失败，则i-1，继续匹配，若成功则i+1，知道文档处理完成</p>
<h3 id="逆向最大匹配法"><a href="#逆向最大匹配法" class="headerlink" title="逆向最大匹配法"></a>逆向最大匹配法</h3><p>文档逆序处理，通过逆序词典匹配，汉语中偏正结构较多，若从后向前匹配，可以适当提高精确度，逆向最大匹配法比正向最大匹配法的误差要小</p>
<h3 id="最少切分法"><a href="#最少切分法" class="headerlink" title="最少切分法"></a>最少切分法</h3><p>使每一句中切出的词数最小</p>
<h3 id="双向匹配法"><a href="#双向匹配法" class="headerlink" title="双向匹配法"></a>双向匹配法</h3><p>将正向最大匹配法与逆向最大匹配法组合，如果两种分词方法得到的匹配结果相同，则认为分词正确，否则，按最小集处理</p>
<h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>考虑到相邻字词关系、词频、共现信息，有较好的实用性</p>
<h3 id="全切分和基于词的频度统计的分词方法"><a href="#全切分和基于词的频度统计的分词方法" class="headerlink" title="全切分和基于词的频度统计的分词方法"></a>全切分和基于词的频度统计的分词方法</h3><p>基于词的频度统计的分词方法是一种全切分方法</p>
<p>全切分要求获得输入序列的所有可接受的切分形式，而部分切分只取得一种或几种可接受的切分形式，由于部分切分忽略了可能的其他切分形式，所以建立在部分切分基础上的分词方法不管采取何种歧义纠正策略，都可能会遗漏正确的切分，造成分词错误或失败。而建立在全切分基础上的分词方法，由于全切分取得了所有可能的切分形式，因而从根本上避免了可能切分形式的遗漏，克服了部分切分方法的缺陷。</p>
<p>问题：</p>
<ol>
<li><p>全切分算法只是能获得正确分词的前提，因为全切分不具有歧义检测功能，最终分词结果的正确性和完全性依赖于独立的歧义处理方法，如果评测有误，也会造成错误的结果。</p>
</li>
<li><p>全切分的切分结果个数随句子长度的增长呈指数增长，一方面将导致庞大的无用数据充斥于存储数据库；另一方面当句长达到一定长度后，由于切分形式过多,造成分词效率严重下降。</p>
</li>
</ol>
<p>解决方案：</p>
<p>基于词的频度统计的分词方法：</p>
<p>这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。</p>
<h2 id="基于知识理解"><a href="#基于知识理解" class="headerlink" title="基于知识理解"></a>基于知识理解</h2><p>基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。</p>
<h2 id="并行分词方法"><a href="#并行分词方法" class="headerlink" title="并行分词方法"></a>并行分词方法</h2><p>并行分词方法：这种分词方法借助于一个含有分词词库的管道进行 ,比较匹配过程是分步进行的 ,每一步可以对进入管道中的词同时与词库中相应的词进行比较 ,由于同时有多个词进行比较匹配 ,因而分词速度可以大幅度提高。这种方法涉及到多级内码理论和管道的词典数据结构。（详细算法可以参考吴胜远的《并行分词方法的研究》。）</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>交叉熵</title>
    <url>/posts/37871.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>交叉验证</title>
    <url>/posts/54780.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>信息熵</title>
    <url>/posts/5656.html</url>
    <content><![CDATA[<p>不确定性程度的物理量</p>
<p>自封闭系统的运动向均匀分布—熵总是增加的</p>
<h2 id="联合熵"><a href="#联合熵" class="headerlink" title="联合熵"></a>联合熵</h2><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>ID3</p>
<h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h2><p>C4.5</p>
<h2 id="gini系数"><a href="#gini系数" class="headerlink" title="gini系数"></a>gini系数</h2><p>CART</p>
<h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2>]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/posts/51507.html</url>
    <content><![CDATA[<p>用于分类和回归的非监督学习方法，通过简单的决策规则（if-else）预测目标</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>思想简单，可视乎表达，易理解，可以处理多分类问题</li>
<li>可能会过拟合，此时需要剪枝、采用设置最小样本数目或树的深度</li>
<li>基于启发式算法，节点采用贪婪算法（局部最优），不能保证全局最优，可以随机抽取样本，训练多个树</li>
<li>过于复杂的概念，无法表达</li>
</ul>
<h2 id="决策树-CART"><a href="#决策树-CART" class="headerlink" title="决策树 CART"></a>决策树 CART</h2><p>CART: classifcation and regression tree</p>
<h2 id="irsi数据集构建分类决策树"><a href="#irsi数据集构建分类决策树" class="headerlink" title="irsi数据集构建分类决策树"></a>irsi数据集构建分类决策树</h2><pre><code>from sklearn.datasets import load_iris
from sklearn import tree

#加载iris数据集
iris = load_iris()

clf = tree.DecisionTreeClassifier()
clf = clf.fit(iris.data, iris.target)

import pydotplus
dot_data = tree.export_graphviz(clf, out_file=None)
#dot_data = tree.export_graphviz(clf, out_file=None, 
                              feature_names=iris.feature_names,  
                              class_names=iris.target_names,  
                              filled=True, rounded=True,  
                              special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data)
#导出决策树
graph.write_pdf(&quot;iris.pdf&quot;) 
#Image(graph.create_png())
</code></pre>
<p><img src="http://thyrsi.com/t6/625/1543991582x2890174459.jpg" alt="iris树"></p>
<h2 id="sklearn-example"><a href="#sklearn-example" class="headerlink" title="sklearn example"></a>sklearn example</h2><pre><code>import numpy as np
import matplotlib.pyplot as plt

from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier

# Parameters
n_classes = 3
plot_colors = &quot;ryb&quot;
plot_step = 0.02

# Load data
iris = load_iris()

for pairidx, pair in enumerate([[0, 1], [0, 2], [0, 3],
                                [1, 2], [1, 3], [2, 3]]):
    # We only take the two corresponding features
    X = iris.data[:, pair]
    y = iris.target

    # Train
    clf = DecisionTreeClassifier().fit(X, y)

    # Plot the decision boundary
    plt.subplot(2, 3, pairidx + 1)

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),
                         np.arange(y_min, y_max, plot_step))
    plt.tight_layout(h_pad=0.5, w_pad=0.5, pad=2.5)

    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    cs = plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu)

    plt.xlabel(iris.feature_names[pair[0]])
    plt.ylabel(iris.feature_names[pair[1]])

    # Plot the training points
    for i, color in zip(range(n_classes), plot_colors):
        idx = np.where(y == i)
        plt.scatter(X[idx, 0], X[idx, 1], c=color, label=iris.target_names[i],
                    cmap=plt.cm.RdYlBu, edgecolor=&#39;black&#39;, s=15)

plt.suptitle(&quot;Decision surface of a decision tree using paired features&quot;)
plt.legend(loc=&#39;lower right&#39;, borderpad=0, handletextpad=0)
plt.axis(&quot;tight&quot;)
plt.show()
</code></pre>
<p>   <img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_iris_0011.png" alt="iris树"></p>
<p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_iris.html#sphx-glr-auto-examples-tree-plot-iris-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_iris.html#sphx-glr-auto-examples-tree-plot-iris-py</a></p>
<h2 id="决策树回归"><a href="#决策树回归" class="headerlink" title="决策树回归"></a>决策树回归</h2><p>max_depth：图的深度，值太大会导致过拟合</p>
<pre><code># Import the necessary modules and libraries
import numpy as np
from sklearn.tree import DecisionTreeRegressor
import matplotlib.pyplot as plt

# Create a random dataset
rng = np.random.RandomState(1)
X = np.sort(5 * rng.rand(80, 1), axis=0)
y = np.sin(X).ravel() #学习sin曲线
y[::5] += 3 * (0.5 - rng.rand(16)) #干扰值

# Fit regression model
regr_1 = DecisionTreeRegressor(max_depth=2)
regr_2 = DecisionTreeRegressor(max_depth=5)
regr_1.fit(X, y)
regr_2.fit(X, y)

# Predict
X_test = np.arange(0.0, 5.0, 0.01)[:, np.newaxis]
y_1 = regr_1.predict(X_test)
y_2 = regr_2.predict(X_test)

# Plot the results
plt.figure()
plt.scatter(X, y, s=20, edgecolor=&quot;black&quot;,
            c=&quot;darkorange&quot;, label=&quot;data&quot;)
plt.plot(X_test, y_1, color=&quot;cornflowerblue&quot;,
         label=&quot;max_depth=2&quot;, linewidth=2)
plt.plot(X_test, y_2, color=&quot;yellowgreen&quot;, label=&quot;max_depth=5&quot;, linewidth=2)
plt.xlabel(&quot;data&quot;)
plt.ylabel(&quot;target&quot;)
plt.title(&quot;Decision Tree Regression&quot;)
plt.legend()
plt.show()
</code></pre>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_tree_regression_001.png" alt="iris树"></p>
<p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py</a></p>
<h2 id="多输出问题"><a href="#多输出问题" class="headerlink" title="多输出问题"></a>多输出问题</h2><pre><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeRegressor

# Create a random dataset
rng = np.random.RandomState(1)
X = np.sort(200 * rng.rand(100, 1) - 100, axis=0)
y = np.array([np.pi * np.sin(X).ravel(), np.pi * np.cos(X).ravel()]).T #输出X正弦 余弦
y[::5, :] += (0.5 - rng.rand(20, 2)) #干扰

# Fit regression model
regr_1 = DecisionTreeRegressor(max_depth=2)
regr_2 = DecisionTreeRegressor(max_depth=5)
regr_3 = DecisionTreeRegressor(max_depth=8)
regr_1.fit(X, y)
regr_2.fit(X, y)
regr_3.fit(X, y)

# Predict
X_test = np.arange(-100.0, 100.0, 0.01)[:, np.newaxis]
y_1 = regr_1.predict(X_test)
y_2 = regr_2.predict(X_test)
y_3 = regr_3.predict(X_test)

# Plot the results
plt.figure()
s = 25
plt.scatter(y[:, 0], y[:, 1], c=&quot;navy&quot;, s=s,
            edgecolor=&quot;black&quot;, label=&quot;data&quot;)
plt.scatter(y_1[:, 0], y_1[:, 1], c=&quot;cornflowerblue&quot;, s=s,
            edgecolor=&quot;black&quot;, label=&quot;max_depth=2&quot;)
plt.scatter(y_2[:, 0], y_2[:, 1], c=&quot;red&quot;, s=s,
            edgecolor=&quot;black&quot;, label=&quot;max_depth=5&quot;)
plt.scatter(y_3[:, 0], y_3[:, 1], c=&quot;orange&quot;, s=s,
            edgecolor=&quot;black&quot;, label=&quot;max_depth=8&quot;)
plt.xlim([-6, 6])
plt.ylim([-6, 6])
plt.xlabel(&quot;target 1&quot;)
plt.ylabel(&quot;target 2&quot;)
plt.title(&quot;Multi-output Decision Tree Regression&quot;)
plt.legend(loc=&quot;best&quot;)
plt.show()
</code></pre>
<p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_tree_regression_multioutput_001.png" alt="iris树"></p>
<p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression_multioutput.html#sphx-glr-auto-examples-tree-plot-tree-regression-multioutput-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_tree_regression_multioutput.html#sphx-glr-auto-examples-tree-plot-tree-regression-multioutput-py</a>
 </p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>基于信息熵分词</title>
    <url>/posts/5567.html</url>
    <content><![CDATA[<p>分片属性：分片概率、分片频度、自由度、凝固程度</p>
<h2 id="自由度"><a href="#自由度" class="headerlink" title="自由度"></a>自由度</h2><p>文本片段的自由运用程度</p>
<p>如果一个文本片段能够算作一个词的话，它应该能够灵活地出现在各种不同的环境中，具有非常丰富的左邻字集合和右邻字集合。</p>
<h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>衡量信息量大小</p>
<p>用信息熵来衡量一个文本片段的左邻字集合和右邻字集合丰富程度。考虑这么一句话”吃葡萄不吐葡萄皮不吃葡萄倒吐葡萄皮”，”葡萄”一词出现了四次，其中左邻字分别为 {吃, 吐, 吃, 吐} ，右邻字分别为 {不, 皮, 倒, 皮} 。根据公式，”葡萄”一词的左邻字的信息熵为 - (1&#x2F;2) · log(1&#x2F;2) - (1&#x2F;2) · log(1&#x2F;2) ≈ 0.693 ，它的右邻字的信息熵则为 - (1&#x2F;2) · log(1&#x2F;2) - (1&#x2F;4) · log(1&#x2F;4) - (1&#x2F;4) · log(1&#x2F;4) ≈ 1.04 。可见，在这个句子中，”葡萄”一词的右邻字更加丰富一些。</p>
<p>一个文本片段的自由运用程度为它的左邻字信息熵和右邻字信息熵中的较小值。</p>
<p>通过信息熵算法，可以很好的区分一些专有名词像玫瑰、蝙蝠等，一些地名像新西兰、伦敦等，这些自由度较低的词汇的</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>多元回归</title>
    <url>/posts/38286.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>特征选择</title>
    <url>/posts/13744.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>数据清洗</title>
    <url>/posts/12365.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>时间序列分析</title>
    <url>/posts/60273.html</url>
    <content><![CDATA[<h2 id="自相关性"><a href="#自相关性" class="headerlink" title="自相关性"></a>自相关性</h2><p>协方差矩阵和相关系数主要研究两个连续变量的相似程度（相关性）</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>最大似然</title>
    <url>/posts/46933.html</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得从模型中抽取该n组样本观测值的概率最大，而不是像最小二乘估计法旨在得到使得模型能最好地拟合样本数据的参数估计量。</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>欠采样undersampling，过采样oversampling</title>
    <url>/posts/44165.html</url>
    <content><![CDATA[<p>又称为 上采样  下采样</p>
<h2 id="数据不平衡问题"><a href="#数据不平衡问题" class="headerlink" title="数据不平衡问题"></a>数据不平衡问题</h2><p>默认阈值(比如二分类正反例中0.5)导致模型输出倾向于数据多的类别</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>调整分类阈值，偏向数据少的类别</li>
<li>选择ROC或F1作为评估标准</li>
<li>过采样、欠采样</li>
</ol>
<h3 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h3><p>将样本数量少的类别生成的样本数量和数量多的类别一样多，合成新的样本来缓解类不平衡</p>
<p>注：随机过采样采用简单复制样本增加少数类样本，导致模型不够泛化</p>
<h3 id="欠采样"><a href="#欠采样" class="headerlink" title="欠采样"></a>欠采样</h3><p>从数量多的类别中抽取与等量的样本数据，抛弃一些样本来缓解类不平衡</p>
<h3 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h3><p>经典过采样</p>
<p>人工合成数据（Synthetic Minority Over-sampling Technique）</p>
<p>分析数量较少类别的样本数据，基于“插值”来为少数类合成新样本，并添加到数据集</p>
<ol>
<li>确定采样倍率 N（N为整数，N&gt;&#x3D;1）</li>
<li>计算少数类 样本x(i)到本样本欧式距离，得到x(i)的k个近邻</li>
<li>随机选择近邻x^, xnew &#x3D; x + rand(0,1)*(x^-x),重复N次，得到N个新样本</li>
<li>对所有少数类样本x(i)执行1，2操作，合成NT个新样本</li>
</ol>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/posts/3313.html</url>
    <content><![CDATA[<h2 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h2>]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习-奇异值分解SVD</title>
    <url>/posts/106.html</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/pinard/p/6251584.html" title="SVD">奇异值分解在特征降维中的作用</a></p>
<p><a href="https://www.cnblogs.com/lzllovesyl/p/5243370.html" title="SVD">奇异值分解在推荐系统中的应用</a></p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>留一验证</title>
    <url>/posts/25124.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/posts/52662.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>词袋模型</title>
    <url>/posts/23220.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/posts/60504.html</url>
    <content><![CDATA[<h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>logistic回归又称logistic回归分析，是一种广义的线性回归分析模型</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>随机森林</title>
    <url>/posts/47295.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<hr>
<h2 id="title-机器学习的10个项目"><a href="#title-机器学习的10个项目" class="headerlink" title="title:机器学习的10个项目"></a>title:机器学习的10个项目</h2><h1 id="Deepy"><a href="#Deepy" class="headerlink" title="Deepy"></a>Deepy</h1><p>   Deepy 由 Raphael Shu 开发，是一个基于 Theano 扩展深度学习框架，它提供了一个简洁的、高阶的组件（如 LSTMs）、批规范化、自动编码等功能。Deepy 宣称其框架是十分简洁明了的，它的官方文档和示例也同样如此。<br>   Deepy 工作原理：在给定训练数据和参数（随机初始化）下运行模型，将错误（或梯度）反馈并更新参数，这个过程反复进行。 </p>
<h1 id="MLxtend"><a href="#MLxtend" class="headerlink" title="MLxtend"></a>MLxtend</h1><p>   MLxtend 由 Sebastian Raschka 开发，是一系列有效工具的集合，也是针对机器学习任务的扩展。Sebastian Raschka 提到 MLxtend 本质上是一些有效的工具集，也是与机器学习和数据科学相关的参考资料。他提到开发 MLxtend 主要是基于以下几个原因：<br>   一些其他地方找不到的特定算法（如序列特征选择算法、多数表决分类器、叠加预估、绘图决策区域等）<br>   用于教学目的（逻辑回归、Softmax 回归、多层感知器、PCA、PCA 内核等）这些实现主要关注于代码的可读性，而不是单纯的效率<br>   打包便利：tensorflow、Softmax 回归和多层感知器<br>   MLxtend 基本上是 Sebastian Raschka 所写的一个机器学习运行常用的库，其中很多功能的实现都与 scikit-learn 的 API 相似，但作者仍在持续更新中，且作者表示所有的新增特性与创新的算法都会一起打包在 MLxtend 中。</p>
<h1 id="Datacleaner"><a href="#Datacleaner" class="headerlink" title="Datacleaner"></a>Datacleaner</h1><p>   datacleaner 由 Randal Olson 开发，他认为自己开发的 datacleaner 是一个“能自动清除数据集并且让它们便于分析的 Python 工具。”他认为：datacleaner 所做的将会节约你大量的编码和清理数据的时间。<br>   datacleaner 还处于开发过程中，但目前已经能够处理以下常规（传统方式下耗时量巨大的）数据清洗任务：<br>   在列的基础上，用模式或中位数替换丢失的值<br>   用数值等价物对非数值变量进行编码等</p>
<h1 id="Auto-sklearn"><a href="#Auto-sklearn" class="headerlink" title="Auto-sklearn"></a>Auto-sklearn</h1><p>   auto-sklearn 由德国弗莱堡大学机器学习自动算法小组开发，是针对 Scikit-learn 环境的自动机器学习工具。<br>   auto-sklearn 能将机器学习用户从算法选择和高参数调整中解救出来，它利用了近期在贝叶斯优化、元学习和集成构筑上研究的优势。其大致工作原理如下：</p>
<h1 id="Deep-Mining"><a href="#Deep-Mining" class="headerlink" title="Deep Mining"></a>Deep Mining</h1><p>   Deep Mining 由来自 MIT CSAIL 实验室的 Sebastien Dubois 开发，是一个机器学习深管道自动调谐器。为了尽快实现最好的分类精度，该软件将迭代、智能地测试一些超参数集。<br>   另外值得一提的是文件夹 GCP-HPO 包含所有高斯过程（GCP）的实现代码以及基于其基础上的超参数优化（HPO）。高斯过程（GCP）可以看作是一种改进的版本。这项新技术被证明优于基于 GP 的超参数优化，已经远比随机搜索表现要好。</p>
<h1 id="Rusty-Machine"><a href="#Rusty-Machine" class="headerlink" title="Rusty Machine"></a>Rusty Machine</h1><p>   Rusty Machine 是基于 Rust 的机器学习方法，Rust 是由 Mozilla 赞助开发的一种与C和 C++ 较为相似的计算机编程语言，其号称“Rust 是一种系统的编程语言，运行速度极快，可以防止错误，并保证线程安全。”<br>   Rusty Machine 的开发者是否活跃，目前支持一系列想学习技术，包括：线性回归、逻辑回归、k-均值聚类、神经网络、支持向量机等等。<br>   Rusty Machine 还支持数据结构，如内置向量和矩阵。作为一种常见的模型接口，Rusty Machine 为每个支持的模型提供了训练和预测的功能。</p>
<h1 id="Scikit-image"><a href="#Scikit-image" class="headerlink" title="Scikit-image"></a>Scikit-image</h1><p>   scikit-image 图像是针对 SciPy 使用 Python 的图像处理方法。scikit-image 是机器学习吗？它其实是一个机器学习项目（没有确切地表示他们必须用机器学习方法），scikit-image 就属于数据处理和准备工具这一类。该项目包括一些图像处理算法，如点检测、滤波、特征选择和形态学等。</p>
<h1 id="NLP-Compromise"><a href="#NLP-Compromise" class="headerlink" title="NLP Compromise"></a>NLP Compromise</h1><p>   NLP Compromise 是由 Java 语言编写的，其在浏览器中进行自然语言处理过程。NLP Compromise 非常容易安装和使用，以下是它的一个使用范例：</p>
<h1 id="Datatest"><a href="#Datatest" class="headerlink" title="Datatest"></a>Datatest</h1><p>   Datatest 是一个依靠数据冲突的测试集，其由 Python 编写。<br>   Datatest 扩展了数据校正的测试工具标准数据库<br>   Datatest 是一种寻找数据冲突和准备的不同方式，如果你的大部分时间都被花在这个任务上，也许换一种新的方法是值得的。</p>
<h1 id="GoLearn"><a href="#GoLearn" class="headerlink" title="GoLearn"></a>GoLearn</h1><pre><code>GoLearn 是一种针对 Go 语言的机器学习库，自称 Go 语言机器学习的“内置电池”学习库。简洁、易定制是其追求的目标。
对于一些想分支出来的 Python 用户或者想尝试下机器学习的 Go 语言用户来说，GoLearn 是一个不错的选项。GoLearn 实现了熟悉的 Scikit-learn 适应/预测界面，可实现快速预估测试和交换。
</code></pre>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<hr>
<h2 id="title-主成分分析"><a href="#title-主成分分析" class="headerlink" title="title:主成分分析"></a>title:主成分分析</h2><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>1、神经网络最好设计成三层结构（输入层、隐藏层、输出层）<br>2、如果隐藏非要设计多层，保持每层的神经元数量相同<br>3、输入层神经元的数量与特性个数相同<br>4、输出层的神经元数量与输出结果的要求相关。比如10分类网络的输出层神经元数量是10个<br>5、隐层神经元的数量越多效果越好，但是过多的话，会增加计算量。最好多于输入层神经元的数量</p>
<h1 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a>训练步骤</h1><p>1、随机初始化所有权重矩阵<br>2、向前传播计算所有层的激活值<br>3、计算损失成本<br>4、反向传播计算更新权重<br>5、使用“梯度检验”确认反向传播计算是否足够有效。(注意：一旦确认有效，立即关闭“梯度检验”)<br>6、使用梯度下降或任何有效算法获得最优权重矩阵</p>
]]></content>
      <categories>
        <category>mechine</category>
      </categories>
  </entry>
  <entry>
    <title>node常见错误处理</title>
    <url>/posts/343ed70.html</url>
    <content><![CDATA[<h2 id="npm-ERR-Refusing-to-delete"><a href="#npm-ERR-Refusing-to-delete" class="headerlink" title="npm ERR! Refusing to delete"></a>npm ERR! Refusing to delete</h2><p>删除node_modules,重新执行npm install</p>
<h2 id="SyntaxError-Unexpected-token"><a href="#SyntaxError-Unexpected-token" class="headerlink" title="SyntaxError: Unexpected token"></a>SyntaxError: Unexpected token</h2><p>版本问题，找到匹配的版本</p>
<h2 id="node-与-npm-版本不匹配"><a href="#node-与-npm-版本不匹配" class="headerlink" title="node 与 npm 版本不匹配"></a>node 与 npm 版本不匹配</h2><p><a href="https://nodejs.org/zh-cn/download/releases/">https://nodejs.org/zh-cn/download/releases/</a></p>
<h2 id="下载包超时问题"><a href="#下载包超时问题" class="headerlink" title="下载包超时问题"></a>下载包超时问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="npm-ERR-notsup-Unsupported-platform-for-x66-115-101-x76-101-x6e-x74-x73-x40-x31-x2e-48-x2e-x31-x34-wanted-“os”-“darwin”-“arch”-“any”"><a href="#npm-ERR-notsup-Unsupported-platform-for-x66-115-101-x76-101-x6e-x74-x73-x40-x31-x2e-48-x2e-x31-x34-wanted-“os”-“darwin”-“arch”-“any”" class="headerlink" title="npm ERR! notsup Unsupported platform for &#x66;&#115;&#101;&#x76;&#101;&#x6e;&#x74;&#x73;&#x40;&#x31;&#x2e;&#48;&#x2e;&#x31;&#x34;: wanted {“os”:“darwin”,“arch”:“any”}"></a>npm ERR! notsup Unsupported platform for <a href="mailto:&#x66;&#115;&#101;&#x76;&#101;&#x6e;&#x74;&#x73;&#x40;&#x31;&#x2e;&#48;&#x2e;&#x31;&#x34;">&#x66;&#115;&#101;&#x76;&#101;&#x6e;&#x74;&#x73;&#x40;&#x31;&#x2e;&#48;&#x2e;&#x31;&#x34;</a>: wanted {“os”:“darwin”,“arch”:“any”}</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法一 npm install-g npm@3.10.7 (更高版本会强制在window下安装fsevent，而fsevent只会在mac系统上可用)</span><br><span class="line">方法二 删除pafsevent依赖</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm常用命令</title>
    <url>/posts/cf3ec6ef.html</url>
    <content><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo@版本号</span><br></pre></td></tr></table></figure>
<h2 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br><span class="line">npm install-g n</span><br><span class="line">n stable</span><br></pre></td></tr></table></figure>

<h2 id="npm-check-updates安装"><a href="#npm-check-updates安装" class="headerlink" title="npm-check-updates安装"></a>npm-check-updates安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>
<h2 id="检查包"><a href="#检查包" class="headerlink" title="检查包"></a>检查包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure>

<h2 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h2><p>npm update <package></package></p>
<h2 id="检查-package-json-的最新依赖项"><a href="#检查-package-json-的最新依赖项" class="headerlink" title="检查 package.json 的最新依赖项"></a>检查 package.json 的最新依赖项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">ncu</span><br></pre></td></tr></table></figure>

<h2 id="更新-package-json-的最新依赖项"><a href="#更新-package-json-的最新依赖项" class="headerlink" title="更新 package.json 的最新依赖项"></a>更新 package.json 的最新依赖项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure>

<h2 id="检查包是否最新"><a href="#检查包是否最新" class="headerlink" title="检查包是否最新"></a>检查包是否最新</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ncu &lt;package&gt;</span><br></pre></td></tr></table></figure>
<h2 id="更新包到最新"><a href="#更新包到最新" class="headerlink" title="更新包到最新"></a>更新包到最新</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update &lt;name&gt; -g</span><br><span class="line"></span><br><span class="line">ncu -u &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看全局安装包最新版本"><a href="#查看全局安装包最新版本" class="headerlink" title="查看全局安装包最新版本"></a>查看全局安装包最新版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ncu -g</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/posts/19482.html</url>
    <content><![CDATA[<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>volatile：保证多线程下的可见性</p>
<blockquote>
<p>读volatile：每当子线程读取volatile变量时，都会从主线程重新拷贝一份<br>写volatile: 每当子线程修改volatile变量时，都会在修改后同步到主线程去</p>
</blockquote>
<p>synchronized：对象锁、类锁、方法锁（其它篇有介绍）</p>
<pre><code>public class Singleton &#123;

    private static volatile Singleton instance;

    private Singleton()&#123;
    &#125;

    public static Singleton getInstance()&#123;
        if(instance == null)&#123;
            synchronized(Singleton.class)&#123;
                if(instance == null)&#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>pattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-原型模式</title>
    <url>/posts/41018.html</url>
    <content><![CDATA[<p>使用原型对象的方法创建对象的实列，创建的实例equals原型</p>
<p>final 类型修饰的成员变量不能进行深度拷贝</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等</li>
<li>构造对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>工厂模式中使用</li>
<li>共有信息很多</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对象内引用原先原型的对象</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对象内引用也拷贝一份</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package prototype;

//Cloneable 标记对象可拷贝
public class PersonClone implements Cloneable &#123;

    @Override //Override Object方法
    public PersonClone clone()&#123;
        try &#123;
            //clone 不会调用构造方法
            return (PersonClone)super.clone();
        &#125; catch (CloneNotSupportedException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;


package prototype;

public class MainClass &#123;
    public static void main(String[] args) &#123;
        PersonClone personClone = new PersonClone();
        PersonClone clone = personClone.clone();
        System.out.println(personClone.hashCode());
        System.out.println(clone.hashCode());
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>pattern</category>
      </categories>
  </entry>
  <entry>
    <title>nvm多版本管理</title>
    <url>/posts/b00c03e2.html</url>
    <content><![CDATA[<h2 id="nvm配置修改"><a href="#nvm配置修改" class="headerlink" title="nvm配置修改"></a>nvm配置修改</h2><p>修改nvm的安装目录settings</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_mirror: npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm                  // 提示相关命令</span><br><span class="line">nvm ls               // 查看已安装node版本</span><br><span class="line">nvm install XX      // 安装XX版本的node</span><br><span class="line">nvm uninstall XX    // 卸载XX版本的node</span><br><span class="line">nvm use XX         // 切换到XX版本</span><br><span class="line">nvm current // 显示当前版本</span><br><span class="line">nvm ls available // 查看运程线上所有版本</span><br><span class="line">nvm root // 查看nvm安装路径</span><br><span class="line">nvm proxy // 查看设置与代理</span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>nvm use 切换环境无效</p>
<ul>
<li>切换到管理员权限</li>
<li>node 在nvm之前安装，切换无效，需要卸载后使用nvm安装（npm ls -g –depth&#x3D;0）</li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-委派模式</title>
    <url>/posts/36157.html</url>
    <content><![CDATA[<p>代理模式+策略模式，典型 Spring 中的 DispatcherServlet</p>
<p>用户将任务全权委派给代理负责，代理负责根据策略任务调度具体的执行单元</p>
<h2 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h2><pre><code>/**
 * 执行单元实现的接口
 */
public interface ITarget &#123;

    void doSomething(String command);

&#125;

/**
 * 执行单元A
 */
public class TargetA implements ITarget &#123;
    @Override
    public void doSomething(String command) &#123;

    &#125;
&#125;

/**
 * 执行单元B
 */
public class TargetB implements ITarget &#123;
    @Override
    public void doSomething(String command) &#123;
        
    &#125;
&#125;
</code></pre>
<h2 id="执行单元调度者"><a href="#执行单元调度者" class="headerlink" title="执行单元调度者"></a>执行单元调度者</h2><pre><code>public class Manager &#123;
    private Map&lt;String ,ITarget&gt; targets = new HashMap&lt;String ,ITarget&gt;();

    public Manager()&#123;
        targets.put(&quot;commandA&quot;,new TargetA());
        targets.put(&quot;commandB&quot;,new TargetB());
    &#125;

    public void dispatch(String command)&#123;
        targets.get(command).doSomething(command);
    &#125;
&#125;
</code></pre>
<h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><pre><code>public class Boss &#123;
    
    public static void main(String[] args) &#123;
        Manager manager = new Manager();
        manager.dispatch(&quot;Command1&quot;);
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>pattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/posts/40592.html</url>
    <content><![CDATA[<p>流程相同，执行过程中有差别</p>
<p>可用于定义算法骨架，将一些实现放到子类中实现，达到不用改变算法结构，重新实现算法的目的</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package template;

public abstract class Model &#123;
    /**
     * 类似的行为、逻辑
     */
    protected abstract void start();

    protected abstract void stop();

    /**
     * 固定的流程  模板化
     */
    final public void excet()&#123;
        this.start();
        this.stop();
    &#125;
&#125;

package template;

public class Ocar extends Model &#123;
    @Override
    protected void start() &#123;

    &#125;

    @Override
    protected void stop() &#123;

    &#125;
&#125;

package template;

public class Wcar extends Model &#123;
    @Override
    protected void start() &#123;

    &#125;

    @Override
    protected void stop() &#123;

    &#125;
&#125;

package template;

public class Client &#123;
    public static void main(String[] args) &#123;
        Model wcar=new Wcar();
        wcar.excet();

        Model ocar=new Ocar();
        ocar.excet();
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>pattern</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/posts/7457.html</url>
    <content><![CDATA[<p>开发过程中，需要根据不同场景选择不同算法和策略。</p>
<p>将需要经常改变的部分抽象提取为接口，通过引用该接口，就可以调用该接口实现类的行为，即具体策略。实现了策略具体实现和调用者的隔离。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>可以动态改变对象行为</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>使用哪种策略需要调用者自己决定</li>
<li>产生很多策略类</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public interface IStrategy &#123;
    public void doSomething();
&#125;

public class Strategy1 implements IStrategy &#123;
    @Override
    public void doSomething() &#123;

    &#125;
&#125;

public class Strategy2 implements IStrategy &#123;
    @Override
    public void doSomething() &#123;

    &#125;
&#125;

public class Context implements IStrategy &#123;

    private IStrategy strategy;

    public Context(IStrategy strategy)&#123;
        this.strategy = strategy;
    &#125;

    @Override
    public void doSomething() &#123;
        strategy.doSomething();
    &#125;
&#125;

public static void main(String[] args) &#123;
    IStrategy strategy = new Strategy1();
    Context context = new Context(strategy);
    context.doSomething();
&#125;
</code></pre>
]]></content>
      <categories>
        <category>pattern</category>
      </categories>
  </entry>
  <entry>
    <title>mysql-count性能优化</title>
    <url>/posts/6fde2059.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><h2 id="count-语句实现方式"><a href="#count-语句实现方式" class="headerlink" title="count(*)语句实现方式"></a>count(*)语句实现方式</h2><p>在不同的MySQL引擎中，count(*)有不同的实现方式。</p>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM引擎把一个表的总行数存在了磁盘上，执行count(*)的时候会直接返回这个数，效率很高； 加 where 条件后，无法直接得到结果，也需要过滤。</p>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB引执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
<p>InnoDB不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。当你的记录数越来越多的时候，计算一个表的总行数会越来越慢。 </p>
<h4 id="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"><a href="#为什么InnoDB不跟MyISAM一样，也把数字存起来呢？" class="headerlink" title="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"></a>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</h4><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<p>这里，我用一个算count(*)的例子来为你解释一下。表“应该返回多少行”也是不确定的。</p>
<p>假设表t中现在有10000条记录，我们设计了三个用户并行的会话。假设表t中现在有10000条记录，我们设计了三个用户并行的会话。</p>
<p>会话A先启动事务并查询一次表的总行数；</p>
<p>会话B启动事务，插入一行后记录后，查询表的总行数；</p>
<p>会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。</p>
<p>我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p>
<p>你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p>
<p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p>
<p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p>
<p>索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。是通过采样来估算的。<br>有多不准呢，官方文档说误差可能达到40%到50%。所以，show table status命令显示的行数也不能直接使用。</p>
<p>MyISAM表虽然count(*)很快，但是不支持事务；</p>
<p>show table status命令虽然返回很快，但是不准确；</p>
<p>InnoDB表直接count(<em>)会遍历全表，虽然结果准确，但会导致性能问题。InnoDB表直接count(</em>)会遍历全表，虽然结果准确，但会导致性能问题。</p>
<p>如果你现在有一个页面经常要显示交易系统的操作记录总数，到底</p>
<h2 id="最佳实现"><a href="#最佳实现" class="headerlink" title="最佳实现"></a>最佳实现</h2><p>自己计数</p>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？没错，缓存系统可能会丢失更新。</p>
<p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p>
<p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>
<p>但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p>
<p>我们是这么定义不精确的：</p>
<ol>
<li><p>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</p>
</li>
<li><p>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</p>
</li>
</ol>
<p>这两种情况，都是逻辑不一致的。</p>
<p>会话A是一个插入交易记录的逻辑，往数据表里插入一行R，然后Redis计数加1；会话B就是查询页面显示时需要的数据。</p>
<p>在图2的这个时序里，在T3时刻会话B来查询的时候，会显示出新插入的R这个记录，但是Redis的计数还没加1。这时候，就会出现我们说的数据不一致。</p>
<p>你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改Redis计数。而读的时候是先读Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。</p>
<p>调整顺序后，会话B在T3时刻查询的时候，Redis计数加了1了，但还查不到新插入的R这一行，也是数据不一致的情况。</p>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，</p>
<p>所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p>
<h3 id="用数据库保存计数"><a href="#用数据库保存计数" class="headerlink" title="用数据库保存计数"></a>用数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p>
<p>会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。还没有提交，所以计数值加1这个操作对会话B还不可见。</p>
<p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p>
<h2 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h2><p>基于InnoDB引擎，count(*)、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别。</p>
<p>首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p>
<p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p>
<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>
<ol>
<li><p>server层要什么就给什么；</p>
</li>
<li><p>InnoDB只给必要的值；</p>
</li>
<li><p>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</p>
</li>
</ol>
<p>这是什么意思呢？接下来，我们就一个个地来看看。这是什么意思呢？接下来，我们就一个个地来看看。</p>
<p>对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p>
<p>对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。返回id会涉及到解析数据行，以及拷贝字段值的操作。</p>
<p>对于count(字段)来说：</p>
<ol>
<li><p>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</p>
</li>
<li><p>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</p>
</li>
</ol>
<p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p>
<p>但是count(<em>)是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>)肯定不是null，按行累加。</p>
<p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p>
<p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p>
<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</p>
<p>今天，我和你聊了聊MySQL中获得表行数的两种方法。我们提到了在不同引擎中count(*)的实现</p>
<p>把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。而把计数值也放在MySQL中，就解决了一致性视图的问题。</p>
<p>InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。</p>
<p>我们用事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么我只查一行的语句，也执行这么慢</title>
    <url>/posts/649145f1.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>19 | 为什么我只查一行的语句，也执行这么慢？2018-12-26 林晓斌</p>
<p>一般情况下，如果我跟你说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大</p>
<p>量的数据。但有些情况下，“查一行”，也会执行得特别慢。今天，我就跟你聊聊这个有趣的话</p>
<p>题，看看什么情况下，会出现这个现象。需要说明的是，如果MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用率很高或</p>
<p>ioutil（IO利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于我们今天的讨论范</p>
<p>围。为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，</p>
<p>并且我在里面插入了10万行记录。接下来，我会用几个不同的场景来举例，有些是前面的文章中我们已经介绍过的知识点，你看看</p>
<p>能不能一眼看穿，来检验一下吧。第一类：查询长时间不返回</p>
<p>如图1所示，在表t执行下面的SQL语句：</p>
<p>查询结果长时间不返回。图1 查询长时间不返回</p>
<p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一</p>
<p>下show processlist命令，看看当前语句处于什么状态。mysql&gt; CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>c</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;100000)do</p>
<pre><code>insert into t values(i,i)

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。等MDL锁</p>
<p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。图2 Waiting for table metadata lock状态示意图</p>
<p>出现这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句</p>
<p>堵住了。在第6篇文章《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》中，我给你介绍过一种复现</p>
<p>方法。但需要说明的是，那个复现过程是基于MySQL 5.6版本的。而MySQL 5.7版本修改了MDL</p>
<p>的加锁策略，所以就不能复现这个场景了。不过，在MySQL 5.7版本下复现这个场景，也很容易。如图3所示，我给出了简单的复现步骤。图3 MySQL 5.7中Waiting for table metadata lock的复现步骤</p>
<p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所</p>
<p>以，session B进入等待状态。这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来</p>
<p>很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需</p>
<p>要设置performance_schema&#x3D;on)</p>
<p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把</p>
<p>这个连接用kill 命令断开即可。图4 查获加表锁的线程id</p>
<p>等flush</p>
<p>接下来，我给你举另外一种查询被堵住的情况。我在表t上，执行下面的SQL语句：</p>
<p>这里，我先卖个关子。你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什</p>
<p>么原因。图5 Waiting for table flush状态示意图</p>
<p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用</p>
<p>法，一般有以下两个：</p>
<p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关</p>
<p>闭MySQL里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住</p>
<p>mysql&gt; select * from information_schema.processlist where id&#x3D;1;</p>
<p>flush tables t with read lock;</p>
<p>flush tables with read lock;</p>
<p>了，然后它又堵住了我们的select语句。现在，我们一起来复现一下这种情况，复现步骤如图6所示：</p>
<p>图6 Waiting for table flush的复现步骤</p>
<p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表</p>
<p>t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等</p>
<p>session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show</p>
<p>processlist的结果，肯定就知道应该怎么做了。图 7 Waiting for table flush的show processlist 结果</p>
<p>等行锁</p>
<p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。上面这条语句的用法你也很熟悉了，我们在第8篇《事务到底是隔离的还是不隔离的？》文章介</p>
<p>绍当前读时提到过。由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我</p>
<p>们的select语句就会被堵住。复现步骤和现场如下：</p>
<p>mysql&gt; select * from t where id&#x3D;1 lock in share mode; </p>
<p>图 8 行锁复现</p>
<p>图 9 行锁show processlist 现场</p>
<p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可</p>
<p>以通过sys.innodb_lock_waits 表查到。查询方法是：</p>
<p>mysql&gt; select * from t sys.innodb_lock_waits where locked_table&#x3D;<code>&#39;test&#39;.&#39;t&#39;</code>\G</p>
<p>图10 通过sys.innodb_lock_waits 查行锁</p>
<p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是</p>
<p>KILL QUERY 4或KILL 4。不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这</p>
<p>个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，</p>
<p>现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的</p>
<p>时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。第二类：查询慢</p>
<p>经过了重重封“锁”，我们再来看看一些查询慢的例子。先来看一条你一定知道原因的SQL语句：</p>
<p>mysql&gt; select * from t where c&#x3D;50000 limit 1;</p>
<p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接</p>
<p>后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。图11 全表扫描5万行的slow log</p>
<p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上</p>
<p>一般都配置超过1秒才算慢查询。但你要记住：坏查询不一定是慢查询。我们这个例子里面只</p>
<p>有10万行记录，数据量大起来的话，执行时间就线性涨上去了。扫描行数多，所以执行慢，这个很好理解。但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。如图12所示，是这个例子的slow log。可以看到，执行的语句是</p>
<p>虽然扫描行数是1，但执行时间却长达800毫秒。图12 扫描一行却执行得很慢</p>
<p>是不是有点奇怪呢，这些时间都花在哪里了？如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1</p>
<p>lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。图 13 加上lock in share mode的slow log</p>
<p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个</p>
<p>mysql&gt; select * from t where id&#x3D;1；</p>
<p>语句的执行输出结果。图14 两个语句的输出结果</p>
<p>第一个语句的查询结果里c&#x3D;1，带lock in share mode的语句返回的是c&#x3D;1000001。看到这里应该</p>
<p>有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，</p>
<p>再分析原因。图15 复现步骤</p>
<p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后</p>
<p>session B才开始执行update 语句。session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答</p>
<p>案。图16 id&#x3D;1的数据状态</p>
<p>session B更新完100万次，生成了100万个回滚日志(undo log)。带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很</p>
<p>快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行</p>
<p>undo log，执行了100万次以后，才将1这个结果返回。注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方</p>
<p>便你看图。小结</p>
<p>今天我给你举了在一个简单的表上，执行“查一行”，可能会出现的被锁住和执行慢的例子。这其</p>
<p>中涉及到了表锁、行锁和一致性读的概念。在实际使用中，碰到的场景会更复杂。但大同小异，你可以按照我在文章中介绍的定位方法，来</p>
<p>定位并解决问题。最后，我给你留一个问题吧。我们在举例加锁读的时候，用的是这个语句，select * from t where id&#x3D;1 lock in share mode。由</p>
<p>于id上有索引，所以可以直接定位到id&#x3D;1这一行，因此读锁也是只加在了这一行上。但如果是下面的SQL语句，</p>
<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？你可以把你的观点和验证方法写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢</p>
<p>你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>在上一篇文章最后，我留给你的问题是，希望你可以分享一下之前碰到过的、与文章中类似的场</p>
<p>景。@封建的风 提到一个有趣的场景，值得一说。我把他的问题重写一下，表结构如下：</p>
<p>假设现在表里面，有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行</p>
<p>语句是这么写的:</p>
<p>这时候，MySQL会怎么执行呢？最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没</p>
<p>有这么做。那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上</p>
<p>并没有这个值，也很快就能返回空结果。begin;</p>
<p>select * from t where c&#x3D;5 for update;</p>
<p>commit;</p>
<p>mysql&gt; CREATE TABLE <code>table_a</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>b</code> varchar(10) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>b</code> (<code>b</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>mysql&gt; select * from table_a where b&#x3D;’1234567890abcd’;</p>
<p>但实际上，MySQL也不是这么做的。这条SQL语句的执行很慢，流程是这样的：</p>
<ol>
<li>在传给引擎执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截</li>
</ol>
<p>了前10个字节，就是’1234567890’进去做匹配；</p>
<ol start="2">
<li><p>这样满足条件的数据有10万行；</p>
</li>
<li><p>因为是select *， 所以要做10万次回表；</p>
</li>
<li><p>但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;</p>
</li>
<li><p>返回结果是空。这个例子，是我们文章内容的一个很好的补充。虽然执行过程中可能经过函数操作，但是最终在</p>
</li>
</ol>
<p>拿到结果后，server层还是要做一轮判断的。评论区留言点赞板：</p>
<p>@赖阿甘 提到了等号顺序问题，时间上MySQL优化器执行过程中，where 条件部分， a&#x3D;b和</p>
<p>b&#x3D;a的写法是一样的。@沙漠里的骆驼 提到了一个常见的问题。相同的模板语句，但是匹配行数不同，语句执行时</p>
<p>间相差很大。这种情况，在语句里面有order by这样的操作时会更明显。@Justin 回答了我们正文中的问题，如果id 的类型是整数，传入的参数类型是字符串的时候，</p>
<p>可以用上索引。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么我的MySQL会“抖”一下</title>
    <url>/posts/a5f547a0.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>12 | 为什么我的MySQL会“抖”一下？2018-12-10 林晓斌</p>
<p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但</p>
<p>是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持</p>
<p>续时间还很短。看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。你的SQL语句为什么变“慢”了</p>
<p>在前面第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，我为你介绍了WAL机</p>
<p>制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志</p>
<p>叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写</p>
<p>完redo log后，就返回给客户端，本次更新成功。做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记</p>
<p>忆就是内存。掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是</p>
<p>flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一</p>
<p>致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算</p>
<p>进去。当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写</p>
<p>入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10</p>
<p>文，这次又要赊9文。图1 “孔乙己赊账”更新和flush过程</p>
<p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而</p>
<p>MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。那么，什么情况会引发数据库的flush过程呢？我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改</p>
<p>到账本上？第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活</p>
<p>儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确</p>
<p>的账目记录到账本中才行。这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把</p>
<p>checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意</p>
<p>图，这里我改成环形，便于大家理解。图2 redo log状态图</p>
<p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到</p>
<p>CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图</p>
<p>中从write pos到CP’之间就是可以再写入的redo log的区域。第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出</p>
<p>账本把孔乙己这笔账先加进去。这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰</p>
<p>一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据</p>
<p>页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，</p>
<p>就保证了每个数据页有两种状态：</p>
<p>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</p>
<p>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不</p>
<p>如更新账本。这种场景，对应的就是MySQL认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起</p>
<p>来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也</p>
<p>要见缝插针地找时间，只要有机会就刷一点“脏页”。第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都</p>
<p>记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁</p>
<p>盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。接下来，你可以分析一下上面四种场景对性能的影响。其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库</p>
<p>本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前</p>
<p>两种场景下的性能问题。第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况</p>
<p>的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更</p>
<p>新数会跌为0。第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。InnoDB用缓冲池</p>
<p>（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>
<p>第一种是，还没有使用的；</p>
<p>第二种是，使用了并且是干净页；</p>
<p>第三种是，使用了并且是脏页。InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久</p>
<p>不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是</p>
<p>脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li><p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p>
</li>
<li><p>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。InnoDB刷脏页的控制策略</p>
</li>
</ol>
<p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时</p>
<p>候，可以刷多快。这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设</p>
<p>置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机</p>
<p>读写的命令：</p>
<p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就</p>
<p>曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，</p>
<p>但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个</p>
<p>系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页</p>
<p>累积，影响了查询和更新性能。虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不</p>
<p>能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按</p>
<p>照“全力”的百分比来刷脏页。根据我前面提到的知识点，试想一下，如果你来设计策略控制刷脏页的速度，会参考哪些因</p>
<p>素呢？这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是redo log写</p>
<p>满。所以，InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。 fio -filename&#x3D;$filename -direct&#x3D;1 -iodepth 1 -thread -rw&#x3D;randrw -ioengine&#x3D;psync -bs&#x3D;16k -size&#x3D;500M -numjobs&#x3D;10 -runtime&#x3D;10 -group_reporting -name&#x3D;mytest </p>
<p>InnoDB会根据这两个因素先单独算出两个数字。参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页</p>
<p>比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p>
<p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，</p>
<p>我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为</p>
<p>F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按</p>
<p>照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上</p>
<p>面我们通过脏页比例和redo log写入速度算出来的两个值。F1(M)</p>
<p>{</p>
<p>  if M&gt;&#x3D;innodb_max_dirty_pages_pct then</p>
<pre><code>  return 100;
</code></pre>
<p>  return 100*M&#x2F;innodb_max_dirty_pages_pct;</p>
<p>}</p>
<p>图3 InnoDB刷脏页速度策略</p>
<p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论</p>
<p>是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源</p>
<p>并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且平时要多关注脏页比</p>
<p>例，不要让它经常接近75%。其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到</p>
<p>的，具体的命令参考下面的代码：</p>
<p>接下来，我们再看一个有趣的策略。一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而</p>
<p>MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁</p>
<p>边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还</p>
<p>可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放</p>
<p>到一起刷。在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述</p>
<p>的“连坐”机制，值为0时表示不找邻居，自己刷自己的。找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS</p>
<p>一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值</p>
<p>设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操</p>
<p>作，减少SQL语句响应时间。在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。小结</p>
<p>今天这篇文章，我延续第2篇中介绍的WAL的概念，和你解释了这个机制后续需要的刷脏页操作</p>
<p>和执行时机。利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触</p>
<p>发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。文章最后，我给你留下一个思考题吧。mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME &#x3D; ‘Innodb_buffer_pool_pages_dirty’;</p>
<p>select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME &#x3D; ‘Innodb_buffer_pool_pages_total’;</p>
<p>select @a&#x2F;@b;</p>
<p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo</p>
<p>log设置成4个1GB的文件。但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么</p>
<p>会出现这样的情况呢？你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我留给你的问题是，给一个学号字段创建索引，有哪些方法。由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个</p>
<p>学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定</p>
<p>的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字</p>
<p>节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我</p>
<p>们设定的这个背景，可以保证这个转换后结果的唯一性。评论区中，也有其他一些很不错的见解。评论用户@封建的风 说，一个学校的总人数这种数据量，50年才100万学生，这个表肯定是小</p>
<p>表。为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉</p>
<p>得值得at出来。@小潘 同学提了另外一个极致的方向。如果碰到表数据量特别大的场景，通过这种方式的收益</p>
<p>是很不错的。评论区留言点赞板：</p>
<p>@lttzzlll ，提到了用整型存“四位年份+五位编号”的方法；</p>
<p>由于整个学号的值超过了int上限，@老杨同志 也提到了用8个字节的bigint来存的方法。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么表数据删掉一半，表文件大小不变</title>
    <url>/posts/89a00def.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>13 | 为什么表数据删掉一半，表文件大小不变？2018-12-12 林晓斌</p>
<p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表</p>
<p>文件的大小还是没变？那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部</p>
<p>分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而</p>
<p>MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很</p>
<p>小，所以我们今天主要讨论的是表数据。接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正</p>
<p>确回收空间的方法。参数innodb_file_per_table</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数</p>
<p>innodb_file_per_table控制的：</p>
<ol>
<li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一</li>
</ol>
<p>起；</p>
<ol start="2">
<li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。从MySQL 5.6.6版本开始，它的默认值就是ON了。我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文</li>
</ol>
<p>件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文</p>
<p>件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。所以，将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个</p>
<p>设置展开的。我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除</p>
<p>数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空</p>
<p>间却没有被回收。我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。数据删除流程</p>
<p>我们先再来看一下InnoDB中一个索引的示意图。在前面第4和第5篇文章中，我和你介绍索引时</p>
<p>曾经提到过，InnoDB里的数据都是用B+树的结构组织的。图1 B+树索引示意图</p>
<p>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入</p>
<p>一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记</p>
<p>录，会怎么样？答案是，整个数据页就可以被复用了。但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果</p>
<p>插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复</p>
<p>用这个位置了。而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的</p>
<p>所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新</p>
<p>页的时候，page A是可以被复用的。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一</p>
<p>个数据页就被标记为可复用。进一步地，如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记</p>
<p>为可复用。但是磁盘上，文件不会变小。你现在知道了，delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件</p>
<p>的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被</p>
<p>使用的空间，看起来就像是“空洞”。实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造</p>
<p>成索引的数据页分裂。假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？图2 插入数据导致页分裂</p>
<p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面</p>
<p>page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1</p>
<p>个记录的位置是空洞）。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造</p>
<p>成空洞的。也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就</p>
<p>能达到收缩表空间的目的。而重建表，就可以达到这样的目的。重建表</p>
<p>试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么</p>
<p>做呢？你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A</p>
<p>里读出来再插入到表B中。由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键</p>
<p>索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完</p>
<p>成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。这里，你可以使用alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命</p>
<p>令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自</p>
<p>动完成转存数据、交换表名、删除旧表的操作。图3 改锁表DDL</p>
<p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到</p>
<p>表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个</p>
<p>DDL不是Online的。而在MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。我给你简单描述一下引入了Online DDL之后，重建表的流程：</p>
<ol>
<li><p>建立一个临时文件，扫描表A主键的所有数据页；</p>
</li>
<li><p>用数据页中表A的记录生成B+树，存储到临时文件中；</p>
</li>
<li><p>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图</p>
</li>
</ol>
<p>中state2的状态；</p>
<ol start="4">
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的</li>
</ol>
<p>数据文件，对应的就是图中state3的状态；</p>
<ol start="5">
<li>用临时文件替换表A的数据文件。图4 Online DDL</li>
</ol>
<p>可以看到，与图3过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方</p>
<p>案在重建表的过程中，允许对表A做增删改操作。这也就是Online DDL名字的来源。我记得有同学在第6篇讲表锁的文章《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》的评</p>
<p>论区留言说，DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据</p>
<p>之前就退化成读锁了。为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执</p>
<p>行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，</p>
<p>就可以认为是Online的。需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来</p>
<p>说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时</p>
<p>间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。Online 和 inplace</p>
<p>说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。你可能注意到了，在图3中，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临</p>
<p>时表，是在server层创建的。在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出</p>
<p>来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是</p>
<p>一个“原地”操作，这就是“inplace”名称的来源。所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL</p>
<p>呢？答案是不能。因为，tmp_file也是要占用临时空间的。我们重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p>
<p>跟inplace对应的就是拷贝表的方式了，用法是：</p>
<p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？其实不是的，只是在重建表这个逻辑中刚好是这样而已。比如，如果我要给InnoDB表的一个字段加全文索引，写法是：</p>
<p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。如果说这两个逻辑之间的关系是什么的话，可以概括为：</p>
<ol>
<li>DDL过程如果是Online的，就一定是inplace的；</li>
</ol>
<p>alter table t engine&#x3D;innodb,ALGORITHM&#x3D;inplace;</p>
<p>alter table t engine&#x3D;innodb,ALGORITHM&#x3D;copy;</p>
<p>alter table t add FULLTEXT(field_name);</p>
<ol start="2">
<li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文</li>
</ol>
<p>索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。最后，我们再延伸一下。在第10篇文章《MySQL为什么有时候会选错索引》的评论区中，有同学问到使用optimize</p>
<p>table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一</p>
<p>下。从MySQL 5.6版本开始，alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4</p>
<p>的流程了；</p>
<p>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程</p>
<p>中加了MDL读锁；</p>
<p>optimize table t 等于recreate+analyze。小结</p>
<p>今天这篇文章，我和你讨论了数据库中收缩表空间的方法。现在你已经知道了，如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是</p>
<p>不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。我跟你介绍了重建</p>
<p>表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的</p>
<p>版本，这个命令是会阻塞DML的，这个你需要特别小心。最后，又到了我们的课后问题时间。假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：</p>
<ol>
<li><p>一个表t文件大小为1TB；</p>
</li>
<li><p>对这个表执行 alter table t engine&#x3D;InnoDB；</p>
</li>
<li><p>发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。你觉得可能是什么原因呢 ？你可以把你觉得可能的原因写在留言区里，我会在下一篇文章的末尾把大家描述的合理的原因都</p>
</li>
</ol>
<p>列出来，以后其他同学就不用掉到这样的坑里了。感谢你的收听，也欢迎你把这篇文章分享给更</p>
<p>多的朋友一起阅读。上期问题时间</p>
<p>在上期文章最后，我留给你的问题是，如果一个高配的机器，redo log设置太小，会发生什么情</p>
<p>况。每次事务提交都要写redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这</p>
<p>个“环”将很快被写满，write pos一直追着CP。这时候系统不得不停止所有更新，去推进checkpoint。这时，你看到的现象就是磁盘压力很小，但是数据库出现间歇性的性能下跌。评论区留言点赞板：</p>
<p>@某、人 给了一个形象的描述，而且提到了，在这种情况下，连change buffer的优化也失效</p>
<p>了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏</p>
<p>页操作；</p>
<p>有几个同学提到了内存淘汰脏页，对应的redo log的操作，这个我们会在后面的文章中展开，</p>
<p>大家可以先看一下 @melon 同学的描述了解一下；</p>
<p>@算不出流源 提到了“动态平衡”，其实只要出现了这种“平衡”，意味着本应该后台的操作，就</p>
<p>已经影响了业务应用，属于有损失的平衡。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么这些SQL语句逻辑相同，性能却差异巨大</title>
    <url>/posts/fbe10c45.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？2018-12-24 林晓斌</p>
<p>在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的</p>
<p>话，就会不经意间导致整个数据库的压力变大。我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速</p>
<p>解决问题。案例一：条件字段函数操作</p>
<p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员</p>
<p>id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个</p>
<p>表的建表语句如下：</p>
<p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发</p>
<p>生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么</p>
<p>写：</p>
<p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了</p>
<p>特别久，才返回了结果。如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就</p>
<p>用不上索引了，这是MySQL的规定。现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where</p>
<p>t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成where month(t_modified)&#x3D;7的时候就不行</p>
<p>了？下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。mysql&gt; CREATE TABLE <code>tradelog</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>tradeid</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>operator</code> int(11) DEFAULT NULL,</p>
<p>  <code>t_modified</code> datetime DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>tradeid</code> (<code>tradeid</code>),</p>
<p>  KEY <code>t_modified</code> (<code>t_modified</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>mysql&gt; select count(*) from tradelog where month(t_modified)&#x3D;7;</p>
<p>图1 t_modified索引示意图</p>
<p>如果你的SQL语句条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的</p>
<p>路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃</p>
<p>走树搜索功能。需要注意的是，优化器并不是要放弃使用这个索引。在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引</p>
<p>t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引</p>
<p>来得更快。因此最终还是会选择索引t_modified。接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。图2 explain 结果</p>
<p>key&#x3D;”t_modified”表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数</p>
<p>据，rows&#x3D;100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的</p>
<p>是使用了覆盖索引。也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引</p>
<p>的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化</p>
<p>器就能按照我们预期的，用上t_modified索引的快速定位能力了。当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他</p>
<p>年份补齐。到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只</p>
<p>能使用全索引扫描。不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索</p>
<p>引。比如，对于select * from tradelog where id + 1 &#x3D; 10000这个SQL语句，这个加1操作并不会</p>
<p>改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写</p>
<p>SQL语句的时候，手动改写成 where id &#x3D; 10000 -1才可以。案例二：隐式类型转换</p>
<p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。我们一起看一下这条SQL语句：</p>
<p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表</p>
<p>扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做</p>
<p>类型转换。那么，现在这里就有两个问题：</p>
<p>mysql&gt; select count(*) from tradelog where</p>
<pre><code>-&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or

-&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or 

-&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);
</code></pre>
<p>mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<ol>
<li>数据类型转换的规则是什么？2. 为什么有数据类型转换，就需要走全索引扫描？先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不</li>
</ol>
<p>住，应该怎么办呢？这里有一个简单的方法，看 select “10” &gt; 9的结果：</p>
<ol>
<li><p>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</p>
</li>
<li><p>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。验证结果如图3所示。图3 MySQL中字符串和数字转换的效果示意图</p>
</li>
</ol>
<p>从图中可知，select “10” &gt; 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL</p>
<p>中，字符串和数字做比较的话，是将字符串转换成数字。这时，你再看这个全表扫描的语句：</p>
<p>就知道对于优化器来说，这个语句相当于：</p>
<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜</p>
<p>索功能。现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<p>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717;</p>
<p>select * from tradelog where id&#x3D;”83126”;</p>
<p>你可以先自己分析一下，再到数据库里面去验证确认。接下来，我们再来看一个稍微复杂点的例子。案例三：隐式字符编码转换</p>
<p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复</p>
<p>现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p>
<p>mysql&gt; CREATE TABLE <code>trade_detail</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>tradeid</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>trade_step</code> int(11) DEFAULT NULL, &#x2F;<em>操作步骤</em>&#x2F;</p>
<p>  <code>step_info</code> varchar(32) DEFAULT NULL, &#x2F;<em>步骤信息</em>&#x2F;</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>tradeid</code> (<code>tradeid</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert into tradelog values(1, ‘aaaaaaaa’, 1000, now());</p>
<p>insert into tradelog values(2, ‘aaaaaaab’, 1000, now());</p>
<p>insert into tradelog values(3, ‘aaaaaaac’, 1000, now());</p>
<p>insert into trade_detail values(1, ‘aaaaaaaa’, 1, ‘add’);</p>
<p>insert into trade_detail values(2, ‘aaaaaaaa’, 2, ‘update’);</p>
<p>insert into trade_detail values(3, ‘aaaaaaaa’, 3, ‘commit’);</p>
<p>insert into trade_detail values(4, ‘aaaaaaab’, 1, ‘add’);</p>
<p>insert into trade_detail values(5, ‘aaaaaaab’, 2, ‘update’);</p>
<p>insert into trade_detail values(6, ‘aaaaaaab’, 3, ‘update again’);</p>
<p>insert into trade_detail values(7, ‘aaaaaaab’, 4, ‘commit’);</p>
<p>insert into trade_detail values(8, ‘aaaaaaac’, 1, ‘add’);</p>
<p>insert into trade_detail values(9, ‘aaaaaaac’, 2, ‘update’);</p>
<p>insert into trade_detail values(10, ‘aaaaaaac’, 3, ‘update again’);</p>
<p>insert into trade_detail values(11, ‘aaaaaaac’, 4, ‘commit’);</p>
<p>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2; &#x2F;<em>语句Q1</em>&#x2F;</p>
<p>图4 语句Q1的explain 结果</p>
<p>我们一起来看下这个结果：</p>
<ol>
<li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索</li>
</ol>
<p>引，rows&#x3D;1表示只扫描一行；</p>
<ol start="2">
<li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫</li>
</ol>
<p>描。在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因</p>
<p>此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。接下来，我们看下这个explain结果表示的执行流程：</p>
<p>图5 语句Q1的执行过程</p>
<p>图中：</p>
<p>第1步，是根据id在tradelog表里找到L2这一行；</p>
<p>第2步，是从L2中取出tradeid字段的值；</p>
<p>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的</p>
<p>key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是</p>
<p>否匹配。进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引</p>
<p>的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是</p>
<p>utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问</p>
<p>题时会得到的答案。但是你应该再追问一下，为什么字符集不同就用不上索引呢？我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p>
<p>其中，$L2.tradeid.value的字符集是utf8mb4。参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字</p>
<p>符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再</p>
<p>跟L2做比较。也就是说，实际上这个语句等同于下面这个写法：</p>
<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。到这里，你终于明确了，字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段</p>
<p>上加函数操作，是直接导致对被驱动表做全表扫描的原因。mysql&gt; select * from trade_detail where tradeid&#x3D;$L2.tradeid.value; </p>
<p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换</p>
<p>的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方</p>
<p>向”进行转换的。select * from trade_detail  where CONVERT(traideid USING utf8mb4)&#x3D;$L2.tradeid.value; </p>
<p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id&#x3D;4的操作，对应的操作者是</p>
<p>谁”，再来看下这个语句和它的执行计划。图6 explain 结果</p>
<p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了</p>
<p>被驱动表tradelog里的索引(tradeid)，扫描行数是1。这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一</p>
<p>下。假设驱动表trade_detail里id&#x3D;4的行记为R4，那么在连接的时候（图5的第3步），被驱动表</p>
<p>tradelog上执行的就是类似这样的SQL 语句：</p>
<p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程</p>
<p>就被改写成：</p>
<p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。理解了原理以后，就可以用来指导操作了。如果要优化语句</p>
<p>的执行过程，有两种做法：</p>
<p>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就</p>
<p>mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;</p>
<p>select operator from tradelog  where traideid &#x3D;$R4.tradeid.value; </p>
<p>select operator from tradelog  where traideid &#x3D;CONVERT($R4.tradeid.value USING utf8mb4); </p>
<p>select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2;</p>
<p>没有字符集转换的问题了。如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不</p>
<p>能做这个DDL的话，那就只能采用修改SQL语句的方法了。图7 SQL语句优化后的explain结果</p>
<p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看</p>
<p>到，这次索引走对了。小结</p>
<p>今天我给你举了三个例子，其实是在说同一件事儿，即：对索引字段做函数操作，可能会破坏</p>
<p>索引值的有序性，因此优化器就决定放弃走树搜索功能。第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为</p>
<p>要求在索引字段上做函数操作而导致了全索引扫描。MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1&#x3D;1000改写成where id&#x3D;1000-1就</p>
<p>能够用上索引快速查找，也不会主动做这个语句重写。因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习</p>
<p>惯。最后，又到了思考题时间。今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什</p>
<p>么，又是怎么解决的呢？你可以把你经历和分析写在留言区里，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</p>
<p>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid&#x3D;CONVERT(l.tradeid USING utf8) and l.id&#x3D;2; </p>
<p>上期问题时间</p>
<p>我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得</p>
<p>到需要的数据，你觉得有没有进一步的优化方法。这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后</p>
<p>执行下面这条SQL语句：</p>
<p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以</p>
<p>的。@倪大人 同学在评论区就提到了这个方法。这次评论区出现了很多很棒的留言：</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>@老杨同志 提出了重新整理的方法、@雪中鼠[悠闲] 提到了用rowid的方法，是类似的思路，</p>
<p>就是让表里面保存一个无空洞的自增值，这样就可以用我们的随机算法1来实现；</p>
<p>@吴宇晨 提到了拿到第一个值以后，用id迭代往下找的方案，利用了主键索引的有序性。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-事务隔离：为什么你改了我还看不见</title>
    <url>/posts/7433cb2c.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>03 | 事务隔离：为什么你改了我还看不见？2018-11-19 林晓斌</p>
<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转</p>
<p>账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必</p>
<p>须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时</p>
<p>间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事</p>
<p>务”这个概念了。简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事</p>
<p>务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引</p>
<p>擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代</p>
<p>的重要原因之一。今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给</p>
<p>出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。隔离性与隔离级别</p>
<p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一</p>
<p>致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-</p>
<p>repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概</p>
<p>念。在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要</p>
<p>在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、</p>
<p>读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐</p>
<p>一为你解释：</p>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一</p>
<p>致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突</p>
<p>的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中</p>
<p>只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。mysql&gt; create table T(c int) engine&#x3D;InnoDB;</p>
<p>insert into T(c) values(1);</p>
<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3</p>
<p>的返回值分别是什么。若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被</p>
<p>A看到了。因此，V2、V3也都是2。若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，</p>
<p>V3的值也是2。若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：</p>
<p>事务在执行期间看到的数据前后必须是一致的。若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，</p>
<p>事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离</p>
<p>级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级</p>
<p>别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离</p>
<p>级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避</p>
<p>免并行访问。我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其</p>
<p>实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，</p>
<p>你一定要记得将MySQL的隔离级别设置为“读提交”。配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用</p>
<p>show variables来查看当前的值。总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时</p>
<p>候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务</p>
<p>更新的影响。mysql&gt; show variables like ‘transaction_isolation’;</p>
<p>+———————–+—————-+</p>
<p>| Variable_name | Value |</p>
<p>+———————–+—————-+</p>
<p>| transaction_isolation | READ-COMMITTED |</p>
<p>+———————–+—————-+</p>
<p>事务隔离的实现</p>
<p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复</p>
<p>读”。在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通</p>
<p>过回滚操作，都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看</p>
<p>到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多</p>
<p>个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前</p>
<p>值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的</p>
<p>事务是不会冲突的。你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数</p>
<p>据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占</p>
<p>用存储空间。在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终</p>
<p>提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终</p>
<p>只好为了清理回滚段，重建整个库。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候</p>
<p>展开。事务的启动方式</p>
<p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并</p>
<p>不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是</li>
</ol>
<p>rollback。2. set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个</p>
<p>select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行</p>
<p>commit 或 rollback 语句，或者断开连接。有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的</p>
<p>查询都在事务中，如果是长连接，就导致了意外的长事务。因此，我会建议你总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式</p>
<p>每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾</p>
<p>虑，我建议你使用commit work and chain语法。在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行</p>
<p>commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语</p>
<p>句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查</p>
<p>找持续时间超过60s的事务。select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p>
<p>小结</p>
<p>这篇文章里面，我介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存</p>
<p>在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地</p>
<p>使用MySQL的事务特性。我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也</p>
<p>是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>在上期文章的最后，我给你留下的问题是一天一备跟一周一备的对比。好处是“最长恢复时间”更短。在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，</p>
<p>而要恢复出一个到昨天晚上23点的备份。一周一备最坏情况就要应用一周的binlog了。系统的对应指标就是 @尼古拉斯·赵四 @慕塔 提到的RTO（恢复目标时间）。当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来</p>
<p>的，就需要你根据业务重要性来评估了。同时也感谢 @super blue cat、@高枕、@Jason 留下了高质量的评论。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-全局锁和表锁 ：给表加个字段怎么有这么多阻碍</title>
    <url>/posts/9cd031b1.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？2018-11-26 林晓斌</p>
<p>今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资</p>
<p>源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访</p>
<p>问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。今天这篇文</p>
<p>章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介</p>
<p>绍。这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是</p>
<p>碰到锁时的现象和其背后的原理。全局锁</p>
<p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是</p>
<p>Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命</p>
<p>令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括</p>
<p>建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</p>
<p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</p>
<p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问</p>
<p>题。假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉</p>
<p>他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表</p>
<p>(u_course)，会怎么样呢？你可以看一下这个图：</p>
<p>图1 业务和备份状态图</p>
<p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了</p>
<p>一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程</p>
<p>表再备份账户余额表，又可能会出现什么结果？也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致</p>
<p>的。说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视</p>
<p>图的，对吧？是的，就是在可重复读隔离级别下开启一个事务。官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导</p>
<p>数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是</p>
<p>可以正常更新的。你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？一致性读是好，但前提是引擎要支</p>
<p>持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是</p>
<p>只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。所以，single-transaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不</p>
<p>支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用</p>
<p>InnoDB替代MyISAM的原因之一。你也许会问，既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢？确实</p>
<p>readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原</p>
<p>因：</p>
<p>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备</p>
<p>库。因此，修改global变量的方式影响面更大，我不建议你使用。二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么</p>
<p>MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为</p>
<p>readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个</p>
<p>库长时间处于不可写状态，风险较高。业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论</p>
<p>是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍</p>
<p>的表级锁。备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章《事务隔</p>
<p>离：为什么你改了我还看不见？》中的相关内容。表级锁</p>
<p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。表锁的语法是 lock tables … read&#x2F;write。与FTWRL类似，可以用unlock tables主动释放锁，</p>
<p>也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写</p>
<p>外，也限定了本线程接下来的操作对象。举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读</p>
<p>写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操</p>
<p>作。连写t1都不允许，自然也不能访问其他表。在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持</p>
<p>行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被</p>
<p>自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个</p>
<p>表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果</p>
<p>跟表结构对不上，肯定是不行的。因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当</p>
<p>要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线</p>
<p>程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看</p>
<p>到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操</p>
<p>作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也</p>
<p>会出问题。我们来看一下下面的操作序列，假设表t是一个小表。备注：这里的实验环境是MySQL 5.6。我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是</p>
<p>MDL读锁，因此可以正常执行。之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写</p>
<p>锁，因此只能被阻塞。如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也</p>
<p>会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被</p>
<p>锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session</p>
<p>再请求的话，这个库的线程很快就会爆满。你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释</p>
<p>放，而会等到整个事务提交后再释放。基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema</p>
<p>库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务</p>
<p>在执行，要考虑先暂停DDL，或者kill掉这个长事务。但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频</p>
<p>繁，而你不得不加个字段，你该怎么做呢？这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面</p>
<p>设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后</p>
<p>面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n</p>
<p>这个语法。小结</p>
<p>今天，我跟你介绍了MySQL的全局锁和表级锁。全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-</p>
<p>transaction参数，对应用会更友好。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock</p>
<p>tables这样的语句，你需要追查一下，比较可能的情况是：</p>
<p>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；</p>
<p>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock</p>
<p>tables 和 unlock tables 改成 begin 和 commit，问题就解决了。MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和</p>
<p>更新。最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction方法做逻</p>
<p>辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从</p>
<p>备库上会看到什么现象呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。说明：这篇文章没有介绍到物理备份，物理备份会有一篇单独的文章。上期问题时间</p>
<p>上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。ALTER TABLE tbl_name NOWAIT add column …</p>
<p>ALTER TABLE tbl_name WAIT N add column … </p>
<p>我直接贴@老杨同志 的回复略作修改如下（我修改的部分用橙色标出）：</p>
<p>表记录</p>
<p>–a–|–b–|–c–|–d–</p>
<p>1 2 3 d</p>
<p>1 3 2 d</p>
<p>1 4 3 d</p>
<p>2 1 3 d</p>
<p>2 2 2 d</p>
<p>2 3 4 d</p>
<p>主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。索引 ca 的组织是先按c排序，再按a排序，同时记录主键</p>
<p>–c–|–a–|–主键部分b– （注意，这里不是ab，而是只有b）</p>
<p>2 1 3</p>
<p>2 2 2</p>
<p>3 1 2</p>
<p>3 1 4</p>
<p>3 2 1</p>
<p>4 2 3</p>
<p>这个跟索引c的数据是一模一样的。索引 cb 的组织是先按c排序，在按b排序，同时记录主键</p>
<p>–c–|–b–|–主键部分a– （同上）</p>
<p>2 2 2</p>
<p>2 3 1</p>
<p>3 1 2</p>
<p>3 2 1</p>
<p>3 4 1</p>
<p>4 3 2</p>
<p>所以，结论是ca可以去掉，cb需要保留。评论区留言点赞：</p>
<p>@浪里白条 帮大家总结了复习要点；</p>
<p>@约书亚 的问题里提到了MRR优化；</p>
<p>@HwangZHen 留言言简意赅。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-基础架构：一条SQL查询语句是如何执行的</title>
    <url>/posts/2db0ff3f.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>01 | 基础架构：一条SQL查询语句是如何执行的？2018-11-14 林晓斌</p>
<p>你好，我是林晓斌。这是专栏的第一篇文章，我想来跟你聊聊MySQL的基础架构。我们经常说，看一个事儿千万不</p>
<p>要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。同样，对于</p>
<p>MySQL的学习也是这样。平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简</p>
<p>单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p>
<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，</p>
<p>让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本</p>
<p>质，更为快速地定位并解决问题。下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功</p>
<p>能模块中的执行过程。mysql&gt; select * from T where ID&#x3D;10；</p>
<p>MySQL的逻辑架构图</p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务</p>
<p>功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在</p>
<p>这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、</p>
<p>Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了</p>
<p>默认存储引擎。也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不</p>
<p>过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用</p>
<p>engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功</p>
<p>能也不同，在后面的文章中，我们会讨论到引擎的选择。从图中不难看出，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。你可</p>
<p>以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执</p>
<p>行流程，依次看下每个组件的作用。连接器</p>
<p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连</p>
<p>接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行</p>
<p>中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器</p>
<p>就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序</p>
<p>结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面</p>
<p>的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不</p>
<p>会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命</p>
<p>令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这</p>
<p>一行，就表示现在系统里面有一个空闲连接。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制</p>
<p>的，默认值是8小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection</p>
<p>to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接</p>
<p>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是</p>
<p>尽量使用长连接。mysql -h$ip -P$port -u$user -p</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为</p>
<p>MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候</p>
<p>才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现</p>
<p>象看就是MySQL异常重启了。怎么解决这个问题呢？你可以考虑以下两种方案。1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开</p>
<p>连接，之后要查询再重连。2. 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行</p>
<p>mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，</p>
<p>但是会将连接恢复到刚刚创建完时的状态。查询缓存</p>
<p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过</p>
<p>的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是</p>
<p>查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客</p>
<p>户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存</p>
<p>中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结</p>
<p>果，这个效率会很高。但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于</p>
<p>利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此</p>
<p>很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库</p>
<p>来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成</p>
<p>DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语</p>
<p>句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<p>mysql&gt; select SQL_CACHE * from T where ID&#x3D;10；</p>
<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有</p>
<p>这个功能了。分析器</p>
<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此</p>
<p>需要对SQL语句做解析。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识</p>
<p>别出里面的字符串分别是什么，代表什么。MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别</p>
<p>成“表名T”，把字符串“ID”识别成“列ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，</p>
<p>判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个</p>
<p>语句select少打了开头的字母“s”。一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。优化器</p>
<p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）</p>
<p>的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<p>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是</p>
<p>否等于20。也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否</p>
<p>等于10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择</p>
<p>mysql&gt; elect * from t where ID&#x3D;1;</p>
<p>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from t where ID&#x3D;1’ at line 1</p>
<p>mysql&gt; select * from t1 join t2 using(ID)  where t1.c&#x3D;10 and t2.d&#x3D;20;</p>
<p>使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些</p>
<p>疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单</p>
<p>独展开说明优化器的内容。执行器</p>
<p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶</p>
<p>段，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有</p>
<p>权限的错误，如下所示。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引</p>
<p>擎提供的接口。比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则</li>
</ol>
<p>将这行存在结果集中；</p>
<ol start="2">
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后</li>
</ol>
<p>循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了</p>
<p>多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟</p>
<p>rows_examined并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，</p>
<p>里面会有详细的说明。mysql&gt; select * from T where ID&#x3D;10;</p>
<p>ERROR 1142 (42000): SELECT command denied to user ‘b‘@’localhost’ for table ‘T’</p>
<p>小结</p>
<p>今天我给你介绍了MySQL的逻辑架构，希望你对一个SQL语句完整执行流程的各个阶段有了一</p>
<p>个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每</p>
<p>个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 select * from T where k&#x3D;1, 那</p>
<p>肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是</p>
<p>在我们上面提到的哪个阶段报出来的呢？感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-怎么给字符串字段加索引</title>
    <url>/posts/e1ece7cd.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>11 | 怎么给字符串字段加索引？2018-12-07 林晓斌</p>
<p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天</p>
<p>要讨论的问题。假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p>
<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语</p>
<p>句就只能做全表扫描。同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，</p>
<p>mysql&gt; create table SUser(</p>
<p>ID bigint unsigned primary key,</p>
<p>email varchar(64), </p>
<p>… </p>
<p>)engine&#x3D;innodb; </p>
<p>mysql&gt; select f1, f2 from SUser where email&#x3D;’xxx’;</p>
<p>如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。比如，这两个在email字段上创建索引的语句：</p>
<p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2</p>
<p>索引里面，对于每个记录都是只取前6个字节。那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引</p>
<p>的示意图。图1 email 索引结构</p>
<p>mysql&gt; alter table SUser add index index1(email);</p>
<p>或</p>
<p>mysql&gt; alter table SUser add index index2(email(6));</p>
<p>图2 email(6) 索引结构</p>
<p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：</p>
<p>zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。如果使用的是index1（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li><p>从index1索引树找到满足索引值是’<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#115;&#120;&#x79;&#x7a;&#64;&#120;&#120;&#x78;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#115;&#120;&#x79;&#x7a;&#64;&#120;&#120;&#x78;&#46;&#x63;&#111;&#x6d;</a>’的这条记录，取得ID2的值；</p>
</li>
<li><p>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</p>
</li>
<li><p>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足</p>
</li>
</ol>
<p>email&#x3D;‘<a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#x73;&#x73;&#120;&#121;&#x7a;&#x40;&#x78;&#120;&#120;&#46;&#99;&#x6f;&#109;">&#122;&#x68;&#x61;&#x6e;&#x67;&#x73;&#x73;&#120;&#121;&#x7a;&#x40;&#x78;&#120;&#120;&#46;&#99;&#x6f;&#109;</a>’的条件了，循环结束。这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。select id,name,email from SUser where email&#x3D;‘<a href="mailto:&#122;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#x78;&#121;&#122;&#x40;&#120;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;">&#122;&#104;&#x61;&#110;&#x67;&#x73;&#115;&#x78;&#121;&#122;&#x40;&#120;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;</a>‘;</p>
<p>如果使用的是index2（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li><p>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</p>
</li>
<li><p>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#122;&#x68;&#97;&#110;&#x67;&#115;&#x73;&#x78;&#121;&#x7a;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#110;&#x67;&#115;&#x73;&#x78;&#121;&#x7a;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#111;&#x6d;</a>’，这行记录丢</p>
</li>
</ol>
<p>弃；</p>
<ol start="3">
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取</li>
</ol>
<p>整行然后判断，这次值对了，将这行记录加入结果集；</p>
<ol start="4">
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。在这个过程中，要回主键索引取4次数据，也就是扫描了4行。通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变</li>
</ol>
<p>多。但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取</p>
<p>email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到</p>
<p>ID2，只扫描一行就结束了。也就是说使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查</p>
<p>询成本。于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前</p>
<p>缀呢？实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的</p>
<p>键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用</p>
<p>这个语句：</p>
<p>mysql&gt; select count(distinct email) as L from SUser;</p>
<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如</p>
<p>5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以</p>
<p>选择前缀长度为6。前缀索引对覆盖索引的影响</p>
<p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止</p>
<p>如此，我们再看一下另外一个场景。你先来看看这个SQL语句：</p>
<p>与前面例子中的SQL语句</p>
<p>相比，这个语句只要求返回id和email字段。所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查</p>
<p>到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结</p>
<p>构）的话，就不得不回到ID索引再去判断email字段的值。即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，</p>
<p>但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信</p>
<p>息。也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀</p>
<p>索引时需要考虑的一个因素。其他方式</p>
<p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不</p>
<p>mysql&gt; select </p>
<p>  count(distinct left(email,4)）as L4,</p>
<p>  count(distinct left(email,5)）as L5,</p>
<p>  count(distinct left(email,6)）as L6,</p>
<p>  count(distinct left(email,7)）as L7,</p>
<p>from SUser;</p>
<p>select id,email from SUser where email&#x3D;‘<a href="mailto:&#122;&#104;&#x61;&#110;&#103;&#x73;&#x73;&#x78;&#121;&#x7a;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#x6f;&#109;">&#122;&#104;&#x61;&#110;&#103;&#x73;&#x73;&#x78;&#121;&#x7a;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#x6f;&#109;</a>‘;</p>
<p>select id,name,email from SUser where email&#x3D;‘<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#x73;&#x78;&#121;&#122;&#64;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#x73;&#x78;&#121;&#122;&#64;&#120;&#120;&#x78;&#x2e;&#99;&#x6f;&#109;</a>‘;</p>
<p>够好的情况时，我们要怎么办呢？比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前</p>
<p>6位一般会是相同的。假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的</p>
<p>话，这个索引的区分度就非常低了。按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的</p>
<p>效率也就会越低。那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理</p>
<p>方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。答案是，有的。第一种方式是使用倒序存储。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你</p>
<p>可以这么写：</p>
<p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区</p>
<p>分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。第二种方式是使用hash字段。你可以在表上再创建一个整数字段，来保存身份证的校验码，</p>
<p>同时在这个字段上创建索引。然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码</p>
<p>可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你</p>
<p>的查询语句where部分要判断id_card的值是否精确相同。这样，索引的长度变成了4个字节，比原来小了很多。mysql&gt; select field_list from t where id_card &#x3D; reverse(‘input_id_card_string’);</p>
<p>mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</p>
<p>mysql&gt; select field_list from t where id_card_crc&#x3D;crc32(‘input_id_card_string’) and id_card&#x3D;’input_id_card_string’</p>
<p>接下来，我们再一起看看使用倒序存储和使用hash字段这两种方法的异同点。首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的</p>
<p>方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样</p>
<p>地，hash字段的方式也只能支持等值查询。它们的区别，主要体现在以下三个方面：</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字</li>
</ol>
<p>段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如</p>
<p>果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。2. 在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash</p>
<p>字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的</p>
<p>话，reverse函数额外消耗的CPU资源会更小些。3. 从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽</p>
<p>然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储</p>
<p>方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。小结</p>
<p>在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的</p>
<p>方式有：</p>
<ol>
<li><p>直接创建完整索引，这样可能比较占用空间；</p>
</li>
<li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p>
</li>
<li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p>
</li>
<li><p>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支</p>
</li>
</ol>
<p>持范围扫描。在实际应用中，你要根据业务字段的特点选择使用哪种方式。好了，又到了最后的问题时间。如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号</p>
<p>的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第</p>
<p>十位是入学年份、最后五位是顺序编号。系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验</p>
<p>证这个行为的话，你会怎么设计这个登录名的索引呢？你可以把你的分析思路和设计结果写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上篇文章中的第一个例子，评论区有几位同学说没有复现，大家要检查一下隔离级别是不是</p>
<p>RR（Repeatable Read，可重复读），创建的表t是不是InnoDB引擎。我把复现过程做成了一</p>
<p>个视频，供你参考。在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain的结果就不对了？这</p>
<p>里，我来为你分析一下原因。delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来</p>
<p>的10万行。但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之</p>
<p>前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数</p>
<p>据。这样，索引a上的数据其实就有两份。然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令</p>
<p>看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选</p>
<p>字段a作为索引更合适）</p>
<p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是</p>
<p>show table status的值。这个值的计算方法，我会在后面有文章为你详细讲解。评论区留言点赞板：</p>
<p>@斜面镜子 Bill 的评论最接近答案；</p>
<p>@某、人 做了两个很不错的对照试验；</p>
<p>@ye7zi 等几位同学很认真的验证，赞态度。大家的机器如果IO能力比较差的话，做这个验证</p>
<p>的时候，可以把innodb_flush_log_at_trx_commit 和 sync_binlog 都设置成0。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-日志系统：一条SQL更新语句是如何执行的</title>
    <url>/posts/7470fa8d.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>02 | 日志系统：一条SQL更新语句是如何执行的？2018-11-16 林晓斌</p>
<p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还</p>
<p>记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后</p>
<p>到达存储引擎。那么，一条更新语句的执行流程又是怎样的呢？之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你</p>
<p>是不是心中也会不免会好奇，这是怎样做到的呢？我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个</p>
<p>整型字段c：</p>
<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>
<p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看</p>
<p>这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。mysql&gt; create table T(ID int primary key, c int);</p>
<p>mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<p>MySQL的逻辑架构图</p>
<p>你执行语句前要先连接数据库，这是连接器的工作。前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会</p>
<p>把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主</p>
<p>角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过</p>
<p>的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有</p>
<p>意思的地方，这些设计思路也可以用到你自己的程序里。重要的日志模块：redo log</p>
<p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记</p>
<p>录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会</p>
<p>有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<p>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</p>
<p>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到</p>
<p>这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老</p>
<p>花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的</p>
<p>帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到</p>
<p>对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问</p>
<p>题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-</p>
<p>Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账</p>
<p>本。具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里</p>
<p>面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作</p>
<p>记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的</p>
<p>事。如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎</p>
<p>么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把</p>
<p>这些记录从粉板上擦掉，为记新账腾出空间。与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是</p>
<p>1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环</p>
<p>写，如下面这个图所示。write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文</p>
<p>件。write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos</p>
<p>追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把</p>
<p>checkpoint推进一下。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个</p>
<p>能力称为crash-safe。要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或</p>
<p>写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板</p>
<p>上的数据明确赊账账目。重要的日志模块：binlog</p>
<p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能</p>
<p>层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是</p>
<p>InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。我想你肯定会问，为什么会有两份日志呢？因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有</p>
<p>crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL</p>
<p>的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统— —也就是</p>
<p>redo log来实现crash-safe能力。这两种日志有以下三点不同。1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的</p>
<p>是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件</p>
<p>写到一定大小后会切换到下一个，并不会覆盖以前的日志。有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语</p>
<p>句时的内部流程。1. 执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一</p>
<p>行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然</p>
<p>后再返回。2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行</p>
<p>数据，再调用引擎接口写入这行新数据。3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处</p>
<p>于prepare状态。然后告知执行器执行完成了，随时可以提交事务。4. 执行器生成这个操作的binlog，并把binlog写入磁盘。5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更</p>
<p>新完成。这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表</p>
<p>示是在执行器中执行的。update语句执行流程</p>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和</p>
<p>commit，这就是”两阶段提交”。两阶段提交</p>
<p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得</p>
<p>从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承</p>
<p>诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期</p>
<p>做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数</p>
<p>据，那你可以这么做：</p>
<p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备</p>
<p>份恢复到临时库；</p>
<p>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时</p>
<p>刻。这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢</p>
<p>复到线上库去。好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法</p>
<p>来进行解释。由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写</p>
<p>binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语</p>
<p>句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？1. 先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异</p>
<p>常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回</p>
<p>来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份</p>
<p>日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这</p>
<p>个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。2. 先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以</p>
<p>后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日</p>
<p>志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是</p>
<p>1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的</p>
<p>状态不一致。你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再</p>
<p>多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来</p>
<p>实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保</p>
<p>持逻辑上的一致。小结</p>
<p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，</p>
<p>表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证</p>
<p>MySQL异常重启之后数据不丢失。sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建</p>
<p>议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑</p>
<p>一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有</p>
<p>的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或</p>
<p>者说，它影响了这个数据库系统的哪个指标？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-深入浅出索引（上）</title>
    <url>/posts/1b52f1b8.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>04 | 深入浅出索引（上）</p>
<p>2018-11-21 林晓斌</p>
<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢，</p>
<p>分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，</p>
<p>索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，</p>
<p>所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识</p>
<p>点，加深你对数据库索引的理解。一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500</p>
<p>页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一</p>
<p>会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。索引的常见模型</p>
<p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模</p>
<p>型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的</p>
<p>数据结构，它们分别是哈希表、有序数组和搜索树。下面我主要从使用的角度，为你简单分析一下这三种模型的区别。哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找</p>
<p>到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个</p>
<p>确定的位置，然后把value放在数组的这个位置。不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方</p>
<p>法是，拉出一个链表。假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应</p>
<p>的哈希索引的示意图如下所示：</p>
<p>图1 哈希表示意图</p>
<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，</p>
<p>这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函</p>
<p>数算出N；然后，按顺序遍历，找到User2。需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会</p>
<p>很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢</p>
<p>的。你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必</p>
<p>须全部扫描一遍了。所以，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引</p>
<p>擎。而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号</p>
<p>查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p>图2 有序数组示意图</p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你</p>
<p>要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的</p>
<p>User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一</p>
<p>个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦</p>
<p>了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于静态存储引擎，比如你要保存的是2017年某个城市的所有人口</p>
<p>信息，这类不会再修改的数据。二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二</p>
<p>叉搜索树来实现的话，示意图如下所示：</p>
<p>图3 二叉搜索树示意图</p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查</p>
<p>ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得</p>
<p>到。这个时间复杂度是O(log(N))。当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更</p>
<p>新的时间复杂度也是O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右</p>
<p>递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因</p>
<p>是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在</p>
<p>机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100</p>
<p>万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真</p>
<p>够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该</p>
<p>使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存</p>
<p>1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一</p>
<p>个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内</p>
<p>存中，那么访问磁盘的平均次数就更少了。N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中</p>
<p>了。不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数</p>
<p>据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开</p>
<p>了。你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我</p>
<p>们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能</p>
<p>会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理</p>
<p>数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分</p>
<p>析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。现在，我们一起进入相对偏实战的内容吧。在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索</p>
<p>引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不</p>
<p>同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和</p>
<p>你分析一下其中的索引模型。InnoDB 的索引模型</p>
<p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。这个表的建表语句是：</p>
<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意</p>
<p>图如下。图4 InnoDB的索引组织结构</p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered</p>
<p>index）。非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引</p>
<p>（secondary index）。根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区</p>
<p>mysql&gt; create table T(</p>
<p>id int primary key, </p>
<p>k int not null, </p>
<p>name varchar(16),</p>
<p>index (k))engine&#x3D;InnoDB;</p>
<p>别？如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</p>
<p>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID</p>
<p>的值为500，再到ID索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主</p>
<p>键查询。索引维护</p>
<p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插</p>
<p>入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就</p>
<p>相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的</p>
<p>数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，</p>
<p>整体空间利用率降低大约50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合</p>
<p>并的过程，可以认为是分裂过程的逆过程。基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY</p>
<p>KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条</p>
<p>新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如</p>
<p>字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的</p>
<p>叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无</p>
<p>绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。8个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样</p>
<p>的：</p>
<ol>
<li><p>只有一个索引；</p>
</li>
<li><p>该索引必须是唯一索引。你一定看出来了，这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，</p>
</li>
</ol>
<p>可以避免每次查询需要搜索两棵树。小结</p>
<p>今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么</p>
<p>InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的</p>
<p>空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。最后，我给你留下一个问题吧。对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个</p>
<p>SQL语句可以这么写：</p>
<p>如果你要重建主键索引，也可以这么写：</p>
<p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好</p>
<p>的方法是什么？alter table T drop index k;</p>
<p>alter table T add index(k);</p>
<p>alter table T drop primary key;</p>
<p>alter table T add primary key(id);</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章末尾给你留下的问题是：如何避免长事务对业务的影响？这个问题，我们可以从应用开发端和数据库端来看。首先，从应用开发端来看：</p>
<ol>
<li>确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的</li>
</ol>
<p>general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架</p>
<p>如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我</p>
<p>见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务</p>
<p>可以去掉。3. 业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，</p>
<p>来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后</p>
<p>续的文章中会提到这类案例）</p>
<p>其次，从数据库端来看：</p>
<ol>
<li><p>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的</p>
</li>
</ol>
<p>值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。感谢 @壹笙☞漂泊 @王凯 @易翔 留下的高质量评论。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-深入浅出索引（下）</title>
    <url>/posts/a3ee96dd.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>05 | 深入浅出索引（下）</p>
<p>2018-11-23 林晓斌</p>
<p>在上一篇文章中，我和你介绍了InnoDB索引的数据结构模型，今天我们再继续聊聊跟MySQL索</p>
<p>引有关的概念。在开始这篇文章之前，我们先来看一下这个问题：</p>
<p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜</p>
<p>索操作，会扫描多少行？下面是这个表的初始化语句。mysql&gt; create table T (</p>
<p>ID int primary key,</p>
<p>k int NOT NULL DEFAULT 0, </p>
<p>s varchar(16) NOT NULL DEFAULT ‘’,</p>
<p>index k(k))</p>
<p>engine&#x3D;InnoDB;</p>
<p>insert into T values(100,1, ‘aa’),(200,2,’bb’),(300,3,’cc’),(500,5,’ee’),(600,6,’ff’),(700,7,’gg’);</p>
<p>图1 InnoDB的索引组织结构</p>
<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li><p>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</p>
</li>
<li><p>再到ID索引树查到ID&#x3D;300对应的R3；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</p>
</li>
<li><p>再回到ID索引树查到ID&#x3D;500对应的R4；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k</p>
</li>
</ol>
<p>索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有</p>
<p>可能经过索引优化，避免回表过程呢？覆盖索引</p>
<p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值</p>
<p>已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，</p>
<p>索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用</p>
<p>的性能优化手段。需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k</p>
<p>上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL</p>
<p>认为扫描行数是2。基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份</p>
<p>证号和名字建立联合索引？假设这个市民表的定义是这样的：</p>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，</p>
<p>我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是</p>
<p>不是浪费空间？如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它</p>
<p>可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑</p>
<p>了。这正是业务DBA，或者称为业务数据架构师的工作。最左前缀原则</p>
<p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》</p>
<p>中，和你详细讨论。CREATE TABLE <code>tuser</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>id_card</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>name</code> varchar(32) DEFAULT NULL,</p>
<p>  <code>age</code> int(11) DEFAULT NULL,</p>
<p>  <code>ismale</code> tinyint(1) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>id_card</code> (<code>id_card</code>),</p>
<p>  KEY <code>name_age</code> (<code>name</code>,<code>age</code>)</p>
<p>) ENGINE&#x3D;InnoDB</p>
<p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现</p>
<p>在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但</p>
<p>总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的</p>
<p>索引又感觉有点浪费。应该怎么做呢？这里，我先和你说结论吧。B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。图2 （name，age）索引示意图</p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有</p>
<p>需要的结果。如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like</p>
<p>‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，</p>
<p>直到不满足条件为止。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左</p>
<p>前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索</p>
<p>引内的字段顺序。这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联</p>
<p>合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可</p>
<p>以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索</p>
<p>引，并用这个索引支持“根据身份证号查询地址”的需求。那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使</p>
<p>用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、</p>
<p>(b) 这两个索引。这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段</p>
<p>大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。索引下推</p>
<p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能</p>
<p>要问，那些不符合最左前缀的部分，会怎么样呢？我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一</p>
<p>个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足</p>
<p>条件的记录ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索</p>
<p>引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。图3和图4，是这两个过程的执行流程图。mysql&gt; select * from tuser where name like ‘张%’ and age&#x3D;10 and ismale&#x3D;1;</p>
<p>图3 无索引下推执行流程</p>
<p>图4 索引下推执行流程</p>
<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，</p>
<p>只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的</p>
<p>记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判</p>
<p>断，就只需要回表2次。小结</p>
<p>今天这篇文章，我和你继续讨论了数据库索引的概念，包括了覆盖索引、前缀索引、索引下推。你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我</p>
<p>们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。接下来我给你留下一个问题吧。实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维</p>
<p>护的库里面，有这么一个表，表结构定义类似这样的：</p>
<p>公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c</p>
<p>上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：</p>
<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为</p>
<p>什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理。在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分</p>
<p>裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样</p>
<p>页面的利用率最高，也就是索引更紧凑、更省空间。这道题目，我给你的“参考答案”是：</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删</p>
<p>除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做</p>
<p>了。这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。在专栏的第12篇文章</p>
<p>CREATE TABLE <code>geek</code> (</p>
<p>  <code>a</code> int(11) NOT NULL,</p>
<p>  <code>b</code> int(11) NOT NULL,</p>
<p>  <code>c</code> int(11) NOT NULL,</p>
<p>  <code>d</code> int(11) NOT NULL,</p>
<p>  PRIMARY KEY (<code>a</code>,<code>b</code>),</p>
<p>  KEY <code>c</code> (<code>c</code>),</p>
<p>  KEY <code>ca</code> (<code>c</code>,<code>a</code>),</p>
<p>  KEY <code>cb</code> (<code>c</code>,<code>b</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select * from geek where c&#x3D;N order by a limit 1;</p>
<p>select * from geek where c&#x3D;N order by b limit 1;</p>
<p>《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。评论区留言中， @壹笙☞漂泊 做了很详细的笔记，@高枕 帮同学解答了问题，@约书亚 提了一</p>
<p>个很不错的面试问题。在这里，我要和你们道一声感谢。PS：如果你在面试中，曾有过被MySQL相关问题难住的经历，也可以把这个问题发到评论区，</p>
<p>我们一起来讨论。如果解答这个问题，需要的篇幅会很长的话，我可以放到答疑文章展开。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-行锁功过：怎么减少行锁对性能的影响</title>
    <url>/posts/3f0fbdd7.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>07 | 行锁功过：怎么减少行锁对性能的影响？2018-11-28 林晓斌</p>
<p>在上一篇文章中，我跟你介绍了MySQL的全局锁和表级锁，今天我们就来讲讲MySQL的行锁。MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如</p>
<p>MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同</p>
<p>一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，</p>
<p>这也是MyISAM被InnoDB替代的重要原因之一。我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候</p>
<p>事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导</p>
<p>致程序出现非预期行为，比如两阶段锁。从两阶段锁说起</p>
<p>我先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字</p>
<p>段id是表t的主键。这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才</p>
<p>能继续执行。知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释</p>
<p>放，而是要等到事务结束时才释放。这个就是两阶段锁协议。知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把</p>
<p>最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个</p>
<p>业务需要涉及到以下操作：</p>
<ol>
<li><p>从顾客A账户余额中扣除电影票价；</p>
</li>
<li><p>给影院B的账户余额增加这张电影票价；</p>
</li>
<li><p>记录一条交易日志。也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交</p>
</li>
</ol>
<p>易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的</p>
<p>顺序呢？试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为</p>
<p>它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才</p>
<p>释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额</p>
<p>这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，</p>
<p>这并没有完全解决你的困扰。如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动</p>
<p>时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库</p>
<p>每秒就执行不到100个事务。这是什么原因呢？这里，我就要说到死锁和死锁检测了。死锁和死锁检测</p>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致</p>
<p>这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和</p>
<p>事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数</p>
<p>innodb_lock_wait_timeout来设置。另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事</p>
<p>务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现</p>
<p>死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于</p>
<p>在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确</p>
<p>实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会</p>
<p>出现很多误伤。所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且</p>
<p>innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发</p>
<p>现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁</p>
<p>住，如此循环，最后判断是否出现了循环等待，也就是死锁。那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是</p>
<p>O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级</p>
<p>的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到</p>
<p>CPU利用率很高，但是每秒却执行不了几个事务。根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结</p>
<p>在于，死锁检测要耗费大量的CPU资源。一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检</p>
<p>测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严</p>
<p>重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关</p>
<p>掉死锁检测意味着可能会出现大量的超时，这是业务有损的。另一个思路是控制并发度。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时</p>
<p>最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法</p>
<p>就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过</p>
<p>一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务</p>
<p>端以后，峰值并发数也可能要达到3000。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的</p>
<p>团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，</p>
<p>在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。可能你会问，如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设</p>
<p>计上优化这个问题呢？你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多</p>
<p>条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账</p>
<p>户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等</p>
<p>待个数，也就减少了死锁检测的CPU消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会</p>
<p>减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处</p>
<p>理。小结</p>
<p>今天，我和你介绍了MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的</p>
<p>原则&#x2F;我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并</p>
<p>发度的锁的申请时机尽量往后放。但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了</p>
<p>三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事</p>
<p>务量。最后，我给你留下一个问题吧。如果你要删除一个表里面的前10000行数据，有以下三种方法可</p>
<p>以做到：</p>
<p>第一种，直接执行delete from T limit 10000;</p>
<p>第二种，在一个连接中循环执行20次 delete from T limit 500;</p>
<p>第三种，在20个连接中同时执行delete from T limit 500。你会选择哪一种方法呢？为什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我给你留的问题是：当备库用–single-transaction做逻辑备份的时候，如果从主库的binlog传</p>
<p>来一个DDL语句会怎么样？假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p>
<p>Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</p>
<p>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</p>
<p>&#x2F;* other tables *&#x2F;</p>
<p>Q3:SAVEPOINT sp;</p>
<p>&#x2F;* 时刻 1 *&#x2F;</p>
<p>Q4:show create table <code>t1</code>;</p>
<p>&#x2F;* 时刻 2 *&#x2F;</p>
<p>Q5:SELECT * FROM <code>t1</code>;</p>
<p>&#x2F;* 时刻 3 *&#x2F;</p>
<p>Q6:ROLLBACK TO SAVEPOINT sp;</p>
<p>&#x2F;* 时刻 4 *&#x2F;</p>
<p>&#x2F;* other tables *&#x2F;</p>
<p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p>
<p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性</p>
<p>视图（Q2)；</p>
<p>设置一个保存点，这个很重要（Q3）；</p>
<p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这</p>
<p>里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，</p>
<p>如果开始执行，则很快能够执行完成。参考答案如下：</p>
<ol>
<li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。2. 如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed,</li>
</ol>
<p>please retry transaction，现象：mysqldump终止；</p>
<ol start="3">
<li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：</li>
</ol>
<p>主从延迟，直到Q6执行完成。4. 从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表</p>
<p>结构。评论区留言点赞板：</p>
<p>@Aurora 给了最接近的答案；</p>
<p>@echo＿陈 问了一个好问题；</p>
<p>@壹笙☞漂泊 做了很好的总结。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-顾林晓斌：我的 MySQL 心路历程</title>
    <url>/posts/93f81e0.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>直播回顾 | 林晓斌：我的 MySQL 心路历程</p>
<p>2018-12-18 林晓斌</p>
<p>在专栏上线后的11月21日，我来到极客时间做了一场直播，主题就是“我的MySQL心路历程”。今天，我特意将这个直播的回顾文章，放在了专栏下面，希望你可以从我这些年和MySQL打交</p>
<p>道的经历中，找到对你有所帮助的点。这里，我先和你说一下，在这个直播中，我主要分享的内容：</p>
<ol>
<li><p>我和MySQL打交道的经历；</p>
</li>
<li><p>你为什么要了解数据库原理；</p>
</li>
<li><p>我建议的MySQL学习路径；</p>
</li>
<li><p>DBA的修炼之道。我的经历</p>
</li>
</ol>
<p>以丰富的经历进入百度</p>
<p>我是福州大学毕业的，据我了解，那时候我们学校的应届生很难直接进入百度，都要考到浙江大</p>
<p>学读个研究生才行。没想到的是，我投递了简历后居然进了面试。入职以后，我跑去问当时的面试官，为什么我的简历可以通过筛选？他们说：“因为你的简历厚</p>
<p>啊”。我在读书的时候，确实做了很多项目，也实习过不少公司，所以简历里面的经历就显得很</p>
<p>丰富了。在面试的时候，有个让我印象很深刻的事儿。面试官问我说，你有这么多实习经历，有没有什么</p>
<p>比较好玩儿的事？我想了想答道，跟你说个数据量很大的事儿 ，在跟移动做日志分析的时候我</p>
<p>碰到了几千万行的数据。他听完以后就笑了。后来，我进了百度才知道，几千万行那都是小数据。开始尝试看源码解决问题</p>
<p>加入百度后，我是在贴吧做后端程序，比如权限系统等等。其实很简单，就是写一个C语言程</p>
<p>序，响应客户端请求，然后返回结果。那个时候，我还仅仅是个MySQL的普通用户，使用了一段时间后就出现问题了：一个跑得很快</p>
<p>的请求，偶尔会又跑得非常慢。老板问这是什么原因，而我又不好意思说不知道，于是就自己上</p>
<p>网查资料。但是，2008年那会儿，网上资料很少，花了挺长时间也没查出个所以然。最终，我只好去看源</p>
<p>码。翻到源码，我当时就觉得它还蛮有意思的。而且，源码真的可以帮我解决一些问题。于是一发不可收拾，我从那时候就入了源码的“坑”。混社区分享经验</p>
<p>2010年的时候，阿里正好在招数据库的开发人员。虽然那时我还只是看得懂源码，没有什么开</p>
<p>发经验，但还是抱着试试看的态度投了简历。然后顺利通过了面试，成功进入了阿里。之后，我</p>
<p>就跟着褚霸（霸爷）干了7年多才离开了阿里。在百度的时候，我基本上没有参加过社区活动。因为那时候百度可能更提倡内部分享，解决问题</p>
<p>的经验基本上都是在内网分享。所以，去了阿里以后，我才建了博客、开了微博。我在阿里的花</p>
<p>名叫丁奇，博客、微博、社区也因此都是用的这个名字。为什么要了解数据库原理？这里，我讲几个亲身经历的事情，和你聊聊为什么要了解数据库原理。了解原理能帮你更好地定位问题</p>
<p>一次同学聚会，大家谈起了技术问题。一个在政府里的同学说，他们的系统很奇怪，每天早上都</p>
<p>得重启一下应用程序，否则就提示连接数据库失败，他们都不知道该怎么办。我分析说，按照这个错误提示，应该就是连接时间过长了，断开了连接。数据库默认的超时时间</p>
<p>是8小时，而你们平时六点下班，下班之后系统就没有人用了，等到第二天早上九点甚至十点才</p>
<p>上班，这中间的时间已经超过10个小时了，数据库的连接肯定就会断开了。我当时说，估计这个系统程序写得比较差，连接失败也不会重连，仍然用原来断掉的连接，所以</p>
<p>就报错了。然后，我让他回去把超时时间改得长一点。后来他跟我说，按照这个方法，问题已经</p>
<p>解决了。由此，我也更深刻地体会到，作为开发人员，即使我们只知道每个参数的意思，可能就可以给出</p>
<p>一些问题的正确应对方法。了解原理能让你更巧妙地解决问题</p>
<p>我在做贴吧系统的时候，每次访问页面都要请求一次权限。所以，这个请求权限的请求，访问概</p>
<p>率会非常高，不可能每次都去数据库里查，怎么办呢？我想了个简单的方案：在应用程序里面开了个很大的内存，启动的时候就把整张表全部load到内</p>
<p>存里去。这样再有权限请求的时候，直接从内存里取就行了。数据库重启时，我的进程也会跟着重启，接下来就会到数据表里面做全表扫描，把整个用户相关</p>
<p>信息全部塞到内存里面去。但是，后来我遇到了一个很郁闷的情况。有时候MySQL 崩溃了，我的程序重新加载权限到内存</p>
<p>里，结果这个select语句要执行30分钟左右。本来MySQL正常重启一下是很快的，进程重启也很</p>
<p>快，正常加载权限的过程只需要两分钟就跑完了。但是，为什么异常重启的时候就要30分钟</p>
<p>呢？我没辙了，只好去看源码。然后，我发现MySQL有个机制，当它觉得系统空闲时会尽量去刷脏</p>
<p>页。具体到我们的例子里，MySQL重启以后，会执行我的进程做全表扫描，但是因为这个时候权限</p>
<p>数据还没有初始化完成，我的Server层不可能提供服务，于是MySQL里面就只有我那一个select</p>
<p>全表扫描的请求，MySQL就认为现在很闲，开始拼命地刷脏页，结果就吃掉了大量的磁盘资</p>
<p>源，导致我的全表扫描也跑得很慢。知道了这个机制以后，我就写了个脚本，每隔0.5秒发一个请求，执行一个简单的SQL查询，告</p>
<p>诉数据库其实我现在很忙，脏页刷得慢一点。脚本一发布使用，脏页果然刷得慢了，加载权限的扫描也跑得很快了。据说我离职两年多以后，</p>
<p>这个脚本还在用。你看，如果我们懂得一些参数，并可以理解这些参数，就可以做正确的设置了。而如果我们进一</p>
<p>步地懂得一些原理，就可以更巧妙地解决问题了。看得懂源码让你有更多的方法</p>
<p>2012年的时候，阿里双十一业务的压力比较大。当时还没有这么多的SSD，是机械硬盘的时</p>
<p>代。为了应对压力我们开始引入SSD，但是不敢把SSD直接当存储用，而是作为二级缓存。当时，</p>
<p>我们用了一个叫作Flashcache的开源系统（现在已经是老古董级别了，不知道你有没有听过这</p>
<p>个系统）。Flashcache实现，把SSD当作物理盘的二级缓存，可以提升性能。但是，我们自己部署后发现</p>
<p>性能提升的效果没有预想的那么好，甚至还不如纯机械盘。于是，我跟霸爷就开始研究。霸爷负责分析Flashcache的源码，我负责分析MySQL源码。后来</p>
<p>我们发现Flashcache是有脏页比例的，当脏页比例到了80%就会停下来强行刷盘。一开始我们以为这个脏页比例是全部的20%，看了源码才知道，原来它分了很多个桶，比如说一</p>
<p>个桶20M，这个桶如果用完80%，它就认为脏页满了，就开始刷脏页。这也就意味着，如果你是</p>
<p>顺序写的话，很容易就会把一个桶写满。知道了这个原理以后，我就把日志之类顺序写的数据全都放到了机械硬盘，把随机写的数据放到</p>
<p>了Flashcache上。这样修改以后，效果就好了。你看，如果能看得懂源码，你的操作行为就会不一样。MySQL学习路径</p>
<p>说到MySQL的学习路径，其实我上面分享的这些内容，都可以归结为学习路径。首先你要会用，要去了解每个参数的意义，这样你的运维行为（使用行为）就会不一样。千万不</p>
<p>要从网上拿了一些使用建议，别人怎么用，你就怎么用，而不去想为什么。再往后，就要去了解</p>
<p>每个参数的实现原理。一旦你了解了这些原理，你的操作行为就会不一样。 再进一步，如果看</p>
<p>得懂源码，那么你对数据库的理解也会不一样。再来讲讲我是怎么带应届生的。实践是很好的学习方式，所以我会让新人来了以后先搭主备，然</p>
<p>后你就会发现每个人的自学能力都不一样。比如遇到有延迟，或者我们故意构造一个主备数据不</p>
<p>一致的场景，让新人了解怎么分析问题，解决问题。如果一定要总结出一条学习路径的话，那首先要会用，然后可以发现问题。在专栏里面，我在每篇文章末尾，都会提出一个常见问题，作为思考题。这些问题都不会很难，</p>
<p>是跟专栏文章挂钩、又是会经常遇到的，但又无法直接从文章里拿到答案。我的建议是，你可以尝试先不看答案自己去思考，或者去数据库里面翻一翻，这将会是一个不错</p>
<p>的过程。再下一步就是实践。之后当你觉得开始有一些“线”的概念了，再去看MySQL的官方手册。在我</p>
<p>的专栏里，有人曾问我要不要直接去看手册？我的建议是，一开始千万不要着急看手册，这里面有100多万个英文单词，你就算再厉害，也是</p>
<p>看了后面忘了前面。所以，你一定要自己先有脉络，然后有一个知识网络，再看手册去查漏补</p>
<p>缺。我自己就是这么一路走过来的。另外，在专栏的留言区，很多用户都希望我能推荐一本书搭配专栏学习。如果只推荐一本的话，</p>
<p>我建议你读一下《高性能MySQL》这本书，它是MySQL这个领域的经典图书，已经出到第三版</p>
<p>了，你可以想象一下它的流行度。这本书的其中两位译者（彭立勋、翟卫祥）是我原团队的小伙伴，有着非常丰富的MySQL源码</p>
<p>开发经验，他们对MySQL的深刻理解，让这本书保持了跟原作英文版同样高的质量。极客时间的编辑说，他们已经和出版社沟通，为我们专栏的用户争取到了全网最低价，仅限3</p>
<p>天，你可以直接点击链接购买。DBA的修炼</p>
<p>DBA和开发工程师有什么相同点？我带过开发团队，也带过DBA团队，所以可以分享一下这两个岗位的交集。其实，DBA本身要有些开发底子，比如说做运维系统的开发。另外，自动化程度越高，DBA的</p>
<p>日常运维工作量就越少，DBA得去了解开发业务逻辑，往业务架构师这个方向去做。开发工程师也是一样，不能所有的问题都指望DBA来解决。因为，DBA在每个公司都是很少的</p>
<p>几个人。所以，开发也需要对数据库原理有一定的了解，这样向DBA请教问题时才能更专业，</p>
<p>更高效地解决问题。所以说，这两个岗位应该有一定程度的融合，即：开发要了解数据库原理，DBA要了解业务和</p>
<p>开发。DBA有前途吗？这里我要强调的是，每个岗位都有前途，只需要根据时代变迁稍微调整一下方向。像原来开玩笑说DBA要体力好，因为得搬服务器。后来DBA的核心技能成了会搭库、会主备切</p>
<p>换，但是现在这些也不够用了，因为已经有了自动化系统。所以，DBA接下来一方面是要了解业务，做业务的架构师；另一方面，是要有前瞻性，做主动</p>
<p>诊断系统，把每个业务的问题挑出来做成月报，让业务开发去优化，有不清楚的地方，开发同学</p>
<p>会来找你咨询。你帮助他们做好了优化之后，可以把优化的指标呈现出来。这将很好地体现出你</p>
<p>对于公司的价值。有哪些比较好的习惯和提高SQL效率的方法？这个方法，总结起来就是：要多写SQL，培养自己对SQL语句执行效率的感觉。以后再写或者建</p>
<p>索引的时候，知道这个语句执行下去大概的时间复杂度，是全表扫描还是索引扫描、是不是需要</p>
<p>回表，在心里都有一个大概的概念。这样每次写出来的SQL都会快一点，而且不容易犯低级错误。这也正式我开设这个专栏的目标。看源码需要什么技术？看源码的话，一是要掌握C和C++；另外还要熟悉一些调试工具。因为代码是静态的，运行起来</p>
<p>是动态的，看代码是单线程的，运行起来是多线程的，所以要会调试。另外，我不建议你用可视化的工具。虽然可视化工具很方便，但你不知道这个操作点下去以后，</p>
<p>实际上做了什么，所以我建议你自己手写代码和SQL语句，这样对一些底层原理你会更明白。怎么学习C、C++？我在读研究生的时候，在C和C++语言的学习上进步最大。那时，我去给专科上C和C++的课。我觉得自己已经会了，完全可以教得了。但去了之后，我才</p>
<p>知道，自己会跟能够教别人完全是两码事儿。备课的时候，你不能只讲会用的部分，还得把原理</p>
<p>讲清楚。这样，就会倒逼自己进行更深入更全面的学习。有的人看完技术博客和专栏，会把这篇文章的提纲列一下，写写自己的问题和对这篇文章的理</p>
<p>解。这个过程，是非常利于学习的。因为你听进来是一回事儿，讲出去则是另一回事儿。学数据库要保持什么心态？不只是数据库，所有多线程的服务，调试和追查问题的过程都是很枯燥的，遇到问题都会很麻</p>
<p>烦。但是，你找出问题时的那一下会很爽。我觉得你得找到这种感觉，它可以支持你度过接下来要枯燥很久的那段时光，这样你才能继续坚</p>
<p>持下去。当然，如果有更快乐的学习过程还是更好的，希望这个专栏能让你学习得轻松些。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>conda使用指南</title>
    <url>/posts/1d208056.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以安装Anaconda<br>通过Anaconda Prompts进入conda 命令行</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="更换为国内源"><a href="#更换为国内源" class="headerlink" title="更换为国内源"></a>更换为国内源</h2><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><p>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</a></p>
<h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><p>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/main/">https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/free/">https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/">https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/">https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/">https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/">https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</a><br>conda config –set show_channel_urls yes<br>conda config –remove-key channels</p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>1.验证conda是否被安装：conda –version(查看conda版本的一个命令)<br>2.更新conda至最新的版本:conda update conda<br>3.conda –help:查看conda帮助信息<br>4.conda list:查看当前环境中已安装的包信息<br>5.conda search –full-name 包名  精确查找可供安装的包版本<br>6.conda search 包名的一部分名称  模糊查找可供安装的包版本<br>7.conda install 包名  在当前环境中安装包(当使用conda install无法进行安装时，可以使用pip install进行安装,pip install无法安装的时候，可以使用conda install 安装)<br>8.conda remove 包名   卸载当前环境中的包<br>9.conda update –all   更新所有包<br>10.conda update 包名   更新指定包</p>
<p>默认情况下，新创建的环境将会被保存在&#x2F;Users&#x2F;<user_name>&#x2F;anaconda3&#x2F;env目录下，其中，<user_name>为当前用户的用户名。<br>创建新的环境<br>conda create –name 新的python环境的名称<br>conda create –name 新的python环境的名称 python&#x3D;要安装的python版本<br>conda create –name 新的python环境的名称 python&#x3D;要安装的python版本 要安装的包名</user_name></user_name></p>
<p>切换环境<br>activate python环境名称   切换到xx环境中<br>deactivate python环境名称  退出xx环境</p>
<p>conda env list ：显示已创建的环境<br>conda create –name 新的虚拟环境名称 –clone 要克隆的虚拟环境名称<br>conda remove –name 虚拟环境的名称 –all</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>cuda安装</title>
    <url>/posts/bcc8f365.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="默认安装位置"><a href="#默认安装位置" class="headerlink" title="默认安装位置"></a>默认安装位置</h2><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</p>
<p>nvcc –version 查看安装版本（环境变量配置）</p>
<h2 id="cuda下载地址"><a href="#cuda下载地址" class="headerlink" title="cuda下载地址"></a>cuda下载地址</h2><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10">https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10</a></p>
<h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p>
<h2 id="cudnn下载地址"><a href="#cudnn下载地址" class="headerlink" title="cudnn下载地址"></a>cudnn下载地址</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></p>
<h3 id="版本关系和查看"><a href="#版本关系和查看" class="headerlink" title="版本关系和查看"></a>版本关系和查看</h3><p>cuda： Compute Unified Device Architecture，是一种有NVIDIA推出的通用并行计算架构， 该架构使GPU能够解决复杂的计算问题。</p>
<p>cudnn： 是NVIDIA 推出的用于深度神经网络的GPU加速库，他强调性能，易用性和低内存开销。</p>
<p>cuda和cudnn的关系： cudnn是基于cuda架构开发的专门用于深度神经网络的GPU加速库。cuda可以理解为一个大的商圈，但这个商圈是空的，还未装修。cudnn可以理解为装修后的房间，例如负一楼专门针对游乐（深度神经网络）装修成大型游乐厂。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>plt绘图</title>
    <url>/posts/8c2e92d2.html</url>
    <content><![CDATA[<h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplotasplt</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">r_basicdx=redis.Redis(host=<span class="string">&#x27;172.20.3.52&#x27;</span>,port=<span class="number">6373</span>,db=<span class="number">1</span>)</span><br><span class="line">l_basicdx=redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">6379</span>,db=<span class="number">1</span>)</span><br><span class="line">keys=r_basicdx.keys()</span><br><span class="line">forkeyinkeys:</span><br><span class="line">value=r_basicdx.get(key)</span><br><span class="line">l_basicdx.<span class="built_in">set</span>(key,value)</span><br><span class="line">image=pickle.loads(value)</span><br><span class="line">f=plt.figure()</span><br><span class="line">ax=f.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.text(<span class="number">0.1</span>,<span class="number">0.9</span>,key,ha=<span class="string">&#x27;center&#x27;</span>,va=<span class="string">&#x27;center&#x27;</span>,transform=ax.transAxes)</span><br><span class="line">plt.imshow(image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python-数学</title>
    <url>/posts/25757.html</url>
    <content><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="数学分析-概率论基础"><a href="#数学分析-概率论基础" class="headerlink" title="数学分析 概率论基础"></a>数学分析 概率论基础</h2><h3 id="导数与梯度"><a href="#导数与梯度" class="headerlink" title="导数与梯度"></a>导数与梯度</h3><h3 id="taylor展式的应用"><a href="#taylor展式的应用" class="headerlink" title="taylor展式的应用"></a>taylor展式的应用</h3><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>数据收集</li>
<li>数据清洗</li>
<li>特征工程</li>
<li>数据建模</li>
</ol>
<h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><p>线性回归、rate、loss</p>
<p>em code</p>
<p>em算法</p>
<p>gmm与图像</p>
<p>图像的卷积</p>
<p>去均值ICA分离</p>
<p>带噪声的信号分离</p>
<p>SVM: 高斯核函数的影响</p>
<p>HMM分词：MLE</p>
<p>LDA</p>
<p>舆情</p>
<p>最大熵模型</p>
<p>聚类</p>
<p>降维</p>
<p>SVM</p>
<p>主题模型pLASA&#x2F;LDA</p>
<p>条件随机场</p>
<p>变分推导Variation Inference</p>
<p>深度学习</p>
<p>$$ S&#x3D;\frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \frac{1}{4!} + \frac{1}{4!} + \Lambda + \frac{1}{n!}  $$</p>
<p>跳跃表分析</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>pytorch使用指南</title>
    <url>/posts/936ee6a2.html</url>
    <content><![CDATA[<h1 id="安装构建"><a href="#安装构建" class="headerlink" title="安装构建"></a>安装构建</h1><p><a href="https://www.tensorflow.org/install/source_windows">https://www.tensorflow.org/install/source_windows</a></p>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p><a href="https://www.tensorflow.org/learn#prepare-data">https://www.tensorflow.org/learn#prepare-data</a></p>
<h1 id="调试模型"><a href="#调试模型" class="headerlink" title="调试模型"></a>调试模型</h1><p><a href="https://www.tensorflow.org/learn#build-models">https://www.tensorflow.org/learn#build-models</a></p>
<h1 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h1><p><a href="https://www.tensorflow.org/learn#deploy-models">https://www.tensorflow.org/learn#deploy-models</a></p>
<h1 id="生产应用"><a href="#生产应用" class="headerlink" title="生产应用"></a>生产应用</h1><p><a href="https://www.tensorflow.org/learn#implement-mlops">https://www.tensorflow.org/learn#implement-mlops</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow使用指南</title>
    <url>/posts/676b1804.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以安装Anaconda<br>通过Anaconda Prompts进入conda 命令行</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="更换为国内源"><a href="#更换为国内源" class="headerlink" title="更换为国内源"></a>更换为国内源</h2><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><p>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</a></p>
<h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><p>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/main/">https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/free/">https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/">https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/">https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/">https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/">https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</a></p>
<h3 id="搜索时显示通道地址"><a href="#搜索时显示通道地址" class="headerlink" title="搜索时显示通道地址"></a>搜索时显示通道地址</h3><p>conda config –set show_channel_urls yes</p>
<h3 id="还原原始通道"><a href="#还原原始通道" class="headerlink" title="还原原始通道"></a>还原原始通道</h3><p>conda config –remove-key channels</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>一些好的技术博客</title>
    <url>/posts/39a747bc.html</url>
    <content><![CDATA[<p>陈梓瀚 <a href="http://cppblog.com/vczh">http://cppblog.com/vczh</a></p>
<p>赵劼 <a href="http://blog.zhaojie.me/">http://blog.zhaojie.me/</a></p>
<p>martin <a href="https://www.martinfowler.com/">https://www.martinfowler.com/</a></p>
<p>jakewharton <a href="https://jakewharton.com/">https://jakewharton.com/</a></p>
<p>stallman <a href="https://stallman.org/">https://stallman.org/</a></p>
]]></content>
      <categories>
        <category>records</category>
      </categories>
  </entry>
  <entry>
    <title>量化交易</title>
    <url>/posts/28981.html</url>
    <content><![CDATA[<p>投资决策模型化，基于历史数据验证，交易自动执行</p>
<p>股市波动，长期、短期、相对</p>
<h2 id="投资指标"><a href="#投资指标" class="headerlink" title="投资指标"></a>投资指标</h2><h3 id="风险收益率"><a href="#风险收益率" class="headerlink" title="风险收益率"></a>风险收益率</h3><p>夏普率&#x3D;（收益-无风险利率）&#x2F;波动率</p>
<h3 id="胜率赔率"><a href="#胜率赔率" class="headerlink" title="胜率赔率"></a>胜率赔率</h3><p>胜率是指出手赚钱次数与总出手次数之比</p>
<p>赔率是指平均每次出手赚到的钱除以平均每次出手赔的钱，也叫做盈亏比</p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="阿尔法策略"><a href="#阿尔法策略" class="headerlink" title="阿尔法策略"></a>阿尔法策略</h3><p>优点：不管指数是涨还是下跌，都能赚钱的一种方法，具体的操作思路是找出市场里最优秀的品种，做多这些品种，然后做空相应多的指数，这样就锁定了最优秀的品种带来的收益，而把指数带来的波动进行了平抑。<br>缺点：回撤和收益都比较小的交易策略</p>
<h3 id="程序化CTA"><a href="#程序化CTA" class="headerlink" title="程序化CTA"></a>程序化CTA</h3><p>优点：适合大众使用的程序化交易方法，是指将交易策略的思想设计成完整的逻辑运行体系，然后用合适的计算机语言编写成程序，有计算机进行自动交易。程序化交易的优点是，将交易模式系统化，制度化，排除人性的心理障碍，确保交易策略的执行行。挣的是趋势的钱，挣的是纪律的钱，但因为趋势不常有，所以这是一种低胜率，高赔率的方法。</p>
<p>入场条件、出场条件，品种选择、时机选择，资金管理</p>
<h3 id="统计套利"><a href="#统计套利" class="headerlink" title="统计套利"></a>统计套利</h3><p>通过计算某些关联品种之间出现了价差的扩大，那就可以在品种之间进行配对交易，从而进行套利</p>
<h3 id="低风险套利"><a href="#低风险套利" class="headerlink" title="低风险套利"></a>低风险套利</h3><p>ETF套利也是一种低风险套利，比如某个ETF指数基金现在的价格是2.1，而如果我们用一揽子股票来组成这个ETF指数基金，价格是2块，那么我们就可以在市场上卖出基金，买入股票，来得到这0.1的差价。这些套利比较容易执行，收入也很可观，而且风险很小。</p>
<h3 id="高频交易"><a href="#高频交易" class="headerlink" title="高频交易"></a>高频交易</h3><p>利用计算机处理市场微观结构层面的不均衡性，往往交易次数多，持仓时间短，可能会送大量交易指令，又快速撤单，再反向做交易获得收益，每笔交易平均利润小但稳定。</p>
<p>优点是总收益率极高，当日平仓降低隔夜风险，隔夜资金利息收入降低资金成本，绩效评估周期短。</p>
<h3 id="算法交易"><a href="#算法交易" class="headerlink" title="算法交易"></a>算法交易</h3><p>降低冲击成本的一种被动的程序化交易，通过科学的成本估算模型和交易实施算法，将一个大额的交易拆分成系列小额交易 在合理的时间点分别执行，以此来尽量减少 对市场价格造成的冲击，降低交易成本，而且还能帮助机构投资者快速增加交易量。适合的对象包括大小非减持者，大宗交易接盘出货，“大宗交易-融券卖出”套利者，Alpha套利者，套期保值者，日以上级别程序化交易者等。</p>
<p>参考：<a href="https://www.jianshu.com/p/2c470ef5d083">https://www.jianshu.com/p/2c470ef5d083</a></p>
]]></content>
      <categories>
        <category>quant</category>
      </categories>
  </entry>
  <entry>
    <title>谷歌账号停用</title>
    <url>/posts/4107aa29.html</url>
    <content><![CDATA[<h2 id="停用原因"><a href="#停用原因" class="headerlink" title="停用原因"></a>停用原因</h2><p>使用了代理，频繁的切换IP地区</p>
<h2 id="申诉方法"><a href="#申诉方法" class="headerlink" title="申诉方法"></a>申诉方法</h2><p>登陆账号，按照提示申诉</p>
<p>申诉模板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">您好我的账户是xxxxx@gmail.com。我是中国区用户，必需使用vpn代理才能使用谷歌产品，可能由于vpn的不稳定和频繁切换造成账号异常被停用，这个账号对我很重要，希望您可以帮我解决一下，非常感谢。</span><br><span class="line">Hello my account is xxxxx@gmail.com. I am a user in China, must use VPN proxy to use Google products, may be due to VPN instability and frequent switching caused by abnormal account deactivation, this account is very important to me, I hope you can help me solve it, thank you very much.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>records</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>申诉</tag>
      </tags>
  </entry>
  <entry>
    <title>redis统计信息--INFO</title>
    <url>/posts/56223.html</url>
    <content><![CDATA[<p>显示关于redis服务器的状态报告和统计数值</p>
<pre><code>    redis&gt; INFO
    # Server
    redis_version:2.9.11 //服务器版本
    redis_git_sha1:937384d0
    redis_git_dirty:0
    redis_build_id:8e9509442863f22
    redis_mode:standalone  //mode
    os:Linux 3.13.0-35-generic x86_64
    arch_bits:64
    multiplexing_api:epoll //事件处理机制
    gcc_version:4.8.2
    process_id:4716 //进程ID
    run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc  //随机标识符（用于 Sentinel 和集群）
    tcp_port:6379   //监听端口号
    uptime_in_seconds:362  //启动以来，经过的秒数
    uptime_in_days:0  //启动以来，经过的天数
    hz:10  //serverCron运行频率，此值越大表示redis对&quot;间歇性task&quot;的执行次数越频繁(次数/秒)
    lru_clock:1725349  //以分钟为单位进行自增的时钟，用于 LRU 管理
    config_file:
    
    # Clients
    connected_clients:1  //已连接客户端的数量（不包括通过从属服务器连接的客户端）
    client_longest_output_list:0  //当前连接的客户端当中，最长的输出列表
    client_biggest_input_buf:0  //当前连接的客户端当中，最大输入缓存
    blocked_clients:0 //正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量
    
    # Memory
    used_memory:508536  //由 Redis 分配器分配的内存总量，以字节（byte）为单位
    used_memory_human:496.62K  //以人类可读的格式返回 Redis 分配的内存总量
    used_memory_rss:7974912  //从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。
    //理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿  
    //当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片
    //当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。
    used_memory_peak:508536 //Redis 的内存消耗峰值（以字节为单位）
    used_memory_peak_human:496.62K //以人类可读的格式返回 Redis 的内存消耗峰值
    used_memory_lua:33792  // Lua 引擎所使用的内存大小（以字节为单位）
    mem_fragmentation_ratio:15.68  //used_memory_rss 和 used_memory 之间的比率
    mem_allocator:jemalloc-3.2.0  //在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc
    
    # Persistence
    loading:0  //一个标志值，记录了服务器是否正在载入持久化文件  
    rdb_changes_since_last_save:6 //距离最近一次成功创建持久化文件之后，经过了多少秒
    rdb_bgsave_in_progress:0 //一个标志值，记录了服务器是否正在创建 RDB 文件
    rdb_last_save_time:1411011131 //最近一次成功创建 RDB 文件的 UNIX 时间戳
    rdb_last_bgsave_status:ok //一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败
    rdb_last_bgsave_time_sec:-1 //记录了最近一次创建 RDB 文件耗费的秒数
    rdb_current_bgsave_time_sec:-1 // 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
    aof_enabled:0 //标志值，记录了 AOF 是否处于打开状态。
      //如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：    
      // aof_current_size : AOF 文件目前的大小。
      // aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。
      // aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。
      // aof_buffer_length : AOF 缓冲区的大小。
      // aof_rewrite_buffer_length : AOF 重写缓冲区的大小。
      // aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。
      // aof_delayed_fsync : 被延迟的 fsync 调用数量。
    aof_rewrite_in_progress:0 //一个标志值，记录了服务器是否正在创建 AOF 文件。
    aof_rewrite_scheduled:0 //一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作
    aof_last_rewrite_time_sec:-1 //最近一次创建 AOF 文件耗费的时长。
    aof_current_rewrite_time_sec:-1 //如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒
    aof_last_bgrewrite_status:ok //一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。
    aof_last_write_status:ok //
    
    # Stats
    total_connections_received:2 //服务器已接受的连接请求数量
    total_commands_processed:4 //服务器已执行的命令数量
    instantaneous_ops_per_sec:0 //服务器每秒钟执行的命令数量
    rejected_connections:0 //因为最大客户端数量限制而被拒绝的连接请求数量
    sync_full:0 
    sync_partial_ok:0 
    sync_partial_err:0
    expired_keys:0 //因为过期而被自动删除的数据库键数量
    evicted_keys:0 //因为最大内存容量限制而被驱逐（evict）的键数量。
    keyspace_hits:0 //查找数据库键成功的次数。
    keyspace_misses:0 //查找数据库键失败的次数。
    pubsub_channels:0 //目前被订阅的频道数量。
    pubsub_patterns:0 //目前被订阅的模式数量。
    latest_fork_usec:0 //最近一次 fork() 操作耗费的毫秒数。
    migrate_cached_sockets:0
    
    # Replication
    role:master //如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。
    connected_slaves:0
    master_repl_offset:0
    repl_backlog_active:0
    repl_backlog_size:1048576
    repl_backlog_first_byte_offset:0
    repl_backlog_histlen:0
    
    # CPU
    used_cpu_sys:0.21  // Redis 服务器耗费的系统 CPU 。
    used_cpu_user:0.17  // Redis 服务器耗费的用户 CPU 。
    used_cpu_sys_children:0.00 //后台进程耗费的系统 CPU 。
    used_cpu_user_children:0.00 //后台进程耗费的用户 CPU 。
    
    # Cluster
    cluster_enabled:0  //一个标志值，记录集群功能是否已经开启
    
    # Keyspace
    db0:keys=2,expires=0,avg_ttl=0 //部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。
</code></pre>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/posts/41634.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>图是由顶点集（VertexSet）和边集（EdgeSet）组成，针对图G，顶点集和边集分别记为V(G)和E(G)。依据图的边集是否为有向，可把图分为有向图和无向图，根据图是否有权重，可以分为有权图和无权图</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li>邻接点-在一个无向图中，若存在一条边<code>&lt;Vi,Vj&gt;</code>，则称Vi，Vj为此边的两个端点，并称它们互为邻接点</li>
<li>出&#x2F;入边-在一个有向图张，若存在一条边<code>&lt;Vi,Vj&gt;</code>，则称此边为顶点Vi的出边，顶点Vj的一条入边</li>
<li>度&#x2F;入度&#x2F;出度-无向图中的度定义为以该顶点为一个端点的边的数目，记为D(V)。有向图的入度定为多少边指向该顶点，出度是该顶点出边的个数</li>
</ol>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><code>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。对于无向图 如果顶点b1和b2是连接的，那么在二维矩阵中matrix[b1,b2]和matrix[b2,b1]位置的值置为1，如果是有向图b1指向b2，那么 matrix[b1,b2]=1,matrix[b2,b1]=0；下面用一个例子表示无向图和有向图的邻接矩阵；</code></p>
<p>如果图是一个带权图，需要把1换为相应边上的权值，把非对角线上的换成一个很大的特定的实数则可，表示相应的边不存在，这个特定的实数通常用无穷大或MaxValue来表示，他要大于图G中所有边的权值</p>
<p><a href="#matrix">代码实现</a></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接矩阵与邻接表相比，它会造成空间的一定损失，它需要为每个顶点都分配n个边的空间，其实有很多边都是不存在边，但是邻接表的实现就不一样，它只关心存在的边，不关心不存在的边。邻接表由数组+链表组成对于上面的无向图，邻接表表示为（由于有向和无向的差别不是太大，所以只是画出了无向的邻接表表示）</p>
<p><a href="#table">代码实现</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><span id="matrix">邻接矩阵实现</span></p>
<pre><code>package Graph;
//边集数组 ，存放边的信息
//邻域数组表示  和 邻域表表示  是两种不同的表示方式
//表示的是插入边的元素，边的起点和终点  边的权重
public class EdgeElement &#123;
    int fromvex;
    int endvex;
    int weight;
    
    public EdgeElement(int v1,int v2)&#123;
        //对于无权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=1;
    &#125;
    public EdgeElement(int v1,int v2,int wgt)&#123;
        //对于有权重图的初始化
        fromvex=v1;
        endvex=v2;
        weight=wgt;
    &#125;	
&#125;


package Graph;
//可以通过边集来得到一个图的构成
public interface Graph &#123;
    void creatGraph(EdgeElement d[]);		//通过边结点来构建一个图
    GraphType graphType();				//返回图的类型  无向无权图 无向有权图  有向无权图  有向有权图 定义一个枚举变量
    int vertices();					//返回图的顶点数
    int edges();					//返回图的边数
    boolean find(int i,int j);			//从图中查找一条边(i,j)是否存在
    void putEdge(EdgeElement theEdge);		//像图中插入一条边 theEdge
    void removeEdge(int i,int j);			//从图中删除一条边
    int degree(int i);				//返回顶点i的度
    int inDegree(int i);				//返回顶点i的入度
    int outDegree(int i);				//返回顶点i的出度
    void output();					//以图的顶点集和边集的形式输出一个图
    void depthFirstSearch(int v);			//从顶点v开始深度优先搜索整幅图
    void breadthFirstSearch(int v);			//从顶点v开始广度优先搜索整幅图
&#125;

//在邻域数组中写数据
public void creatGraph(EdgeElement[] d) &#123;
    int i;
    for(i=0;i&lt;d.length;i++)&#123;
        if(d[i]==null) break;
        int v1,v2;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2)&#123;
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        &#125;
        if(type==GraphType.NoDirectionNoWeight)&#123;
            a[v1][v2]=a[v2][v1]=1;
        &#125;else if(type==GraphType.NoDirectionWeight)&#123;
            a[v1][v2]=a[v2][v1]=d[i].weight;
        &#125;else if(type==GraphType.DirectionNoWeight)&#123;
            a[v1][v2]=1;
        &#125;else&#123;
            a[v1][v2]=d[i].weight;
        &#125;
    &#125;
    e=i;			//边的数目
&#125;

public void putEdge(EdgeElement theEdge) &#123;
    int v1,v2;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2)&#123;
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    &#125;
    if(a[v1][v2]==0 || a[v1][v2]==MaxValue) e++;		//边数e的值加一
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;
        if(type==GraphType.NoDirectionNoWeight)&#123;
            a[v1][v2]=a[v2][v1]=1;
        &#125;else&#123;
            a[v1][v2]=a[v2][v1]=theEdge.weight;
        &#125;
    &#125;else&#123;
        if(type==GraphType.DirectionNoWeight) a[v1][v2]=1;
        else&#123;
            a[v1][v2]=theEdge.weight;
        &#125;
    &#125;
&#125;

public void removeEdge(int i, int j) &#123;
    if(i&lt;0 || i&gt;n-1 || j&lt;0 || j&gt;n-1 || i==j)&#123;
        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);
        System.exit(0);
    &#125;
    if(a[i][j]==0 || a[i][j]==MaxValue)&#123;
        System.out.println(&quot;要删除的边不存在，退出运行！&quot;);
        System.exit(0);			
    &#125;
    if(type==GraphType.NoDirectionNoWeight)&#123;
        a[i][j]=a[j][i]=0;
    &#125;else if(type==GraphType.NoDirectionWeight)&#123;
        a[i][j]=a[j][i]=MaxValue;
    &#125;else if(type==GraphType.DirectionNoWeight)&#123;
        a[i][j]=0;
    &#125;else a[i][j]=MaxValue;
    e--;
&#125;

//得到该结点的度
public int degree(int i) &#123;
    if(i&lt;0 || i&gt; n-1)&#123;
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    &#125;
    int k=0;
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            if(a[i][j]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;
            
        &#125;
    &#125;else&#123;
        k = inDegree(i)+outDegree(i);
    &#125;
    return k;
&#125;
//入度
public int inDegree(int i) &#123;					
    if(i&lt;0 || i&gt; n-1)&#123;
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    &#125;
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;
        return -1;
    &#125;
    int k=0;
    for(int j=0;j&lt;n;i++)&#123;
        if(a[j][i]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;
    &#125;
    return k;
&#125;
//出度
public int outDegree(int i) &#123;
    if(i&lt;0 || i&gt; n-1)&#123;
        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);
        System.exit(0);
    &#125;
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;
        return -1;
    &#125;
    int k=0;
    for(int j=0;j&lt;n;i++)&#123;
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue) k++;
    &#125;
    return k;
&#125;

//输出
public void output() &#123;
    int i,j;
    System.out.print(&quot;V=&#123;&quot;);//输出顶点集合
    for(i=0;i&lt;n-1;i++)&#123;
        System.out.print(i+&quot;,&quot;);
    &#125;
    System.out.print(n-1+&quot;&#125;&quot;);//输出顶点集合
    //输出边集合
    System.out.print(&quot;E=&#123;&quot;);
    if(type==GraphType.NoDirectionNoWeight || type==GraphType.DirectionNoWeight)&#123;
        for(i=0;i&lt;n;i++)&#123;
            for(j=0;j&lt;n;j++)&#123;
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue)&#123;
                    if(type==GraphType.NoDirectionNoWeight)&#123;
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;),&quot;);
                    &#125;else&#123;
                        System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;else&#123;
        for(i=0;i&lt;n;i++)&#123;
            for(j=0;j&lt;n;j++)&#123;
                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue)&#123;
                    if(type==GraphType.NoDirectionWeight)&#123;
                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;+a[i][j]+&quot;,&quot;);
                    &#125;else System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;+a[i][j]+&quot;,&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
    System.out.print(&quot;&#125;&quot;);
&#125;

//深度优先进行搜索   是从哪个顶点开始遍历，这里可以用顶点序号表示顶点
public void depthFirstSearch(int v) &#123;		//驱动函数
    boolean visited[]=new boolean[n];
    for(int i=0;i&lt;n;i++)&#123;
        visited[i]=false;
    &#125;
    dfs(v,visited);							//把每个结点遍历一次。
    System.out.println();
&#125;
//进行深度优先搜索的内部递归方法使用
private void dfs(int i,boolean visited[])&#123;	//工作函数
    System.out.print(i+&quot; &quot;);
    visited[i]=true;
    for(int j=0;j&lt;n;j++)&#123;
        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue &amp;&amp; !visited[j])&#123;
            dfs(j,visited);
        &#125;
    &#125;
&#125;
</code></pre>
<p><span id="table">邻接表实现</span></p>
<pre><code>package GraphLink;
//定义邻接表类型
public class EdgeNode&#123;
    //需要一个存储自身结点
    int adjvex;
    int weight;
    EdgeNode next;
    //无权图
    public EdgeNode(int adj,EdgeNode nt)&#123;
        this.adjvex=adj;
        this.next=nt;
        this.weight=1;
    &#125;
    //有权图
    public EdgeNode(int adj,int wgt,EdgeNode nt)&#123;
        this.adjvex=adj;
        this.weight=wgt;
        this.next=nt;
    &#125;
&#125;

//生成图函数
@Override
public void creatGraph(EdgeElement[] d) &#123;
    int i;
    for(i=0;i&lt;d.length;i++)&#123;//处理边集合  如果边集合重复 那程序不就有问题了么  这点要处理
        if(d[i]==null) break;
        int v1,v2,weight;
        v1=d[i].fromvex;
        v2=d[i].endvex;
        weight=d[i].weight;
        if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;
            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
            System.exit(0);
        &#125;
        if(type==GraphType.NoDirectionNoWeight)&#123;//处理无方向 无权重的图
            a[v1]=new EdgeNode(v2,a[v1]);//把边挂载在主干上,a为EdgeNode类型的一维数组
            a[v2]=new EdgeNode(v1,a[v2]);//处理第二条边
        &#125;else if(type==GraphType.NoDirectionWeight)&#123;//处理无向有权图
            a[v1]=new EdgeNode(v2,weight,a[v1]);
            a[v2]=new EdgeNode(v1,weight,a[v2]);
        &#125;else if(type==GraphType.DirectionNoWeight)&#123;//处理有向无权图
            a[v1]=new EdgeNode(v2,a[v1]);
        &#125;else &#123;
            a[v1]=new EdgeNode(v2,weight,a[v1]);
        &#125;
    &#125;
    e=i;
&#125;

//在图中查找一条边
public boolean find(int v1,int v2)&#123;
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    &#125;
    EdgeNode p=a[v1];
    while(p!=null)&#123;
        if(p.adjvex==v2)&#123;
            return true;
        &#125;
        p=p.next;
    &#125;
    return false;
&#125;

//向图中插入一条边
public void putEdge(EdgeElement theEdge)&#123;
    int v1,v2,weight;
    v1=theEdge.fromvex;
    v2=theEdge.endvex;
    weight=theEdge.weight;
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    &#125;
    EdgeNode p=a[v1];
    while(p!=null)&#123;
        if(p.adjvex==v2)&#123;
            break;//退出后处理
        &#125;
        p=p.next;
    &#125;
    if(p==null) e++;
    else&#123;
        if(type==GraphType.DirectionWeight || type==GraphType.NoDirectionWeight)&#123;
            p.weight=weight;
        &#125;
        if(type==GraphType.NoDirectionWeight)&#123;//无向有权重的另一条边也要处理
            EdgeNode q=a[v2];
            while(q!=null)&#123;
                if(q.adjvex==v1) break;
                q=q.next;
            &#125;
            q.weight=weight;
        &#125;
        return;
    &#125;
    if(type==GraphType.NoDirectionNoWeight)&#123;//如果是无向无权重
        a[v1]=new EdgeNode(v2, a[v1]);
        a[v2]=new EdgeNode(v1, a[v2]);
    &#125;else if(type==GraphType.NoDirectionWeight)&#123;//处理无向有权重
        a[v1]=new EdgeNode(v2,weight,a[v1]);
        a[v2]=new EdgeNode(v1,weight,a[v2]);
    &#125;else if(type==GraphType.DirectionNoWeight)&#123;//有向无权重
        a[v1]=new EdgeNode(v2,a[v1]);
    &#125;else&#123;
        a[v1]=new EdgeNode(v2, weight,a[v1]);
    &#125;
&#125;

public void removeEdge(int v1,int v2)&#123;
    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;
        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);
        System.exit(0);
    &#125;
    EdgeNode p=a[v1],q=null;//拿到主干结点
    while(p!=null)&#123;
        if(p.adjvex==v2) break;
        q=p;
        p=p.next;
    &#125;
    if(p==null)&#123;
        System.out.println(&quot;要删除的边不存在，程序退出运行&quot;);
        System.exit(0);
    &#125;
    if(q==null)&#123;//该结点在表头上 主干的节点就是需要找的结点
        a[v1]=a[v1].next;
    &#125;else&#123;
        q.next=p.next;//嫁接上
    &#125;
    //删除无向图的另一个结点上的边
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;
        EdgeNode p1=a[v2],q1=null;
        while(p1!=null)&#123;
            if(p1.adjvex==v1)&#123;
                break;
            &#125;
            q1=p1;
            p1=p1.next;
        &#125;
        if(q1==null)&#123;
            a[v2]=a[v2].next;
        &#125;else&#123;
            q1.next=p1.next;
        &#125;
    &#125;
    e--;
&#125;

//返回一个顶点的度，度分为入度和出度，要分别处理
public int degree(int i)&#123;
    if(i&lt;0||i&gt;n-1)&#123;
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);			
    &#125;
    int k=0;
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;
        EdgeNode p=a[i];
        while(p!=null)&#123;
            k++;
            p=p.next;
        &#125;
        return k;
    &#125;else return inDegree(i)+outDegree(i);
&#125;
//求出并返回一个顶点的入度
public int inDegree(int i)&#123;//返回指向该顶点的度，入度，用双循环来实现
    int k=0;//记录入度个数
    if(i&lt;0||i&gt;n-1)&#123;
        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);
        System.exit(0);			
    &#125;
    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;
        return -1;
    &#125;else&#123;
        for(int j=0;j&lt;n;j++)&#123;
            EdgeNode p=a[j];
            while(p!=null)&#123;
                if(p.adjvex==i)k++;
                p=p.next;
            &#125;
        &#125;
    &#125;
    return k;
&#125;
//返回一个顶点的出度
public int outDegree(int i)&#123;
    int k=0;//记录出度的数目
    EdgeNode p=a[i];
    while(p!=null)&#123;
        k++;
        p=p.next;
    &#125;
    return k;
&#125;

//得到邻接矩阵
public int[][] getAdjacencyMatrix()&#123;
    int adjacencyMatrix[][]=new int[n][n];
    if(type==GraphType.DirectionNoWeight||type==GraphType.DirectionWeight)&#123;//有向性
        //有向 那不存在的边是存在一个InfinityValue
        for(int i=0;i&lt;n;i++)&#123;
            for(int j=0;j&lt;n;j++)&#123;
                if(i==j) adjacencyMatrix[i][j]=0;
                else adjacencyMatrix[i][j]=InfinityValue;
            &#125;
        &#125;
    &#125;else&#123;
        //无向 都设置为0
        for(int i=0;i&lt;n;i++)&#123;
            for(int j=0;j&lt;n;j++)&#123;
                 adjacencyMatrix[i][j]=0;
            &#125;
        &#125;			
    &#125;
        //遍历整个图
        for(int i=0;i&lt;n;i++)&#123;
            EdgeNode p=a[i];
            while(p!=null)&#123;
                adjacencyMatrix[i][p.adjvex]=p.weight;
                p=p.next;
            &#125;
        &#125;	
    return adjacencyMatrix;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>遗传算法</title>
    <url>/posts/34642.html</url>
    <content><![CDATA[<p>遗传算法（Genetic Algorithms ）是基于生物进化理论的原理发展起来的一种广为应用的、高效的随机搜索与优化的方法。其主要特点是群体搜索策略和群体中个体之间的信息交换，搜索不依赖于梯度信息。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>初始化 t←0进化代数计数器；T是最大进化代数；随机生成M个个体作为初始群体P（t）</li>
<li>个体评价 计算P（t）中各个个体的适应度；</li>
<li>选择运算 将选择算子作用于群体；</li>
<li>交叉运算 将交叉算子作用于群体；</li>
<li>变异运算 将变异算子作用于群体，并通过以上运算得到下一代群体P（t + 1）;</li>
<li>终止条件判断  t≦T：t← t+1 转到步骤2；t&gt;T：终止 输出解。</li>
</ol>
<h2 id="模型构成"><a href="#模型构成" class="headerlink" title="模型构成"></a>模型构成</h2><ol>
<li>决策变量及各种约束条件，即个体的表现型X和问题的解空间</li>
<li>目标函数最大OR 最小， 数学描述形式 量化方法</li>
<li>染色体编码方法 （二进制、整数、浮点数）</li>
<li>解码方法</li>
<li>个体适应度的量化评价方法 F(x)  （旅行商问题及最短路径）</li>
<li>设计遗传算子</li>
<li>有关运行参数</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>局部收敛</li>
<li>全局搜索能力不够强</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li>交叉算子</li>
<li>变异算子</li>
<li>选择策略</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;  
  
import java.io.BufferedReader;  
import java.io.FileInputStream;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.Random;  
  
public class GA &#123;  
  
    private int scale;// 种群规模  
    private int cityNum; // 城市数量，染色体长度  
    private int MAX_GEN; // 运行代数  
    private int[][] distance; // 距离矩阵  
    private int bestT;// 最佳出现代数  
    private int bestLength; // 最佳长度  
    private int[] bestTour; // 最佳路径  
  
    // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段  
    private int[][] oldPopulation;  
    private int[][] newPopulation;// 新的种群，子代种群  
    private int[] fitness;// 种群适应度，表示种群中各个个体的适应度  
  
    private float[] Pi;// 种群中各个个体的累计概率  
    private float Pc;// 交叉概率  
    private float Pm;// 变异概率  
    private int t;// 当前代数  
  
    private Random random;  
  
    public GA() &#123;  
  
    &#125;  
  
    /** 
     * constructor of GA 
     *  
     * @param s 
     *            种群规模 
     * @param n 
     *            城市数量 
     * @param g 
     *            运行代数 
     * @param c 
     *            交叉率 
     * @param m 
     *            变异率 
     *  
     **/  
    public GA(int s, int n, int g, float c, float m) &#123;  
        scale = s;  
        cityNum = n;  
        MAX_GEN = g;  
        Pc = c;  
        Pm = m;  
    &#125;  
  
    // 给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默  
    @SuppressWarnings(&quot;resource&quot;)  
    /** 
     * 初始化GA算法类 
     * @param filename 数据文件名，该文件存储所有城市节点坐标数据 
     * @throws IOException 
     */  
    private void init(String filename) throws IOException &#123;  
        // 读取数据  
        int[] x;  
        int[] y;  
        String strbuff;  
        BufferedReader data = new BufferedReader(new InputStreamReader(  
                new FileInputStream(filename)));  
        distance = new int[cityNum][cityNum];  
        x = new int[cityNum];  
        y = new int[cityNum];  
        for (int i = 0; i &lt; cityNum; i++) &#123;  
            // 读取一行数据，数据格式1 6734 1453  
            strbuff = data.readLine();  
            // 字符分割  
            String[] strcol = strbuff.split(&quot; &quot;);  
            x[i] = Integer.valueOf(strcol[1]);// x坐标  
            y[i] = Integer.valueOf(strcol[2]);// y坐标  
        &#125;  
        // 计算距离矩阵  
        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628  
        for (int i = 0; i &lt; cityNum - 1; i++) &#123;  
            distance[i][i] = 0; // 对角线为0  
            for (int j = i + 1; j &lt; cityNum; j++) &#123;  
                double rij = Math  
                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])  
                                * (y[i] - y[j])) / 10.0);  
                // 四舍五入，取整  
                int tij = (int) Math.round(rij);  
                if (tij &lt; rij) &#123;  
                    distance[i][j] = tij + 1;  
                    distance[j][i] = distance[i][j];  
                &#125; else &#123;  
                    distance[i][j] = tij;  
                    distance[j][i] = distance[i][j];  
                &#125;  
            &#125;  
        &#125;  
        distance[cityNum - 1][cityNum - 1] = 0;  
  
        bestLength = Integer.MAX_VALUE;  
        bestTour = new int[cityNum + 1];  
        bestT = 0;  
        t = 0;  
  
        newPopulation = new int[scale][cityNum];  
        oldPopulation = new int[scale][cityNum];  
        fitness = new int[scale];  
        Pi = new float[scale];  
  
        random = new Random(System.currentTimeMillis());  
        /* 
         * for(int i=0;i&lt;cityNum;i++) &#123; for(int j=0;j&lt;cityNum;j++) &#123; 
         * System.out.print(distance[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125; 
         */  
        // 初始化种群  
  
    &#125;  
  
    // 初始化种群  
    void initGroup() &#123;  
        int i, j, k;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 0; k &lt; scale; k++)// 种群数  
        &#123;  
            oldPopulation[k][0] = random.nextInt(65535) % cityNum;  
            for (i = 1; i &lt; cityNum;)// 染色体长度  
            &#123;  
                oldPopulation[k][i] = random.nextInt(65535) % cityNum;  
                for (j = 0; j &lt; i; j++) &#123;  
                    if (oldPopulation[k][i] == oldPopulation[k][j]) &#123;  
                        break;  
                    &#125;  
                &#125;  
                if (j == i) &#123;  
                    i++;  
                &#125;  
            &#125;  
        &#125;  
  
        /* 
         * for(i=0;i&lt;scale;i++) &#123; for(j=0;j&lt;cityNum;j++) &#123; 
         * System.out.print(oldPopulation[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125; 
         */  
    &#125;  
  
    public int evaluate(int[] chromosome) &#123;  
        // 0123  
        int len = 0;  
        // 染色体，起始城市,城市1,城市2...城市n  
        for (int i = 1; i &lt; cityNum; i++) &#123;  
            len += distance[chromosome[i - 1]][chromosome[i]];  
        &#125;  
        // 城市n,起始城市  
        len += distance[chromosome[cityNum - 1]][chromosome[0]];  
        return len;  
    &#125;  
  
    // 计算种群中各个个体的累积概率，前提是已经计算出各个个体的适应度fitness[max]，作为赌轮选择策略一部分，Pi[max]  
    void countRate() &#123;  
        int k;  
        double sumFitness = 0;// 适应度总和  
  
        double[] tempf = new double[scale];  
  
        for (k = 0; k &lt; scale; k++) &#123;  
            tempf[k] = 10.0 / fitness[k];  
            sumFitness += tempf[k];  
        &#125;  
  
        Pi[0] = (float) (tempf[0] / sumFitness);  
        for (k = 1; k &lt; scale; k++) &#123;  
            Pi[k] = (float) (tempf[k] / sumFitness + Pi[k - 1]);  
        &#125;  
  
        /* 
         * for(k=0;k&lt;scale;k++) &#123; System.out.println(fitness[k]+&quot; &quot;+Pi[k]); &#125; 
         */  
    &#125;  
  
    // 挑选某代种群中适应度最高的个体，直接复制到子代中  
    // 前提是已经计算出各个个体的适应度Fitness[max]  
    public void selectBestGh() &#123;  
        int k, i, maxid;  
        int maxevaluation;  
  
        maxid = 0;  
        maxevaluation = fitness[0];  
        for (k = 1; k &lt; scale; k++) &#123;  
            if (maxevaluation &gt; fitness[k]) &#123;  
                maxevaluation = fitness[k];  
                maxid = k;  
            &#125;  
        &#125;  
  
        if (bestLength &gt; maxevaluation) &#123;  
            bestLength = maxevaluation;  
            bestT = t;// 最好的染色体出现的代数;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                bestTour[i] = oldPopulation[maxid][i];  
            &#125;  
        &#125;  
  
        // System.out.println(&quot;代数 &quot; + t + &quot; &quot; + maxevaluation);  
        // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
        copyGh(0, maxid);// 将当代种群中适应度最高的染色体k复制到新种群中，排在第一位0  
    &#125;  
  
    // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置  
    public void copyGh(int k, int kk) &#123;  
        int i;  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k][i] = oldPopulation[kk][i];  
        &#125;  
    &#125;  
  
    // 赌轮选择策略挑选  
    public void select() &#123;  
        int k, i, selectId;  
        float ran1;  
        // Random random = new Random(System.currentTimeMillis());  
        for (k = 1; k &lt; scale; k++) &#123;  
            ran1 = (float) (random.nextInt(65535) % 1000 / 1000.0);  
            // System.out.println(&quot;概率&quot;+ran1);  
            // 产生方式  
            for (i = 0; i &lt; scale; i++) &#123;  
                if (ran1 &lt;= Pi[i]) &#123;  
                    break;  
                &#125;  
            &#125;  
            selectId = i;  
            // System.out.println(&quot;选中&quot; + selectId);  
            copyGh(k, selectId);  
        &#125;  
    &#125;  
  
    //进化函数，正常交叉变异  
    public void evolution() &#123;  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  
  
        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  
  
        // Random random = new Random(System.currentTimeMillis());  
        float r;  
  
        // 交叉方法  
        for (k = 0; k &lt; scale; k = k + 2) &#123;  
            r = random.nextFloat();// /产生概率  
            // System.out.println(&quot;交叉率...&quot; + r);  
            if (r &lt; Pc) &#123;  
                // System.out.println(k + &quot;与&quot; + k + 1 + &quot;进行交叉...&quot;);  
                //OXCross(k, k + 1);// 进行交叉  
                OXCross1(k, k + 1);  
            &#125; else &#123;  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率1...&quot; + r);  
                // 变异  
                if (r &lt; Pm) &#123;  
                    // System.out.println(k + &quot;变异...&quot;);  
                    OnCVariation(k);  
                &#125;  
                r = random.nextFloat();// /产生概率  
                // System.out.println(&quot;变异率2...&quot; + r);  
                // 变异  
                if (r &lt; Pm) &#123;  
                    // System.out.println(k + 1 + &quot;变异...&quot;);  
                    OnCVariation(k + 1);  
                &#125;  
            &#125;  
  
        &#125;  
    &#125;  
  
    //进化函数，保留最好染色体不进行交叉变异  
    public void evolution1() &#123;  
        int k;  
        // 挑选某代种群中适应度最高的个体  
        selectBestGh();  
  
        // 赌轮选择策略挑选scale-1个下一代个体  
        select();  
  
        // Random random = new Random(System.currentTimeMillis());  
        float r;  
  
        for (k = 1; k + 1 &lt; scale / 2; k = k + 2) &#123;  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pc) &#123;  
                OXCross1(k, k + 1);// 进行交叉  
                //OXCross(k,k+1);//进行交叉  
            &#125; else &#123;  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) &#123;  
                    OnCVariation(k);  
                &#125;  
                r = random.nextFloat();// /产生概率  
                // 变异  
                if (r &lt; Pm) &#123;  
                    OnCVariation(k + 1);  
                &#125;  
            &#125;  
        &#125;  
        if (k == scale / 2 - 1)// 剩最后一个染色体没有交叉L-1  
        &#123;  
            r = random.nextFloat();// /产生概率  
            if (r &lt; Pm) &#123;  
                OnCVariation(k);  
            &#125;  
        &#125;  
  
    &#125;  
  
    // 类OX交叉算子  
    void OXCross(int k1, int k2) &#123;  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  
  
        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  
  
        while (ran1 == ran2) &#123;  
            ran2 = random.nextInt(65535) % cityNum;  
        &#125;  
  
        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        &#123;  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        &#125;  
        // System.out.println();  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);  
        // System.out.println(&quot;-----------------------&quot;);  
        // System.out.println();  
        flag = ran2 - ran1 + 1;// 删除重复基因前染色体长度  
        for (i = 0, j = ran1; i &lt; flag; i++, j++) &#123;  
            Gh1[i] = newPopulation[k2][j];  
            Gh2[i] = newPopulation[k1][j];  
        &#125;  
        // 已近赋值i=ran2-ran1个基因  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh1[i] == Gh1[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh2[i] == Gh2[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        &#125;  
  
        // System.out.println(&quot;进行交叉--------------------------&quot;);  
        // System.out.println(k1+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) &#123;  
        // System.out.print(newPopulation[k1][i] + &quot;-&quot;);  
        // &#125;  
        // System.out.println();  
        // System.out.println(k2+&quot;交叉后...&quot;);  
        // for (i = 0; i &lt; cityNum; i++) &#123;  
        // System.out.print(newPopulation[k2][i] + &quot;-&quot;);  
        // &#125;  
        // System.out.println();  
        // System.out.println(&quot;交叉完毕--------------------------&quot;);  
    &#125;  
  
    // 交叉算子,相同染色体交叉产生不同子代染色体  
    public void OXCross1(int k1, int k2) &#123;  
        int i, j, k, flag;  
        int ran1, ran2, temp;  
        int[] Gh1 = new int[cityNum];  
        int[] Gh2 = new int[cityNum];  
        // Random random = new Random(System.currentTimeMillis());  
  
        ran1 = random.nextInt(65535) % cityNum;  
        ran2 = random.nextInt(65535) % cityNum;  
        while (ran1 == ran2) &#123;  
            ran2 = random.nextInt(65535) % cityNum;  
        &#125;  
  
        if (ran1 &gt; ran2)// 确保ran1&lt;ran2  
        &#123;  
            temp = ran1;  
            ran1 = ran2;  
            ran2 = temp;  
        &#125;  
  
        // 将染色体1中的第三部分移到染色体2的首部  
        for (i = 0, j = ran2; j &lt; cityNum; i++, j++) &#123;  
            Gh2[i] = newPopulation[k1][j];  
        &#125;  
  
        flag = i;// 染色体2原基因开始位置  
  
        for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh2[j] = newPopulation[k2][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (Gh2[i] == Gh2[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        flag = ran1;  
        for (k = 0, j = 0; k &lt; cityNum;)// 染色体长度  
        &#123;  
            Gh1[j] = newPopulation[k1][k++];  
            for (i = 0; i &lt; flag; i++) &#123;  
                if (newPopulation[k2][i] == Gh1[j]) &#123;  
                    break;  
                &#125;  
            &#125;  
            if (i == flag) &#123;  
                j++;  
            &#125;  
        &#125;  
  
        flag = cityNum - ran1;  
  
        for (i = 0, j = flag; j &lt; cityNum; j++, i++) &#123;  
            Gh1[j] = newPopulation[k2][i];  
        &#125;  
  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群  
            newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群  
        &#125;  
    &#125;  
  
    // 多次对换变异算子  
    public void OnCVariation(int k) &#123;  
        int ran1, ran2, temp;  
        int count;// 对换次数  
  
        // Random random = new Random(System.currentTimeMillis());  
        count = random.nextInt(65535) % cityNum;  
  
        for (int i = 0; i &lt; count; i++) &#123;  
  
            ran1 = random.nextInt(65535) % cityNum;  
            ran2 = random.nextInt(65535) % cityNum;  
            while (ran1 == ran2) &#123;  
                ran2 = random.nextInt(65535) % cityNum;  
            &#125;  
            temp = newPopulation[k][ran1];  
            newPopulation[k][ran1] = newPopulation[k][ran2];  
            newPopulation[k][ran2] = temp;  
        &#125;  
  
        /* 
         * for(i=0;i&lt;L;i++) &#123; printf(&quot;%d &quot;,newGroup[k][i]); &#125; printf(&quot;\n&quot;); 
         */  
    &#125;  
  
    public void solve() &#123;  
        int i;  
        int k;  
  
        // 初始化种群  
        initGroup();  
        // 计算初始化种群适应度，Fitness[max]  
        for (k = 0; k &lt; scale; k++) &#123;  
            fitness[k] = evaluate(oldPopulation[k]);  
            // System.out.println(fitness[k]);  
        &#125;  
        // 计算初始化种群中各个个体的累积概率，Pi[max]  
        countRate();  
        System.out.println(&quot;初始种群...&quot;);  
        for (k = 0; k &lt; scale; k++) &#123;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            &#125;  
            System.out.println();  
            System.out.println(&quot;----&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        &#125;  
          
        for (t = 0; t &lt; MAX_GEN; t++) &#123;  
            //evolution1();  
            evolution();  
            // 将新种群newGroup复制到旧种群oldGroup中，准备下一代进化  
            for (k = 0; k &lt; scale; k++) &#123;  
                for (i = 0; i &lt; cityNum; i++) &#123;  
                    oldPopulation[k][i] = newPopulation[k][i];  
                &#125;  
            &#125;  
            // 计算种群适应度  
            for (k = 0; k &lt; scale; k++) &#123;  
                fitness[k] = evaluate(oldPopulation[k]);  
            &#125;  
            // 计算种群中各个个体的累积概率  
            countRate();  
        &#125;  
  
        System.out.println(&quot;最后种群...&quot;);  
        for (k = 0; k &lt; scale; k++) &#123;  
            for (i = 0; i &lt; cityNum; i++) &#123;  
                System.out.print(oldPopulation[k][i] + &quot;,&quot;);  
            &#125;  
            System.out.println();  
            System.out.println(&quot;---&quot; + fitness[k] + &quot; &quot; + Pi[k]);  
        &#125;  
  
        System.out.println(&quot;最佳长度出现代数：&quot;);  
        System.out.println(bestT);  
        System.out.println(&quot;最佳长度&quot;);  
        System.out.println(bestLength);  
        System.out.println(&quot;最佳路径：&quot;);  
        for (i = 0; i &lt; cityNum; i++) &#123;  
            System.out.print(bestTour[i] + &quot;,&quot;);  
        &#125;  
  
    &#125;  
  
      
    /** 
     * @param args 
     * @throws IOException 
     */  
    public static void main(String[] args) throws IOException &#123;  
        System.out.println(&quot;Start....&quot;);  
        GA ga = new GA(30, 48, 1000, 0.8f, 0.9f);  
        ga.init(&quot;c://data.txt&quot;);  
        ga.solve();  
    &#125;  
  
&#125;
</code></pre>
<p>参考：<a href="https://blog.csdn.net/tyhj_sf/article/details/53321527">https://blog.csdn.net/tyhj_sf/article/details/53321527</a></p>
]]></content>
      <categories>
        <category>algrithom</category>
      </categories>
  </entry>
  <entry>
    <title>mysql-MySQL为什么有时候会选错索引</title>
    <url>/posts/1591a1f8.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>10 | MySQL为什么有时候会选错索引？2018-12-05 林晓斌</p>
<p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你</p>
<p>写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确</p>
<p>定的。不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索</p>
<p>引，而导致执行速度变得很慢？我们一起来看一个例子吧。我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p>
<p>CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>a</code> int(11) DEFAULT NULL,</p>
<p>  <code>b</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>a</code> (<code>a</code>),</p>
<p>  KEY <code>b</code> (<code>b</code>)</p>
<p>) ENGINE&#x3D;InnoDB；</p>
<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到</p>
<p>(100000,100000,100000)。我是用存储过程来插入数据的，这里我贴出来方便你复现：</p>
<p>接下来，我们分析一条SQL语句：</p>
<p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。图1 使用explain命令查看语句执行情况</p>
<p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索</p>
<p>引a。不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做</p>
<p>如下操作。delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;100000)do</p>
<pre><code>insert into t values(i, i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select * from t where a between 10000 and 20000;</p>
<p>图2 session A和session B的执行流程</p>
<p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删</p>
<p>除后，又调用了 idata这个存储过程，插入了10万行数据。这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择</p>
<p>索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强</p>
<p>制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。下面的三条SQL语句，就是这个实验过程。第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日</p>
<p>志中；</p>
<p>第二句，Q1是session B原来的查询；</p>
<p>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。如图3所示是这三条SQL语句执行完成后的慢查询日志。set long_query_time&#x3D;0;</p>
<p>select * from t where a between 10000 and 20000; &#x2F;<em>Q1</em>&#x2F;</p>
<p>select * from t force index(a) where a between 10000 and 20000;&#x2F;<em>Q2</em>&#x2F;</p>
<p>图3 slow log结果</p>
<p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，</p>
<p>执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更</p>
<p>长的执行时间。这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错</p>
<p>索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。优化器的逻辑</p>
<p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库</p>
<p>里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越</p>
<p>少，消耗的CPU资源越少。当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行</p>
<p>综合判断。我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描</p>
<p>行数的时候出问题了。那么，问题就是：扫描行数是怎么判断的？MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根</p>
<p>据统计信息来估算记录数。这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越</p>
<p>好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越</p>
<p>大，索引的区分度越好。我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果</p>
<p>。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不</p>
<p>同，而且其实都不准确。图4 表t的show index 结果</p>
<p>那么，MySQL是怎样得到索引的基数的呢？这里，我给你简单介绍一下MySQL采样统计的方</p>
<p>法。为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太</p>
<p>高了，所以只能选择“采样统计”。采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均</p>
<p>值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1&#x2F;M的</p>
<p>时候，会自动触发重新做一次索引统计。在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选</p>
<p>择：</p>
<p>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。但，这还不是全部。你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多</p>
<p>的，选错索引一定还有别的原因。其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要</p>
<p>扫描多少行。接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。图5 意外的explain结果</p>
<p>rows这个字段表示的是预计扫描行数。其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大</p>
<p>了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划</p>
<p>不用，却选择了扫描行数是100000的执行计划呢？这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，</p>
<p>这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执</p>
<p>行时间看来，这个选择并不是最优的。使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，</p>
<p>但图1的选择是对的。也就是说，这个策略并没有问题。所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于</p>
<p>为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看</p>
<p>一下执行效果。图6 执行analyze table t 命令恢复的explain结果</p>
<p>这回对了。所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个</p>
<p>方法来处理。其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优</p>
<p>化器可不止是看扫描行数。依然是基于这个表t，我们看看另外一个语句：</p>
<p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？为了便于分析，我们先来看一下a、b这两个索引的结构图。图7 a、b索引的结构图</p>
<p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索</p>
<p>引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是</p>
<p>需要回到主键索引上取值再判断，所以需要扫描50001行。所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底</p>
<p>是不是这么一回事儿。mysql&gt; select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</p>
<p>图8是执行explain的结果。图8 使用explain方法查看执行计划 2</p>
<p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行</p>
<p>数是50198。从这个结果中，你可以得到两个结论：</p>
<ol>
<li><p>扫描行数的估计值依然不准确；</p>
</li>
<li><p>这个例子里MySQL又选错了索引。索引选择异常和处理</p>
</li>
</ol>
<p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：</p>
<p>原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。MySQL会根据</p>
<p>词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需</p>
<p>要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估</p>
<p>其他索引的执行代价。我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行</p>
<p>效果：</p>
<p>图9 使用不同索引的语句执行耗时</p>
<p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化</p>
<p>器的选择快了40多倍。也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句</p>
<p>mysql&gt; explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;</p>
<p>也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现</p>
<p>的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修</p>
<p>改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不</p>
<p>够敏捷。所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？既然优化器放弃了使用索引a，说明a还不够合适，所以第二种方法就是，我们可以考虑修改</p>
<p>语句，引导MySQL使用我们期望的索引。比如，在这个例子里，显然把“order by b limit 1” 改</p>
<p>成 “order by b,a limit 1” ，语义的逻辑是相同的。我们来看看改之后的效果：</p>
<p>图10 order by b,a limit 1 执行结果</p>
<p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序</p>
<p>的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为</p>
<p>代价更小。现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫</p>
<p>描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条</p>
<p>件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才</p>
<p>可以这么做。如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。图11 改写SQL的explain</p>
<p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数</p>
<p>mysql&gt; select * from  (select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 100)alias limit 1;</p>
<p>据特征诱导了一下优化器，也不具备通用性。第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选</p>
<p>择，或删掉误用的索引。不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较</p>
<p>少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，</p>
<p>最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是</p>
<p>就删掉了这个索引，优化器也就重新选择到了正确的索引。小结</p>
<p>今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改</p>
<p>语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，今</p>
<p>天的话题，我们面对的是MySQL的bug，每一个展开都必须深入到一行行代码去量化，实在不是</p>
<p>我们在这里应该做的事情。所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。你平时在处理MySQL优化器bug的时候有什么别的方法，也发到评论区分享一下吧。最后，我给你留下一个思考题。前面我们在构造第一个例子的过程中，通过session A的配合，</p>
<p>让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001</p>
<p>变成37000多。而如果没有session A的配合，只是单独执行delete from t 、call idata()、explain这三句话，会看</p>
<p>到rows字段其实还是10000左右。你可以自己验证一下这个结果。这是什么原因呢？也请你分析一下吧。你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，如果某次写入使用了change buffer机制，之后主机异常</p>
<p>重启，是否会丢失change buffer和数据。这个问题的答案是不会丢失，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提</p>
<p>交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change</p>
<p>buffer也能找回来。在评论区有同学问到，merge的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为</p>
<p>你分析一下。merge的执行流程是这样的：</p>
<ol>
<li><p>从磁盘读入数据页到内存（老版本的数据页）；</p>
</li>
<li><p>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新</p>
</li>
</ol>
<p>版数据页；</p>
<ol start="3">
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更。到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修</li>
</ol>
<p>改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。评论区留言点赞板：</p>
<p>@某、人 把02篇的redo log更新细节和change buffer的更新串了起来；</p>
<p>@Ivan 回复了其他同学的问题，并联系到Checkpoint机制；</p>
<p>@约书亚 问到了merge和redolog的关系。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-MySQL是怎么保证主备一致的</title>
    <url>/posts/9b1409.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>24 | MySQL是怎么保证主备一致的？2019-01-07 林晓斌</p>
<p>在前面的文章中，我不止一次地和你提到了binlog，大家知道binlog可以用来归档，也可以用来</p>
<p>做主备同步，但它的内容是什么样的呢？为什么备库执行了binlog就可以跟主库保持一致了呢？今天我就正式地和你介绍一下它。毫不夸张地说，MySQL能够成为现下最流行的开源数据库，binlog功不可没。在最开始，MySQL是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的</p>
<p>高可用架构，都直接依赖于binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是</p>
<p>从最基本的一主一备演化过来的。今天这篇文章我主要为你介绍主备的基本原理。理解了背后的设计原理，你也可以从业务开发的</p>
<p>角度，来借鉴这些设计思想。MySQL主备的基本原理</p>
<p>如图1所示就是基本的主备切换流程。图 1 MySQL主备切换流程</p>
<p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过</p>
<p>来，到本地执行。这样可以保持节点B和A的数据是相同的。当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读</p>
<p>（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li><p>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</p>
</li>
<li><p>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</p>
</li>
<li><p>可以用readonly状态，来判断节点的角色。你可能会问，我把备库设置成只读了，还怎么跟主库保持同步更新呢？这个问题，你不用担心。因为readonly设置对超级(super)权限用户是无效的，而用于同步更新的</p>
</li>
</ol>
<p>线程，就拥有超级权限。接下来，我们再看看节点A到B这条线的内部流程是什么样的。图2中画出的就是一个update</p>
<p>语句在节点A执行，然后同步到节点B的完整流程图。图2 主备流程图</p>
<p>图2中，包含了我在上一篇文章中讲到的binlog和redo log的写入机制相关的内容，可以看到：主</p>
<p>库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连</p>
<p>接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个</li>
</ol>
<p>位置开始请求binlog，这个位置包含文件名和日志偏移量。2. 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和</p>
<p>sql_thread。其中io_thread负责与主库建立连接。3. 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。4. 备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。5. sql_thread读取中转日志，解析出日志里的命令，并执行。这里需要说明，后来由于多线程复制方案的引入，sql_thread演化成为了多个线程，跟我们今天</p>
<p>要介绍的原理没有直接关系，暂且不展开。分析完了这个长连接的逻辑，我们再来看一个问题：binlog里面到底是什么内容，为什么备库拿</p>
<p>过去可以直接执行。binlog的三种格式对比</p>
<p>我在第15篇答疑文章中，和你提到过binlog有两种格式，一种是statement，一种是row。可能你</p>
<p>在其他资料上还会看到有第三种格式，叫作mixed，其实它就是前两种格式的混合。为了便于描述binlog的这三种格式间的区别，我创建了一个表，并初始化几行数据。如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的。注意，下面这个语句包含注释，如果你用MySQL客户端来做这个实验的话，要记得加-c参数，否</p>
<p>则客户端会自动去掉注释。当binlog_format&#x3D;statement时，binlog里面记录的就是SQL语句的原文。你可以用</p>
<p>mysql&gt; CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;a  ̀int(11) DEFAULT NULL,</p>
<p>  t̀_modified  ̀timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;a  ̀(̀ a )̀,</p>
<p>  KEY t̀_modified (̀̀ t_modified )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(1,1,’2018-11-13’);</p>
<p>insert into t values(2,2,’2018-11-12’);</p>
<p>insert into t values(3,3,’2018-11-11’);</p>
<p>insert into t values(4,4,’2018-11-10’);</p>
<p>insert into t values(5,5,’2018-11-09’);</p>
<p>mysql&gt; delete from t &#x2F;<em>comment</em>&#x2F;  where a&gt;&#x3D;4 and t_modified&lt;&#x3D;’2018-11-10’ limit 1;</p>
<p>mysql&gt; show binlog events in ‘master.000001’;</p>
<p>命令看binlog中的内容。图3 statement格式binlog 示例</p>
<p>现在，我们来看一下图3的输出结果。第一行SET @@SESSION.GTID_NEXT&#x3D;’ANONYMOUS’你可以先忽略，后面文章我们会在</p>
<p>介绍主备切换的时候再提到；</p>
<p>第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务；</p>
<p>第三行就是真实执行的语句了。可以看到，在真实执行的delete命令之前，还有一个“use</p>
<p>‘test’”命令。这条命令不是我们主动执行的，而是MySQL根据当前要操作的表所在的数据库，</p>
<p>自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库</p>
<p>里，都能够正确地更新到test库的表t。use ‘test’命令之后的delete 语句，就是我们输入的SQL原文了。可以看到，binlog“忠实”地记</p>
<p>录了SQL命令，甚至连注释也一并记录了。最后一行是一个COMMIT。你可以看到里面写着xid&#x3D;61。你还记得这个XID是做什么用的吗？如果记忆模糊了，可以再回顾一下第15篇文章中的相关内容。为了说明statement 和 row格式的区别，我们来看一下这条delete命令的执行效果图：</p>
<p>图4 delete执行warnings</p>
<p>可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格</p>
<p>式，并且语句中有limit，所以这个命令可能是unsafe的。为什么这么说呢？这是因为delete 带limit，很可能会出现主备数据不一致的情况。比如上面这个</p>
<p>例子：</p>
<ol>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除</li>
</ol>
<p>的是a&#x3D;4这一行；</p>
<ol start="2">
<li>但如果使用的是索引t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是a&#x3D;5这一</li>
</ol>
<p>行。由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库</p>
<p>执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引</p>
<p>t_modified。因此，MySQL认为这样写是有风险的。那么，如果我把binlog的格式改为binlog_format&#x3D;‘row’， 是不是就没有这个问题了呢？我们先来</p>
<p>看看这时候binog中的内容吧。图5 row格式binlog 示例</p>
<p>可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式</p>
<p>的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。1. Table_map event，用于说明接下来要操作的表是test库的表t;</p>
<ol start="2">
<li>Delete_rows event，用于定义删除的行为。其实，我们通过图5是看不到详细信息的，还需要借助mysqlbinlog工具，用下面这个命令解析和</li>
</ol>
<p>查看binlog中的内容。因为图5中的信息显示，这个事务的binlog是从8900这个位置开始的，所以</p>
<p>可以用start-position参数来指定从这个位置的日志开始解析。mysqlbinlog  -vv data&#x2F;master.000001 –start-position&#x3D;8900;</p>
<p>图6 row格式binlog 示例的详细信息</p>
<p>从这个图中，我们可以看到以下几个信息：</p>
<p>server id 1，表示这个事务是在server_id&#x3D;1的这个库上执行的。每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。Table_map event跟在图5中看到的相同，显示了接下来要打开的表，map到数字226。现在我</p>
<p>们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map</p>
<p>event、都会map到一个单独的数字，用于区分对不同表的操作。我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以</p>
<p>看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4这些值）。binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段</p>
<p>的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，</p>
<p>就是只会记录id&#x3D;4这个信息。最后的Xid event，用于表示事务被正确地提交了。你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样</p>
<p>binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。为什么会有mixed格式的binlog？基于上面的信息，我们来讨论一个问题：为什么会有mixed这种binlog格式的存在场景？推论</p>
<p>过程是这样的：</p>
<p>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的</p>
<p>话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，</p>
<p>就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗</p>
<p>费IO资源，影响执行速度。所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思</p>
<p>是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，</p>
<p>否则就用statement格式。也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。因此，如果你的线上MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个</p>
<p>不合理的设置。你至少应该把binlog的格式设置为mixed。比如我们这个例子，设置为mixed后，就会记录为row格式；而如果执行的语句去掉limit 1，就会</p>
<p>记录为statement格式。当然我要说的是，现在越来越多的场景要求把MySQL的binlog格式设置成row。这么做的理由有</p>
<p>很多，我来给你举一个可以直接看出来的好处：恢复数据。接下来，我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问</p>
<p>题。通过图6你可以看出来，即使我执行的是delete语句，row格式的binlog也会把被删掉的行的整行</p>
<p>信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把</p>
<p>binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的</p>
<p>字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成</p>
<p>delete语句，删除掉这被误插入的一行数据就可以了。如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所</p>
<p>以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据</p>
<p>库里面执行，就能恢复这个更新操作了。其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情</p>
<p>况，也时有发生。MariaDB的Flashback工具就是基于上面介绍的原理来回滚数据的。虽然mixed格式的binlog现在已经用得不多了，但这里我还是要再借用一下mixed格式来说明一个</p>
<p>问题，来看一下这条SQL语句：</p>
<p>如果我们把binlog格式设置为mixed，你觉得MySQL会把它记录为row格式还是statement格式</p>
<p>呢？先不要着急说结果，我们一起来看一下这条语句执行的效果。图7 mixed格式和now()</p>
<p>可以看到，MySQL用的居然是statement格式。你一定会奇怪，如果这个binlog过了1分钟才传给</p>
<p>备库的话，那主备的数据不就不一致了吗？接下来，我们再用mysqlbinlog工具来看看：</p>
<p>mysql&gt; insert into t values(10,10, now());</p>
<p>图8 TIMESTAMP 命令</p>
<p>从图中的结果可以看到，原来binlog在记录event的时候，多记了一条命令：SET</p>
<p>TIMESTAMP&#x3D;1546103491。它用 SET TIMESTAMP命令约定了接下来的now()函数的返回时</p>
<p>间。因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备份，这个insert</p>
<p>语句插入的行，值都是固定的。也就是说，通过这条SET TIMESTAMP命令，MySQL就确保了</p>
<p>主备数据的一致性。我之前看过有人在重放binlog数据的时候，是这么做的：用mysqlbinlog解析出日志，然后把里面</p>
<p>的statement语句直接拷贝出来执行。你现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执</p>
<p>行的结果很可能是错误的。所以，用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发</p>
<p>给MySQL执行。类似下面的命令：</p>
<p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析</p>
<p>出来，放到MySQL去执行。循环复制问题</p>
<p>通过上面对MySQL中binlog基本内容的理解，你现在可以知道，binlog的特性确保了在备库执行</p>
<p>相同的binlog，可以得到与主库相同的状态。因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是</p>
<p>一致的。其实，图1中我画的是M-S结构，但实际生产上使用比较多的是双M结构，也就是图9所</p>
<p>示的主备切换流程。mysqlbinlog master.000001  –start-position&#x3D;2738 –stop-position&#x3D;2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</p>
<p>图 9 MySQL主备切换流程–双M结构</p>
<p>对比图9和图1，你可以发现，双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B</p>
<p>之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。但是，双M结构还有一个问题需要解决。业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新</p>
<p>语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log</p>
<p>后生成binlog）。那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然</p>
<p>后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？从上面的图6中可以看到，MySQL在binlog中记录了这个命令第一次执行时所在实例的server</p>
<p>id。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p>
<ol>
<li><p>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</p>
</li>
<li><p>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</p>
</li>
<li><p>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这</p>
</li>
</ol>
<p>个日志是自己生成的，就直接丢弃这个日志。按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p>
<ol>
<li><p>从节点A更新的事务，binlog里面记的都是A的server id；</p>
</li>
<li><p>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</p>
</li>
<li><p>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循</p>
</li>
</ol>
<p>环在这里就断掉了。小结</p>
<p>今天这篇文章，我给你介绍了MySQL binlog的格式和一些基本机制，是后面我要介绍的读写分</p>
<p>离等系列文章的背景知识，希望你可以认真消化理解。binlog在MySQL的各种高可用方案上扮演了重要角色。今天介绍的可以说是所有MySQL高可用</p>
<p>方案的基础。在这之上演化出了诸如多节点、半同步、MySQL group replication等相对复杂的方</p>
<p>案。我也跟你介绍了MySQL不同格式binlog的优缺点，和设计者的思考。希望你在做系统开发时候，</p>
<p>也能借鉴这些设计思想。最后，我给你留下一个思考题吧。说到循环复制问题的时候，我们说MySQL通过判断server id的方式，断掉死循环。但是，这个机</p>
<p>制其实并不完备，在某些场景下，还是有可能出现死循环。你能构造出一个这样的场景吗？又应该怎么解决呢？你可以把你的设计和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我留给你的问题是，你在什么时候会把线上生产库设置成“非双1”。我目前知道的场景，有</p>
<p>以下这些：</p>
<ol>
<li>业务高峰期。一般如果有预知的高峰期，DBA会有预案，把主库设置成“非双1”。2. 备库延迟，为了让备库尽快赶上主库。@永恒记忆和@Second Sight提到了这个场景。3. 用备份恢复主库的副本，应用binlog的过程，这个跟上一种场景类似。4. 批量导入数据的时候。一般情况下，把生产库改成“非双1”配置，是设置innodb_flush_logs_at_trx_commit&#x3D;2、</li>
</ol>
<p>sync_binlog&#x3D;1000。评论区留言点赞板：</p>
<p>Sinyo   2</p>
<p>@way 同学提到了一个有趣的现象，由于从库设置了 binlog_group_commit_sync_delay和</p>
<p>binlog_group_commit_sync_no_delay_count导致一直延迟的情况。我们在主库设置这两个参</p>
<p>数，是为了减少binlog的写盘压力。备库这么设置，尤其在“快要追上”的时候，就反而会受这</p>
<p>两个参数的拖累。一般追主备就用“非双1”（追上记得改回来）。@一大只 同学验证了在sync_binlog&#x3D;0的情况下，设置sync_delay和sync_no_delay_count的</p>
<p>现象，点赞这种发现边界的意识和手动验证的好习惯。是这样的：sync_delay和</p>
<p>sync_no_delay_count的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入</p>
<p>sync_binlog阶段。这时候如果判断sync_binlog&#x3D;0，就直接跳过，还是不调fsync。@锅子 同学提到，设置sync_binlog&#x3D;0的时候，还是可以看到binlog文件马上做了修改。这个</p>
<p>是对的，我们说“写到了page cache”，就是文件系统的page cache。而你用ls命令看到的就是</p>
<p>文件系统返回的结果。精选留言</p>
<p>主库 A 从本地读取 binlog，发给从库 B；</p>
<p>老师，请问这里的本地是指文件系统的 page cache还是disk呢？2019-01-21</p>
<p> 作者回复</p>
<p>好问题，</p>
<p>是这样的，对于A的线程来说，就是“读文件”，</p>
<ol>
<li><p>如果这个文件现在还在 page cache中，那就最好了，直接读走；</p>
</li>
<li><p>如果不在page cache里，就只好去磁盘读</p>
</li>
</ol>
<p>这个行为是文件系统控制的，MySQL只是执行“读文件”这个操作</p>
<p>2019-01-21</p>
<p>Leon    1</p>
<p>老师，我想问下双M架构下，主从复制，是不是一方判断自己的数据比对方少就从对方复制，</p>
<p>判断依据是什么</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>好问题。一开始创建主备关系的时候， 是由备库指定的。比如基于位点的主备关系，备库说“我要从binlog文件A的位置P”开始同步， 主库就从这个指定</p>
<p>的位置开始往后发。而主备复制关系搭建完成以后，是主库来决定“要发数据给备库”的。所以主库有生成新的日志，就会发给备库。2019-01-25</p>
<p>观弈道人   6</p>
<p>老师你好，问个备份问题，假如周日23点做了备份，周二20点需要恢复数据，那么在用binlog</p>
<p>恢复时，如何恰好定位到周日23点的binlog,谢谢。2019-01-07</p>
<p> 作者回复</p>
<p>Mysqlbinlog有个参数—stop-datetime</p>
<p>2019-01-07</p>
<p>堕落天使   3</p>
<p>老师，您好，问一个关于change buffer的问题。对于insert语句来说，change buffer的优化主要在非唯一的二级索引上，因为主键是唯一索引，</p>
<p>插入必须要判断是否存在。那么对于update语句呢？如下（假设c有非唯一索引，id是主键，d没有索引）：</p>
<p>update t set d&#x3D;2 where c&#x3D;10;</p>
<p>原先以为：从索引c取出id之后，不会回表，也不会把修改行的数据读入内存，而是直接在chan</p>
<p>ge buffer中记录一下。但看了今天得内容之后又迷糊了，因为如果不把修改行的数据读入内存</p>
<p>，它又怎么把旧数据写入binlog中呢？所以我想问的就是，上面的sql语句会不会把修改行的内容也读进内存？如果读进内存，那读进</p>
<p>内存的这一步难道就为了写binlog吗？如果不读进内存，那binlog中的旧数据又是怎么来的呢？还有delete语句也同理。2019-01-07</p>
<p> 作者回复</p>
<p>修改的行要读入内存呀</p>
<p>写binlog只需要主键索引上的值</p>
<p>你这个语句的话，如果字段c d上都有索引，那么c用不上chsnge buffer,</p>
<p>D可能可以同上</p>
<p>2019-01-07</p>
<p>hua168   2</p>
<p>大神，我前些天去面试，面试官问了一题:</p>
<p>mysql做主从，一段时间后发现从库在高峰期会发生一两条条数据丢失（不记得是查询行空白</p>
<p>还是查询不到了），主从正常，怎么判断？1.我问他是不是所以从库都是一样，他说不一样</p>
<p>2.我说低峰期重做新的从库观察，查看日志有没有报错？他好像不满意这个答案。二、他还问主库挂了怎么办？1. mysql主从+keepalived&#x2F;heartbeat</p>
<p>有脑裂，还是有前面丢数据问题</p>
<ol start="2">
<li>用MMM或HMA之类</li>
</ol>
<p>3.用ZK之类</p>
<p>三、写的压力大怎么办？我回答，分库，分表</p>
<p>感觉整天他都不怎么满意，果然没让我复试了，我郁闷呀，我就面试运维的，问数据这么详细</p>
<p>。 </p>
<p>大神，能说下我哪里有问题吗？现在我都想不明白 </p>
<p>2019-01-08</p>
<p> 作者回复</p>
<p>运维现在要求也挺高的</p>
<p>第一个问题其实我也没看懂，“高峰期丢数据”是指主备延迟查不到数据，还是真的丢了，得先</p>
<p>问清楚下</p>
<p>不过你回答的第二点不太好，低峰期重做这个大家都知道要这么做，而且只是修复动作，没办</p>
<p>法用来定位原因，面试官是要问你分析问题的方法（方向错误）</p>
<p>重搭从库错误日志里面什么都没有的（这个比较可惜，暴露了对字节不够了解，一般不了解的</p>
<p>方法在面试的时候是不如不说的）</p>
<p>第二个问题三点都是你回答的吗？那还算回答得可以的，但是不能只讲名词，要找个你熟悉细</p>
<p>节的方案展开一下</p>
<p>三方向也是对的</p>
<p>我估计就是第一个问题减分比较厉害</p>
<p>2019-01-08</p>
<p>HuaMax   2</p>
<p>课后题。如果在同步的过程中修改了server id，那用原server id 生成的log被两个M认为都不是</p>
<p>自己的而被循环执行，不知这种情况会不会发生</p>
<p>2019-01-07</p>
<p> 作者回复</p>
<p>是的，会</p>
<p>2019-01-07</p>
<p>风二中   1</p>
<p>在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使</p>
<p>用了索引 t_modified</p>
<p>老师，您好，这里索引选择不一样，是因为前面提到的mysql 会选错索引吗？这种情况应该发</p>
<p>生比较少吧，这里应该都会选择索引a吧，还是说这里只是一个事例，还有更复杂的情况</p>
<p>2019-01-12</p>
<p> 作者回复</p>
<p>对，只是一个举例的</p>
<p>2019-01-12</p>
<p>夜空中最亮的星（华仔）   1</p>
<p>级联复制，3个数据库，首尾相连，应会出现死循环</p>
<p>2019-01-08</p>
<p> 作者回复</p>
<p>不会哦，1给2，2给3，3给1，1就放弃了</p>
<p>不过引入第三个节点的思路是对的哈 </p>
<p>2019-01-08</p>
<p>changshan   1</p>
<p>老师好，mixed是row和statement的优点整合折中方案，这应该是好多系统设计理念吧？那么</p>
<p>问题一：mixed既然能判断是什么时候使用row，什么时候使用statement，那么为什么好多推</p>
<p>荐都是使用row而且不是使用mixed呢？是因为mixed这种模式下的自动选择转换不准确可能会</p>
<p>出现主从问题吗？问题二：当使用mixed模式情况下，mysql内部是怎么判断的呢？比如有limit</p>
<p>语句就会选择记录row格式，有now()函数还是同样会记录statement格式，mysql只是简单的某</p>
<p>些特定场景下会使用记录row格式吗？谢谢。2019-01-07</p>
<p> 作者回复</p>
<ol>
<li><p>就是我们文中后面说的那些原因，要用这些binlog的内容去做别的事情 </p>
</li>
<li><p>对，固定模式下的。好问题，我去拉不下最新版本代码看下规则</p>
</li>
</ol>
<p>2019-01-07</p>
<p>柚子   1</p>
<p>大佬您好，文中说现在越来越多的使用row方式的binlog，那么只能选择接受写入慢和占用空间</p>
<p>大的弊端么？2019-01-07</p>
<p> 作者回复</p>
<p>是的，当然还有minimal可选，会好些 </p>
<p>2019-01-07</p>
<p>汪炜   0</p>
<p>老师，问个问题，希望能被回答：</p>
<p>mmysql不是双一设置的时候，破坏了二阶段提交，事务已提交，redo没有及时刷盘，binlog刷</p>
<p>盘了，这种情况，mysql是怎么恢复的，这个事务到底算不算提交？2019-01-23</p>
<p> 作者回复</p>
<p>如果”redo没有及时刷盘，binlog刷盘了”之后瞬间数据库所在主机掉电，</p>
<p>主机重启，MySQL重启以后，这个事务会丢失；这里确实会引起日志和数据不一致，</p>
<p>这个就是我们说要默认设置为双1的原因之一哈</p>
<p>2019-01-23</p>
<p>Mackie .Weng   0</p>
<p>老师，你的课真好， 你讲的都是生产实际用到的，点赞~</p>
<p>不过近期有点苦恼，要请教一下近期遇到的事</p>
<p>场景：</p>
<p>SSD硬盘，我们数据一天一备份，想通过昨天凌晨备份+binlog恢复到最新数据，导出的binlog</p>
<p>为2G，然后发现导入binlog花费了4，5小时，看了下binlog日志里面有很多这种信息</p>
<h1 id="at-2492"><a href="#at-2492" class="headerlink" title="at 2492"></a>at 2492</h1><p>#190108 17:08:38 server id 2 end_log_pos 2601 CRC32 0x8b0598ec Query thread_id&#x3D;1227779</p>
<p>5 exec_time&#x3D;0 error_code&#x3D;0</p>
<p>SET TIMESTAMP&#x3D;1546938518&#x2F;<em>!</em>&#x2F;;</p>
<p>BEGIN</p>
<p>&#x2F;<em>!</em>&#x2F;;</p>
<h1 id="at-2601"><a href="#at-2601" class="headerlink" title="at 2601"></a>at 2601</h1><h1 id="at-2633"><a href="#at-2633" class="headerlink" title="at 2633"></a>at 2633</h1><h1 id="at-2919"><a href="#at-2919" class="headerlink" title="at 2919"></a>at 2919</h1><p>#190108 17:08:38 server id 2 end_log_pos 2950 CRC32 0x13806369 Xid &#x3D; 1924155105</p>
<p>COMMIT&#x2F;<em>!</em>&#x2F;;</p>
<p>问题：</p>
<p>1、在导出binlog为2G而且看了下里面很多这种事务，这是什么东西，有什么用吗</p>
<p>2、这种事务在导出binlog的时候可以不记录吗，然后来提高恢复数据的速度？3、如果这是正常的情况，有无推荐更好的数据恢复方案或者工具</p>
<p>感谢老师</p>
<p>2019-01-14</p>
<p> 作者回复</p>
<ol>
<li><p>有用，最好保留这些信息一起执行；</p>
</li>
<li><p>提升不了多少速度的，花时间主要还是在更新数据的那些日志上，那些日志又不能去掉的：</p>
</li>
</ol>
<p>）</p>
<ol start="3">
<li>这个方案是串行恢复。你可以把全量恢复出来的库，接成线上一个从库的备库，开并行复制</li>
</ol>
<p>，</p>
<p>2019-01-14</p>
<p>秋一匹   0</p>
<p>老师，您好。我这慢了一步。。。学习晚了点。我这之前碰到了个问题，有一段时间主从复制</p>
<p>延迟比较厉害，达到5s左右吧，一般都是1～2秒吧。首先排除不是网络原因。想问下还有哪些</p>
<p>因素会影响主从复制呢？2019-01-10</p>
<p> 作者回复</p>
<p>还是要给一下更具体的信息</p>
<p>比如主库的tps</p>
<p>备库的跟复制相关的配置等信息</p>
<p>2019-01-10</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师你好：</p>
<p>有一个疑惑，多条语句同时在commit阶段过程中，如果发生写入binlog和写入redolog的顺序不</p>
<p>一致的情况。主从备份的时候，从库是不是会导致数据不一致呀？2019-01-10</p>
<p>未知   0</p>
<p>老师在讲row模式的数据恢复时，感觉insert，update，delete的数据格式和undo log的差不多。之前文章一直说redo和binlog，老师抽空也讲下undo和回滚段的知识。2019-01-10</p>
<p> 作者回复</p>
<p>Undo前面大致有说过了，你要了解undo的什么内容呢</p>
<p>2019-01-10</p>
<p>光   0</p>
<p>林老师今天遇到个问题就是主从同步延迟，查到主从状态中出现：Slave_SQL_Running_State: </p>
<p>Waiting for Slave Workers to free pending events。不知道这个是否会引起延迟。查了些资料说</p>
<p>得都不是很明白。老师是否可以简短解答下。以及这种延迟如何避免。2019-01-09</p>
<p> 作者回复</p>
<p>这个的意思是， 现在工作线程里面等待的队列太多，都已经超过上限了，要等工作线程消化掉</p>
<p>一些事务再分</p>
<p>简单说，就是备库的应用日志的队列太慢了。。2019-01-10</p>
<p>梁中华   0</p>
<p>我有一个比较极端一点的HA问题，假设主库的binlog刚写成功还未来得及把binlog同步到从库，</p>
<p>主库就掉电了，这时候从库的数据会不完整吗？第二个问题，原主库重启加入集群后，那条没有传出去的binlog会如何处理？2019-01-09</p>
<p>不迷失   0</p>
<p>请教一下，生产环境能不能使用正常使用表连接？要注意哪些地方？DBA总是说不建议用，还</p>
<p>催促我将使用了表连接的地方改造，但也说不出个所以然。目前在两个百万级数据的表中有用</p>
<p>到内连接，并没有觉得有什么问题</p>
<p>2019-01-08</p>
<p> 作者回复</p>
<p>索引使用正确，不要出现全表扫描，其实OK的</p>
<p>2019-01-08</p>
<p>hua168   0</p>
<p>这样，我是想增加一些经验，怕后面试又遇到，想问一下大神分析思路，这种问题没经验回答</p>
<p>。我就差点回答用阿里云的DRDS了 </p>
<p>现在开源的mysql中间件生存环境中用什么比较多呀？mycat还是网易的cetus？海量存储阿里云有OSS，有没有对应的开源软件呀？用于生存环境的，没有接触过，想问下，</p>
<p>搞下实验后再去找工作。 </p>
<p>2019-01-08</p>
<p> 作者回复</p>
<p>中间件作为练手这些都可以的</p>
<p>你搜“开源分布式存储系统”</p>
<p>2019-01-08</p>
<p>React   0</p>
<p>老师好，文章前面说主从最好从机设置readonly.那么在双主的情况(互为主备)下，设置不同的</p>
<p>自增值是否就可以不用设置只读了？且此时复制是否可以跳过主键冲突，因为自增值不同？2019-01-08</p>
<p> 作者回复</p>
<p>如果自增值严格控制了，也没必要设置跳过主键冲突了对吧（反正不冲突）</p>
<p>除非你的业务就是设计好支持多点写入，否则还是把不写入的都设置上readonly吧</p>
<p>2019-01-08</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-MySQL是怎么保证数据不丢的</title>
    <url>/posts/4c5bdfaf.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>23 | MySQL是怎么保证数据不丢的？2019-01-04 林晓斌</p>
<p>今天这篇文章，我会继续和你介绍在业务高峰期临时提升性能的方法。从文章标题“MySQL是怎</p>
<p>么保证数据不丢的？”，你就可以看出来，今天我和你介绍的方法，跟数据的可靠性有关。在专栏前面文章和答疑篇中，我都着重介绍了WAL机制（你可以再回顾下第2篇、第9篇、第12</p>
<p>篇和第15篇文章中的相关内容），得到的结论是：只要redo log和binlog保证持久化到磁盘，就</p>
<p>能确保MySQL异常重启后，数据可以恢复。评论区有同学又继续追问，redo log的写入流程是怎么样的，如何保证redo log真实地写入了磁</p>
<p>盘。那么今天，我们就再一起看看MySQL写入binlog和redo log的流程。binlog的写入机制</p>
<p>其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的</p>
<p>时候，再把binlog cache写到binlog文件中。一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到</p>
<p>了binlog cache的保存问题。系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程</p>
<p>内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状</p>
<p>态如图1所示。图1 binlog写盘状态</p>
<p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁</p>
<p>盘，所以速度比较快。图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的</p>
<p>IOPS。write 和fsync的时机，是由参数sync_binlog控制的：</p>
<ol>
<li><p>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</p>
</li>
<li><p>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</p>
</li>
<li><p>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际</p>
</li>
</ol>
<p>的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其</p>
<p>设置为100~1000中的某个数值。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的</p>
<p>binlog日志。redo log的写入机制</p>
<p>接下来，我们再说说redo log的写入机制。在专栏的第15篇答疑文章中，我给你介绍了redo log buffer。事务在执行过程中，生成的redo</p>
<p>log是要先写到redo log buffer的。然后就有同学问了，redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？答案是，不需要。如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这</p>
<p>时日志丢了也不会有损失。那么，另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久</p>
<p>化到磁盘呢？答案是，确实会有。这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2 中的三个颜色</p>
<p>块。图2 MySQL redo log存储状态</p>
<p>这三种状态分别是：</p>
<ol>
<li><p>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</p>
</li>
<li><p>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就</p>
</li>
</ol>
<p>是图中的黄色部分；</p>
<ol start="3">
<li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢</li>
</ol>
<p>多了。为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种</p>
<p>可能取值：</p>
<ol>
<li><p>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</p>
</li>
<li><p>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</p>
</li>
<li><p>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的</p>
</li>
</ol>
<p>page cache，然后调用fsync持久化到磁盘。注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台</p>
<p>线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁</p>
<p>盘的。实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo</p>
<p>log写入到磁盘中。1. 一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，</p>
<p>后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是write，而</p>
<p>没有调用fsync，也就是只留在了文件系统的page cache。2. 另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁</p>
<p>盘。假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程</p>
<p>的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻</p>
<p>辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo</p>
<p>log buffer里的日志一起持久化到磁盘。这里需要说明的是，我们介绍两阶段提交的时候说过，时序上redo log先prepare， 再写binlog，</p>
<p>最后再把redo log commit。如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，</p>
<p>因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。（如果你印象</p>
<p>有点儿模糊了，可以再回顾下第15篇文章中的相关内容）。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就</p>
<p>不需要fsync了，只会write到文件系统的page cache中就够了。通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设</p>
<p>置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶</p>
<p>段），一次是binlog。这时候，你可能有一个疑问，这意味着我从MySQL看到的TPS是每秒两万的话，每秒就会写四</p>
<p>万次磁盘。但是，我用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？解释这个问题，就要用到组提交（group commit）机制了。这里，我需要先和你介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN是单调</p>
<p>递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加</p>
<p>上length。LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN和</p>
<p>redo log、checkpoint的关系，我会在后面的文章中详细展开。如图3所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到</p>
<p>磁盘的过程，对应的LSN分别是50、120 和160。图3 redo log 组提交</p>
<p>从图中可以看到，</p>
<ol>
<li><p>trx1是第一个到达的，会被选为这组的 leader；</p>
</li>
<li><p>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</p>
</li>
<li><p>trx1去写盘的时候，带的就是LSN&#x3D;160，因此等trx1返回时，所有LSN小于等于160的redo</p>
</li>
</ol>
<p>log，都已经被持久化到磁盘；</p>
<ol start="4">
<li>这时候trx2和trx3就可以直接返回了。所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就</li>
</ol>
<p>只能老老实实地一个事务对应一次持久化操作了。在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能</p>
<p>越多，节约IOPS的效果就越好。为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。在介绍两阶段提交的时</p>
<p>候，我曾经给你画了一个图，现在我把它截过来。图4 两阶段提交</p>
<p>图中，我把“写binlog”当成一个动作。但实际上，写binlog是分成两步的：</p>
<ol>
<li><p>先把binlog从binlog cache中写到磁盘上的binlog文件；</p>
</li>
<li><p>调用fsync持久化。MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面</p>
</li>
</ol>
<p>的图变成了这样：</p>
<p>图5 两阶段提交细化</p>
<p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务</p>
<p>的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到</p>
<p>一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和</p>
<p>binlog_group_commit_sync_no_delay_count来实现。1. binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</p>
<ol start="2">
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。所以，当binlog_group_commit_sync_delay设置为0的时</li>
</ol>
<p>候，binlog_group_commit_sync_no_delay_count也无效了。之前有同学在评论区问到，WAL机制是减少磁盘写，可是每次提交事务都要写redo log和</p>
<p>binlog，这磁盘读写次数也没变少呀？现在你就能理解了，WAL机制主要得益于两个方面：</p>
<ol>
<li><p>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</p>
</li>
<li><p>组提交机制，可以大幅度降低磁盘的IOPS消耗。分析到这里，我们再来回答这个问题：如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO</p>
</li>
</ol>
<p>上，可以通过哪些方法来提升性能呢？针对这个问题，可以考虑以下三种方法：</p>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参</li>
</ol>
<p>数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加</p>
<p>语句的响应时间，但没有丢失数据的风险。2. 将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时</p>
<p>会丢binlog日志。3. 将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。我不建议你把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo</p>
<p>log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文</p>
<p>件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，</p>
<p>但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。小结</p>
<p>在专栏的第2篇和第15篇文章中，我和你分析了，如果redo log和binlog是完整的，MySQL是如</p>
<p>何保证crash-safe的。今天这篇文章，我着重和你介绍的是MySQL是“怎么保证redo log和binlog</p>
<p>是完整的”。希望这三篇文章串起来的内容，能够让你对crash-safe这个概念有更清晰的理解。之前的第15篇答疑文章发布之后，有同学继续留言问到了一些跟日志相关的问题，这里为了方</p>
<p>便你回顾、学习，我再集中回答一次这些问题。问题1：执行一个update语句以后，我再去执行hexdump命令直接查看ibd文件内容，为什么没</p>
<p>有看到数据有改变呢？回答：这可能是因为WAL机制的原因。update语句执行完成后，InnoDB只保证写完了redo</p>
<p>log、内存，可能还没来得及将数据写到磁盘。问题2：为什么binlog cache是每个线程自己维护的，而redo log buffer是全局共用的？回答：MySQL这么设计的主要原因是，binlog是不能“被打断的”。一个事务的binlog必须连续</p>
<p>写，因此要整个事务完成后，再一起写到文件里。而redo log并没有这个要求，中间有生成的日志可以写到redo log buffer中。redo log buffer中的</p>
<p>内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。问题3：事务执行期间，还没到提交阶段，如果发生crash的话，redo log肯定丢了，这会不会导</p>
<p>致主备不一致呢？回答：不会。因为这时候binlog 也还在binlog cache里，没发给备库。crash以后redo log和binlog</p>
<p>都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。问题4：如果binlog写完盘以后发生crash，这时候还没给客户端答复就重启了。等客户端再重连</p>
<p>进来，发现事务已经提交成功了，这是不是bug？回答：不是。你可以设想一下更极端的情况，整个事务都提交成功了，redo log commit完成了，备库也收到</p>
<p>binlog并执行了。但是主库和客户端网络断开了，导致事务成功的包返回不回去，这时候客户端</p>
<p>也会收到“网络断开”的异常。这种也只能算是事务成功的，不能认为是bug。实际上数据库的crash-safe保证的是：</p>
<ol>
<li><p>如果客户端收到事务成功的消息，事务就一定持久化了；</p>
</li>
<li><p>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</p>
</li>
<li><p>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。最后，又到了课后问题时间。今天我留给你的思考题是：你的生产库设置的是“双1”吗？ 如果平时是的话，你有在什么场景下</p>
</li>
</ol>
<p>改成过“非双1”吗？你的这个操作又是基于什么决定的？另外，我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？你可以把你的理解或者经验写在留言区，我会在下一篇文章的末尾选取有趣的评论和你一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上篇文章最后，想要你分享的是线上“救火”的经验。@Long 同学，在留言中提到了几个很好的场景。其中第3个问题，“如果一个数据库是被客户端的压力打满导致无法响应的，重启数据库是没</p>
<p>用的。”，说明他很好地思考了。这个问题是因为重启之后，业务请求还会再发。而且由于是重启，buffer pool被清空，可能会</p>
<p>导致语句执行得更慢。他提到的第4个问题也很典型。有时候一个表上会出现多个单字段索引（而且往往这是因为运</p>
<p>维工程师对索引原理不够清晰做的设计），这样就可能出现优化器选择索引合并算法的现</p>
<p>象。但实际上，索引合并算法的效率并不好。而通过将其中的一个索引改成联合索引的方</p>
<p>法，是一个很好的应对方案。还有其他几个同学提到的问题场景，也很好，很值得你一看。@Max 同学提到一个很好的例子：客户端程序的连接器，连接完成后会做一些诸如show</p>
<p>columns的操作，在短连接模式下这个影响就非常大了。这个提醒我们，在review项目的时候，不止要review我们自己业务的代码，也要review连接器</p>
<p>的行为。一般做法就是在测试环境，把general_log打开，用业务行为触发连接，然后通过</p>
<p>general log分析连接器的行为。@Manjusaka 同学的留言中，第二点提得非常好：如果你的数据库请求模式直接对应于客户</p>
<p>请求，这往往是一个危险的设计。因为客户行为不可控，可能突然因为你们公司的一个运营推</p>
<p>广，压力暴增，这样很容易把数据库打挂。在设计模型里面设计一层，专门负责管理请求和数据库服务资源，对于比较重要和大流量的业</p>
<p>务，是一个好的设计方向。锅子   2</p>
<p>老师好，有一个疑问：当设置sync_binlog&#x3D;0时，每次commit都只时write到page cache，并不</p>
<p>会fsync。但是做实验时binlog文件中还是会有记录，这是什么原因呢？是不是后台线程每秒一</p>
<p>次的轮询也会将binlog cache持久化到磁盘？还是有其他的参数控制呢？2019-01-04</p>
<p> 作者回复</p>
<p>你看到的“binlog的记录”，也是从page cache读的哦。Page cache是操作系统文件系统上的 </p>
<p>好问题</p>
<p>2019-01-04</p>
<p>倪大人   4</p>
<p>老师求解sync_binlog和binlog_group_commit_sync_no_delay_count这两个参数区别</p>
<p>如果</p>
<p>@Vincent 同学提了一个好问题，用文中提到的DDL方案，会导致binlog里面少了这个DDL语</p>
<p>句，后续影响备份恢复的功能。由于需要另一个知识点（主备同步协议），我放在后面的文章</p>
<p>中说明。精选留言</p>
<p>sync_binlog &#x3D; N</p>
<p>binlog_group_commit_sync_no_delay_count &#x3D; M</p>
<p>binlog_group_commit_sync_delay &#x3D; 很大值</p>
<p>这种情况fsync什么时候发生呀，min(N,M)吗？感觉sync_binlog搭配binlog_group_commit_sync_delay也可以实现组提交？如果</p>
<p>sync_binlog &#x3D; 0</p>
<p>binlog_group_commit_sync_no_delay_count &#x3D; 10</p>
<p>这种情况下是累计10个事务fsync一次？2019-01-04</p>
<p> 作者回复</p>
<p>好问题，我写这篇文章的时候也为了这个问题去翻了代码，是这样的：</p>
<p>达到N次以后，可以刷盘了，然后再进入(sync_delay和no_delay_count)这个逻辑；</p>
<p>Sync_delay如果很大，就达到no_delay_count才刷；</p>
<p>只要sync_binlog&#x3D;0,也会有前面的等待逻辑，但是等完后还是不调fsync </p>
<p>2019-01-06</p>
<p>WilliamX   3</p>
<p>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？这个问题，感觉还有一点，binlog存储是以statement或者row格式存储的，而redo log是以page</p>
<p>页格式存储的。page格式，天生就是共有的，而row格式，只跟当前事务相关</p>
<p>2019-01-04</p>
<p> 作者回复</p>
<p>嗯，这个解释也很好。  </p>
<p>2019-01-04</p>
<p>一大只    2</p>
<p>你是怎么验证的？等于0的时候虽然有走这个逻辑，但是最后调用fsync之前判断是0，就啥也没</p>
<p>做就走了</p>
<p>回复老师:</p>
<p>老师，我说的sync_binlog&#x3D;0或&#x3D;1效果一样，就是看语句实际执行的效果，参数binlog_group_c</p>
<p>ommit_sync_delay我设置成了500000微秒，在&#x3D;1或&#x3D;0时，对表进行Insert，然后都会有0.5秒的</p>
<p>等待，也就是执行时间都是0.51 sec，关闭binlog_group_commit_sync_delay，insert执行会飞</p>
<p>快，所以我认为&#x3D;1或&#x3D;0都是受组提交参数的影响的。2019-01-05</p>
<p> 作者回复</p>
<p>  </p>
<p>非常好</p>
<p>然后再补上我回答的这个逻辑，就完备了</p>
<p>2019-01-05</p>
<p>alias cd&#x3D;rm -rf   1</p>
<p>事务A是当前事务，这时候事务B提交了。事务B的redolog持久化时候，会顺道把A产生的redol</p>
<p>og也持久化，这时候A的redolog状态是prepare状态么？2019-01-28</p>
<p> 作者回复</p>
<p>不是。说明一下哈，所谓的 redo log prepare，是“当前事务提交”的一个阶段，也就是说，在事务A提</p>
<p>交的时候，我们才会走到事务A的redo log prepare这个阶段。事务A在提交前，有一部分redo log被事务B提前持久化，但是事务A还没有进入提交阶段，是无</p>
<p>所谓“redo log prepare”的。好问题</p>
<p>2019-01-28</p>
<p>某、人   1</p>
<p>有调到非双1的时候,在大促时非核心库和从库延迟较多的情况。设置的是sync_binlog&#x3D;0和innodb_flush_log_at_trx_commit&#x3D;2</p>
<p>针对0和2,在mysql crash时不会出现异常,在主机挂了时，会有几种风险:</p>
<p>1.如果事务的binlog和redo log都还未fsync,则该事务数据丢失</p>
<p>2.如果事务binlog fsync成功,redo log未fsync,则该事务数据丢失。虽然binlog落盘成功,但是binlog没有恢复redo log的能力,所以redo log不能恢复.</p>
<p>不过后续可以解析binlog来恢复这部分数据</p>
<p>3.如果事务binlog fsync未成功,redo log成功。由于redo log恢复数据是在引擎层,所以重新启动数据库,redo log能恢复数据,但是不能恢复serve</p>
<p>r层的binlog,则binlog丢失。如果该事务还未从FS page cache里发送给从库,那么主从就会出现不一致的情况</p>
<p>4.如果binlog和redo log都成功fsync,那么皆大欢喜。老师我有几个问题:</p>
<p>1.因为binlog不能被打断,那么binlog做fsync是单线程吧?</p>
<p>如果是的话,那么binlog的write到fsync的时间,就应该是redo log fsync+上一个事务的binlog fsync</p>
<p>时间。但是测试到的现象,一个超大事务做fsync时,对其它事务的提交影响也不大。如果是多线程做fsync,怎么保证的一个事务binlog在磁盘上的连续性？2. 5.7的并行复制是基于binlog组成员并行的,为什么很多文章说是表级别的并行复制？2019-01-06</p>
<p> 作者回复</p>
<ol>
<li>Write的时候只要写进去了，fsync其实很快的。连续性是write的时候做的（写的时候保证了</li>
</ol>
<p>连续）</p>
<ol start="2">
<li>你的理解应该是对的。不是表级</li>
</ol>
<p>2019-01-06</p>
<p>永恒记忆   1</p>
<p>主从模式下，内网从库如果设置双1，刚还原的数据发现根本追不上主库，所以从库设置了0，</p>
<p>老师后面章节会讲关于mysql包括主从监控这块的内容吗。2019-01-04</p>
<p> 作者回复</p>
<p>会讲到</p>
<p>2019-01-04</p>
<p>往事随风，顺其自然   1</p>
<p>redolog 里面有已经提交事物日志，还有未提交事物日志都持久化到磁盘，此时异常重启，binl</p>
<p>og 里面不是多余记录的未提交事物，干嘛不设计不添加未提交事物不更好</p>
<p>2019-01-04</p>
<p>miu   0</p>
<p>老师，关于BINLOG_GROUP_COMMIT_SYNC_DELAY，</p>
<p>BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT，</p>
<p>SYNC_BINLOG三个参数，我的理解是：</p>
<p>若SYNC_BINLOG&gt;1时，且设置了BINLOG_GROUP_COMMIT_SYNC_DELAY和BINLOG_GR</p>
<p>OUP_COMMIT_SYNC_NO_DELAY_COUNT两个参数。例如 </p>
<p>sync_binlog&#x3D;2，</p>
<p>BINLOG_GROUP_COMMIT_SYNC_DELAY&#x3D;1000000，</p>
<p>BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT&#x3D;3，</p>
<p>那么在执行完第1个事务后，在第2个事务提交时，会根据后续的事务提交来判断fsync等待的时</p>
<p>间，</p>
<p>若后续在1秒内没有累积3个事务的提交，则会等待1秒后再做fsync，从SQL语句来看，执行第</p>
<p>一个语句很快，第二个语句需要等待1秒才成功。这时延时等待的时间是BINLOG_GROUP_C</p>
<p>OMMIT_SYNC_DELAY所设置的值。若执行完第1个事务后，并行执行3个事务（1秒内完成），则后续3个事务会同时做fsync，这时</p>
<p>延时等待的时间是BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT设置的数量的事</p>
<p>务提交的间隔时间。也就是sync_binlog+BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT-1 个事务做一</p>
<p>次fsync。我测试的版本是MySQL官方5.7.24，请老师点评。2019-02-01</p>
<p> 作者回复</p>
<p>这两个逻辑不建议放到一起算</p>
<p>就是按照这样：</p>
<ol>
<li>有设置 BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT这个值，（假设SYNC_D</li>
</ol>
<p>ELAY很大），提交的时候就得等这么多次才能过；</p>
<ol start="2">
<li>到了提交阶段，又要按照sync_binlog来判断是否刷盘。新春快乐~</li>
</ol>
<p>2019-02-04</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>老师不好意思，我接着刚才的问题问哈</p>
<p>并发事务的redolog持久化，会把当前事务的redolog持久化，当前事务的redolog持久化后prepa</p>
<p>re状态么？redolog已经被持久化到磁盘了，那么当前事务提交时候，redolog变为prepare状态</p>
<p>，这时候是从redologbuffer加载还是从磁盘加载？2019-01-28</p>
<p> 作者回复</p>
<p>每个事务在提交过程的prepare阶段，会把redolog持久化； “当前事务的redolog持久化后prepar</p>
<p>e状态么”这个描述还是不清楚，你用事务A、事务B这样来描述吧 </p>
<p>redolog已经被持久化到磁盘了，那么当前事务提交时候，</p>
<p>（其实这里只是“部分”被持久化，因为这个事务自己在执行的过程中，还会产生新的日志），</p>
<p>只需要继续持久化剩下的redo log</p>
<p>2019-01-28</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>您好，我看文章后有俩点疑问，前提条件如果mysql设置双1</p>
<p>1、这时候磁盘中的redolog的状态是什么状态呢？是prepare么？2、如果一个事务在进行中的时候redolog已经被持久化，在事务提交时候，这条redolog还在re</p>
<p>dolog-buffer中么？2019-01-27</p>
<p> 作者回复</p>
<ol>
<li><p>“这时候磁盘中的redolog的状态是什么状态呢？是prepare么？”这个“这时候”是什么意思 </p>
</li>
<li><p>还在，不过随时可以被覆盖</p>
</li>
</ol>
<p>2019-01-28</p>
<p>嘻嘻   0</p>
<ol>
<li>如果客户端收到事务成功的消息，事务就一定持久化了；</li>
</ol>
<p>commit是在什么阶段返回的？如果写完page cache就返回也没有持久化吧？2019-01-25</p>
<p> 作者回复</p>
<p>第一个问题没看懂。“如果写完page cache就返回也没有持久化吧”， 是的，</p>
<p>“客户端收到事务成功的消息，事务就一定持久化了”是建立在双1基础上的。2019-01-26</p>
<p>Geek_527020   0</p>
<p>您好，老师，我有一个以后，组提交，把为提交事务的redo log写入磁盘，如果有查询，岂不</p>
<p>是查到未提交事务的更新内容了?</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>不会啊，有MVCC的， 08篇再看下</p>
<p>2019-01-25</p>
<p>J!   0</p>
<p>共同写一个binlog文件，这个过程应该需要锁来维持提交的时序吧，写文件的时候是不是可能</p>
<p>会变成瓶颈点？2019-01-23</p>
<p> 作者回复</p>
<p>不会的，大家分头写，然后一起持久化到磁盘</p>
<p>2019-01-23</p>
<p>Komine   0</p>
<p>为什么binlog 是不能“被打断的”的呢？主要出于什么考虑？2019-01-22</p>
<p> 作者回复</p>
<p>好问题</p>
<p>我觉得一个比较重要的原因是，一个线程只能同时有一个事务在执行。由于这个设定，所以每当执行一个begin&#x2F;start transaction的时候，就会默认提交上一个事务；</p>
<p>这样如果一个事务的binlog被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破</p>
<p>坏了原子性，是有问题的。2019-01-22</p>
<p>就是个渣渣    0</p>
<p>林老师，你好！超过了binlog_cache_size，暂存到磁盘，那如果超过了max_binlog_cache_siz</p>
<p>e 就直接报错了呢，这两个参数的关联是什么呢？2019-01-19</p>
<p> 作者回复</p>
<p>max_binlog_cache_size只是用来限制设置binlog_cache_size的时候的上限 </p>
<p>并不参与执行语句的逻辑的</p>
<p>2019-01-19</p>
<p>似水流年   0</p>
<p>我网上查pagecache是在内存里的，这与您讲的一样吗？2019-01-15</p>
<p> 作者回复</p>
<p>就是文件系统的page cache，是属于操作系统的内存的一部分</p>
<p>2019-01-15</p>
<p>猪哥哥   0</p>
<p>老师好, 能说下innodb_log_buffer_size参数的作用吗</p>
<p>2019-01-10</p>
<p>roaming   0</p>
<p>看了几遍，终于看明白了</p>
<p>2019-01-10</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-10</p>
<p>猪哥哥   0</p>
<p>老师 我想问下文件系统的page cache还是不是内存, 是不是文件系统向内核申请的一块的内存?</p>
<p>2019-01-10</p>
<p> 作者回复</p>
<p>你理解的是对的</p>
<p>2019-01-10</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-MySQL是怎么保证高可用的</title>
    <url>/posts/9d443267.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>25 | MySQL是怎么保证高可用的？2019-01-09 林晓斌</p>
<p>在上一篇文章中，我和你介绍了binlog的基本内容，在一个主备关系中，每个备库接收主库的</p>
<p>binlog并执行。正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能</p>
<p>达到跟主库一致的状态，这就是最终一致性。但是，MySQL要提供高可用能力，只有最终一致性是不够的。为什么这么说呢？今天我就着重</p>
<p>和你分析一下。这里，我再放一次上一篇文章中讲到的双M结构的主备切换流程图。图 1 MySQL主备切换流程–双M结构</p>
<p>主备延迟</p>
<p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动</p>
<p>操作，比如主库所在机器掉电。接下来，我们先一起看看主动切换的场景。在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即“同步延迟”。与数据同步有</p>
<p>关的时间点主要包括以下三个：</p>
<ol>
<li><p>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</p>
</li>
<li><p>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</p>
</li>
<li><p>备库B执行完成这个事务，我们把这个时刻记为T3。所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也</p>
</li>
</ol>
<p>就是T3-T1。你可以在备库上执行show slave status命令，它的返回结果里面会显示</p>
<p>seconds_behind_master，用于表示当前备库延迟了多少秒。seconds_behind_master的计算方法是这样的：</p>
<ol>
<li><p>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</p>
</li>
<li><p>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到</p>
</li>
</ol>
<p>seconds_behind_master。可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用</p>
<p>seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？其实不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来</p>
<p>获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行</p>
<p>seconds_behind_master计算的时候会自动扣掉这个差值。需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是</p>
<p>非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个</p>
<p>事务之间的时间差。所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog</p>
<p>的速度要慢。接下来，我就和你一起分析下，这可能是由哪些原因导致的。主备延迟的来源</p>
<p>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或</p>
<p>者，他们会把20个主库放在4台机器上，而把备库集中在一台机器上。其实我们都知道，更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署</p>
<p>时，一般都会将备库设置为“非双1”的模式。但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的</p>
<p>时候，就可能会导致主备延迟了。当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以主备库选</p>
<p>用相同规格的机器，并且做对称部署，是现在比较常见的情况。追问1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？这就是第二种常见的可能了，即备库的压力大。一般的想法是，主库既然提供了写能力，那么</p>
<p>备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在</p>
<p>备库上跑。我真就见过不少这样的情况。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备</p>
<p>库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延</p>
<p>迟。这种情况，我们一般可以这么处理：</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。2. 通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能</li>
</ol>
<p>力。而从库，就很适合用来做备份。追问2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？这就是第三种可能了，即大事务。大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所</p>
<p>以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。不知道你所在公司的DBA有没有跟你这么说过：不要一次性地用delete语句删除太多数据。其</p>
<p>实，这就是一个典型的大事务场景。比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次</p>
<p>性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很</p>
<p>不错的），所以会在晚上执行这些大量数据的删除操作。结果，负责的DBA同学半夜就会收到延迟报警。然后，DBA团队就要求你后续再删除数据的时</p>
<p>候，要控制每个事务删除的数据量，分成多次删除。另一种典型的大事务场景，就是大表DDL。这个场景，我在前面的文章中介绍过。处理方案</p>
<p>就是，计划内的DDL，建议使用gh-ost方案（这里，你可以再回顾下第13篇文章《为什么表数据</p>
<p>删掉一半，表文件大小不变？》中的相关内容）。追问3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？造成主备延迟还有一个大方向的原因，就是备库的并行复制能力。这个话题，我会留在下一篇</p>
<p>文章再和你详细介绍。备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描</p>
<p>述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。其实还是有不少其他情况会导致主备延迟，如果你还碰到过其他场景，欢迎你在评论区给我留</p>
<p>言，我来和你一起分析、讨论。由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。可靠性优先策略</p>
<p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则</li>
</ol>
<p>持续重试这一步；</p>
<ol start="2">
<li><p>把主库A改成只读状态，即把readonly设置为true；</p>
</li>
<li><p>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</p>
</li>
<li><p>把备库B改成可读写状态，也就是把readonly 设置为false；</p>
</li>
<li><p>把业务请求切到备库B。这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。图2 MySQL可靠性优先主备切换流程</p>
</li>
</ol>
<p>备注：图中的SBM，是seconds_behind_master参数的简写。可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于</p>
<p>readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需</p>
<p>要在步骤1先做判断，确保seconds_behind_master的值足够小。试想如果一开始主备延迟就长达30分钟，而不先做判断直接切换的话，系统的不可用时间就会</p>
<p>长达30分钟，这种情况一般业务都是不可接受的。当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的</p>
<p>策略，来把这个不可用时间几乎降为0。可用性优先策略</p>
<p>如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库</p>
<p>B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一</p>
<p>致的情况。接下来，我就和你分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t：</p>
<p>这个表定义了一个自增主键id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员</p>
<p>要继续在表t上执行两条插入语句的命令，依次是：</p>
<p>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到5秒。在插入一条c&#x3D;4的语句</p>
<p>mysql&gt; CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) unsigned NOT NULL AUTO_INCREMENT,</p>
<p>  &#96;c  ̀int(11) unsigned DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t(c) values(1),(2),(3);</p>
<p>insert into t(c) values(4);</p>
<p>insert into t(c) values(5);</p>
<p>后，发起了主备切换。图3是可用性优先策略，且binlog_format&#x3D;mixed时的切换流程和数据结果。图3 可用性优先策略，且binlog_format&#x3D;mixed</p>
<p>现在，我们一起分析下这个切换流程：</p>
<ol>
<li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。2. 步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c&#x3D;4”这个中转日志，</li>
</ol>
<p>就开始接收客户端“插入 c&#x3D;5”的命令。3. 步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。4. 步骤5中，备库B执行“插入c&#x3D;4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执</p>
<p>行的“插入c&#x3D;5”这个语句，传到主库A，就插入了一行新数据（5,5）。最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是</p>
<p>由可用性优先流程导致的。那么，如果我还是用可用性优先策略，但设置binlog_format&#x3D;row，情况又会怎样呢？因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一</p>
<p>致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况</p>
<p>下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。图4中我画出了详细过程，你可以自己再分析一下。图4 可用性优先策略，且binlog_format&#x3D;row</p>
<p>从上面的分析中，你可以看到一些结论：</p>
<ol>
<li>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格</li>
</ol>
<p>式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，</p>
<p>很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。2. 主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠</p>
<p>性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。但事无绝对，有没有哪种情况数据的可用性优先级更高呢？答案是，有的。我曾经碰到过这样的一个场景：</p>
<p>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短</p>
<p>暂的不一致也不会引发业务问题。同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法</p>
<p>执行。这时候，你可能就需要选择先强行切换，事后再补数据的策略。当然，事后复盘的时候，我们想到了一个改进措施就是，让业务逻辑不要依赖于这类日志的写</p>
<p>入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临</p>
<p>时库里面。这样的话，这种场景就又可以使用可靠性优先策略了。接下来我们再看看，按照可靠性优先的思路，异常切换会是什么效果？假设，主库A和备库B间的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主</p>
<p>库。我们在主动切换的时候，可以等到主备延迟小于5秒的时候再启动切换，但这时候已经别无</p>
<p>选择了。图5 可靠性优先策略，主库不可用</p>
<p>采用可靠性优先策略的话，你就必须得等到备库B的seconds_behind_master&#x3D;0之后，才能切</p>
<p>换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用</p>
<p>的状态。因为，主库A掉电后，我们的连接还没有切到备库B。你可能会问，那能不能直接切换到备库B，但是保持B只读呢？这样也不行。因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前</p>
<p>执行完成的事务，会认为有“数据丢失”。虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢</p>
<p>失数据的状态”也是不能被接受的。聊到这里你就知道了，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主</p>
<p>备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。小结</p>
<p>今天这篇文章，我先和你介绍了MySQL高可用系统的基础，就是主备切换逻辑。紧接着，我又</p>
<p>和你讨论了几种会导致主备延迟的情况，以及相应的改进方向。然后，由于主备延迟的存在，切换策略就有不同的选择。所以，我又和你一起分析了可靠性优先</p>
<p>和可用性优先策略的区别。在实际的应用中，我更建议使用可靠性优先的策略。毕竟保证数据准确，应该是数据库服务的底</p>
<p>线。在这个基础上，通过减少主备延迟，提升系统的可用性。最后，我给你留下一个思考题吧。一般现在的数据库运维系统都有备库延迟监控，其实就是在备库上执行 show slave status，采集</p>
<p>seconds_behind_master的值。假设，现在你看到你维护的一个备库，它的延迟监控的图像类似图6，是一个45°斜向上的线段，</p>
<p>你觉得可能是什么原因导致呢？你又会怎么去确认这个原因呢？图6 备库延迟</p>
<p>你可以把你的分析写在评论区，我会在下一篇文章的末尾跟你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期我留给你的问题是，什么情况下双M结构会出现循环复制。一种场景是，在一个主库更新事务后，用命令set global server_id&#x3D;x修改了server_id。等日志再</p>
<p>传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。另一种场景是，有三个节点的时候，如图7所示，trx1是在节点 B执行的，因此binlog上的</p>
<p>server_id就是B，binlog传给节点 A，然后A和A’搭建了双M结构，就会出现循环复制。图7 三节点循环复制</p>
<p>这种三节点复制的场景，做数据库迁移的时候会出现。如果出现了循环复制，可以在A或者A’上，执行如下命令：</p>
<p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。评论区留言点赞板：</p>
<p>stop slave；</p>
<p>CHANGE MASTER TO IGNORE_SERVER_IDS&#x3D;(server_id_of_B);</p>
<p>start slave;</p>
<p>stop slave；</p>
<p>CHANGE MASTER TO IGNORE_SERVER_IDS&#x3D;();</p>
<p>start slave;</p>
<p>某、人   12</p>
<p>遇到过下面几种造成主从延迟的情况:</p>
<p>1.主库DML语句并发大,从库qps高</p>
<p>2.从库服务器配置差或者一台服务器上几台从库(资源竞争激烈,特别是io)</p>
<p>3.主库和从库的参数配置不一样</p>
<p>4.大事务(DDL,我觉得DDL也相当于一个大事务)</p>
<p>5.从库上在进行备份操作</p>
<p>6.表上无主键的情况(主库利用索引更改数据,备库回放只能用全表扫描,这种情况可以调整slave_</p>
<p>rows_search_algorithms参数适当优化下)</p>
<p>7.设置的是延迟备库</p>
<p>8.备库空间不足的情况下</p>
<p>这期的问题：</p>
<p>看这曲线,应该是从库正在应用一个大事务,或者一个大表上无主键的情况(有该表的更新)</p>
<p>@一大只、@HuaMax 同学提到了第一个复现方法；</p>
<p>@Jonh同学提到了IGNORE_SERVER_IDS这个解决方法；</p>
<p>@React 提到，如果主备设置不同的步长，备库是不是可以设置为可读写。我的建议是，只要</p>
<p>这个节点设计内就不会有业务直接在上面执行更新，就建议设置为readonly。精选留言</p>
<p>应该是T3随着时间的增长在增长,而T1这个时间点是没变的,造成的现象就是</p>
<p>随着时间的增长,second_behind_master也是有规律的增长</p>
<p>2019-01-10</p>
<p> 作者回复</p>
<p>分析的点很准确 </p>
<p>2019-01-11</p>
<p>undifined   2</p>
<p>问题答案：</p>
<ol>
<li><p>备库在执行复杂查询，导致资源被占用</p>
</li>
<li><p>备库正在执行一个大事务</p>
</li>
<li><p>DML 语句执行</p>
</li>
</ol>
<p>老师我的理解对吗</p>
<p>2019-01-09</p>
<p> 作者回复</p>
<p>1不太准确，明天我会提到哈</p>
<p>23对的</p>
<p>2019-01-09</p>
<p>7号   1</p>
<p>老师，生产环境有一张表需要清理，该表大小140G。要保留最近一个月的数据，又不能按时间</p>
<p>直接用detele删（全表扫描），本来想通过清空分区表删，但是分区表又是哈希的。。有没好</p>
<p>的办法呢？2019-01-09</p>
<p> 作者回复</p>
<p>估计下一个月占多少比例，如果比较小就建新表，把数据导过去吧</p>
<p>如果一个月占比高的话，只能一点点删了。时间字段有索引的话，每个分区按时间过滤出来删除</p>
<p>2019-01-09</p>
<p>Sr7vy   1</p>
<p>问题1：T3的解释是：备库执行完这个事物。则：Seconds_Behind_Master&#x3D;T3-T1。如T1&#x3D;30</p>
<p>min，主执行完成，备没有执行。猜测1：那么Seconds_Behind_Master&#x3D;30min吗？猜测2：备</p>
<p>执需要先把这个30min的事务执行完后，Seconds_Behind_Master&#x3D;30min？问题2：很多时候是否能把Seconds_Behind_Master当作真正的延迟时间（面试常被问）？如</p>
<p>果能，pt-heartbeat存在还有啥意义啊？2019-01-09</p>
<p> 作者回复</p>
<p>问题1:</p>
<p>1.备库没收到，还是收到没执行，前者0，后者30</p>
<ol start="2">
<li>第二问没看懂</li>
</ol>
<p>问题2:</p>
<p>类似的，主库把日志都发给备库了吗</p>
<p>2019-01-09</p>
<p>万勇   1</p>
<p>主备同步延迟，工作中常遇到几种情况：</p>
<p>1.主库做大量的dml操作，引起延迟</p>
<p>2.主库有个大事务在处理，引起延迟</p>
<p>3.对myisam存储引擎的表做dml操作，从库会有延迟。4.利用pt工具对主库的大表做字段新增、修改和添加索引等操作，从库会有延迟。2019-01-09</p>
<p> 作者回复</p>
<p>  </p>
<p>你是有故事的 </p>
<p>2019-01-09</p>
<p>梁中华   1</p>
<p>我有一个比较极端一点的HA问题，假设主库的binlog刚写成功还未来得及把binlog同步到从库，</p>
<p>主库就掉电了，这时候从库的数据会不完整吗？第二个问题，原主库重启加入集群后，那条没有传出去的binlog会如何处理？2019-01-09</p>
<p> 作者回复</p>
<p>1.可能会丢</p>
<ol start="2">
<li>要看重启之后的拓扑结构了，如果还有节点是这个库的从库，还是会拿走的</li>
</ol>
<p>2019-01-09</p>
<p> JJ   1</p>
<p>请问老师，主库断电了，怎么把binlog传给从库同步数据，怎么使的SBM为0主从切换呢？2019-01-09</p>
<p> 作者回复</p>
<p>等应用完就认为是SBM&#x3D;0</p>
<p>如果不能接受主库有来不及传的，就使用semi-sync</p>
<p>2019-01-09</p>
<p>via   1</p>
<p>通过 binlog 输出到外部系统，比如 Hadoop 这类…</p>
<p>文中这个具体是可采用什么工具呢？2019-01-09</p>
<p> 作者回复</p>
<p>canal 可以了解下</p>
<p>2019-01-10</p>
<p>Sinyo   1</p>
<p>老师，在 binlog row模式下，insert 到表中一条记录，这条记录中某个字段不填，该字段在表中</p>
<p>有设置默认值，利用canal解析binlog出来，这个不填的字段会不存在；难道 binlog 只记录有插</p>
<p>入的字段数据，表字段的默认数据就不会记录么？mysql版本5.7.22 canal版本1.0.3</p>
<p>2019-01-09</p>
<p> 作者回复</p>
<p>不会啊</p>
<p>insert记录的时候肯定都记录的</p>
<p>你的默认值是什么？2019-01-10</p>
<p>700   0</p>
<p>老师请教下，MySQL 主从跨 IDC 的痛点是什么？同城 IDC 和异地 IDC 的痛点一样吗？怎么来</p>
<p>解决这些痛点？2019-01-22</p>
<p> 作者回复</p>
<p>跨IDC还好吧，跨城市或者跨洲才比较麻烦</p>
<p>其实主要还是延迟的问题，这个确实不好解决。业务开发的时候尽量是本城市访问，否则容易出现抖动</p>
<p>2019-01-23</p>
<p>强哥   0</p>
<p>今天跟公司的dba咨询了下，目前公司用的主备切换策略都是可用性优先，说是可靠性优先的</p>
<p>话，可能会引起雪崩，主要还是业务的并发高，这种场景您是怎么看呢？麻烦给下思路谢谢。2019-01-21</p>
<p> 作者回复</p>
<p>额 那这个是要跟业务好好讨论一下架构设计的，可以这么跟业务说，如果是由于问题导致整个</p>
<p>连不通，会不会雪崩？也就是说，可用性不可能100%，如果不可用就雪崩，表示架构需要优化。之后才谈策略选择（否则这样根本没得谈哈）</p>
<p>2019-01-21</p>
<p>cheriston   0</p>
<p>老师 seconds_behind_master&#x3D;0 也不能100%代表主库与从库之间没有延迟 吧 ?</p>
<p>2019-01-18</p>
<p> 作者回复</p>
<p>嗯嗯，看下28篇 </p>
<p>2019-01-18</p>
<p>悟空   0</p>
<p>老师文章末尾思考题部分，有点困惑求解答。循环复制我之前理解是B-&gt;A-&gt;A’-&gt;B这样的拓扑结构。而双M结构理解是A-&gt;A’-&gt;A，此时A是A’的主库和从库，B只能是A的从库。那么trx1在从库B上</p>
<p>的更新就不会传给A。文中是一种假设吗？还是我理解偏差了 ~</p>
<p>——–正文——–</p>
<p>trx1 是在节点 B 执行的，因此 binlog 上的 server_id 就是 B，binlog 传给节点 A，然后A 和 A’搭</p>
<p>建了双 M 结构，就会出现循环复制。2019-01-12</p>
<p> 作者回复</p>
<p>这个说的是迁移过程，</p>
<p>也就是说，一开始A是B的从库，后来迁移过程中，停止了A和B的主备关系，让A和A’互为主备</p>
<p>2019-01-12</p>
<p>崔伟协   0</p>
<p>发生主从切换的时候，主有的最新数据没同步到从，会出现这种情况吗，出现了会怎么样</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>异常切换有可能的</p>
<p>要根据你的处理策略了，如果不能丢，有几个可选的</p>
<p>1.不切换（等这个库自己恢复起来）</p>
<ol start="2">
<li><p>使用semi-sync策略</p>
</li>
<li><p>启动后业务做数据对账（这个一般用得少，成本高）</p>
</li>
</ol>
<p>2019-01-11</p>
<p>任鹏斌   0</p>
<p>老师好发现我们系统中一条sql写法比较独特</p>
<p>SELECT</p>
<p>IF(ha.curricula_type &#x3D; ‘02’</p>
<p>AND ((cla.model_code IN (‘CM05004’ , ‘CM05001’)</p>
<p>AND cla.is_vip_video &#x3D; 1)</p>
<p>OR cla.model_code &#x3D; ‘CM05008’),</p>
<p>‘1’,</p>
<p>‘0’) AS ‘isUK’</p>
<p>FROM</p>
<p>h_curricula ha,</p>
<p>h_class cla</p>
<p>WHERE</p>
<p>ha.<code>code</code> &#x3D; ‘2’ </p>
<p>AND cla.<code>code</code> &#x3D;’2’ </p>
<p>使用查询分析器后所有列都无信息显示，只在Extra列显示，</p>
<p>Impossible WHERE noticed after reading const tables，不知道如何分析其执行计划。如果code列均为两个表的主键类型是varchar，想知道这种情况下是否会产生笛卡尔积？2019-01-11</p>
<p> 作者回复</p>
<p>Impossible WHERE noticed after reading const tables</p>
<p>这个语句是不是执行结果是空？2019-01-11</p>
<p>康磊   0</p>
<p>老师你好，现在一般采用读写分离，读的是从库，那么主从如果出现延迟的话，读库就读的不</p>
<p>是最新数据，对这种问题有什么好建议吗？2019-01-11</p>
<p> 作者回复</p>
<p>第28篇专门讲这个问题，敬请期待 </p>
<p>2019-01-11</p>
<p>cyberty   0</p>
<p>请问老师，如果备库连接主库之后，主库的系统时间修改了，备库同步的时候是否会自动修正</p>
<p>？2019-01-10</p>
<p> 作者回复</p>
<p>好问题，不会</p>
<p>2019-01-10</p>
<p>风萧雨瑟   0</p>
<p>老师问一下集群在开启并行复制的情况下：</p>
<p>主库参数：binlog_group_commit_sync_delay&#x3D;1000；binlog_group_commit_sync_no_delay_c</p>
<p>ount&#x3D;10</p>
<p>从库：slave_parallel_type&#x3D;LOGICAL_CLOCK；slave_parallel_workers&#x3D;8</p>
<p>MySQL：社区版5.7.20</p>
<p>在从库上查看slave status的时Seconds_Behind_Master总是显示落后10-15，在有大量更新的</p>
<p>情况下数据会一直增大，通过binlog来看的话Read_Master_Log_Pos 和Exec_Master_Log_Po</p>
<p>s相差总是在1000+，甚至变大的更大。但将slave_parallel_type更改回默认值DATABASE时，R</p>
<p>ead_Master_Log_Pos 和Exec_Master_Log_Pos相差很小，甚至可以相同。在不同的集群上开启并行复制都会出现相同的情况，但将slave_parallel_type更改回默认值DAT</p>
<p>ABASE时都要比LOGICAL_CLOCK延迟情况要好。更换5.7.24版本的情况下有同样的问题。如果有两台从库，机器配置相同其它参数一样。一台设置成slave_parallel_type&#x3D;DATABASE。而另一台设置成LOGICAL_CLOCK，不管是线上的表现还是通过sysbench压测来看，设置成L</p>
<p>OGICAL_CLOCK的从库延迟确实要比DATABASE大一些。这个情况从哪里排查一下？谢谢。2019-01-10</p>
<p> 作者回复</p>
<p>先看看26篇，然后再下面留下你的理解和新的疑问哈 </p>
<p>2019-01-10</p>
<p>xm   0</p>
<p>一般主从延时多少算是合理的？是秒级别吗？2019-01-10</p>
<p> 作者回复</p>
<p>一般大于1就不好 ^_^</p>
<p>2019-01-10</p>
<p>Chris   0</p>
<p>老师，咨询个问题，现在遇到一个问题，mysql数据库总是crash，重新启动服务又正常，然后</p>
<p>运行一段时间又会crash，报错如下InnoDB: Assertion failure in thread 6792 in file fil0fil.cc line 5</p>
<p>805</p>
<p>InnoDB: Failing assertion: err &#x3D;&#x3D; DB_SUCCESS</p>
<p>InnoDB: We intentionally generate a memory trap.</p>
<p>InnoDB: Submit a detailed bug report to <a href="http://bugs.mysql.com/">http://bugs.mysql.com</a>.</p>
<p>InnoDB: If you get repeated assertion failures or crashes, even</p>
<p>InnoDB: immediately after the mysqld startup, there may be</p>
<p>InnoDB: corruption in the InnoDB tablespace. Please refer to</p>
<p>InnoDB: <a href="http://dev.mysql.com/doc/refman/5.7/en/forcing-innodb-recovery.html">http://dev.mysql.com/doc/refman/5.7/en/forcing-innodb-recovery.html</a></p>
<p>InnoDB: about forcing recovery.</p>
<p>08:52:33 UTC - mysqld got exception 0x80000003 ;</p>
<p>This could be because you hit a bug. It is also possible that this binary</p>
<p>or one of the libraries it was linked against is corrupt, improperly built,</p>
<p>or misconfigured. This error can also be caused by malfunctioning hardware.</p>
<p>Attempting to collect some information that could help diagnose the problem.</p>
<p>As this is a crash and something is definitely wrong, the information</p>
<p>collection process might fail.</p>
<p>key_buffer_size&#x3D;8388608</p>
<p>read_buffer_size&#x3D;131072</p>
<p>max_used_connections&#x3D;60</p>
<p>max_threads&#x3D;151</p>
<p>thread_count&#x3D;45</p>
<p>connection_count&#x3D;45</p>
<p>It is possible that mysqld could use up to </p>
<p>key_buffer_size + (read_buffer_size + sort_buffer_size)*max_threads &#x3D; 68010 K bytes of mem</p>
<p>ory</p>
<p>Hope that’s ok; if not, decrease some variables in the equation.</p>
<p>Thread pointer: 0x0</p>
<p>Attempting backtrace. You can use the following information to find out</p>
<p>where mysqld died. If you see no messages after this, something went</p>
<p>terribly wrong…</p>
<p>13f9b9812 mysqld.exe!my_sigabrt_handler()[my_thr_init.c:449]</p>
<p>13fd5e349 mysqld.exe!raise()[winsig.c:587]</p>
<p>13fd5d240 mysqld.exe!abort()[abort.c:82]</p>
<p>13fab9b08 mysqld.exe!ut_dbg_assertion_failed()[ut0dbg.cc:67]</p>
<p>13fae06da mysqld.exe!fil_aio_wait()[fil0fil.cc:5807]</p>
<p>13fa7eb84 mysqld.exe!io_handler_thread()</p>
<p>The manual page at <a href="http://dev.mysql.com/doc/mysql/en/crashing">http://dev.mysql.com/doc/mysql/en/crashing</a>.</p>
<p>2019-01-10</p>
<p> 作者回复</p>
<p>看着好像是磁盘问题了，你这个是5.7的哪个小版本？还有，尽量不要用windows系统哦 </p>
<p>2019-01-11</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-grant与flush privileges</title>
    <url>/posts/15070583.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>在MySQL里面，grant语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant之后要马上跟着执行一个flush privileges命令，才能使赋权语句生效。我最开始使用</p>
<p>MySQL的时候，就是照着一个操作文档的说明按照这个顺序操作的。那么，grant之后真的需要执行flush privileges吗？如果没有执行这个flush命令的话，赋权语句真</p>
<p>的不能生效吗？接下来，我就先和你介绍一下grant语句和flush privileges语句分别做了什么事情，然后再一起来 分析这个问题。为了便于说明，我先创建一个用户：</p>
<p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地</p>
<p>址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。这条命令做了两个动作：</p>
<ol>
<li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的</li>
</ol>
<p>字段的值都是N；</p>
<p>create user ‘ua‘@’%’ identified by ‘pa’;</p>
<ol start="2">
<li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。图1就是这个时刻用户ua在user表中的状态。图1 mysql.user 数据行</li>
</ol>
<p>在MySQL中，用户权限是有不同的范围的。接下来，我就按照用户权限范围从大到小的顺序依</p>
<p>次和你说明。全局权限</p>
<p>全局权限，作用于整个MySQL实例，这些权限信息保存在mysql库的user表里。如果我要给用户</p>
<p>ua赋一个最高权限的话，语句是这么写的：</p>
<p>这个grant命令做了两个动作：</p>
<ol>
<li><p>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</p>
</li>
<li><p>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进</p>
</li>
</ol>
<p>制的“全1”。在这个grant命令执行完成后，如果有新的客户端使用用户名ua登录成功，MySQL会为新连接维</p>
<p>护一个线程对象，然后从acl_users数组里查到这个用户的权限，并将权限值拷贝到这个线程对</p>
<p>象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存</p>
<p>的权限位。基于上面的分析我们可以知道：</p>
<ol>
<li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的</li>
</ol>
<p>连接会使用新的权限。2. 对于一个已经存在的连接，它的全局权限不受grant命令的影响。需要说明的是，一般在生产环境上要合理控制用户权限的范围。我们上面用到的这个grant语</p>
<p>句就是一个典型的错误示范。如果一个用户有所有权限，一般就不应该设置为所有IP地址都可以</p>
<p>访问。如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p>
<p>这条revoke命令的用法与grant类似，做了如下两个动作：</p>
<ol>
<li><p>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为“N”；</p>
</li>
<li><p>内存里，从数组acl_users中找到这个用户对应的对象，将access的值修改为0。db权限</p>
</li>
</ol>
<p>除了全局权限，MySQL也支持库级别的权限定义。如果要让用户ua拥有库db1的所有权限，可以</p>
<p>执行下面这条命令：</p>
<p>grant all privileges on <em>.</em> to ‘ua‘@’%’ with grant option;</p>
<p>revoke all privileges on <em>.</em> from ‘ua‘@’%’;</p>
<p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了 如下两个动作：</p>
<ol>
<li><p>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</p>
</li>
<li><p>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。图2就是这个时刻用户ua在db表中的状态。图2 mysql.db 数据行</p>
</li>
</ol>
<p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据</p>
<p>user、host和db找到匹配的对象，然后根据对象的权限位来判断。也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。grant all privileges on db1.* to ‘ua‘@’%’ with grant option;</p>
<p>grant操作对于已经存在的连接的影响，在全局权限和基于db的权限效果是不同的。接下来，我</p>
<p>们做一个对照试验来分别看一下。图3 权限操作效果</p>
<p>需要说明的是，图中set global sync_binlog这个操作是需要super权限的。可以看到，虽然用户ua的super权限在T3时刻已经通过revoke语句回收了，但是在T4时刻执行</p>
<p>set global的时候，权限验证还是通过了。这是因为super是全局权限，这个权限信息在线程对象</p>
<p>中，而revoke操作影响不到这个线程对象。而在T5时刻去掉ua对db1库的所有权限后，在T6时刻session B再操作db1库的表，就会报错“权</p>
<p>限不足”。这是因为acl_dbs是一个全局数组，所有线程判断db权限都用这个数组，这样revoke操</p>
<p>作马上就会影响到session B。这里在代码实现上有一个特别的逻辑，如果当前会话已经处于某一个db里面，之前use这个库的</p>
<p>时候拿到的库权限会保存在会话变量中。你可以看到在T6时刻，session C和session B对表t的操作逻辑是一样的。但是session B报错，</p>
<p>而session C可以执行成功。这是因为session C在T2 时刻执行的use db1，拿到了这个库的权</p>
<p>限，在切换出db1库之前，session C对这个库就一直有权限。表权限和列权限</p>
<p>除了db级别的权限外，MySQL支持更细粒度的表权限和列权限。其中，表权限定义存放在表</p>
<p>mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在</p>
<p>内存的hash结构column_priv_hash中。这两类权限的赋权命令如下：</p>
<p>跟db权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结</p>
<p>构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。看到这里，你一定会问，看来grant语句都是即时生效的，那这么看应该就不需要执行flush</p>
<p>privileges语句了呀。答案也确实是这样的。flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造</p>
<p>一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一</p>
<p>遍。同样地，对于db权限、表权限和列权限，MySQL也做了这样的处理。也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。而如果我</p>
<p>们都是用grant&#x2F;revoke语句来执行的话，内存和数据表本来就是保持同步更新的。因此，正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。flush privileges使用场景</p>
<p>create table db1.t1(id int, a int);</p>
<p>grant all privileges on db1.t1 to ‘ua‘@’%’ with grant option;</p>
<p>GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO ‘ua‘@’%’ with grant option;</p>
<p>那么，flush privileges是在什么时候使用呢？显然，当数据表中的权限数据跟内存中的权限数据</p>
<p>不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表。我们来看一</p>
<p>下下面这个场景：</p>
<p>图4 使用flush privileges</p>
<p>可以看到，T3时刻虽然已经用delete语句删除了用户ua，但是在T4时刻，仍然可以用ua连接成</p>
<p>功。原因就是，这时候内存中acl_users数组中还有这个用户，因此系统判断时认为用户还正常</p>
<p>存在。在T5时刻执行过flush命令后，内存更新，T6时刻再要用ua来登录的话，就会报错“无法访</p>
<p>问”了。直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。比如，前</p>
<p>面这个通过delete语句删除用户的例子，就会出现下面的情况：</p>
<p>图5 不规范权限操作导致的异常</p>
<p>可以看到，由于在T3时刻直接删除了数据表的记录，而内存的数据还存在。这就导致了：</p>
<ol>
<li><p>T4时刻给用户ua赋权限失败，因为mysql.user表中找不到这行记录；</p>
</li>
<li><p>而T5时刻要重新创建这个用户也不行，因为在做内存判断的时候，会认为这个用户还存在。小结</p>
</li>
</ol>
<p>今天这篇文章，我和你介绍了MySQL用户权限在数据表和内存中的存在形式，以及grant和</p>
<p>revoke命令的执行逻辑。grant语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用</p>
<p>grant和revoke语句，是不需要随后加上flush privileges语句的。flush privileges语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不</p>
<p>一致的情况下再使用。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以</p>
<p>我们尽量不要使用这类语句。另外，在使用grant语句赋权时，你可能还会看到这样的写法：</p>
<p>这条命令加了identified by ‘密码’， 语句的逻辑里面除了赋权外，还包含了：</p>
<ol>
<li><p>如果用户’ua’@’%’不存在，就创建这个用户，密码是pa；</p>
</li>
<li><p>如果用户ua已经存在，就将密码修改成pa。grant super on <em>.</em> to ‘ua‘@’%’ identified by ‘pa’;</p>
</li>
</ol>
<p>这也是一种不建议的写法，因为这种写法很容易就会不慎把密码给改了。“grant之后随手加flush privileges”，我自己是这么使用了两三年之后，在看代码的时候才发现其</p>
<p>实并不需要这样做，那已经是2011年的事情了。去年我看到一位小伙伴这么操作的时候，指出这个问题时，他也觉得很神奇。因为，他和我一样</p>
<p>看的第一份文档就是这么写的，自己也一直是这么用的。所以，今天的课后问题是，请你也来说一说，在使用数据库或者写代码的过程中，有没有遇到过</p>
<p>类似的场景：误用了很长时间以后，由于一个契机发现“啊，原来我错了这么久”？你可以把你的经历写在留言区，我会在下一篇文章的末尾选取有趣的评论和你分享。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，MySQL解析statement格式的binlog的时候，对于load data命令，解析出来为什</p>
<p>么用的是load data local。这样做的一个原因是，为了确保备库应用binlog正常。因为备库可能配置了</p>
<p>secure_file_priv&#x3D;null，所以如果不用local的话，可能会导入失败，造成主备同步延迟。另一种应用场景是使用mysqlbinlog工具解析binlog文件，并应用到目标库的情况。你可以使用下</p>
<p>面这条命令 ：</p>
<p>把日志直接解析出来发给目标库执行。增加local，就能让这个方法支持非本地的$host。评论区留言点赞板：</p>
<p>mysqlbinlog $binlog_file | mysql -h$host -P$port -u$user -p$pwd</p>
<p>@poppy 、@库淘淘 两位同学提到了第一个场景；</p>
<p>@王显伟 @lionetes 两位同学帮忙回答了 @undifined 同学的疑问，拷贝出来的文件要确保</p>
<p>MySQL进程可以读。undifined   7</p>
<p>权限的作用范围和修改策略总结：</p>
<p><a href="http://ww1.sinaimg.cn/large/d1885ed1ly1g0ab2twmjaj21gs0js78u.jpg">http://ww1.sinaimg.cn/large/d1885ed1ly1g0ab2twmjaj21gs0js78u.jpg</a></p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p> ，优秀</p>
<p>2019-02-18</p>
<p>夜空中最亮的星（华仔）   3</p>
<p>通过老师的讲解 flush privileges 这回彻底懂了，高兴 </p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-19</p>
<p>way   1</p>
<p>写个比较小的点：在命令行查询数据需要行转列的时候习惯加个\G ; 比如slave slave stauts \G ;</p>
<p>后来发现 ; 是多余的。列几个常用的</p>
<p>\G 行转列并发送给 mysql server</p>
<p>\g 等同于 ;</p>
<p>! 执行系统命令</p>
<p>精选留言</p>
<p>\q exit</p>
<p>\c 清除当前SQL（不执行）</p>
<p>\s mysql status 信息</p>
<p>其他参考 \h</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p> </p>
<p>我最开始使用MySQL的时候，就是不自然的在\G后面加分号</p>
<p>而且还看到报错，好紧张 </p>
<p>2019-02-20</p>
<p>XD   1</p>
<p>老师，我刚说的是acl_db，是在db切换的时候，从acl_dbs拷贝到线程内部的？类似acl_user。session a</p>
<p>drop user ‘test‘@’%’;</p>
<p>create user ‘test‘@’%’ identified by ‘123456’;</p>
<p>grant SELECT,UPDATE on gt.* to ‘test‘@’%’;</p>
<p>session b 使用test登录</p>
<p>use gt;</p>
<p>session a</p>
<p>revoke SELECT,UPDATE on gt.* from ‘test‘@’%’;</p>
<p>session b</p>
<p>show databases; &#x2F;&#x2F;只能看到information_schema库</p>
<p>use gt; &#x2F;&#x2F; Access denied for user ‘test‘@’%’ to database ‘gt’</p>
<p>show tables; &#x2F;&#x2F;可以看到gt库中所有的表</p>
<p>select&#x2F;update &#x2F;&#x2F;操作都正常</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>你说的对，我刚翻代码确认了下，确实是特别对“当前db”有一个放过的逻辑。多谢指正。我勘误下。2019-02-19</p>
<p>夹心面包   1</p>
<p>我在此分享一个授权库的小技巧, 如果需要授权多个库,库名还有规律,比如 db_201701 db_2017</p>
<p>02</p>
<p>可以采用正则匹配写一条 grant on db______,每一个_代表一个字符.这样避免了多次授权,简化</p>
<p>了过程。我们线上已经采用</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>是的，MySQL还支持 % 赋权，%表示匹配任意字符串，</p>
<p>比如</p>
<p>grant all privileges on <code>db%</code>.* to … 表示所有以db为前缀的库。不过。。。我比较不建议这么用 </p>
<p>2019-02-19</p>
<p>萤火虫   0</p>
<p>坚持到最后 为老师打call</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p> </p>
<p>是真爱</p>
<p>2019-02-20</p>
<p>wljs   0</p>
<p>老师我想问个问题 我们公司一个订单表有110个字段 想拆分成两个表 第一个表放经常查的字段</p>
<p>第二个表放不常查的 现在程序端不想改sql，数据库端来实现 当查询字段中 第一个表不存在 就</p>
<p>去关联第二个表查出数据 db能实现不？2019-02-19</p>
<p>舜   0</p>
<p>老师，介绍完了order by后能不能继续介绍下group by的原理？等了好久了，一直想继续在orde</p>
<p>r by基础上理解下group by，在使用过程中两者在索引利用上很相近，性能考虑也类似</p>
<p>2019-02-19</p>
<p> 作者回复</p>
<p>37篇讲了group by的，你看下</p>
<p>还有问再提出来 </p>
<p>2019-02-19</p>
<p>旭东   0</p>
<p>老师请教一个问题：MySQL 表设计时列表顺序对MySQL性能的影响大吗？对表的列顺序有什</p>
<p>么建议吗？2019-02-18</p>
<p> 作者回复</p>
<p>没有影响</p>
<p>建议就是每次如果要加列都加到最后一列 </p>
<p>2019-02-19</p>
<p>XD   0</p>
<p>老师，实际测试了下。两个会话ab，登陆账号都为user。a中给user授予db1的select、update权限，b切换到db1，可</p>
<p>以正常增改。然后a中回收该用户的db权限，b会话中的用户还是可以进行增改操作的。我发现用户的db权限好像是在切换数据库的时候刷新的，只要不切换，grant操作并不会产生作</p>
<p>用，所以acl_db是否也是维护在线程内部的呢？以及，权限检验应该是在优化器的语义分析里进行的吧？2019-02-18</p>
<p> 作者回复</p>
<p>acl_dbs是全局数组</p>
<p>把你使用sql语句，和语句序列发一下哦</p>
<p>类似按照时间顺序</p>
<p>session a：</p>
<p>xxx</p>
<p>xxx</p>
<p>session b:</p>
<p>xxxx</p>
<p>session a:</p>
<p>xxxx</p>
<p>这样</p>
<p>2019-02-18</p>
<p>发芽的紫菜   0</p>
<p>老师，联合索引的数据结构是怎么样的？到底是怎么存的？看了前面索引两章，还是不太懂，</p>
<p>留言里老师说会在后面章节会讲到，但我也没看到，所以来此问一下？老师能否画图讲解一下</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>联合索引就是两个字段拼起来作索引</p>
<p>比如一个索引如果定义为(f1,f2),</p>
<p>在数据上，就是f1的值之后跟着f2的值。查找的时候，比如执行 where f1&#x3D;M and f2&#x3D;N, 也是把M,N拼起来，去索引树查找</p>
<p>2019-02-18</p>
<p>晨思暮语   0</p>
<p>丁老师,您好：</p>
<p>关于上一章我留言的疑问,我重新整理了下。就是第十五章中老师留的思考题。我模拟了老师的实验,结果有点出入,请老师帮忙看看，谢谢！</p>
<p>基础环境:</p>
<p>mysql&gt; select version();</p>
<p>+————+</p>
<p>| version() |</p>
<p>+————+</p>
<p>| 5.7.22-log |</p>
<p>+————+</p>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; show variables like ‘%tx%’;</p>
<p>+—————+—————–+</p>
<p>| Variable_name | Value |</p>
<p>+—————+—————–+</p>
<p>| tx_isolation | REPEATABLE-READ |</p>
<p>| tx_read_only | OFF |</p>
<p>+—————+—————–+</p>
<p>2 rows in set (0.00 sec)</p>
<p>模拟实验:</p>
<p>session A: </p>
<p>mysql&gt; begin; </p>
<p>mysql&gt; select * from t; </p>
<p>+—-+——+ </p>
<p>| id | a | </p>
<p>+—-+——+ </p>
<p>| 1 | 2 | </p>
<p>+—-+——+ </p>
<p>1 row in set (0.00 sec) </p>
<p>session B: </p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1; </p>
<p>Query OK, 1 row affected (0.00 sec) </p>
<p>Rows matched: 1 Changed: 1 Warnings: 0 </p>
<p>SESSION A: </p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1; </p>
<p>Query OK, 0 rows affected (0.00 sec) </p>
<p>Rows matched: 1 Changed: 0 Warnings: 0 </p>
<p>&#x2F;<em>老师的实验显示为：1 rows affected</em>&#x2F; </p>
<p>mysql&gt; select * from t where id&#x3D;1; </p>
<p>+—-+——+ </p>
<p>| id | a | </p>
<p>+—-+——+ </p>
<p>| 1 | 2 | </p>
<p>+—-+——+ </p>
<p>1 row in set (0.00 sec) </p>
<p>&#x2F;*老师实验的查询结果为：1,3 *&#x2F;</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>这个跟binlog_format有关。如果binlog_format&#x3D;row, 那么最后session A的select查到的是2；</p>
<p>如果binlog_format&#x3D;statement, 那么最后session A的select查到的是3；</p>
<p>我们在文章里面有做了说明了，这个逻辑是依赖于“MySQL在执行update语句的时候，有没有</p>
<p>把字段c也读进来”，</p>
<p>2019-02-26</p>
<p>Sinyo   0</p>
<p>查一张大表，order_key字段值对应的最小createtime；</p>
<p>以前一直用方法一查数，后来同事说可以优化成方法二，查询效率比方法一高了几倍；</p>
<p>mysql特有的group by功能，没有group by的字段默认取查到的第一条记录；</p>
<p>方法一：</p>
<p>select distinct order_key</p>
<p>,createtime</p>
<p>from (select order_key</p>
<p>,min(createtime) createtime</p>
<p>from aaa</p>
<p>group by order_key) a</p>
<p>join aaa b</p>
<p>on a.order_key &#x3D; b.order_key</p>
<p>and a.createtime &#x3D; b.createtime</p>
<p>方法二：</p>
<p>select order_key</p>
<p>,createtime</p>
<p>from (select order_key</p>
<p>,createtime</p>
<p>FROM aaa</p>
<p>order by createtime</p>
<p>) a</p>
<p>group by order_key</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p> </p>
<p>这第二个写法跟：</p>
<p>select order_key ,createtime FROM aaa force index(createtime) group by order_key</p>
<p>的逻辑语义相同吗？2019-02-18</p>
<p>Leon    0</p>
<p>老师我使用delte删除用户，再创建用户都是失败，但是使用drop就可以了</p>
<p>mysql&gt; create user ‘ua‘@’%’ identified by ‘L1234567890c-‘;</p>
<p>ERROR 1396 (HY000): Operation CREATE USER failed for ‘ua‘@’%’</p>
<p>mysql&gt; drop user ‘ua‘@’%’;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; create user ‘ua‘@’%’ identified by ‘L1234567890c-‘;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>是不是drop才会同时从内存和磁盘删除用户信息，但是delete只是从磁盘删除</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>对，drop是同时操作磁盘和内存，</p>
<p>delete就是我们说的不规范操作</p>
<p>2019-02-18</p>
<p>爸爸回来了   0</p>
<p>众所周知，sql是不区分大小写的。然而，涉及插件的变量却不是这样；上次在配置一个插件的</p>
<p>参数的时候，苦思良久……最后发现了这个问题。难受 </p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p> 你说的是参数的名字，还是参数的值？2019-02-18</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-insert语句的锁为什么这么多</title>
    <url>/posts/107cc463.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>40 | insert语句的锁为什么这么多？2019-02-13 林晓斌</p>
<p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增</p>
<p>锁。因此，insert语句是一个很轻量的操作。不过，这个结论对于“普通的insert语句”才有效。也就是</p>
<p>说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申</p>
<p>请到自增id以后就立马释放自增锁。那么，今天这篇文章，我们就一起来聊聊这个话题。insert … select 语句</p>
<p>我们先从昨天的问题说起吧。表t和t2的表结构、初始化数据语句如下，今天的例子我们还是针</p>
<p>对这两个表展开。现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format&#x3D;statement时执行：</p>
<p>这个语句时，需要对表t的所有行和间隙加锁呢？其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p>
<p>图1 并发insert场景</p>
<p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key</p>
<p>lock，会在语句执行完成后，才允许session A的insert语句执行。但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于</p>
<p>是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t̀  ̀(</span><br><span class="line"></span><br><span class="line">  ìd  ̀<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">  `c  ̀<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  `d  ̀<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (̀ id )̀,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c  ̀(̀ c )̀</span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。insert 循环写入</p>
<p>当然了，执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。此时，我们可以这么写这条SQL语句 ：</p>
<p>这个语句的加锁范围，就是表t索引c上的(3,4]和(4,supremum]这两个next-key lock，以及主键索</p>
<p>引上id&#x3D;4这一行。它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。因此整条语句的扫描行数是1。这个语句执行的慢查询日志（slow log），如下图所示：</p>
<p>图2 慢查询日志–将数据插入表t2</p>
<p>通过这个慢查询日志，我们看到Rows_examined&#x3D;1，正好验证了执行这条语句的扫描行数为1。那么，如果我们是要把这样的一行数据插入到表t中的话：</p>
<p>语句的执行流程是怎样的？扫描行数又是多少呢？这时候，我们再看慢查询日志就会发现不对了。图3 慢查询日志–将数据插入表t</p>
<p>可以看到，这时候的Rows_examined的值是5。insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);</p>
<p>insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);</p>
<p>我在前面的文章中提到过，希望你都能够学会用explain的结果来“脑补”整条语句的执行过程。今</p>
<p>天，我们就来一起试试。如图4所示就是这条语句的explain结果。图4 explain结果</p>
<p>从Extra字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过</p>
<p>程中，需要把表t的内容读出来，写入临时表。图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果</p>
<p>读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这</p>
<p>个语句的扫描行数就应该是2，而不是5。所以，这个猜测不对。实际上，Explain结果里的rows&#x3D;1是因为受到了limit 1 的影响。从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如图5所示，是在执行这个语句前</p>
<p>后查看Innodb_rows_read的结果。图5 查看 Innodb_rows_read变化</p>
<p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因为默认临时表是使用</p>
<p>Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。这样，我们就把整个执行过程理清楚了：</p>
<ol>
<li>创建临时表，表里有两个字段c和d。2. 按照索引c扫描表t，依次取c&#x3D;4、3、2、1，然后回表，读到c和d的值写入临时表。这</li>
</ol>
<p>时，Rows_examined&#x3D;4。3. 由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这</p>
<p>时，Rows_examined的值加1，变成了5。也就是说，这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-</p>
<p>key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果</p>
<p>读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参</p>
<p>与计算逻辑，就跟语义不符。由于实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整</p>
<p>个表t。它的优化方法也比较简单，就是用前面介绍的方法，先insert into到临时表temp_t，这样</p>
<p>就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。当然，由于这个语句涉及的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临</p>
<p>时表优化时，语句序列的写法如下：</p>
<p>insert 唯一键冲突</p>
<p>前面的两个例子是使用insert … select的情况，接下来我要介绍的这个例子就是最常见的insert语</p>
<p>句出现唯一键冲突的情况。对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一</p>
<p>键冲突的例子。create temporary table temp_t(c int,d int) engine&#x3D;memory;</p>
<p>insert into temp_t  (select c+1, d from t force index(c) order by c desc limit 1);</p>
<p>insert into t select * from temp_t;</p>
<p>drop table temp_t;</p>
<p>图6 唯一键冲突加锁</p>
<p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行</p>
<p>的insert语句进入了锁等待状态。也就是说，session A执行的insert语句，发生唯一键冲突的时候，并不只是简单地报错返回，还</p>
<p>在冲突的索引上加了锁。我们前面说过，一个next-key lock就是由它右边界的值定义的。这时</p>
<p>候，session A持有索引c上的(5,10]共享next-key lock（读锁）。至于为什么要加这个读锁，其实我也没有找到合理的解释。从作用上来看，这样做可以避免这一</p>
<p>行被别的事务删掉。这里官方文档有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-</p>
<p>key lock。但实际上，这两类索引冲突加的都是next-key lock。有同学在前面文章的评论区问到，在有多个唯一索引的表中并发插入数据时，会出现死锁。但</p>
<p>是，由于他没有提供复现方法或者现场，我也无法做分析。所以，我建议你在评论区发问题的时</p>
<p>候，尽量同时附上复现方法，或者现场信息，这样我才好和你一起分析问题。这里，我就先和你分享一个经典的死锁场景，如果你还遇到过其他唯一键冲突导致的死锁场景，</p>
<p>也欢迎给我留言。图7 唯一键冲突–死锁</p>
<p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。这个死锁产生的逻辑是这样的：</p>
<ol>
<li>在T1时刻，启动session A，并执行insert语句，此时在索引c的c&#x3D;5上加了记录锁。注意，这</li>
</ol>
<p>个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下第21篇文章介绍</p>
<p>的加锁规则）。备注：这个bug，是我在写这篇文章查阅文档时发现的，已经发给官方并被verified了。2. 在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样</p>
<p>地，session C也在索引c上，c&#x3D;5这一个记录上，加了读锁。3. T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加</p>
<p>上写锁。两个session都要等待对方的行锁，所以就出现了死锁。这个流程的状态变化图如下所示。图8 状态变化图–死锁</p>
<p>insert into … on duplicate key update</p>
<p>上面这个例子是主键冲突后直接报错，如果是改写成</p>
<p>的话，就会给索引c上(5,10] 加一个排他的next-key lock（写锁）。insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一</p>
<p>键约束，就执行后面的更新语句。insert into t values(11,10,10) on duplicate key update d&#x3D;100; </p>
<p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。现在表t里面已经有了(1,1,1)和(2,2,2)这两行，我们再来看看下面这个语句执行的效果：</p>
<p>图9 两个唯一键同时冲突</p>
<p>可以看到，主键id是先判断的，MySQL认为这个语句跟id&#x3D;2这一行冲突，所以修改的是id&#x3D;2的</p>
<p>行。需要注意的是，执行这条语句的affected rows返回的是2，很容易造成误解。实际上，真正更新</p>
<p>的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1， insert</p>
<p>计数也加了1。小结</p>
<p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别</p>
<p>下，这个语句会给select的表里扫描到的记录和间隙加读锁。而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入</p>
<p>用户临时表来做优化。insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到</p>
<p>由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。最后，我给你留一个问题吧。你平时在两个表之间拷贝数据用的是什么方法，有什么注意事项吗？在你的应用场景里，这个方</p>
<p>法，相较于其他方法的优势是什么呢？你可以把你的经验和分析写在评论区，我会在下一篇文章的末尾选取有趣的评论来和你一起分</p>
<p>析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我们已经在文章中回答了上期问题。有同学提到，如果在insert … select 执行期间有其他线程操作原表，会导致逻辑错误。其实，这</p>
<p>是不会的，如果不加锁，就是快照读。一条语句执行期间，它的一致性视图是不会修改的，所以即使有其他事务修改了原表的数据，也</p>
<p>不会影响这条语句看到的数据。评论区留言点赞板：</p>
<p>huolang   8</p>
<p>老师，死锁的例子，关于sessionA拿到的c&#x3D;5的记录锁，sessionB和sessionC发现唯一键冲突</p>
<p>会加上读锁我有几个疑惑：</p>
<ol>
<li>sessionA拿到的c&#x3D;5的记录锁是写锁吗？2. 为什么sessionB和sessionC发现唯一键冲突会加上读锁？3. 如果sessionA拿到c&#x3D;5的记录所是写锁，那为什么sessionB和sessionC还能加c&#x3D;5的读锁，</li>
</ol>
<p>写锁和读锁不应该是互斥的吗？4. sessionA还没有提交，为什么sessionB和sessionC能发现唯一键冲突？2019-02-13</p>
<p>@长杰 同学回答得非常准确。精选留言</p>
<p> 作者回复</p>
<ol>
<li><p>是的</p>
</li>
<li><p>这个我觉得是为了防止这个记录再被删除（不过这个理由不是很硬，我还没有找到其他解释</p>
</li>
<li><p>互斥的，所以这两个语句都在等待。注意next-key lock是由间隙锁和记录锁组成的哦， 间隙</p>
</li>
</ol>
<p>锁加成功了的。好问题。4. 还没有提交，但是这个记录已经作为最新记录写进去了，复习一下08篇哈</p>
<p>2019-02-14</p>
<p>老杨同志   4</p>
<p>课后问题：</p>
<p>我用的最多还是insert into select 。如果数量比较大，会加上limit 100,000这种。并且看看后面</p>
<p>的select条件是否走索引。缺点是会锁select的表。方法二：导出成excel，然后拼sql 成 insert i</p>
<p>nto values(),(),()的形式。方法3，写类似淘宝调动的定时任务，任务的逻辑是查询100条记录，</p>
<p>然后多个线程分到几个任务执行，比如是个线程，每个线程10条记录，插入后，在查询新的10</p>
<p>0条记录处理。2019-02-13</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-14</p>
<p>sonic   3</p>
<p>你好，</p>
<p>我想问下文章中关于为什么需要创建临时表有这一句话：</p>
<p>如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录</p>
<p>如果参与计算逻辑，就跟语义不符。我的疑问是：既然隔离级别是可重复读，照理来说新插入的的记录应该不会参与计算逻辑呀。2019-02-14</p>
<p> 作者回复</p>
<p>可重复读隔离级别下，事务是可以看到自己刚刚修改的数据的 ，好问题</p>
<p>2019-02-16</p>
<p>滔滔   2</p>
<p>老师，之前提到的一个有趣的问题”A、B两个用户，如果互相喜欢，则成为好友。设计上是有</p>
<p>两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯</p>
<p>一索引即uk_user_id_liker_id。语句执行顺序是这样的：</p>
<p>以A喜欢B为例：</p>
<p>1、先查询对方有没有喜欢自己（B有没有喜欢A）</p>
<p>select * from like where user_id &#x3D; B and liker_id &#x3D; A</p>
<p>2、如果有，则成为好友</p>
<p>insert into friend</p>
<p>3、没有，则只是喜欢关系</p>
<p>insert into like”，这个问题中如果把select语句改成”当前读”，则当出现A,B两个人同时喜欢对方</p>
<p>的情况下，是不是会出现由于”当前读”加的gap锁导致后面insert语句阻塞，从而发生死锁？2019-02-13</p>
<p> 作者回复</p>
<p>好问题</p>
<p>这种情况下一般是造成锁等待，不会造成死锁吧  </p>
<p>2019-02-14</p>
<p>夹心面包   2</p>
<p>1 关于insert造成死锁的情况,我之前做过测试,事务1并非只有insert,delete和update都可能造成死</p>
<p>锁问题,核心还是插入唯一值冲突导致的.我们线上的处理办法是 1 去掉唯一值检测 2减少重复值</p>
<p>的插入 3降低并发线程数量</p>
<p>2 关于数据拷贝大表我建议采用pt-archiver,这个工具能自动控制频率和速度,效果很不错,提议在</p>
<p>低峰期进行数据操作</p>
<p>2019-02-13</p>
<p> 作者回复</p>
<p> ，这两点都是很有用的建议</p>
<p>2019-02-13</p>
<p>王伯轩   1</p>
<p>老师你好,去年双11碰到了dbcrash掉的情况.至今没有找到答案,心里渗得慌.老师帮忙分析下. </p>
<p>我是一个开发,关于db的知识更多是在应用和基本原理上面,实在是找不到原因. 我也搜了一些资</p>
<p>料 感觉像是mysql的bug,不过在其buglist中没有找到完全一致的，当然也可能是我们业务也许导</p>
<p>致库的压力大的原因. </p>
<p>应用端看到的现象是db没有响应，应用需要访问db的线程全部僵死.db表现是hang住 , 当时的诊</p>
<p>断日志如下，表面表现为一直获取不到latch锁（被一个insert线程持有不释放） <a href="https://note.you/">https://note.you</a></p>
<p>dao.com&#x2F;ynoteshare1&#x2F;index.html?id&#x3D;1771445db3ff1e08cbdd8328ea6765a7&amp;type&#x3D;note#&#x2F; 隔离</p>
<p>级别是rr</p>
<p>同样的crash双11当天后面又出现了一次（哭死）,</p>
<p>都是重启数据库解决的,</p>
<p>后面应用层面做了一样优化,没有再crash过，优化主要如下：</p>
<p>1.减小读压力，去除一些不必要的查询，</p>
<p>2.优化前，有并发事务写和查询同一条数据记录，即事务a执行insert 尚未提交，事务b就来查询</p>
<p>（快照读），优化后保证查询时insert事务已经提交</p>
<p>2019-02-19</p>
<p> 作者回复</p>
<p>这就是压力太大了。。 一般伴随着ioutil很大，语句执行特别慢，别的语句就被堵着等锁，等超</p>
<p>时就自己crash</p>
<p>2019-02-19</p>
<p>phpzheng-好客旅游网   1</p>
<p>phpzheng-好客旅游网   1</p>
<p>循环插入数据，然后拿着刚刚插入的主键id，更新数据。请问怎么提高这个情况的效率</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>insert以后</p>
<p>select last_insert_id,</p>
<p>再update，</p>
<p>只能这么做啦</p>
<p>如果要快一些，可能可以考虑减少交互，比如写成存储过程</p>
<p>2019-02-16</p>
<p>伟仔_Hoo   0</p>
<p>老师，看到您的回复，当select c+1, d from t force index(c) order by c desc limit 1;这条语句单</p>
<p>独执行是会在c索引上加(4,sup] 这个next key lock, 于是我进行了尝试</p>
<p>sessionA: </p>
<p>begin;</p>
<p>select c+1, d from t3 force index(c) order by c desc limit 1;</p>
<p>sessionB:</p>
<p>insert into t3 values(5, 5, 5);</p>
<p>结果是，sessionB插入成功，是不是我哪里理解错了？我的版本是5.7.23</p>
<p>2019-03-15</p>
<p> 作者回复</p>
<p>session A的select语句没有加 for update 或者 lock in share mode ?</p>
<p>2019-03-16</p>
<p>猫小妖的尾巴   0</p>
<p>老师，我们的业务中有用到insert …on duplicate key update导致死锁的情况，表是有唯一索引，</p>
<p>DBA那边的解释是有唯一索引的insert需要两把锁，事务1先申请X锁成功, 然后申请S锁, 但是事</p>
<p>务2正在申请X锁, 与事务1的S锁冲突, 系统决定回滚事务2，然后我就改成先查询存在直接updat</p>
<p>e不存在再用原来的逻辑，不过我感觉还是不太明白，你可以解释一下吗</p>
<p>2019-03-10</p>
<p>涵涵妈 lilian   0</p>
<p>老师，能帮忙看下这个死锁记录吗？对于duplicate key插入有什么阻止的好方法？LATEST DE</p>
<p>TECTED DEADLOCK</p>
<hr>
<p>190222 8:37:45</p>
<p>*** (1) TRANSACTION:</p>
<p>TRANSACTION 16FEC1AE, ACTIVE 0 sec inserting</p>
<p>mysql tables in use 1, locked 1</p>
<p>LOCK WAIT 6 lock struct(s), heap size 1248, 3 row lock(s)</p>
<p>MySQL thread id 169973, OS thread handle 0x2ba0fa040700, query id 41915315 10.45.133.181 </p>
<p>W59FFHKU</p>
<p>INSERT INTO resource (</p>
<p>Id</p>
<p>, Name</p>
<p>, Date</p>
<p>, User</p>
<p>) VALUES (99127, ‘RS_2098185e367d11e9878202a98a7af318’, ‘’, ‘JR’)</p>
<p>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 78 page no 71 n bits 160 index <code>PRIMARY</code> of table <code>resource</code> trx id</p>
<p>16FEC1AE lock_mode X insert intention waiting</p>
<p>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</p>
<p>0: len 8; hex 73757072656d756d; asc supremum;;</p>
<p>*** (2) TRANSACTION:</p>
<p>TRANSACTION 16FEC1AF, ACTIVE 0 sec inserting</p>
<p>mysql tables in use 1, locked 1</p>
<p>6 lock struct(s), heap size 1248, 3 row lock(s)</p>
<p>MySQL thread id 169996, OS thread handle 0x2ba0ffec2700, query id 41915317 10.45.133.181 </p>
<p>W59FFHKU</p>
<p>INSERT INTO resource (</p>
<p>Id</p>
<p>, Name</p>
<p>, Date</p>
<p>, User</p>
<p>) VALUES (99125, ‘RS_2098b778367d11e9878202a98a7af318’, ‘’, ‘JR’)</p>
<p>*** (2) HOLDS THE LOCK(S):</p>
<p>RECORD LOCKS space id 78 page no 71 n bits 160 index <code>PRIMARY</code> of table <code>resource</code> trx id</p>
<p>16FEC1AF lock mode S</p>
<p>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</p>
<p>0: len 8; hex 73757072656d756d; asc supremum;;</p>
<p>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 78 page no 71 n bits 160 index <code>PRIMARY</code> of table <code>resource</code> trx id</p>
<p>16FEC1AF lock_mode X insert intention waiting</p>
<p>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</p>
<p>0: len 8; hex 73757072656d756d; asc supremum;;</p>
<p>*** WE ROLL BACK TRANSACTION (2)</p>
<p>2019-03-10</p>
<p>涵涵妈 lilian   0</p>
<p>老师，重复主键插入冲突是否推荐insert ignore方法？2019-03-09</p>
<p> 作者回复</p>
<p>这个取决于业务需求，如果是明确会存在这样的情况，并且可以忽略，是可以这么用的</p>
<p>2019-03-09</p>
<p>轻松的鱼   0</p>
<p>老师好，想请教一下死锁的例子中：</p>
<ol>
<li>在 session A rollback 前，session B&#x2F;C 都因为唯一性冲突申请了 S Next-key lock，但是被 s</li>
</ol>
<p>ession A 的 X but not gap lock 阻塞；</p>
<ol start="2">
<li>在 session A rollbak 后，session B&#x2F;C 顺利获得 S Next-key lock，并且都要继续进行插入，</li>
</ol>
<p>这时候我认为是因为插入意向锁（LOCK_INSERT_INTENTION）导致的死锁，因为插入意向</p>
<p>锁会被 gap lock 阻塞，造成了相互等待。还没有进入到记录 X lock。不知道我分析的对不对？2019-03-06</p>
<p>张永志   0</p>
<p>对主键插入加读锁的个人理解，两个会话insert同样记录，在没有提交情况下，insert主键加读</p>
<p>锁是为了避免第一个会话回滚后，第二个会话可以正常执行；第一个会话提交后，第二个会话</p>
<p>再报错。2019-02-28</p>
<p> 作者回复</p>
<p>是为了实现这个目的，是吧 </p>
<p>2019-02-28</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>关于文中的锁描述有所疑惑。文中出现过 共享的next-key锁 和 排他的next-key锁。我们知道next-key是由 gap lock 和 行锁组成的。我一直以来的认知是 gap lock都是s锁，没有x锁。而行锁有s锁和x锁。比如 select………lock in share mode，行锁是s</p>
<p>锁。比如select………for update，行锁就是x锁。但是gap lock 始终是s锁。文中直接描述next-key lock是排他的，总让我认为gap lock和行锁都是x锁。不知道我理解得对不对？2019-02-27</p>
<p> 作者回复</p>
<p>是这样的，gap lock是无所谓S还是X的。但是record lock 有。Gap lock + 排他的record 就称作 排他的next-key lock 吧 </p>
<p>2019-02-27</p>
<p>滔滔   0</p>
<p>老师，select c+1, d from t force index(c) order by c desc limit 1;这条语句如果单独执行，是会</p>
<p>对表t进行全表加锁，还是只加(3,4],(4,sup]这两个next key锁。还有一个问题，这里为什么要加f</p>
<p>orce index(c)，不加会是怎样的效果呢？ </p>
<p>2019-02-24</p>
<p> 作者回复</p>
<p>(4,sup]</p>
<p>以防优化器不走索引，影响我们结论（比如数据量比较小的时候）</p>
<p>2019-02-25</p>
<p>发条橙子 。   0</p>
<p>老师，年后过来狂补课程了哈哈 ， 看到老师的bug留言已经被fix掉准备在最新版本发布了呢。 </p>
<p>这里我有一个疑问， 我之前以为只有更新的时候才会加锁， 参考前面的文章，innodb要先扫描</p>
<p>表中数据，被扫描到的行要加锁 。或者我们执行 select 的时候手动加上 排他锁 或者 共享锁，也会锁住。这里老师讲到如果索引唯一键冲突， innodb为了做处理加了 next_key lock（S） 这个可以理解</p>
<p>。insert .. select 也是因为有 select 索引会加锁 也可以理解</p>
<p>问题 ：</p>
<p>图7那个死锁的案例， session A 的时候 只是执行了 insert 语句，执行 insert的时候也没有sele</p>
<p>ct之类的，为什么也会在索引c上加个锁， 是什么时候加的呢 ？？？ 是 insert 语句有索引的话</p>
<p>都会给索引加锁么？？2019-02-23</p>
<p> 作者回复</p>
<p>不是都会，是在要写入的时候，发现有主键冲突，才会加上这个next-key lock的锁</p>
<p>2019-02-23</p>
<p>滔滔   0</p>
<p>老师，有个问题insert into … on duplicate key update语句在发生冲突的时候是先加next key读锁</p>
<p>，然后在执行后面的update语句时再给冲突记录加上写锁，从而把之前加的next key读锁变成了</p>
<p>写锁，是这样的吗？2019-02-21</p>
<p> 作者回复</p>
<p>不是，发现冲突直接加的就是写锁</p>
<p>2019-02-24</p>
<p>王伯轩   0</p>
<p>内存锁 大大计划讲下么,实际中碰到内存锁被持有后一直不释放导致db直接crash掉</p>
<p>2019-02-18</p>
<p> 作者回复</p>
<p>这个系列里没讲到了</p>
<p>这种我碰到比较多的是io压力特别大，导致有的事务执行不下去，但是占着锁</p>
<p>然后其他事务就拿不到锁，有一个600计时，超过就crash了</p>
<p>2019-02-18</p>
<p>信信   0</p>
<p>老师好，文中提到：insert into t2(c,d) (select c+1, d from t force index(c) order by c desc limit 1</p>
<p>)的加锁范围是表 t 索引 c 上的 (4,supremum] 这个 next-key lock 和主键索引上 id&#x3D;4 这一行。可是如果我把表t的id为3这行先删除，再执行这个insert…select，那么别的会话执行insert into t </p>
<p>values(3,3,3)会被阻塞，这说明4之前也是有间隙锁的？另外，select c+1, d from t force index(c) order by c desc limit 1 for update 是不是不能用作等值</p>
<p>查询那样分析？因为如果算等值查询，根据优化1是没有间隙锁的。2019-02-17</p>
<p> 作者回复</p>
<p>你说的对，这里其实是“向左扫描”，加锁范围应该是(3,4] 和 (4, supremum]。 </p>
<p>2019-02-17</p>
<p>Justin   0</p>
<p>插入意向锁的gal lock和next key lock中的 gaplock互斥吗？2019-02-15</p>
<p> 作者回复</p>
<p>额，</p>
<p>这里我们要澄清一下哈</p>
<p>只有一个gap lock，就是 next key lock &#x3D; gap lock + record lock；</p>
<p>我们说一个insert语句如果要插入一个间隙，而这个间隙上有gap lock的话，insert语句会被堵住</p>
<p>，这个被堵住的效果，实现机制上是用插入意向锁和gap lock相互作用来实现的。gap lock并不属于插入意向锁的一部分 ，就没有“插入意向锁的gal lock”这个概念哈</p>
<p>2019-02-16</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-join语句怎么优化</title>
    <url>/posts/6651e679.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>35 | join语句怎么优化？2019-02-01 林晓斌</p>
<p>在上一篇文章中，我和你介绍了join语句的两种算法，分别是Index Nested-Loop Join(NLJ)和</p>
<p>Block Nested-Loop Join(BNL)。我们发现在使用NLJ算法的时候，其实效果还是不错的，比通过应用层拆分成多个语句然后再拼</p>
<p>接查询结果更方便，而且性能也不会差。但是，BNL算法在大表join的时候性能就差多了，比较次数等于两个表参与join的行数的乘积，很</p>
<p>消耗CPU资源。当然了，这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。为了便于分析，我还是创建两个表t1、t2来和你展开今天的问题。为了便于后面量化说明，我在表t1里，插入了1000行数据，每一行的a&#x3D;1001-id的值。也就是</p>
<p>说，表t1中字段a是逆序的。同时，我在表t2中插入了100万行数据。Multi-Range Read优化</p>
<p>在介绍join语句的优化方案之前，我需要先和你介绍一个知识点，即：Multi-Range Read优化</p>
<p>(MRR)。这个优化的主要目的是尽量使用顺序读盘。在第4篇文章中，我和你介绍InnoDB的索引结构时，提到了“回表”的概念。我们先来回顾一下这</p>
<p>个概念。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键</p>
<p>索引上去查整行数据的过程。然后，有同学在留言区问到，回表过程是一行行地查数据，还是批量地查数据？我们先来看看这个问题。假设，我执行这个语句：</p>
<p>create table t1(id int primary key, a int, b int, index(a));</p>
<p>create table t2 like t1;</p>
<p>drop procedure idata;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;1000)do</p>
<pre><code>insert into t1 values(i, 1001-i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;1000000)do</p>
<pre><code>insert into t2 values(i, i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>主键索引是一棵B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是</p>
<p>一行行搜索主键索引的，基本流程如图1所示。图1 基本回表流程</p>
<p>如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较</p>
<p>差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键</p>
<p>的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p>
<ol>
<li><p>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</p>
</li>
<li><p>将read_rnd_buffer中的id进行递增排序；</p>
</li>
<li><p>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。select * from t1 where a&gt;&#x3D;1 and a&lt;&#x3D;100;</p>
</li>
</ol>
<p>这里，read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1</p>
<p>中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找</p>
<p>索引a的下个记录，并继续循环。另外需要说明的是，如果你想要稳定地使用MRR优化的话，需要设置set</p>
<p>optimizer_switch&#x3D;”mrr_cost_based&#x3D;off”。（官方文档的说法，是现在的优化器策略，判断消耗</p>
<p>的时候，会更倾向于不使用MRR，把mrr_cost_based设置为off，就是固定使用MRR了。）</p>
<p>下面两幅图就是使用了MRR优化后的执行流程和explain结果。图2 MRR执行流程</p>
<p>图3 MRR执行流程的explain结果</p>
<p>从图3的explain结果中，我们可以看到Extra字段多了Using MRR，表示的是用上了MRR优化。而且，由于我们在read_rnd_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递</p>
<p>增顺序的，也就是与图1结果集中行的顺序相反。到这里，我们小结一下。MRR能够提升性能的核心在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这</p>
<p>是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能</p>
<p>体现出“顺序性”的优势。Batched Key Access</p>
<p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key</p>
<p>Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。我们再来看看上一篇文章中用到的NLJ算法的流程图：</p>
<p>图4 Index Nested-Loop Join流程图</p>
<p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是</p>
<p>说，对于表t2来说，每次都是匹配一个值。这时，MRR的优势就用不上了。那怎么才能一次性地多传些值给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给</p>
<p>表t2。既然如此，我们就把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，</p>
<p>就是join_buffer。通过上一篇文章，我们知道join_buffer 在BNL算法里的作用，是暂存驱动表的数据。但是在NLJ</p>
<p>算法里并没有用。那么，我们刚好就可以复用join_buffer到BKA算法中。如图5所示，是上面的NLJ算法优化后的BKA算法的流程。图5 Batched Key Acess流程</p>
<p>图中，我在join_buffer中放入的数据是P1~P100，表示的是只会取查询需要的字段。当然，如果</p>
<p>join buffer放不下P1~P100的所有数据，就会把这100行数据分成多段执行上图的流程。那么，这个BKA算法到底要怎么启用呢？如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p>
<p>其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。set optimizer_switch&#x3D;’mrr&#x3D;on,mrr_cost_based&#x3D;off,batched_key_access&#x3D;on’;</p>
<p>BNL算法的性能问题</p>
<p>说完了NLJ算法的优化，我们再来看BNL算法的优化。我在上一篇文章末尾，给你留下的思考题是，使用Block Nested-Loop Join(BNL)算法时，可能会</p>
<p>对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还</p>
<p>会对系统有什么影响呢？在第33篇文章中，我们说到InnoDB的LRU算法的时候提到，由于InnoDB对Bufffer Pool的LRU</p>
<p>算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据</p>
<p>页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。但是，如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，</p>
<p>就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。这种情况对应的，是冷表的数据量小于整个Buffer Pool的3&#x2F;8，能够完全放入old区域的情况。如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区</p>
<p>域。由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问</p>
<p>到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1</p>
<p>秒之内就被淘汰了。这样，就会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的</p>
<p>数据页没有被合理地淘汰。也就是说，这两种情况都会影响Buffer Pool的正常运作。大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，</p>
<p>对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。为了减少这种影响，你可以考虑增大join_buffer_size的值，减少对被驱动表的扫描次数。也就是说，BNL算法对系统的影响主要包括三个方面：</p>
<ol>
<li><p>可能会多次扫描被驱动表，占用磁盘IO资源；</p>
</li>
<li><p>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常</p>
</li>
</ol>
<p>多的CPU资源；</p>
<ol start="3">
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。我们执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如</li>
</ol>
<p>果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上</p>
<p>索引，把BNL算法转成BKA算法。接下来，我们就具体看看，这个优化怎么做？BNL转BKA</p>
<p>一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p>
<p>我们在文章开始的时候，在表t2中插入了100万行数据，但是经过where条件过滤后，需要参与</p>
<p>join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的</p>
<p>字段b上创建一个索引就很浪费了。但是，如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p>
<ol>
<li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值</li>
</ol>
<p>是256k，可以完全存入。2. 扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，</p>
<p>如果不满足t1.b&#x3D;t2.b，则跳过；</p>
<p>如果满足t1.b&#x3D;t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果</p>
<p>是，就作为结果集的一部分返回，否则跳过。我在上一篇文章中说过，对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中</p>
<p>的所有行。因此判断等值条件的次数是1000*100万&#x3D;10亿次，这个判断的工作量很大。图6 explain结果</p>
<p>图7 语句执行时间</p>
<p>可以看到，explain结果里Extra字段显示使用了BNL算法。在我的测试环境里，这条语句需要执</p>
<p>select * from t1 join t2 on (t1.b&#x3D;t2.b) where t2.b&gt;&#x3D;1 and t2.b&lt;&#x3D;2000;</p>
<p>行1分11秒。在表t2的字段b上创建索引会浪费资源，但是不创建索引的话这个语句的等值条件要判断10亿</p>
<p>次，想想也是浪费。那么，有没有两全其美的办法呢？这时候，我们可以考虑使用临时表。使用临时表的大致思路是：</p>
<ol>
<li><p>把表t2中满足条件的数据放在临时表tmp_t中；</p>
</li>
<li><p>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</p>
</li>
<li><p>让表t1和tmp_t做join操作。此时，对应的SQL语句的写法如下：</p>
</li>
</ol>
<p>图8就是这个语句序列的执行效果。图8 使用临时表的执行效果</p>
<p>可以看到，整个过程3个语句执行时间的总和还不到1秒，相比于前面的1分11秒，性能得到了大</p>
<p>幅提升。接下来，我们一起看一下这个过程的消耗：</p>
<ol>
<li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是</li>
</ol>
<p>100万。create temporary table temp_t(id int primary key, a int, b int, index(b))engine&#x3D;innodb;</p>
<p>insert into temp_t select * from t2 where b&gt;&#x3D;1 and b&lt;&#x3D;2000;</p>
<p>select * from t1 join temp_t on (t1.b&#x3D;temp_t.b);</p>
<ol start="2">
<li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引</li>
</ol>
<p>的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显</p>
<p>的。总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用</p>
<p>上被驱动表上的索引，来触发BKA算法，提升查询性能。扩展-hash join</p>
<p>看到这里你可能发现了，其实上面计算10亿次那个操作，看上去有点儿傻。如果join_buffer里面</p>
<p>维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查</p>
<p>找。这样的话，整条语句的执行速度就快多了吧？确实如此。这，也正是MySQL的优化器和执行器一直被诟病的一个原因：不支持哈希join。并且，MySQL官</p>
<p>方的roadmap，也是迟迟没有把这个优化排上议程。实际上，这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p>
<ol>
<li>select * from t1;取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的</li>
</ol>
<p>set、PHP的dict这样的数据结构。2. select * from t2 where b&gt;&#x3D;1 and b&lt;&#x3D;2000; 获取表t2中满足条件的2000行数据。3. 把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足</p>
<p>匹配的条件的这行数据，就作为结果集的一行。理论上，这个过程会比临时表方案的执行速度还要快一些。如果你感兴趣的话，可以自己验证一</p>
<p>下。小结</p>
<p>今天，我和你分享了Index Nested-Loop Join（NLJ）和Block Nested-Loop Join（BNL）的优化</p>
<p>方法。在这些优化方法中：</p>
<ol>
<li><p>BKA优化是MySQL已经内置支持的，建议你默认使用；</p>
</li>
<li><p>BNL算法效率低，建议你都尽量转成BKA算法。优化的方向就是给被驱动表的关联字段加上</p>
</li>
</ol>
<p>索引；</p>
<ol start="3">
<li><p>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的；</p>
</li>
<li><p>MySQL目前的版本还不支持hash join，但你可以配合应用端自己模拟出来，理论上效果要好</p>
</li>
</ol>
<p>于临时表的方案。最后，我给你留下一道思考题吧。我们在讲join语句的这两篇文章中，都只涉及到了两个表的join。那么，现在有一个三个表join的</p>
<p>需求，假设这三个表的表结构如下：</p>
<p>语句的需求实现如下的join逻辑：</p>
<p>现在为了得到最快的执行速度，如果让你来设计表t1、t2、t3上的索引，来支持这个join语句，</p>
<p>你会加哪些索引呢？同时，如果我希望你用straight_join来重写这个语句，配合你创建的索引，你就需要安排连接顺</p>
<p>序，你主要考虑的因素是什么呢？你可以把你的方案和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上篇文章最后留给你的问题，已经在本篇文章中解答了。这里我再根据评论区留言的情况，简单总结下。根据数据量的大小，有这么两种情况：</p>
<p>@长杰 和 @老杨同志 提到了数据量小于old区域内存的情况；</p>
<p>CREATE TABLE t̀1  ̀(</p>
<p> ìd  ̀int(11) NOT NULL,</p>
<p> &#96;a  ̀int(11) DEFAULT NULL,</p>
<p> &#96;b  ̀int(11) DEFAULT NULL,</p>
<p> &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>create table t2 like t1;</p>
<p>create table t3 like t2;</p>
<p>insert into … &#x2F;&#x2F;初始化三张表的数据</p>
<p>select * from t1 join t2 on(t1.a&#x3D;t2.a) join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2.c&gt;&#x3D;Y and t3.c&gt;&#x3D;Z;</p>
<p>@Zzz 同学，很认真地看了其他同学的评论，并且提了一个很深的问题。对被驱动表数据量</p>
<p>大于Buffer Pool的场景，做了很细致的推演和分析。给这些同学点赞，非常好的思考和讨论。郭健   2</p>
<p>老师，有几个问题还需要请教一下:</p>
<p>1.上一章t1表100条数据，t21000条数据，mysql会每次都会准确的找出哪张表是合理的驱动表</p>
<p>吗？还是需要人为的添加straight_join。2.像left join这种，左边一定是驱动表吧？以左边为标准查看右边有符合的条件，拼成一条数据</p>
<p>，看到你给其他同学的评论说可能不是，这有些疑惑。3.在做join的时候，有些条件是可以放在on中也可以放在where中，比如(t1.yn&#x3D;1 和t2.yn&#x3D;1)这种</p>
<p>简单判断是否删除的。最主要的是，需要根据两个条件才能join的(productCode和custCode),需</p>
<p>要两个都在on里，还是一个在on中，一个在where中更好呢？2019-02-07</p>
<p> 作者回复</p>
<ol>
<li><p>正常是会自己找到合理的，但是用前explain是好习惯哈</p>
</li>
<li><p>这个问题的展开我放到答疑文章中哈</p>
</li>
<li><p>这也是好问题，需要分析是使用哪种算法，也放到答疑文章展开哈。精选留言</p>
</li>
</ol>
<p>新年快乐~</p>
<p>2019-02-07</p>
<p>Geek_02538c   1</p>
<p>过年了，还有新文章，给个赞。 另，where 和 order 与索引的关系，都讲过了，group by 是否</p>
<p>也搞个篇章说一下。2019-02-02</p>
<p> 作者回复</p>
<p>你说得对^_^ 第37篇就是，新年快乐</p>
<p>2019-02-03</p>
<p>Ryoma   1</p>
<p>read_rnd_buffer_length 参数应该是 read_rnd_buffer_size，见文档：<a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></p>
<p>refman&#x2F;8.0&#x2F;en&#x2F;server-system-variables.html#sysvar_read_rnd_buffer_size</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>你说得对，多谢</p>
<p>发起勘误了</p>
<p>新年快乐</p>
<p>2019-02-03</p>
<p>Mr.Strive.Z.H.L   1</p>
<p>老师您好，新年快乐~~</p>
<p>关于三表join有一个疑惑点需要确认：</p>
<p>老师您在评论中说到，三表join不会是前两个表join后得到结果集，再和第三张表join。针对这句话，我的理解是：</p>
<p>假设我们不考虑BKA，就按照一行行数据来判断的话，流程应该如下（我会将server端和innod</p>
<p>b端分的很清楚）：</p>
<p>表是t1 ,t2 ,t3。 t1 straight_join t2 straight_join t3，这样的join顺序。1. 调用innodb接口，从t1中取一行数据，数据返回到server端。2. 调用innodb接口，从t2中取满足条件的数据，数据返回到server端。3. 调用innodb接口，从t3中取满足条件的数据，数据返回到server端。上面三步之后，驱动表 t1的一条数据就处理完了，接下来重复上述过程。（如果采用BKA进行优化，可以理解为不是一行行数据的提取，而是一个范围内数据的提取）</p>
<p>。按照我上面的描述，确实没有前两表先join得结果集，然后再join第三张表的过程。不知道我上面的描述的流程对不对？（我个人觉得，将innodb的处理和server端的处理分隔清</p>
<p>晰，对于sql语句的理解，会透彻很多）</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>新年快乐，分析得很好。可以再补充一句，会更好理解你说的这个过程 ：</p>
<p>如果采用BKA进行优化,每多一个join，就多一个join_buffer</p>
<p>2019-02-02</p>
<p>LY   1</p>
<p>order by cjsj desc limit 0,20 explain Extra只是显示 Using where ，执行时间 7秒钟</p>
<p>order by cjsj desc limit 5000,20 explain Extra只是显示 Using index condition; Using where; Usin</p>
<p>g filesort, 执行时间 0.1 秒</p>
<p>有些许的凌乱了@^^@</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>这正常的，一种可能是这样的： </p>
<p>Using where 就是顺序扫，但是这个上要扫很久才能扫到满足条件的20个记录；</p>
<p>虽然有filesort，但是如果参与排序的行数少，可能速度就更快，而且limit 有堆排序优化哦</p>
<p>2019-02-01</p>
<p>郭健   0</p>
<p>老师，新年快乐！！看到您给我提问的回答，特别期待您之后的答疑，因为dba怕我们查询数</p>
<p>据库时连接时间过长，影响线上实际运行。所以就开发出一个网页，让我们进行查询，但是超</p>
<p>过几秒(具体不知道，查询一个200w的数据，条件没有加索引有时候都会)就会返回time out，所</p>
<p>以当查询大表并join的时候，就会很吃力！想法设法的缩小单位，一般我们都不会为createTime</p>
<p>建一个索引，所以在根据时间缩小范围的时候有时候也并不是很好的选择。我们线上做统计sql</p>
<p>的时候，因为数据量比较大，筛选条件也比较多，一个sql可能在0.4s多，这已经是属于慢sql了</p>
<p>。感谢老师对我提问的回答！！</p>
<p>2019-02-09</p>
<p>磊   0</p>
<p>一直对多表的join有些迷惑，希望老师后面专门把这块给讲的透彻些</p>
<p>2019-02-03</p>
<p> 作者回复</p>
<p>这一期45篇 join差不多就讲这些了 </p>
<p>有问题在评论区提出来哈</p>
<p>2019-02-03</p>
<p>bluefantasy3   0</p>
<p>请教老师一个问题：innodb的Buffer Pool的内存是innodb自己管理还是使用OS的page cache? </p>
<p>我理解应该是innodb自己管理。我在另一个课程里看到如果频繁地把OS的&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_c</p>
<p>aches 改成 1会影响MySQL的性能，如果buffer pool是MySQL自己管理，应该不受这个参数影</p>
<p>响呀？请解答。2019-02-02</p>
<p> 作者回复</p>
<ol>
<li><p>是MySQL 自己管理的</p>
</li>
<li><p>一般只有数据文件是o_direct的，redo log 和 binlog 都是有用到文件系统的page cache, 因此</p>
</li>
</ol>
<p>多少有影响的</p>
<p>好问题  </p>
<p>2019-02-03</p>
<p>信信   0</p>
<p>老师好，有两点疑问请老师解惑：</p>
<p>1、图8上面提到的关于临时表的第三句是不是还是使用straight_join好一些？不然有可能temp_t</p>
<p>被选为驱动表？2、图8下面提到join过程中做了1000次带索引的查询，这里的1000也是在打开mrr的情况下的吗</p>
<p>？是进行了1000次树搜索，还是找到第一个后，依次挨着读呢？2019-02-02</p>
<p> 作者回复</p>
<ol>
<li><p>写straight_join能确定顺序，也可以的，这里写join 也ok的</p>
</li>
<li><p>是进行了1000次树搜索</p>
</li>
</ol>
<p>2019-02-02</p>
<p>HuaMax   0</p>
<p>前提假设：t1.c&gt;&#x3D;X可以让t1成为小表。同时打开BKA和MRR。1、t1表加（c,a)索引。理由：A、t1.c&gt;&#x3D;X可以使用索引；B、加上a的联合索引，join buffer里放</p>
<p>入的是索引（c,a）而不是去主键表取整行，用于与表t2的t1.a &#x3D; t2.a的join查询，不过返回SELE</p>
<p>CT * 最终还是需要回表。2、t2表加(a,b,c)索引。理由：A、加上a避免与t1表join查询的BNL；B、理由同【1-B】；C、加</p>
<p>上c不用回表判断t2.c&gt;&#x3D;Y的筛选条件</p>
<p>3、t3表加（b,c）索引。理由：A、避免与t2表join查询的BNL;C、理由同【2-C】</p>
<p>问题：</p>
<p>1、【1-B】和【2-B】由于select *要返回所有列数据，不敢肯定join buffer里是回表的整行数据</p>
<p>还是索引（c,a)的数据，需要老师解答一下；不过值得警惕的是，返回的数据列对sql的执行策</p>
<p>略有非常大的影响。2、在有join查询时，被驱动表是先做join连接查询，还是先筛选数据再从筛选后的临时表做join</p>
<p>连接？这将影响上述的理由【2-C】和【3-C】</p>
<p>使用straight_join强制指定驱动表，我会改写成这样:select * from t2 STRAIGHT_JOIN t1 on(t1.</p>
<p>a&#x3D;t2.a) STRAIGHT_JOIN t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2.c&gt;&#x3D;Y and t3.c&gt;&#x3D;Z;</p>
<p>考虑因素包括：</p>
<p>1、驱动表使用过滤条件筛选后的数据量，使其成为小表，上面的改写也是基于t2是小表</p>
<p>2、因为t2是跟t1,t3都有关联查询的，这样的话我猜测对t1,t3的查询是不是可以并行执行，而如</p>
<p>果使用t1,t3作为主表的话，是否会先跟t2生成中间表，是个串行的过程？3、需要给t1加（a,c)索引，给t2加（c,a,b）索引。2019-02-02</p>
<p> 作者回复</p>
<p>  很深入的思考哈</p>
<ol>
<li><p>select * ，所以放整行；你说得对，select * 不是好习惯；</p>
</li>
<li><p>第一次join后就筛选；第二次join再筛选；</p>
</li>
</ol>
<p>新春快乐~</p>
<p>2019-02-04</p>
<p>库淘淘   0</p>
<p>set optimizer_switch&#x3D;’mrr&#x3D;on,mrr_cost_based&#x3D;off,batched_key_access&#x3D;on’;</p>
<p>create index idx_c on t2(c);</p>
<p>create index idx_a_c on t1(a,c);</p>
<p>create index idx_b_c on t3(b,c);</p>
<p>mysql&gt; explain select * from t2 </p>
<p>-&gt; straight_join t1 on(t1.a&#x3D;t2.a)</p>
<p>-&gt; straight_join t3 on(t2.b&#x3D;t3.b) </p>
<p>-&gt; where t1.c&gt; 800 and t2.c&gt;&#x3D;600 and t3.c&gt;&#x3D;500;</p>
<p>+—-+————-+——-+————+—————————————</p>
<p>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | </p>
<p>Extra +—————————————-</p>
<p>| 1 | SIMPLE | t2 | NULL | range | idx_c | idx_c | 5 | NULL | 401 | 100.00 | Using index condition</p>
<p>; Using where; Using MRR |</p>
<p>| 1 | SIMPLE | t1 | NULL | ref | idx_a_c | idx_a_c | 5 | test.t2.a | 1 | 33.33 | Using index conditio</p>
<p>n; Using join buffer (Batched Key Access) |</p>
<p>| 1 | SIMPLE | t3 | NULL | ref | idx_b_c | idx_b_c | 5 | test.t2.b | 1 | 33.33 | Using index conditio</p>
<p>n; Using join buffer (Batched Key Access) |</p>
<p>+—-+————-+——-+————+—–+—————————————</p>
<p>3 rows in set, 1 warning (0.00 sec)</p>
<p>以自己理解如下，有问题请老师能够指出</p>
<p>1.根据查询因是select * 肯定回表的，其中在表t2创建索引idx_c,为了能够使用ICP,MRR，如果c</p>
<p>字段重复率高或取值行数多，可以考虑不建索引</p>
<p>2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得</p>
<p>出结果 再各回t2,t3表取出 得到结果集（之前理解都是t1和t2join得结果集再与t3join，本次理解</p>
<p>太确定）</p>
<p>3.t2、t3表建立联合查询目的能够使用ICP</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p> </p>
<p>BKA是从Index Nexted-Loop join 优化而来的，并不是“t1和t2join得结果集再与t3join”，而是直接</p>
<p>嵌套循环执行下去。这个效果相当不错了，MRR，BKA都用上</p>
<p>2019-02-02</p>
<p>LY   0</p>
<p>刚刚凌乱了的那个问题，经explain验证，explain SELECT a.* FROM sys_xxtx a JOIN baq_ryxx</p>
<p>r ON a.ryid &#x3D; r.ID WHERE a.dwbh &#x3D; ‘7E0A13A14101D0A8E0430A0F23BCD0A8’ ORDER BY tx</p>
<p>sj DESC LIMIT 0,20;</p>
<p>使用的索引是txsj ；</p>
<p>explain SELECT a.* FROM sys_xxtx a JOIN baq_ryxx r ON a.ryid &#x3D; r.ID WHERE a.dwbh &#x3D; ‘7E0</p>
<p>A13A14101D0A8E0430A0F23BCD0A8’ ORDER BY txsj DESC LIMIT 5000,20;使用的索引是dw</p>
<p>bh ；</p>
<p>然后回忆起了第10张：MySQL为什么有时候会选错索引？但是从扫描行数、是否使用排序等来看在 LIMIT 5000,20时候也应该优选txsj ?可是这个时候选</p>
<p>择的索引是dwbh, 查询时间也大大缩短</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>嗯，这个跟我们第十篇那个例子挺像的</p>
<p>我们把limit 1 改成limit 100的时候，MySQL认为，要扫描到“100行那么多”，</p>
<p>你这里是limit 5000，200， 这个5000会让优化器认为，选txsj会要扫“很多行，可能很久”</p>
<p>这个确实是优化器还不够完善的地方，有时候不得不用force index~</p>
<p>2019-02-02</p>
<p>dzkk   0</p>
<p>老师，对于关联查询（inner join），个人有几点理解，请帮助审核是否正确，谢了。正确选择：</p>
<p>结果集小的为驱动表，且被驱动表有索引</p>
<p>未知效果选择：</p>
<p>1）结果集小的为驱动表，但是被驱动表没有索引</p>
<p>2）结果集大的为驱动表，但是被驱动表有索引</p>
<p>最差选择：</p>
<p>结果集大的为驱动表，且被驱动表没有索引</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>未知效果选择 是啥意思^_^</p>
<p>2019-02-02</p>
<p>老杨同志   0</p>
<p>我准备给</p>
<p>t1增加索引c</p>
<p>t2增加组合索引b,c</p>
<p>t3增加组合索引b,c</p>
<p>select * from t1 straight_join t2 on(t1.a&#x3D;t2.a) straight_join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2</p>
<p>.c&gt;&#x3D;Y and t3.c&gt;&#x3D;Z;</p>
<p>另外我还有个问题，开篇提到的这句sql select * from t1 where a&gt;&#x3D;1 and a&lt;&#x3D;100;</p>
<p>a是索引列，如果这句索引有order by a，不使用MRR 优化，查询出来就是按a排序的，使用了</p>
<p>mrr优化，是不是要额外排序</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>对，好问题，用了order by就不用MRR了</p>
<p>2019-02-02</p>
<p>poppy   0</p>
<p>select * from t1 join t2 on(t1.a&#x3D;t2.a) join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2.c&gt;&#x3D;Y and t3.c&gt;&#x3D;</p>
<p>Z;</p>
<p>老师，我的理解是真正做join的三张表的大小实际上是t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z对应满足条</p>
<p>件的行数，为了方便快速定位到满足条件的数据，t1、t2和t3的c字段最好都建索引。对于join操</p>
<p>作，按道理mysql应该会优先选择join之后数量比较少的两张表先来进行join操作，例如满足t1.a</p>
<p>&#x3D;t2.a的行数小于满足t2.b&#x3D;t3.b的行数，那么就会优先将t1和t2进行join，选择t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y</p>
<p>中行数少的表作为驱动表，另外一张作为被驱动表，在被驱动表的a的字段上建立索引，这样就</p>
<p>完成了t1和t2的join操作并把结果放入join_buffer准备与t3进行join操作，则在作为被驱动表的t3</p>
<p>的b字段上建立索引。不知道举的这个例子分析得是否正确，主要是这里不知道t1、t2、t3三张</p>
<p>表的数据量，以及满足t1.c&gt;&#x3D;X ，t2.c&gt;&#x3D;Y ，t3.c&gt;&#x3D;Z的数据量，还有各个字段的区分度如何，</p>
<p>是否适合建立索引等。2019-02-01</p>
<p> 作者回复</p>
<p>嗯 这个问题就是留给大家自己设定条件然后分析的，分析得不错哦</p>
<p>2019-02-02</p>
<p>Destroy、   0</p>
<p>BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给驱动表的关联字段加上索</p>
<p>引；</p>
<p>老师最后总结的时候，这句话后面那句，应该是给被驱动表的关联字段加上索引吧。2019-02-01</p>
<p> 作者回复</p>
<p>对的， 细致</p>
<p>已经发起勘误，谢谢你哦，新年快乐</p>
<p>2019-02-01</p>
<p>LY   0</p>
<p>LY  0</p>
<p>YEAR(txsj) &#x3D; ‘2018’ 有结果集，YEAR(txsj) &#x3D; ‘2019’ 无结果集，</p>
<p>YEAR(txsj) &#x3D; ‘2018’ 和 YEAR(txsj) &#x3D; ‘2019’ 查询所需时间 后者是前者的10倍</p>
<p>请老师分析下大概什么原因？2019-02-01</p>
<p> 作者回复</p>
<p>这个信息太不足了 </p>
<p>我第一时间反应是不是有limit？你给贴一下表结构，</p>
<p>sql语句，还有explain这个语句的结果 ，我们再来分析下哈</p>
<p>2019-02-01</p>
<p>John   0</p>
<p>期待這一篇很久啦 終於出來啦 臨時表和範圍搜索實在是醍醐灌頂 謝謝老師</p>
<p>2019-02-01</p>
<p>永恒记忆   0</p>
<p>老师，记得之前看目录之后要将一篇标题大概为“我的mysql为啥莫名其妙重启了”，最近看怎么</p>
<p>没有了？我们确实遇到这种问题，在系统日志里也找不到OOM信息，现象是半个月左右就会自</p>
<p>动重启一下，时间不固定，想请教下是什么问题呢？2019-02-01</p>
<p> 作者回复</p>
<p>贴一下errorlog里面看看有没有异常信息 如果比较大的文件可以发我微博私信附件</p>
<p>写文章的过程中根据大家的评论问题，发现有些知识点应该优先写，目录有做调整哈</p>
<p>2019-02-01</p>
<p>郭江伟   0</p>
<p>select * from t1 join t2 on(t1.a&#x3D;t2.a) join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2.c&gt;&#x3D;Y and t3.c&gt;&#x3D;</p>
<p>Z;</p>
<p>这个语句建索引需要考虑三个表的数据量和相关字段的数据分布、选择率、每个条件返回行数</p>
<p>占比等</p>
<p>我的测试场景是：</p>
<p>t1 1000行数据 t2 100w行数据 t3 100w行，关联字段没有重复值，条件查询返回行数占比很少，</p>
<p>此时索引为： </p>
<p>alter table t1 add key t1_c(c);</p>
<p>alter table t2 add key t2_ac(a,c);</p>
<p>alter table t3 add key t3_bc(b,c);</p>
<p>测试sql无索引是执行需要2分钟多，加了索引后需要0.01秒，加索引后执行计划为：</p>
<p>mysql&gt; explain select * from t1 join t2 on(t1.a&#x3D;t2.a) join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;100 and t</p>
<p>2.c&gt;&#x3D;10 and t3.c&gt;&#x3D;90;</p>
<p>+—-+————-+——-+————+——+—————+——-+———+—————+——+———-</p>
<p>+————————————+</p>
<p>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | </p>
<p>Extra |</p>
<p>+—-+————-+——-+————+——+—————+——-+———+—————+——+———-</p>
<p>+————————————+</p>
<p>| 1 | SIMPLE | t1 | NULL | ALL | t1_a | NULL | NULL | NULL | 1000 | 90.10 | Using where |</p>
<p>| 1 | SIMPLE | t2 | NULL | ref | t2_ac | t2_ac | 5 | sysbench.t1.a | 1 | 33.33 | Using index conditi</p>
<p>on; Using where |</p>
<p>| 1 | SIMPLE | t3 | NULL | ref | t3_bc | t3_bc | 5 | sysbench.t2.b | 1 | 33.33 | Using index conditi</p>
<p>on |</p>
<p>+—-+————-+——-+————+——+—————+——-+———+—————+——+———-</p>
<p>+————————————+</p>
<p>另外，select * 如果改成具体字段的话考虑覆盖索引 可能需要建立不同的索引。2019-02-01</p>
<p> 作者回复</p>
<p> 验证的结果最有说服力</p>
<p>2019-02-01</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-“order by”是怎么工作的</title>
    <url>/posts/ab80f837.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>16 | “order by”是怎么工作的？2018-12-19 林晓斌</p>
<p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们</p>
<p>前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回</p>
<p>前1000个人的姓名、年龄。假设这个表的部分定义是这样的：</p>
<p>这时，你的SQL语句可以这么写：</p>
<p>CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>city</code> varchar(16) NOT NULL,</p>
<p>  <code>name</code> varchar(16) NOT NULL,</p>
<p>  <code>age</code> int(11) NOT NULL,</p>
<p>  <code>addr</code> varchar(128) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  KEY <code>city</code> (<code>city</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么</p>
<p>执行的，以及有什么参数会影响执行的行为。全字段排序</p>
<p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索</p>
<p>引。在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。图1 使用explain命令查看语句的执行情况</p>
<p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于</p>
<p>排序，称为sort_buffer。为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。图2 city字段的索引示意图</p>
<p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li><p>初始化sort_buffer，确定放入name、city、age这三个字段；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name做快速排序；</p>
</li>
<li><p>按照排序结果取前1000行返回给客户端。我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还</p>
</li>
</ol>
<p>会用到这个排序。图3 全字段排序</p>
<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所</p>
<p>需的内存和参数sort_buffer_size。sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量</p>
<p>小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不</p>
<p>利用磁盘临时文件辅助排序。你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中</p>
<p>看到是否使用了临时文件。&#x2F;* 打开optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* @a保存Innodb_rows_read的初始值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select city, name,age from t where city&#x3D;’杭州’ order by name limit 1000; </p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM <code>information_schema</code>.<code>OPTIMIZER_TRACE</code>\G</p>
<p>&#x2F;* @b保存Innodb_rows_read的当前值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 计算Innodb_rows_read差值 *&#x2F;</p>
<p>select @b-@a;</p>
<p>图4 全排序的OPTIMIZER_TRACE部分结果</p>
<p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个</p>
<p>文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理</p>
<p>解，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把</p>
<p>这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序</p>
<p>可以直接在内存中完成。否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越</p>
<p>多，number_of_tmp_files的值就越大。接下来，我再和你解释一下图4中其他两个值的意思。我们的示例表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示</p>
<p>参与排序的行数是4000行。sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使</p>
<p>name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000</p>
<p>行。这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成</p>
<p>MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而</p>
<p>internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数</p>
<p>据从临时表取出来的时候，会让Innodb_rows_read的值加1。rowid排序</p>
<p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件</p>
<p>中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面</p>
<p>要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能</p>
<p>会很差。所以如果单行很大，这个方法效率不够好。那么，如果MySQL认为排序的单行长度太大会怎么做呢？接下来，我来修改一个参数，让MySQL采用另外一种算法。max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意</p>
<p>思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我</p>
<p>们再来看看计算过程有什么改变。新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如</p>
<p>下所示的样子：</p>
<ol>
<li><p>初始化sort_buffer，确定放入两个字段，即name和id；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name进行排序；</p>
</li>
<li><p>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回</p>
</li>
</ol>
<p>给客户端。这个执行流程的示意图如下，我把它称为rowid排序。SET max_length_for_sort_data &#x3D; 16;</p>
<p>图5 rowid排序</p>
<p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中</p>
<p>依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存</p>
<p>存储结果，是直接返回给客户端的。根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？现在，我们就来看看结果有什么不同。首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-</p>
<p>@a这个语句的值变成5000了。因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因</p>
<p>此会多读1000行。图6 rowid排序的OPTIMIZER_TRACE部分输出</p>
<p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一</p>
<p>行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。全字段排序 VS rowid排序</p>
<p>我们来分析一下，从这两个执行流程里，还能得出什么结论。如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过</p>
<p>程中一次可以排序更多行，但是需要再回到原表去取数据。如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这</p>
<p>样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的</p>
<p>order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句</p>
<p>的执行时间也会变得更短。其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看</p>
<p>到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无</p>
<p>序的。你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，</p>
<p>是不是就可以不用再排序了呢？确实是这样的。所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<p>作为与city索引的对比，我们来看看这个索引的示意图。图7 city和name联合索引示意图</p>
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外</p>
<p>确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是</p>
<p>有序的。这样整个查询过程的流程就变成了：</p>
<ol>
<li><p>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返</p>
</li>
</ol>
<p>回；</p>
<ol start="3">
<li>从索引(city,name)取下一个记录主键id；</li>
</ol>
<p>alter table t add index city_user(city, name);</p>
<ol start="4">
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图8 引入(city,name)联合索引后，查询语句的执行计划</li>
</ol>
<p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一</p>
<p>下。图9 引入(city,name)联合索引后，查询语句的执行计划</p>
<p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)</p>
<p>这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前</p>
<p>1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。既然说到这里了，我们再往前讨论，这个语句的执行流程有没有可能进一步简化呢？不知道</p>
<p>你还记不记得，我在第5篇文章《 深入浅出索引（下）》中，和你介绍的覆盖索引。这里我们可以再稍微复习一下。覆盖索引是指，索引上的信息足够满足查询请求，不需要再</p>
<p>回到主键索引上去取数据。按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也</p>
<p>就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age</li>
</ol>
<p>这三个字段的值，作为结果集的一部分直接返回；</p>
<ol start="2">
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接</li>
</ol>
<p>返回；</p>
<ol start="3">
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图10 引入(city,name,age)联合索引后，查询语句的执行流程</li>
</ol>
<p>然后，我们再来看看explain的结果。alter table t add index city_user_age(city, name, age);</p>
<p>图11 引入(city,name,age)联合索引后，查询语句的执行计划</p>
<p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索</p>
<p>引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。小结</p>
<p>今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻</p>
<p>辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能</p>
<p>做到下笔如有神，不犯低级错误。最后，我给你留下一个思考题吧。假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市</p>
<p>中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p>
<p>那么，这个语句执行的时候会有排序过程吗，为什么？如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你</p>
<p>的实现方法又会是什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会</p>
<p>真的去执行一次修改吗？还是看到值相同就直接返回呢？这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我</p>
<p>们可以用一个锁实验来确认。mysql&gt; select * from t where city in (‘杭州’,”苏州”) order by name limit 100;</p>
<p>假设，当前表t里的值是(1,2)。图12 锁验证方式</p>
<p>session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新，</p>
<p>直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。假设当前表里的值是(1,2)。图13 可见性验证方式</p>
<p>session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语</p>
<p>句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章《事务到底是隔</p>
<p>离的还是不隔离的？》中的相关内容）</p>
<p>所以，我们上期思考题的答案应该是选项3，即：InnoDB认真执行了“把这个值修改成(1,2)”这个</p>
<p>操作，该加锁的加锁，该更新的更新。然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不</p>
<p>就不用浪费InnoDB操作，多去更新一次了？其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的</p>
<p>(id&#x3D;1), 而要写的是(a&#x3D;3)，只从这两个信息是看不出来“不需要修改”的。作为验证，你可以看一下下面这个例子。图14 可见性验证方式–对照</p>
<p>补充说明：</p>
<p>上面我们的验证结果都是在binlog_format&#x3D;statement格式下进行的。@didiren 补充了一个case， 如果是binlog_format&#x3D;row 并且binlog_row_image&#x3D;FULL的时候，由</p>
<p>于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id&#x3D;1，</p>
<p>结果就是“返回 (1,2)”。同理，如果是binlog_row_image&#x3D;NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里，</p>
<p>结果还是“返回 (1,2)”。对应的代码如图15所示。这是MySQL 5.6版本引入的，在此之前我没有看过。所以，特此说明。图15 binlog_row_image&#x3D;FULL读字段逻辑</p>
<p>类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字</p>
<p>段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样</p>
<p>通过判断，就会发现不需要修改。这两个点我会在后面讲更新性能的文章中再展开。评论区留言点赞板：</p>
<p>@Gavin 、@melon、@阿建 等同学提到了锁验证法；</p>
<p>@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的：</p>
<p>第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下</p>
<p>的策略。你可以把binlog_format 改成statement再验证下。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么临时表可以重名</title>
    <url>/posts/b0b7112a.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>36 | 为什么临时表可以重名？2019-02-04 林晓斌</p>
<p>今天是大年三十，在开始我们今天的学习之前，我要先和你道一声春节快乐！</p>
<p>在上一篇文章中，我们在优化join查询的时候使用到了临时表。当时，我们是这么用的：</p>
<p>你可能会有疑问，为什么要用临时表呢？直接用普通表是不是也可以呢？今天我们就从这个问题说起：临时表有哪些特征，为什么它适合这个场景？这里，我需要先帮你厘清一个容易误解的问题：有的人可能会认为，临时表就是内存表。但是，</p>
<p>这两个概念可是完全不同的。内存表，指的是使用Memory引擎的表，建表语法是create table … engine&#x3D;memory。这种表的</p>
<p>数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去</p>
<p>比较“奇怪”外，从其他的特征上看，它就是一个正常的表。而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写</p>
<p>create temporary table temp_t like t1;</p>
<p>alter table temp_t add index(b);</p>
<p>insert into temp_t select * from t2 where b&gt;&#x3D;1 and b&lt;&#x3D;2000;</p>
<p>select * from t1 join temp_t on (t1.b&#x3D;temp_t.b);</p>
<p>数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。弄清楚了内存表和临时表的区别以后，我们再来看看临时表有哪些特征。临时表的特性</p>
<p>为了便于理解，我们来看下下面这个操作序列：</p>
<p>图1 临时表特性示例</p>
<p>可以看到，临时表在使用上有以下几个特点：</p>
<ol>
<li>建表语法是create temporary table …。2. 一个临时表只能被创建它的session访问，对其他线程不可见。所以，图中session A创建的</li>
</ol>
<p>临时表t，对于session B就是不可见的。3. 临时表可以与普通表同名。4. session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的</p>
<p>是临时表。5. show tables命令不显示临时表。由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。也正是由于这个特性，临时表就特别适合我们文章开头的join优化这种场景。为什么呢？原因主要包括以下两个方面：</p>
<ol>
<li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，不需要担心表</li>
</ol>
<p>名重复导致建表失败的问题。2. 不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或</p>
<p>者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动</p>
<p>回收，所以不需要这个额外的操作。临时表的应用</p>
<p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分</p>
<p>表系统的跨库查询就是一个典型的使用场景。一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大</p>
<p>表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上。如下图所示：</p>
<p>图2 分库分表简图</p>
<p>一般情况下，这种分库分表系统都有一个中间层proxy。不过，也有一些方案会让客户端直接连</p>
<p>接数据库，也就是没有proxy这一层。在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包</p>
<p>含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将</p>
<p>这条语句路由到哪个分表做查询。比如下面这条语句：</p>
<p>这时，我们就可以通过分表规则（比如，N%1024)来确认需要的数据被放在了哪个分表上。这</p>
<p>种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。但是，如果这个表上还有另外一个索引k，并且查询语句是这样的：</p>
<p>这时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有</p>
<p>行，然后统一做order by 的操作。这种情况下，有两种比较常用的思路。第一种思路是，在proxy层的进程代码中实现排序。这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案</p>
<p>的缺点也比较明显：</p>
<ol>
<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操</li>
</ol>
<p>作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高；</p>
<ol start="2">
<li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。另一种思路就是，把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇</li>
</ol>
<p>总实例上做逻辑操作。比如上面这条语句，执行流程可以类似这样：</p>
<p>在汇总库上创建一个临时表temp_ht，表里包含三个字段v、k、t_modified；</p>
<p>在各个分库上执行</p>
<p>select v from ht where f&#x3D;N;</p>
<p>select v from ht where k &gt;&#x3D; M order by t_modified desc limit 100;</p>
<p>select v,k,t_modified from ht_x where k &gt;&#x3D; M order by t_modified desc limit 100;</p>
<p>把分库执行的结果插入到temp_ht表中；</p>
<p>执行</p>
<p>得到结果。这个过程对应的流程图如下所示：</p>
<p>图3 跨库查询流程示意图</p>
<p>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表temp_ht放</p>
<p>到32个分库中的某一个上。这时的查询逻辑与图3类似，你可以自己再思考一下具体的流程。为什么临时表可以重名？你可能会问，不同线程可以创建同名的临时表，这是怎么做到的呢？接下来，我们就看一下这个问题。我们在执行</p>
<p>select v from temp_ht order by t_modified desc limit 100; </p>
<p>这个语句的时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保</p>
<p>存表数据。这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}<em>{线程id}</em></p>
<p>序列号”。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p>
<p>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文</p>
<p>件，用来存放数据文件；</p>
<p>而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因</p>
<p>此，我们就不需要再创建ibd文件了。从文件名的前缀规则，我们可以看到，其实创建一个叫作t1的InnoDB临时表，MySQL在存储上</p>
<p>认为我们创建的表名跟普通表t1是不同的，因此同一个库下面已经有普通表t1的情况下，还是可</p>
<p>以再创建一个临时表t1的。为了便于后面讨论，我先来举一个例子。图4 临时表的表名</p>
<p>这个进程的进程号是1234，session A的线程id是4，session B的线程id是5。所以你看到</p>
<p>了，session A和session B创建的临时表，在磁盘上的文件不会重名。MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都</p>
<p>对应一个table_def_key。一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两</p>
<p>个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。create temporary table temp_t(id int primary key)engine&#x3D;innodb;</p>
<p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名</p>
<p>也不同，因此可以并存。在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链</p>
<p>表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在</p>
<p>session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。这时候你会发现，binlog中也记录了DROP TEMPORARY TABLE这条命令。你一定会觉得奇</p>
<p>怪，临时表只在线程内自己可以访问，为什么需要写到binlog里面？这，就需要说到主备复制了。临时表和主备复制</p>
<p>既然写binlog，就意味着备库需要。你可以设想一下，在主库上执行下面这个语句序列：</p>
<p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into</p>
<p>t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时</p>
<p>候，就会报错“表temp_t不存在”。你可能会说，如果把binlog设置为row格式就好了吧？因为binlog是row格式时，在记录insert into</p>
<p>t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一</p>
<p>行数据（1,1)”。确实是这样。如果当前的binlog_format&#x3D;row，那么跟临时表有关的语句，就不会记录到binlog</p>
<p>里。也就是说，只在binlog_format&#x3D;statment&#x2F;mixed 的时候，binlog中才会记录临时表的操作。这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主</p>
<p>库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我</p>
<p>们就需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。之前有人问过我一个有趣的问题：MySQL在记录binlog的时候，不论是create table还是alter</p>
<p>table语句，都是原样记录，甚至于连空格都不变。但是如果执行drop table t_normal，系统记录</p>
<p>binlog就会写成：</p>
<p>create table t_normal(id int primary key, c int)engine&#x3D;innodb;&#x2F;<em>Q1</em>&#x2F;</p>
<p>create temporary table temp_t like t_normal;&#x2F;<em>Q2</em>&#x2F;</p>
<p>insert into temp_t values(1,1);&#x2F;<em>Q3</em>&#x2F;</p>
<p>insert into t_normal select * from temp_t;&#x2F;<em>Q4</em>&#x2F;</p>
<p>也就是改成了标准的格式。为什么要这么做呢 ？现在你知道原因了，那就是：drop table命令是可以一次删除多个表的。比如，在上面的例子</p>
<p>中，设置binlog_format&#x3D;row，如果主库上执行 “drop table t_normal, temp_t”这个命令，那么</p>
<p>binlog中就只能记录：</p>
<p>因为备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停</p>
<p>止。所以，drop table命令记录binlog的时候，就必须对语句做改写。“&#x2F;* generated by server *&#x2F;”说明</p>
<p>了这是一个被服务端改写过的命令。说到主备复制，还有另外一个问题需要解决：主库上不同的线程创建同名的临时表是没关系</p>
<p>的，但是传到备库执行是怎么处理的呢？现在，我给你举个例子，下面的序列中实例S是M的备库。图5 主备关系中的临时表操作</p>
<p>主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1 语句都会被传</p>
<p>到备库S上。但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create 语句两</p>
<p>次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行）。那么，这会不会导</p>
<p>致同步线程报错 ？显然是不会的，否则临时表就是一个bug了。也就是说，备库线程在执行的时候，要把这两个t1</p>
<p>DROP TABLE t̀_normal  ̀&#x2F;* generated by server *&#x2F;</p>
<p>DROP TABLE t̀_normal  ̀&#x2F;* generated by server *&#x2F;</p>
<p>表当做两个不同的临时表来处理。这，又是怎么实现的呢？MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应</p>
<p>用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的</p>
<p>table_def_key：</p>
<ol>
<li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的</li>
</ol>
<p>thread_id”;</p>
<ol start="2">
<li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的</li>
</ol>
<p>thread_id”。由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。小结</p>
<p>今天这篇文章，我和你介绍了临时表的用法和特性。在实际应用中，临时表一般用于处理比较复杂的计算逻辑。由于临时表是每个线程自己可见的，</p>
<p>所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时</p>
<p>表也能自动删除，省去了收尾和异常处理的工作。在binlog_format&#x3D;’row’的时候，临时表的操作不记录到binlog中，也省去了不少麻烦，这也可以</p>
<p>成为你选择binlog_format时的一个考虑因素。需要注意的是，我们上面说到的这种临时表，是用户自己创建的 ，也可以称为用户临时表。与</p>
<p>它相对应的，就是内部临时表，在第17篇文章中我已经和你介绍过。最后，我给你留下一个思考题吧。下面的语句序列是创建一个临时表，并将其改名：</p>
<p>图6 关于临时表改名的思考题</p>
<p>可以看到，我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这</p>
<p>是什么原因吗？你可以把你的分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，对于下面这个三个表的join语句，</p>
<p>如果改写成straight_join，要怎么指定连接顺序，以及怎么给三个表创建索引。第一原则是要尽量使用BKA算法。需要注意的是，使用BKA算法的时候，并不是“先计算两个表</p>
<p>join的结果，再跟第三个表join”，而是直接嵌套查询的。具体实现是：在t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z这三个条件里，选择一个经过过滤以后，数据最少</p>
<p>的那个表，作为第一个驱动表。此时，可能会出现如下两种情况。第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。1. 如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a 和</p>
<p>t3.b上创建索引；</p>
<ol start="2">
<li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b 和 t1.a上创建索引。同时，我们还需要在第一个驱动表的字段c上创建索引。第二种情况是，如果选出来的第一个驱动表是表t2的话，则需要评估另外两个条件的过滤效果。总之，整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，因为这样我们的</li>
</ol>
<p>驱动表就会越小。评论区留言点赞板：</p>
<p>select * from t1 join t2 on(t1.a&#x3D;t2.a) join t3 on (t2.b&#x3D;t3.b) where t1.c&gt;&#x3D;X and t2.c&gt;&#x3D;Y and t3.c&gt;&#x3D;Z;</p>
<p>@库淘淘 做了实验验证；</p>
<p>@poppy同学做了很不错的分析；</p>
<p>@dzkk 同学在评论中介绍了MariaDB支持的hash join，大家可以了解一下；</p>
<p>@老杨同志提了一个好问题，如果语句使用了索引a，结果还要对a排序，就不用MRR优化</p>
<p>了，否则回表完还要增加额外的排序过程，得不偿失。尘封   1</p>
<p>新年快乐</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>新年快乐 </p>
<p>2019-02-04</p>
<p>亮   1</p>
<p>老师过年好呀，祝您猪年大吉，财源广进；老师咱们这个课结束后，再开一期好不好啊，没学</p>
<p>够啊，这是我的新年愿望哦</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>新年快乐，共同进步 </p>
<p>2019-02-04</p>
<p>辣椒   0</p>
<p>老师，不同线程可以使用同名的临时表，这个没有问题。但是如果在程序中，用的是连接池中</p>
<p>的连接来操作的，而这些连接不会释放，和数据库保持长连接。这样使用临时表会有问题吗?。2019-02-07</p>
<p> 作者回复</p>
<p>会，“临时表会自动回收”这个功能，主要用于“应用程序异常断开、MySQL异常重启”后，不需</p>
<p>精选留言</p>
<p>要主动去删除表。而平时正常使用的时候，用完删除，还是应该有的好习惯。 </p>
<p>好问题，新年快乐~</p>
<p>2019-02-07</p>
<p>老杨同志   0</p>
<p>新年快乐，老师好勤奋！</p>
<p>有个问题，insert into select语句好像会给select的表加锁，如果没有索引，就锁全表，是不是</p>
<p>这样？什么时候可以大胆的用这类语句？2019-02-04</p>
<p> 作者回复</p>
<p>新年好！</p>
<p>“insert into select语句好像会给select的表加锁，如果没有索引，就锁全表”，是的。这类最好不要很大胆 ，如果不是业务急需的，从源表导出来再写到目标表也是好的。后面第40篇会说到哈。2019-02-05</p>
<p>慕塔   0</p>
<p>打卡 新年快乐   </p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>新年快乐、共同进步 </p>
<p>好勤奋呀 </p>
<p>2019-02-05</p>
<p>cheriston   0</p>
<p>老师辛苦了，大年三十还给我们分享技术，老师新年好 .</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>同祝新年好，共同进步 </p>
<p>2019-02-05</p>
<p>长杰   0</p>
<p>老师，新年快乐，万事如意！</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>新春快乐～</p>
<p>2019-02-05</p>
<p>杰   0</p>
<p>丁大大新春快乐</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>新年快乐 工作顺利~</p>
<p>2019-02-04</p>
<p>某、人   0</p>
<p>老师，新年快乐。由于自身原因，错过几期精彩的内容，年后上班以后在好好补补。2019-02-04</p>
<p> 作者回复</p>
<p>春节快乐 新年身体健康哈</p>
<p>2019-02-04</p>
<p>poppy   0</p>
<p>老师，新年快乐。关于思考题，alter table temp_t rename to temp_t2,我的理解是mysql直接修改的是table_def_ke</p>
<p>y，而对于rename table temp_t2 to temp_t3,mysql直接去mysql的data目录下该数据库的目录(例</p>
<p>如老师实验用的应该是test数据库，所以对应的是test目录)下寻找名为temp_t2.frm的文件去修</p>
<p>改名称，所以就出现了”Can’t find file ‘.&#x2F;test&#x2F;temp_t2.frm’(errno: 2 - No such file or directory)</p>
<p>2019-02-04</p>
<p> 作者回复</p>
<p>春节快乐</p>
<p> </p>
<p>2019-02-04</p>
<p>亮   0</p>
<p>老师您好，在25课里面的置顶留言“6.表上无主键的情况(主库利用索引更改数据,备库回放只能</p>
<p>用全表扫描,这种情况可以调整slave_rows_search_algorithms参数适当优化下)”</p>
<p>为啥会存在无主键的表呢，就算dba没创建主键，Innodb可以用rowid给自动建一个虚拟主键呀</p>
<p>，这样不就是所有的表都有主键了吗？2019-02-04</p>
<p> 作者回复</p>
<p>用户没有显示指定主键的话，InnoDB引擎会自己创建一个隐藏的主键，但是这个主键对Server</p>
<p>层是透明的，优化器用不上。新年快乐~</p>
<p>2019-02-04</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么我只改一行的语句锁这么多</title>
    <url>/posts/e1607c99.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>21 | 为什么我只改一行的语句，锁这么多？2018-12-31 林晓斌</p>
<p>在上一篇文章中，我和你介绍了间隙锁和next-key lock的概念，但是并没有说明加锁规则。间隙</p>
<p>锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问</p>
<p>题上犯错。所以今天，我们就先从这个加锁规则开始吧。首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是</p>
<p>想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷</p>
<p>了代码临时总结出来的。所以，这个规则有以下两条前提说明：</p>
<ol>
<li>MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即</li>
</ol>
<p>5.x系列&lt;&#x3D;5.7.24，8.0系列 &lt;&#x3D;8.0.13。2. 如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习</p>
<p>本专栏的所有同学都能受益。因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认</p>
<p>是可重复读隔离级别。我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。1. 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。2. 原则2：查找过程中访问到的对象才会加锁。3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key</p>
<p>lock退化为间隙锁。5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能</p>
<p>会“毁三观”，也建议你读完文章后亲手实践一下。案例一：等值查询间隙锁</p>
<p>第一个例子是关于等值条件操作间隙：</p>
<p>图1 等值查询的间隙锁</p>
<p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;d  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;c  ̀(̀ c )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(0,0,0),(5,5,5),</p>
<p>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p>
<ol>
<li><p>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p>
</li>
<li><p>同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间</p>
</li>
</ol>
<p>隙锁，因此最终加锁的范围是(5,10)。所以，session B要往这个间隙里面插入id&#x3D;8的记录会被锁住，但是session C修改id&#x3D;10这行是可</p>
<p>以的。案例二：非唯一索引等值锁</p>
<p>第二个例子是关于覆盖索引上的锁：</p>
<p>图2 只加在非唯一索引上的锁</p>
<p>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。这里session A要给索引c上c&#x3D;5的这一行加上读锁。1. 根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。2. 要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到</p>
<p>c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。3. 但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此</p>
<p>退化成间隙锁(5,10)。4. 根据原则2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索</p>
<p>引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。需要注意，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样</p>
<p>了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的</p>
<p>行加上行锁。这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode</p>
<p>来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不</p>
<p>存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。你可以自己验证一下效果。案例三：主键索引范围锁</p>
<p>第三个例子是关于范围查询的。举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相</p>
<p>同吗？你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让</p>
<p>session A执行第二个查询语句，来看看加锁效果。图3 主键索引上范围查询的锁</p>
<p>现在我们就用前面提到的加锁规则，来分析一下session A 会加什么锁呢？mysql&gt; select * from t where id&#x3D;10 for update;</p>
<p>mysql&gt; select * from t where id&gt;&#x3D;10 and id&lt;11 for update;</p>
<ol>
<li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1，</li>
</ol>
<p>主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。2. 范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]。所以，session A这时候锁的范围就是主键索引上，行锁id&#x3D;10和next-key lock(10,15]。这</p>
<p>样，session B和session C的结果你就能理解了。这里你需要注意一点，首次session A定位查找id&#x3D;10的行的时候，是当做等值查询来判断的，而</p>
<p>向右扫描到id&#x3D;15的时候，用的是范围查询判断。案例四：非唯一索引范围锁</p>
<p>接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。图4 非唯一索引范围锁</p>
<p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c&#x3D;10定位记录的时</p>
<p>候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是</p>
<p>说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key</p>
<p>lock。所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后</p>
<p>找了。案例五：唯一索引范围锁bug</p>
<p>前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁</p>
<p>规则中bug的案例。图5 唯一索引范围锁的bug</p>
<p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并</p>
<p>且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个</p>
<p>范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。所以你看到了，session B要更新id&#x3D;20这一行，是会被锁住的。同样地，session C要插入id&#x3D;16</p>
<p>的一行，也会被锁住。照理说，这里锁住id&#x3D;20这一行的行为，其实是没有必要的。因为扫描到id&#x3D;15，就可以确定不用</p>
<p>往后再找了。但实现上还是这么做了，因此我认为这是个bug。我也曾找社区的专家讨论过，官方bug系统上也有提到，但是并未被verified。所以，认为这是</p>
<p>bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。案例六：非唯一索引上存在”等值”的例子</p>
<p>接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表t插入一条新记录。新插入的这一行c&#x3D;10，也就是说现在表里有两个c&#x3D;10的行。那么，这时候索引c上的间隙是什么</p>
<p>状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。mysql&gt; insert into t values(30,10,30);</p>
<p>图6 非唯一索引等值的例子</p>
<p>可以看到，虽然有两个c&#x3D;10，但是它们的主键值id是不同的（分别是10和30），因此这两个</p>
<p>c&#x3D;10的记录之间，也是有间隙的。图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c&#x3D;10,id&#x3D;30)这样的</p>
<p>形式，来表示索引上的一行。现在，我们来看一下案例六。这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select … for update 是类</p>
<p>似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。图7 delete 示例</p>
<p>这时，session A在遍历的时候，先访问第一个c&#x3D;10的记录。同样地，根据原则1，这里加的是</p>
<p>(c&#x3D;5,id&#x3D;5)到(c&#x3D;10,id&#x3D;10)这个next-key lock。然后，session A向右查找，直到碰到(c&#x3D;15,id&#x3D;15)这一行，循环才结束。根据优化2，这是一个</p>
<p>等值查询，向右查找到了不满足条件的行，所以会退化成(c&#x3D;10,id&#x3D;10) 到 (c&#x3D;15,id&#x3D;15)的间隙</p>
<p>锁。也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。图8 delete加锁效果示例</p>
<p>这个蓝色区域左右两边都是虚线，表示开区间，即(c&#x3D;5,id&#x3D;5)和(c&#x3D;15,id&#x3D;15)这两行上都没有锁。案例七：limit 语句加锁</p>
<p>例子6也有一个对照案例，场景如下所示：</p>
<p>图9 limit 语句加锁</p>
<p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c&#x3D;10的记录其实只有两条，因此</p>
<p>加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert</p>
<p>语句执行通过了，跟案例六的结果不同。这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c&#x3D;10, id&#x3D;30)这一行之</p>
<p>后，满足条件的语句已经有两条，循环就结束了。因此，索引c上的加锁范围就变成了从（c&#x3D;5,id&#x3D;5)到（c&#x3D;10,id&#x3D;30)这个前开后闭区间，如下图所</p>
<p>示：</p>
<p>图10 带limit 2的加锁效果</p>
<p>可以看到，(c&#x3D;10,id&#x3D;30）之后的这个间隙并没有在加锁范围里，因此insert语句插入c&#x3D;12是可以</p>
<p>执行成功的。这个例子对我们实践的指导意义就是，在删除数据的时候尽量加limit。这样不仅可以控制删除</p>
<p>数据的条数，让操作更安全，还可以减小加锁的范围。案例八：一个死锁的例子</p>
<p>前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方</p>
<p>便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：</p>
<p>图11 案例八的操作序列</p>
<p>现在，我们按时间顺序来分析一下为什么是这样的结果。1. session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key</p>
<p>lock(5,10] 和间隙锁(10,15)；</p>
<ol start="2">
<li><p>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</p>
</li>
<li><p>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死</p>
</li>
</ol>
<p>锁，InnoDB让session B回滚。你可能会问，session B的next-key lock不是还没申请成功吗？其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间</p>
<p>隙锁，加锁成功；然后加c&#x3D;10的行锁，这时候才被锁住的。也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时</p>
<p>候，是要分成间隙锁和行锁两段来执行的。小结</p>
<p>这里我再次说明一下，我们上面的所有案例都是在可重复读隔离级别(repeatable-read)下验证</p>
<p>的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的</p>
<p>时候才释放的。在最后的案例中，你可以清楚地知道next-key lock实际上是由间隙锁加行锁实现的。如果切换到</p>
<p>读提交隔离级别(read-committed)的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下</p>
<p>行锁的部分。其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成</p>
<p>后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提</p>
<p>交隔离级别的原因。不过，我希望你学过今天的课程以后，可以对next-key lock的概念有更清晰的认识，并且会用加</p>
<p>锁规则去判断语句的加锁范围。在业务需要使用可重复读隔离级别的时候，能够更细致地设计操作数据库的语句，解决幻读问题</p>
<p>的同时，最大限度地提升系统并行处理事务的能力。经过这篇文章的介绍，你再看一下上一篇文章最后的思考题，再来尝试分析一次。我把题目重新描述和简化一下：还是我们在文章开头初始化的表t，里面有6条记录，图12的语句</p>
<p>序列中，为什么session B的insert操作，会被锁住呢？图12 锁分析思考题</p>
<p>另外，如果你有兴趣多做一些实验的话，可以设计好语句序列，在执行之前先自己分析一下，然</p>
<p>后实际地验证结果是否跟你的分析一致。对于那些你自己无法解释的结果，可以发到评论区里，后面我争取挑一些有趣的案例在文章中分</p>
<p>析。你可以把你关于思考题的分析写在留言区，也可以分享你自己设计的锁验证方案，我会在下一篇</p>
<p>文章的末尾选取有趣的评论跟大家分享。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友</p>
<p>一起阅读。上期问题时间</p>
<p>上期的问题，我在本期继续作为了课后思考题，所以会在下篇文章再一起公布“答案”。这里，我展开回答一下评论区几位同学的问题。@令狐少侠 说，以前一直认为间隙锁只在二级索引上有。现在你知道了，有间隙的地方就可</p>
<p>能有间隙锁。@浪里白条 同学问，如果是varchar类型，加锁规则是什么样的。回答：实际上在判断间隙的时候，varchar和int是一样的，排好序以后，相邻两个值之间就有</p>
<p>间隙。有几位同学提到说，上一篇文章自己验证的结果跟案例一不同，就是在session A执行完这两</p>
<p>个语句：</p>
<p>以后，session B 的update 和session C的insert 都会被堵住。这是不是跟文章的结论矛盾？其实不是的，这个例子用的是反证假设，就是假设不堵住，会出现问题；然后，推导出session</p>
<p>A需要锁整个表所有的行和所有间隙。评论区留言点赞板：</p>
<p>begin;</p>
<p>select * from t where d&#x3D;5 for update; &#x2F;<em>Q1</em>&#x2F;</p>
<p>@ 某、人 、@郭江伟 两位同学尝试分析了上期问题，并给了有启发性的解答。堕落天使   1</p>
<p>老师，您好。假期的没跟上，今天补到了这节课，看了之后有几点不是太明白。望能解答一下</p>
<p>。1. 索引c上的锁算不算是行锁。假如索引c上的next-key lock为(0,5] (5,10]，那么5算不算是c上</p>
<p>的行锁？2. 在案例六中，执行 “delete from t where c&#x3D;10;” 语句，索引c上的next-key lock是(5,10],(10,10]</p>
<p>,(10,15)。那么主键索引上的锁是什么呢？是只有行锁，锁住的是 (10,10,10) 和 (30,10,30) 两行</p>
<p>吗？3. 也是在案例六中，session A不变，在session B中执行 “update t_20 set d&#x3D;50 where c&#x3D;5;”、“</p>
<p>update t_20 set d&#x3D;50 where c&#x3D;15;”、“insert into t_20 values(40,15,40);”均执行成功，但执行“ins</p>
<p>ert into t_20 values(50,5,50);” 时，却被阻塞。为什么呢？具体执行语句如下</p>
<p>session A</p>
<p>mysql&gt; begin;</p>
<p>mysql&gt; explain delete from t_20 where c&#x3D;10;</p>
<p>id select_type table partitions type possible_keys key key_len ref rows filtered Extra</p>
<p>1 DELETE t_20 range c c 5 const 2 100 Using where</p>
<p>mysql&gt; delete from t_20 where c&#x3D;10;</p>
<p>session B</p>
<p>mysql&gt; update t_20 set d&#x3D;50 where c&#x3D;5;</p>
<p>Query OK, 1 row affected (0.01 sec)</p>
<p>Rows matched: 1 Changed: 1 Warnings: 0</p>
<p>mysql&gt; update t_20 set d&#x3D;50 where c&#x3D;15;</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>Rows matched: 1 Changed: 1 Warnings: 0</p>
<p>mysql&gt; insert into t_20 values(40,15,40);</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; explain insert into t_20 values(50,5,50);</p>
<p>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——-+</p>
<p>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | </p>
<p>Extra |</p>
<p>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——-+</p>
<p>| 1 | INSERT | t_20 | NULL | ALL | c | NULL | NULL | NULL | NULL | NULL | NULL |</p>
<p>+—-+————-+——-+————+——+—————+——+———+——+——+———-+——-+</p>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; insert into t_20 values(50,5,50);</p>
<p>（block）</p>
<p>精选留言</p>
<p>我使用的mysql版本是：5.7.23-0ubuntu0.16.04.1</p>
<p>show variables的结果太多，我截取了一部分，或许对您分析有帮助：</p>
<p>innodb_version 5.7.23</p>
<p>protocol_version 10</p>
<p>slave_type_conversions </p>
<p>tls_version TLSv1,TLSv1.1</p>
<p>version 5.7.23-0ubuntu0.16.04.1</p>
<p>version_comment (Ubuntu)</p>
<p>version_compile_machine x86_64</p>
<p>version_compile_os Linux</p>
<p>2019-01-03</p>
<p> 作者回复</p>
<ol>
<li><p>Next-key lock 就是间隙锁 行锁，所以包含&#x3D;5这一行</p>
</li>
<li><p>对</p>
</li>
<li><p>(c&#x3D;5,id&#x3D;50)是在这个gap里哦，你试试插入(1,5,50)对比一下。好问题</p>
</li>
</ol>
<p>2019-01-03</p>
<p>张三   25</p>
<p>Happy New Year !这个专栏绝对是极客时间最好我买过最值的专栏。2018-12-31</p>
<p>约书亚   12</p>
<p>早晨睡不着打开极客时间一看，竟然更新了。今天是周日而且在假期中哎…</p>
<p>2018-12-31</p>
<p> 作者回复</p>
<p>风雨无阻 节假日不休，包括元旦和春节 </p>
<p>2018-12-31</p>
<p>HuaMax   4</p>
<p>首先老师新年快乐，学习专栏受益良多！</p>
<p>上期问过老师的问题已了解答案，锁是加在索引上的。再尝试回答问题。c上是普通索引，根据</p>
<p>原则2，访问到的都要加锁，在查询c&gt;&#x3D;15这个条件时，在查找到15后加锁（10，15］，继续往</p>
<p>右查找，按理说不会锁住6这个索引值，但查询语句中加了order by c desc，我猜想会优化为使</p>
<p>用c&lt;&#x3D;20这条语句，查找到20后往左查找，这样会访问到15左边的值10，从而加锁（5，10］</p>
<p>，不知我理解对否？2019-01-01</p>
<p> 作者回复</p>
<p>新年好</p>
<p>对的  </p>
<p>2019-01-01</p>
<p>郭江伟   4</p>
<p>郭江伟   4</p>
<p>老师这次的留下的问题，语句跟上次不一样，上期问题语句是select id from t where c&gt;&#x3D;15 and</p>
<p>c&lt;&#x3D;20 order by c desc for update;；这次缺少了 order by c desc ，不加desc的话insert into t val</p>
<p>ues(6,6,6);不会被堵塞；</p>
<p>根据优化3：索引上的等值查询，在向右遍历时且最后一个值不满足等值条件的时候next-key lo</p>
<p>ck退化为间隙锁；</p>
<p>问题中的sql语句加了desc ，是向左扫描，该优化用不上，所以下限10是闭区间，为了防止c为</p>
<p>10的行加入，需要锁定到索引c键（5,5）</p>
<p>此例中insert into t values(6,5,6) 会堵塞，insert into t values(4,5,6) 不会堵塞，</p>
<p>2018-12-31</p>
<p> 作者回复</p>
<p>嗯你说的对</p>
<p>不过是我少打一个词了，加上去了，要desc哦</p>
<p>重新分析下 </p>
<p>2018-12-31</p>
<p>undifined   3</p>
<p>遇到一个有趣的问题，在老师的解答下终于弄明白了：</p>
<p>CREATE TABLE z (</p>
<p>id INT PRIMARY KEY AUTO_INCREMENT,</p>
<p>b INT,</p>
<p>KEY b(b)</p>
<p>)</p>
<p>ENGINE &#x3D; InnoDB</p>
<p>DEFAULT CHARSET &#x3D; utf8;</p>
<p>INSERT INTO z (id, b)</p>
<p>VALUES (1, 2),</p>
<p>(3, 4),</p>
<p>(5, 6),</p>
<p>(7, 8),</p>
<p>(9, 10);</p>
<p>session A</p>
<p>BEGIN;</p>
<p>SELECT *</p>
<p>FROM z</p>
<p>WHERE b &#x3D; 6 FOR UPDATE;</p>
<p>session B </p>
<p>INSERT INTO z VALUES (0, 4);</p>
<p>这里为什么会被锁住</p>
<p>答案比较长，写在我自己的笔记里了，地址是 <a href="https://helloworlde.github.io/blog/blog/MySQL/M">https://helloworlde.github.io/blog/blog/MySQL/M</a></p>
<p>ySQL-%E4%B8%AD%E5%85%B3%E4%BA%8Egap-lock-next-key-lock-%E7%9A%84%E4%B</p>
<p>8%80%E4%B8%AA%E9%97%AE%E9%A2%98.html</p>
<p>大家可以看看</p>
<p>2019-01-07</p>
<p> 作者回复</p>
<p>好问题，质量很高的笔记</p>
<p>2019-01-10</p>
<p>乾坤   3</p>
<p>您好，关于”优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，ne</p>
<p>xt-key lock 退化为间隙锁。”，我觉得改为”从第一个满足等值条件的索引记录开始向右遍历到</p>
<p>第一个不满足等值条件记录，并将第一个不满足等值条件记录上的next-key lock 退化为间隙锁”</p>
<p>更明确些</p>
<p>2019-01-01</p>
<p> 作者回复</p>
<p>感觉没大差别，嗯嗯，理解就好 </p>
<p>2019-01-02</p>
<p>Geek_9ca34e   2</p>
<p>老师，你好：</p>
<p>我练习实例的时候发现一个问题：如 案例五：唯一索引范围锁 bug</p>
<p>begin;</p>
<p>select * from t where id&gt;10 and id&lt;&#x3D;15 for update;</p>
<p>1、执行如上语句加锁范围(10,15]和(15,20]；</p>
<p>2、因为10未加锁，所以我单独再开一个连接，执行delete from t where id&#x3D;10;不会锁等待，能</p>
<p>正常删除；</p>
<p>3、但是我再执行insert into t values(10,10,10); 语句会等待，无法正常执行；</p>
<p>4、经过分析我发现第一个连接执行的语句的加锁范围已经变成(5,15]和(15,20]，代表锁蔓延了</p>
<p>；这是什么原因呢？2019-01-09</p>
<p> 作者回复</p>
<p>好问题，我会加到答疑文章中，</p>
<p>Gap是一个动态的概念</p>
<p>2019-01-09</p>
<p>往事随风，顺其自然   2</p>
<p>这和分两步有什么关系？(5,10]已经是被锁住，分不分两步来加锁，这个间隙和行锁都被锁住了，session b应该是拿不</p>
<p>到锁才对。2019-01-01</p>
<p>happy涛   1</p>
<p>老师：同上一个问题。 还是案例2. select id from t where c&#x3D;6 for update;</p>
<p>ID为[0,9)都不可以添加，包括-1都可以。为啥会锁这么多。而c锁的是[5,10),大于等于5，小于1</p>
<p>0</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>select id from t where c&#x3D;6 for update;</p>
<p>这个在c上的锁是（5，10）这个间隙</p>
<p>2019-01-23</p>
<p>往事随风，顺其自然   1</p>
<p>session A</p>
<p>mysql&gt; select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode;</p>
<p>+—-+——+——+</p>
<p>| id | c | d |</p>
<p>+—-+——+——+</p>
<p>| 20 | 20 | 20 |</p>
<p>| 15 | 15 | 15 |</p>
<p>+—-+——+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>session b</p>
<p>mysql&gt; insert into t values(6,6,6);</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>可以插入成功，没有被锁住</p>
<p>2019-01-01</p>
<p> 作者回复</p>
<p>Explain结果发一下，还有show variables 结果也发下</p>
<p>2019-01-02</p>
<p>是我的海   0</p>
<p>全是干货赞赞赞，以后出去面试再也不怕面试官装X问锁的问题了</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>一定要低调哈 </p>
<p>如果面试的时候能够让大家回答更有底气，那就太好啦 </p>
<p>2019-01-31</p>
<p>时隐时现   0</p>
<p>不好意思，这次又来晚了，看这种连载技术文章，和看小说一样，养肥了集中看~~</p>
<p>这次的问题如下，希望丁老师有空解答一下。版本：mysql 5.6.39</p>
<p>CREATE TABLE <code>t</code> (</p>
<p><code>a</code> int(11) NOT NULL,</p>
<p><code>b</code> int(11) DEFAULT NULL</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert into t values(1,1),(2,2),(3,3),(4,4),(5,5);</p>
<p>采用READ-COMMITTED隔离级别</p>
<p>案例1、</p>
<p>session A：</p>
<p>begin;</p>
<p>update t set a&#x3D;6 where b&#x3D;1;</p>
<p>session B：</p>
<p>begin;</p>
<p>update t set a&#x3D;7 where b&#x3D;2;</p>
<p>A和B均能执行成功</p>
<p>问题1：官档上说对于RC且全表扫描的update，先逐行添加行锁然后释放掉不符合where条件</p>
<p>的，那么session A成功对(1,1)加锁，理论上session B在扫描(1,1)并尝试加锁时会被阻塞，为</p>
<p>何还能执行成功？官档链接：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isol">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isol</a></p>
<p>ation-levels.html</p>
<p>案例2：</p>
<p>session A：</p>
<p>begin;</p>
<p>update t set a&#x3D;6 where b&#x3D;1;</p>
<p>session B：</p>
<p>begin;</p>
<p>delete from t where b&#x3D;2; – 被阻塞</p>
<p>问题2：为何案例1 中的session B不会被阻塞，而案例2的却被session A的行数阻塞，update和</p>
<p>delete都是全部扫描，难道加锁机制不一样？2019-01-30</p>
<p> 作者回复</p>
<p>好问题，在read-commited隔离级别下，update语句</p>
<p>有一个“semi-consistent” read优化，</p>
<p>意思是，如果update语句碰到一个已经被锁了的行，会读入最新的版本，然后判断一下是不是</p>
<p>满足查询条件，</p>
<p>a)如果不满足，就直接跳过；</p>
<p>b) 如果满足，才进入锁等待</p>
<p>你的第二个问题：这个策略，只对update有效，delete无效</p>
<p>新春快乐~</p>
<p>2019-02-04</p>
<p>Leon    0</p>
<p>老师，案例八session B的操作语句update t set d &#x3D; d + 1 where c &#x3D;10; 由于c是非唯一键索引，</p>
<p>锁（5，10」可以理解</p>
<p>，为什么不锁(10,15} 呢，不是应该继续向后扫描直到第一个不满足条件的值为止吗</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<p>好问题，新年快乐</p>
<p>会锁的，只是因为在(5,10]就被锁住了，所以后面的锁加不上去了 </p>
<p>2019-02-01</p>
<p>happy涛   0</p>
<p>老师：</p>
<p>环境同上. QQ466096028</p>
<p>案二：案三也不对。案例五：b事物也可以执行成功， 16，16，16我也可以写入 ，id（10,15）不可以。案例六：我没有添加C10,ID30的数。还是用0，5，10，15，20，25这几条数据， 案例六中的</p>
<p>代码执行结果是ID（10，15），c(5,15) .. </p>
<p>头好疼，感觉理不清，规则太乱了。2019-01-23</p>
<p> 作者回复</p>
<p>啊 已经是我简化过的规则了。。需要再理解一下。。你用session A、sessionB这种模式列一下复现步骤，哪个不清楚的，我们一个个来看吧</p>
<p>2019-01-23</p>
<p>happy涛   0</p>
<p>老师：</p>
<p>案例二：非唯一索引等值锁，这个文章中，事物A加读取之后， 按您的文章走，最后结果加的</p>
<p>是（5，10）间隙锁， 但我这里为什么插入，c从[0,9)都不能插入。mysql版本是8.0.12,隔离级别是RR，表用的是您的例子，数据也是。2019-01-23</p>
<p> 作者回复</p>
<p>不是哦</p>
<p>案例二的语句是 where c&#x3D;5 lock in share mode, 这个在c上的加锁范围是(5,10)</p>
<p>2019-01-23</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>思考题：</p>
<p>order by desc优化器会向左遍历</p>
<p>1、先判断条件c&lt;&#x3D;20，普通索引等值c&#x3D;20，所以next-key-lock:（25，20]</p>
<p>2、20到15，所以next-key-lock:（20，15]</p>
<p>3、判断c&gt;&#x3D;15，普通索引c&#x3D;15，继续向左遍历到c&#x3D;5不符合条件，并且优化2等值第一个不符</p>
<p>合条件的数据降为间隙锁(5,15)</p>
<p>所以锁的范围是(5,15)+[15,20)+[20,25)</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>3、判断c&gt;&#x3D;15，普通索引c&#x3D;15，继续向左遍历到c&#x3D;5不符合条件，并且优化2等值第一个不符</p>
<p>合条件的数据降为间隙锁(5,15)</p>
<p>所以锁的范围是(5,15)+[15,20)+[20,25)</p>
<p>这个不太对哈（或者说跟我文章里面说的规则不匹配）。c&gt;&#x3D;15这个条件，只会向左匹配到c&#x3D;10这个记录，</p>
<p>只是因为next-key lock是前开后闭区间，所以就是(5,10].</p>
<p>结论的范围也确实是(5,15)+[15,20)+[20,25)  </p>
<p>2019-01-17</p>
<p>J!   0</p>
<p>select max(id) from tb1 和 select id from tb1 order by id desc limit 1; id 为主键，这个两个的加</p>
<p>索过程都是一样的吗</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>都不加锁。。如果你说的是后面加 for update, 加索范围一样的</p>
<p>2019-01-16</p>
<p>任洋   0</p>
<p>老师你好，最近在线上遇到一个问题如下：执行一个简单的update语句更新数据库，where后</p>
<p>面的字段没有索引，这个字段的数据库中值可能有重复，在并发的情况下，会偶发出现数据库</p>
<p>死锁的情况。后面通过，查询出主键，再通过主键进行更新，解决了这个问题，但不明白为什</p>
<p>么会出现死锁的情况，能麻发解释下吗？2019-01-15</p>
<p> 作者回复</p>
<p>update 没索引就是锁住主键索引上所有的行和间隙</p>
<p>锁的内容太多了， 这样确实容易出现死锁哦</p>
<p>2019-01-15</p>
<p>陈   0</p>
<p>老师在案列一中update t set d&#x3D;d+1 where id&#x3D;7 中id是主键也是唯一索引，按优化1应该退化成</p>
<p>行锁才对，为什么insert into t values(8,8,8)会被锁住，我是那儿理解错了?</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>这一行存在的时候是行锁，这一行不存在，那就是间隙锁啦。insert into t values(8,8,8)是被主键上(5,10)的间隙锁锁住的</p>
<p>2019-01-11</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么我只查一行的语句也执行这么慢</title>
    <url>/posts/f5203c05.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>19 | 为什么我只查一行的语句，也执行这么慢？2018-12-26 林晓斌</p>
<p>一般情况下，如果我跟你说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大</p>
<p>量的数据。但有些情况下，“查一行”，也会执行得特别慢。今天，我就跟你聊聊这个有趣的话</p>
<p>题，看看什么情况下，会出现这个现象。需要说明的是，如果MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用率很高或</p>
<p>ioutil（IO利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于我们今天的讨论范</p>
<p>围。为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，</p>
<p>并且我在里面插入了10万行记录。接下来，我会用几个不同的场景来举例，有些是前面的文章中我们已经介绍过的知识点，你看看</p>
<p>能不能一眼看穿，来检验一下吧。第一类：查询长时间不返回</p>
<p>如图1所示，在表t执行下面的SQL语句：</p>
<p>查询结果长时间不返回。图1 查询长时间不返回</p>
<p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一</p>
<p>下show processlist命令，看看当前语句处于什么状态。mysql&gt; CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;100000)do</p>
<pre><code>insert into t values(i,i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。等MDL锁</p>
<p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。图2 Waiting for table metadata lock状态示意图</p>
<p>出现这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句</p>
<p>堵住了。在第6篇文章《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》中，我给你介绍过一种复现</p>
<p>方法。但需要说明的是，那个复现过程是基于MySQL 5.6版本的。而MySQL 5.7版本修改了MDL</p>
<p>的加锁策略，所以就不能复现这个场景了。不过，在MySQL 5.7版本下复现这个场景，也很容易。如图3所示，我给出了简单的复现步骤。图3 MySQL 5.7中Waiting for table metadata lock的复现步骤</p>
<p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所</p>
<p>以，session B进入等待状态。这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来</p>
<p>很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需</p>
<p>要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p>
<p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把</p>
<p>这个连接用kill 命令断开即可。图4 查获加表锁的线程id</p>
<p>等flush</p>
<p>接下来，我给你举另外一种查询被堵住的情况。我在表t上，执行下面的SQL语句：</p>
<p>这里，我先卖个关子。你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什</p>
<p>么原因。图5 Waiting for table flush状态示意图</p>
<p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用</p>
<p>法，一般有以下两个：</p>
<p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关</p>
<p>闭MySQL里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住</p>
<p>mysql&gt; select * from information_schema.processlist where id&#x3D;1;</p>
<p>flush tables t with read lock;</p>
<p>flush tables with read lock;</p>
<p>了，然后它又堵住了我们的select语句。现在，我们一起来复现一下这种情况，复现步骤如图6所示：</p>
<p>图6 Waiting for table flush的复现步骤</p>
<p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表</p>
<p>t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等</p>
<p>session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show</p>
<p>processlist的结果，肯定就知道应该怎么做了。图 7 Waiting for table flush的show processlist 结果</p>
<p>等行锁</p>
<p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。上面这条语句的用法你也很熟悉了，我们在第8篇《事务到底是隔离的还是不隔离的？》文章介</p>
<p>绍当前读时提到过。由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我</p>
<p>们的select语句就会被堵住。复现步骤和现场如下：</p>
<p>mysql&gt; select * from t where id&#x3D;1 lock in share mode; </p>
<p>图 8 行锁复现</p>
<p>图 9 行锁show processlist 现场</p>
<p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可</p>
<p>以通过sys.innodb_lock_waits 表查到。查询方法是：</p>
<p>mysql&gt; select * from t sys.innodb_lock_waits where locked_table&#x3D; ‘̀test’.’t’̀ \G</p>
<p>图10 通过sys.innodb_lock_waits 查行锁</p>
<p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是</p>
<p>KILL QUERY 4或KILL 4。不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这</p>
<p>个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，</p>
<p>现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的</p>
<p>时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。第二类：查询慢</p>
<p>经过了重重封“锁”，我们再来看看一些查询慢的例子。先来看一条你一定知道原因的SQL语句：</p>
<p>mysql&gt; select * from t where c&#x3D;50000 limit 1;</p>
<p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接</p>
<p>后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。图11 全表扫描5万行的slow log</p>
<p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上</p>
<p>一般都配置超过1秒才算慢查询。但你要记住：坏查询不一定是慢查询。我们这个例子里面只</p>
<p>有10万行记录，数据量大起来的话，执行时间就线性涨上去了。扫描行数多，所以执行慢，这个很好理解。但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。如图12所示，是这个例子的slow log。可以看到，执行的语句是</p>
<p>虽然扫描行数是1，但执行时间却长达800毫秒。图12 扫描一行却执行得很慢</p>
<p>是不是有点奇怪呢，这些时间都花在哪里了？如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1</p>
<p>lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。图 13 加上lock in share mode的slow log</p>
<p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个</p>
<p>mysql&gt; select * from t where id&#x3D;1；</p>
<p>语句的执行输出结果。图14 两个语句的输出结果</p>
<p>第一个语句的查询结果里c&#x3D;1，带lock in share mode的语句返回的是c&#x3D;1000001。看到这里应该</p>
<p>有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，</p>
<p>再分析原因。图15 复现步骤</p>
<p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后</p>
<p>session B才开始执行update 语句。session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答</p>
<p>案。图16 id&#x3D;1的数据状态</p>
<p>session B更新完100万次，生成了100万个回滚日志(undo log)。带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很</p>
<p>快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行</p>
<p>undo log，执行了100万次以后，才将1这个结果返回。注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方</p>
<p>便你看图。小结</p>
<p>今天我给你举了在一个简单的表上，执行“查一行”，可能会出现的被锁住和执行慢的例子。这其</p>
<p>中涉及到了表锁、行锁和一致性读的概念。在实际使用中，碰到的场景会更复杂。但大同小异，你可以按照我在文章中介绍的定位方法，来</p>
<p>定位并解决问题。最后，我给你留一个问题吧。我们在举例加锁读的时候，用的是这个语句，select * from t where id&#x3D;1 lock in share mode。由</p>
<p>于id上有索引，所以可以直接定位到id&#x3D;1这一行，因此读锁也是只加在了这一行上。但如果是下面的SQL语句，</p>
<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？你可以把你的观点和验证方法写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢</p>
<p>你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>在上一篇文章最后，我留给你的问题是，希望你可以分享一下之前碰到过的、与文章中类似的场</p>
<p>景。@封建的风 提到一个有趣的场景，值得一说。我把他的问题重写一下，表结构如下：</p>
<p>假设现在表里面，有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行</p>
<p>语句是这么写的:</p>
<p>这时候，MySQL会怎么执行呢？最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没</p>
<p>有这么做。那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上</p>
<p>并没有这个值，也很快就能返回空结果。begin;</p>
<p>select * from t where c&#x3D;5 for update;</p>
<p>commit;</p>
<p>mysql&gt; CREATE TABLE t̀able_a  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;b  ̀varchar(10) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;b  ̀(̀ b )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>mysql&gt; select * from table_a where b&#x3D;’1234567890abcd’;</p>
<p>但实际上，MySQL也不是这么做的。这条SQL语句的执行很慢，流程是这样的：</p>
<ol>
<li>在传给引擎执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截</li>
</ol>
<p>了前10个字节，就是’1234567890’进去做匹配；</p>
<ol start="2">
<li><p>这样满足条件的数据有10万行；</p>
</li>
<li><p>因为是select *， 所以要做10万次回表；</p>
</li>
<li><p>但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;</p>
</li>
<li><p>返回结果是空。这个例子，是我们文章内容的一个很好的补充。虽然执行过程中可能经过函数操作，但是最终在</p>
</li>
</ol>
<p>拿到结果后，server层还是要做一轮判断的。评论区留言点赞板：</p>
<p>@赖阿甘 提到了等号顺序问题，时间上MySQL优化器执行过程中，where 条件部分， a&#x3D;b和</p>
<p>b&#x3D;a的写法是一样的。@沙漠里的骆驼 提到了一个常见的问题。相同的模板语句，但是匹配行数不同，语句执行时</p>
<p>间相差很大。这种情况，在语句里面有order by这样的操作时会更明显。@Justin 回答了我们正文中的问题，如果id 的类型是整数，传入的参数类型是字符串的时候，</p>
<p>可以用上索引。某、人   15</p>
<p>最近几张干货越来越多了,很实用,收获不少.先回答今天的问题</p>
<p>版本5.7.13</p>
<p>rc模式下:</p>
<p>session 1:</p>
<p>begin;</p>
<p>select * from t where c&#x3D;5 for update; </p>
<p>session 2:</p>
<p>delete from t where c&#x3D;10 –等待</p>
<p>session 3:</p>
<p>insert into t values(100001,8) –成功</p>
<p>session 1:</p>
<p>commit</p>
<p>session 2:事务执行成功</p>
<p>rr模式下:</p>
<p>begin;</p>
<p>select * from t where c&#x3D;5 for update; </p>
<p>session 2:</p>
<p>delete from t where c&#x3D;10 –等待</p>
<p>session 3:</p>
<p>insert into t values(100001,8) –等待</p>
<p>session 1:</p>
<p>commit</p>
<p>session 2:事务执行成功</p>
<p>session 3：事务执行成功</p>
<p>从上面这两个简单的例子,可以大概看出上锁的流程.</p>
<p>不管是rr模式还是rc模式,这条语句都会先在server层对表加上MDL S锁,然后进入到引擎层。rc模式下,由于数据量不大只有10W。通过实验可以证明session 1上来就把该表的所有行都锁住</p>
<p>了。导致其他事务要对该表的所有现有记录做更新,是阻塞状态。为什么insert又能成功?</p>
<p>说明rc模式下for update语句没有上gap锁,所以不阻塞insert对范围加插入意向锁,所以更新成功</p>
<p>。session 1commit后,session 2执行成功。表明所有行的x锁是在事务提交完成以后才释放。rr模式下,session 1和session 2与rc模式下都一样,说明rr模式下也对所有行上了X锁。唯一的区别是insert也等待了,是因为rr模式下对没有索引的更新,聚簇索引上的所有记录，都被</p>
<p>加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。由于gap锁阻</p>
<p>精选留言</p>
<p>塞了insert要加的插入意向锁,导致insert也处于等待状态。只有当session 1 commit完成以后。s</p>
<p>ession 1上的所有锁才会释放,S2,S3执行成功</p>
<p>由于例子中的数据量还比较小,如果数据量达到千万级别,就比较直观的能看出,上锁是逐行上锁</p>
<p>的一个过程.扫描一条上一条,直到所有行扫描完,rc模式下对所有行上x锁。rr模式下不仅对所有</p>
<p>行上X锁,还对所有区间上gap锁.直到事务提交或者回滚完成后,上的锁才会被释放。2018-12-26</p>
<p> 作者回复</p>
<p>分析得非常好。两个模式下，各增加一个session 4 : update t set c&#x3D;100 where id&#x3D;10看看哦</p>
<p>基本就全了  </p>
<p>2018-12-26</p>
<p>薛畅   9</p>
<p>回来老师的问题：</p>
<p>在 Read Committed 隔离级别下，会锁上聚簇索引中的所有记录；</p>
<p>在 Repeatable Read 隔离级别下，会锁上聚簇索引中的所有记录，并且会锁上聚簇索引内的所</p>
<p>有 GAP；</p>
<p>在上面两个隔离级别的情况下，如果设置了 innodb_locks_unsafe_for_binlog 开启 semi-consis</p>
<p>tent read 的话，对于不满足查询条件的记录，MySQL 会提前放锁，不过加锁的过程是不可避</p>
<p>免的。2018-12-26</p>
<p>似水流年   4</p>
<p>请问老师，为什么select blocking_pid from sys.schema_table_lock_waits;查不到mdl锁的进程i</p>
<p>d，显示为空。2018-12-28</p>
<p>沙漠里的骆驼   4</p>
<p>@高枕</p>
<p>这里有些资料提供给你参考: </p>
<ol>
<li><p>何登成的技术博客: 加锁分析 <a href="http://hedengcheng.com/?p=771">http://hedengcheng.com/?p=771</a></p>
</li>
<li><p>锁的常见种类: <a href="http://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">http://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html</a></p>
</li>
</ol>
<p>2018-12-26</p>
<p>尘封   3</p>
<p>课后问题：d这一列不存在，但是还是要加MDL锁，释放时间应该是事务提交时。2018-12-26</p>
<p> 作者回复</p>
<p>抱歉，是要写成where c&#x3D;5 , 发起堪误了</p>
<p>2018-12-26</p>
<p>尘封   3</p>
<p>尘封   3</p>
<p>老师，有没有遇到过select语句一直处于killed状态的情况？2018-12-26</p>
<p> 作者回复</p>
<p>有  这个是在后面的文章中会用到的例子</p>
<p>2018-12-26</p>
<p>蠢蠢欲动的腹肌   2</p>
<p>老师，您好</p>
<p>我的mysql版本5.7.24，尝试的时候发现了如下问题</p>
<p>锁住了表T</p>
<p>mysql&gt; lock table T write;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>另一个terminal查询时被阻塞，但是查不到blocking_pid ，这是什么情况呢</p>
<p>mysql&gt; select blocking_pid from sys.schema_table_lock_waits;</p>
<p>Empty set (0.00 sec)</p>
<p>ps:发现查询schema_table_lock_waits表与lock table的语句不能放在一个terminal执行，否则会</p>
<p>报</p>
<p>Table ‘schema_table_lock_waits’ was not locked with LOCK TABLES</p>
<p>自行尝试的同学要注意下，老师有空的话也可以帮看看为什么。。。2018-12-28</p>
<p>小李子   2</p>
<p>老师，为什么session B 执行了 select in share mode ，在等行锁的时候，session C 执行 </p>
<p>select * from sys.innodb_lock_waits where locked_table&#x3D;’<code>test</code>.<code>t</code>‘ 会报这个错 </p>
<p>[Err] 1356 - View ‘sys.innodb_lock_waits’ references invalid table(s) or column(s) or function(s) </p>
<p>or definer&#x2F;invoker of view lack rights to use them，而超时之后，又可以查了？另外，\G 参数会</p>
<p>报语法错误？2018-12-27</p>
<p>Tony Du   2</p>
<p>对于课后问题，select * from t where c&#x3D;5 for update，</p>
<p>当级别为RR时，因为字段c上没有索引，会扫主键索引，这时会把表中的记录都加上X锁。同</p>
<p>时，因为对于innodb来说，当级别为RR时，是可以解决幻读的，此时对于每条记录的间隙还要</p>
<p>加上GAP锁。也就是说，表上每一条记录和每一个间隙都锁上了。当级别为RC时，因为字段c上没有索引，会扫主键索引，这时会把表中的记录都加上X锁。另外，之前看过相关文章，MySQL在实际实现中有些优化措施，比如当RC时，在MySQL serv</p>
<p>er过滤条件，发现不满足后，会把不满足条件的记录释放锁（这里就是把 c!&#x3D;5的记录释放锁）</p>
<p>，这里会违背两阶段的约束。当然，之前每条记录的加锁操作还是不能省略的。还有，对于semi consistent read开启的情况下，也会提前释放锁。2018-12-27</p>
<p>信信   2</p>
<p>老师你好，图3上方提到MySQL 5.7 版本修改了 MDL 的加锁策略，不能复现第六章的场景。但</p>
<p>我认为只要仍然满足：DML操作加MDL读锁，DDL操作加MDL写锁，并且事务提交才释放锁，</p>
<p>那么就可以复现啊。。。所以5.7到底是改了什么导致无法复现的呢？2018-12-27</p>
<p>某、人   2</p>
<p>老师我请教一个问题:</p>
<p>flush tables中close table的意思是说的把open_tables里的表全部关闭掉?下次如果有关于某张表</p>
<p>的操作</p>
<p>又把frm file缓存进Open_table_definitions,把表名缓存到open_tables,还是open_table只是一个计</p>
<p>数?</p>
<p>不是特别明白flush table和打开表是个什么流程</p>
<p>2018-12-26</p>
<p> 作者回复</p>
<p>Flush tables是会关掉表，然后下次请求重新读表信息的</p>
<p>第一次打开表其实就是open_table_definitions，包括读表信息一类的</p>
<p>之后再有查询就是拷贝一个对象，加一个计数这样的</p>
<p>2018-12-26</p>
<p>老杨同志   2</p>
<p>愉快的做一下思考题</p>
<p>begin;</p>
<p>select * from t where c&#x3D;5 for update;</p>
<p>commit;</p>
<p>历史知识的结论是，innodb先锁全表的所有行，返回server层，判断c是否等于5，然后释放c！</p>
<p>&#x3D;5的行锁。验证方法：</p>
<p>事务A执行 锁住一行c！&#x3D;5的记录 比如id &#x3D;3 c&#x3D;3</p>
<p>select * from t where id &#x3D; 3 for update 或者 update t set c&#x3D;4 where id &#x3D;3</p>
<p>然后启动新事务B执行上面的语句select * from t where c&#x3D;5 for update; 看看有没有被阻塞。用于判断事务B的语句会不会试图锁不满足条件的记录。然后把事务A和事务B的执行顺序对调一下，也就是先执行B在执行A。看看有没有阻塞，</p>
<p>判断在事务B加锁成功的情况下会不会释放不满足查询条件记录的行锁。2018-12-26</p>
<p> 作者回复</p>
<p>   思路清晰</p>
<p>隔离级别再愉快地改成RR试试 </p>
<p>2018-12-26</p>
<p>小确幸   1</p>
<p>问一下：索引扫描与全表扫描，有什么异同点？2018-12-26</p>
<p> 作者回复</p>
<p>一般说全表扫描默认是值“扫瞄主键索引”</p>
<p>2018-12-26</p>
<p>陈旭   1</p>
<p>老师，最近遇到了一个问题，看您有什么建议。业务场景是这样的：</p>
<p>1.开启事务</p>
<p>2.在表a插入一条记录</p>
<p>3.在表b更新一条记录</p>
<p>4.在表c更新一条记录</p>
<p>5.提交事务</p>
<p>看程序日志所有sql都没问题（没看数据库日志），但是结果是2的那条插入了，3和4都没更新</p>
<p>，这个问题有哪几种情况？2018-12-26</p>
<p> 作者回复</p>
<p>这是被别的并发事务又改回去了吗 </p>
<p>要么是update的值跟原值相同</p>
<p>要么是update条件没有匹配到行</p>
<p>额，最好给一下每个语句执行后的affacted rows , 还有binlog里的日志内容，才好分析</p>
<p>2018-12-26</p>
<p>杰之7   0</p>
<p>通过这一节的阅读学习，老师讲述了一个查询语句被锁住和查询慢的两种情况。在被锁住中，通过等MDL锁，堵住了select查询语句，可以通过kiss掉持有MDL写锁。第二种</p>
<p>是flush被别的语句堵住，然后flush堵住select语句。第三种是等行锁，通过sys.innodb_lock_w</p>
<p>ait查到，然后kill。在查询慢中，lock in sharde mode直接读1000001</p>
<p>而select * from t where id&#x3D;1需要从1000001执行100百万行，所以查询就慢了。老师昨天给我了学习的建议，每个事例在Mysql中去运行做，有不懂的问老师。真的非常感动</p>
<p>，也给我了会一直跟随老师学习的动力和勇气。学了专栏的一半，需要把之前学的内容复习，</p>
<p>接下来我会跟进老师的课程同时动手做之前的案例，不懂有我的思考之后，会及时请教老师。2019-01-21</p>
<p>唐名之   0</p>
<p>show VARIABLES LIKE ‘performance%’;</p>
<p>performance_schema ON</p>
<p>配置已经是打开的</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>诶。。那奇怪了</p>
<p>执行</p>
<p>select * from performance_schema.metadata_locks; 看看？2019-01-11</p>
<p>唐名之   0</p>
<p>环境：mysql-5.7.24</p>
<p>show VARIABLES LIKE ‘performance%’;</p>
<p>performance_schema ON</p>
<p>A窗口执行：lock table t WRITE;</p>
<p>B窗口执行：select * from t where id&#x3D;1;</p>
<p>C窗口执行：show PROCESSLIST;</p>
<p>53 slave_user DESKTOP-00HHFO4:63064 Binlog Dump 3027 Master has sent all binlog to sla</p>
<p>ve; waiting for more updates </p>
<p>54 root localhost:64572 Sleep 157 </p>
<p>55 root localhost:64573 mysql_action Sleep 158 </p>
<p>56 root localhost:64575 mysql_action Sleep 156 </p>
<p>57 root localhost:64576 mysql_action Sleep 156 </p>
<p>58 root localhost:64577 mysql_action Sleep 156 </p>
<p>59 root localhost:64578 mysql_action Sleep 156 </p>
<p>60 root localhost:64579 mysql_action Sleep 144 </p>
<p>61 root localhost:64581 mysql_action Query 140 Waiting for table metadata lock select * from t</p>
<p>where id&#x3D;1</p>
<p>62 root localhost:64583 mysql_action Query 0 starting </p>
<p>show PROCESSLIST</p>
<p>已出现：“Waiting for table metadata ” 但这三张表都查不出数据，求解；</p>
<p>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</p>
<p>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS；</p>
<p>SELECT * from sys.schema_table_lock_waits;</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>SELECT * from sys.schema_table_lock_waits; 是需要配置里面把performance_schema打开的</p>
<p>；</p>
<p>前面两个语句是只会显示跟innodb的行锁相关的，表级的锁不会显示在这两个表</p>
<p>2019-01-11</p>
<p>M   0</p>
<p>老师讲的很好</p>
<p>2019-01-09</p>
<p> 作者回复</p>
<p>多谢鼓励</p>
<p>看文章的同学都很细致，不敢不认真 </p>
<p>2019-01-09</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>思考题</p>
<p>c无索引x锁应该是锁表。解锁我觉得应该是sessionb的事物提交之后</p>
<p>2019-01-08</p>
<p> 作者回复</p>
<p>不是锁表哈，innodb里面除非明确写lock table，不会锁表；</p>
<p>解锁时机对的</p>
<p>2019-01-10</p>
<p>ʘᴗʘ小白帽ʘᴗʘ   0</p>
<p>涨知识了</p>
<p>2019-01-04</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么还有kill不掉的语句</title>
    <url>/posts/11e721ea.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>32 | 为什么还有kill不掉的语句？2019-01-25 林晓斌</p>
<p>在MySQL中有两个kill命令：一个是kill query +线程id，表示终止这个线程中正在执行的语句；一</p>
<p>个是kill connection +线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个</p>
<p>线程有语句正在执行，也是要先停止正在执行的语句的。不知道你在使用MySQL的时候，有没有遇到过这样的现象：使用了kill命令，却没能断开这个连</p>
<p>接。再执行show processlist命令，看到这条语句的Command列显示的是Killed。你一定会奇怪，显示为Killed是什么意思，不是应该直接在show processlist的结果里看不到这个</p>
<p>线程了吗？今天，我们就来讨论一下这个问题。其实大多数情况下，kill query&#x2F;connection命令是有效的。比如，执行一个查询的过程中，发现执</p>
<p>行时间太久，要放弃继续查询，这时我们就可以用kill query命令，终止这条查询语句。还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的。我们一起来看下这个例</p>
<p>子：</p>
<p>图1 kill query 成功的例子</p>
<p>可以看到，session C 执行kill query以后，session B几乎同时就提示了语句被中断。这，就是我</p>
<p>们预期的结果。收到kill以后，线程做什么？但是，这里你要停下来想一下：session B是直接终止掉线程，什么都不管就直接退出吗？显</p>
<p>然，这是不行的。我在第6篇文章中讲过，当对一个表做增删改查操作时，会在表上加MDL读锁。所以，session B</p>
<p>虽然处于blocked状态，但还是拿着一个MDL读锁的。如果线程被kill的时候，就直接终止，那之</p>
<p>后这个MDL读锁就没机会被释放了。这样看来，kill并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，</p>
<p>可以开始“执行停止的逻辑了”。实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件</p>
<p>事：</p>
<ol>
<li><p>把session B的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；</p>
</li>
<li><p>给session B的执行线程发一个信号。为什么要发信号呢？因为像图1的我们例子里面，session B处于锁等待状态，如果只是把session B的线程状态设置</p>
</li>
</ol>
<p>THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待。发一个信号的目的，就</p>
<p>是让session B退出等待，来处理这个THD::KILL_QUERY状态。其实，这跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进程发一个信号，</p>
<p>然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参</p>
<p>数，就只有“停止”这个命令。上面的分析中，隐含了这么三层意思：</p>
<ol>
<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态</li>
</ol>
<p>是THD::KILL_QUERY，才开始进入语句终止逻辑；</p>
<ol start="2">
<li><p>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</p>
</li>
<li><p>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。到这里你就知道了，原来不是“说停就停的”。接下来，我们再看一个kill不掉的例子，也就是我们在前面第29篇文章中提到的</p>
</li>
</ol>
<p>innodb_thread_concurrency 不够用的例子。首先，执行set global innodb_thread_concurrency&#x3D;2，将InnoDB的并发线程上限数设置为2；然</p>
<p>后，执行下面的序列：</p>
<p>图2 kill query 无效的例子</p>
<p>可以看到：</p>
<ol>
<li><p>sesssion C执行的时候被堵住了；</p>
</li>
<li><p>但是session D执行的kill query C命令却没什么效果，</p>
</li>
<li><p>直到session E执行了kill connection命令，才断开了session C的连接，提示“Lost</p>
</li>
</ol>
<p>connection to MySQL server during query”，</p>
<ol start="4">
<li>但是这时候，如果在session E中执行show processlist，你就能看到下面这个图。图3 kill connection之后的效果</li>
</ol>
<p>这时候，id&#x3D;12这个线程的Commnad列显示的是Killed。也就是说，客户端虽然断开了连接，但</p>
<p>实际上服务端上这条语句还在执行过程中。为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？在实现上，等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但</p>
<p>是，在这个例子里，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执</p>
<p>行，如果不行，就调用nanosleep函数进入sleep状态。也就是说，虽然12号线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的</p>
<p>循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。而当session E执行kill connection 命令时，是这么做的，</p>
<ol>
<li><p>把12号线程状态设置为KILL_CONNECTION；</p>
</li>
<li><p>关掉12号线程的网络连接。因为有这个操作，所以你会看到，这时候session C收到了断开</p>
</li>
</ol>
<p>连接的提示。那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这就是因为在</p>
<p>执行show processlist的时候，有一个特别的逻辑：</p>
<p>所以其实，即使是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出</p>
<p>呢？答案是，只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判</p>
<p>断到线程状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。到这里，我们来小结一下。这个例子是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑。跟这种情况</p>
<p>相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。另一类情况是，终止逻辑耗时较长。这时候，从show processlist结果上看也是</p>
<p>Command&#x3D;Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有</p>
<p>以下几种：</p>
<ol>
<li>超大事务执行期间被kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回</li>
</ol>
<p>收操作，耗时很长。2. 大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临</p>
<p>时文件可能需要等待IO资源，导致耗时较长。3. DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响</p>
<p>耗时较久。之前有人问过我，如果直接在客户端通过Ctrl+C命令，是不是就可以直接终止线程呢？答案是，不可以。这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络</p>
<p>交互，是不可能直接操作服务端线程的。而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继</p>
<p>续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后</p>
<p>发送一个kill query 命令。所以，你可别以为在客户端执行完Ctrl+C就万事大吉了。因为，要kill掉一个线程，还涉及到后端</p>
<p>的很多操作。另外两个关于客户端的误解</p>
<p>在实际使用中，我也经常会碰到一些同学对客户端的使用有误解。接下来，我们就来看看两个最</p>
<p>常见的误解。第一个误解是：如果库里面的表特别多，连接就会很慢。有些线上的库，会包含很多表（我见过最多的一个库里有6万个表）。这时候，你就会发现，每</p>
<p>次用客户端连接都会卡在下面这个界面上。图4 连接等待</p>
<p>而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。因此，有</p>
<p>同学会认为是表的数目影响了连接性能。从第一篇文章你就知道，每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、</p>
<p>用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。但实际上，正如图中的文字提示所说的，当使用默认参数连接的时候，MySQL客户端会提供一</p>
<p>个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>
<ol>
<li><p>执行show databases；</p>
</li>
<li><p>切到db1库，执行show tables；</p>
</li>
<li><p>把这两个命令的结果用于构建一个本地的哈希表。在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非</p>
</li>
</ol>
<p>常多的时候，这一步就会花比较长的时间。也就是说，我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端</p>
<p>慢。图中的提示也说了，如果在连接命令中加上-A，就可以关掉这个自动补全的功能，然后客户端就</p>
<p>可以快速返回了。这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全</p>
<p>表名或者显示提示。实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。其实提示里面没有说，除了加-A以外，加–quick(或者简写为-q)参数，也可以跳过这个阶段。但</p>
<p>是，这个–quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。你看到这个参数，是不是觉得这应该是一个让服务端加速的参数？但实际上恰恰相反，设置了这</p>
<p>个参数可能会降低服务端的性能。为什么这么说呢？MySQL客户端发送请求后，接收服务端返回结果的方式有两种：</p>
<ol>
<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用API开发，对应的</li>
</ol>
<p>就是mysql_store_result 方法。2. 另一种是不缓存，读一个处理一个。如果你用API开发，对应的就是mysql_use_result方</p>
<p>法。MySQL客户端默认采用第一种方式，而如果加上–quick参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变</p>
<p>慢。关于服务端的具体行为，我会在下一篇文章再和你展开说明。那你会说，既然这样，为什么要给这个参数取名叫作quick呢？这是因为使用这个参数可以达到</p>
<p>以下三点效果：</p>
<p>第一点，就是前面提到的，跳过表名自动补全功能。第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费</p>
<p>较多的本地内存，可能会影响客户端本地机器的性能；</p>
<p>第三点，是不会把执行命令记录到本地的命令历史文件。所以你看到了，–quick参数的意思，是让客户端变得更快。小结</p>
<p>在今天这篇文章中，我首先和你介绍了MySQL中，有些语句和连接“kill不掉”的情况。这些“kill不掉”的情况，其实是因为发送kill命令的客户端，并没有强行停止目标线程的执行，而只</p>
<p>是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的“埋点”，才会开始</p>
<p>进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。所以，如果你发现一个线程处于Killed状态，你可以做的事情就是，通过影响系统环境，让这个</p>
<p>Killed状态尽快结束。比如，如果是第一个例子里InnoDB并发度的问题，你就可以临时调大</p>
<p>innodb_thread_concurrency的值，或者停掉别的线程，让出位子给这个线程执行。而如果是回滚逻辑由于受到IO资源限制执行得比较慢，就通过减少系统压力让它加速。做完这些操作后，其实你已经没有办法再对它做什么了，只能等待流程自己完成。最后，我给你留下一个思考题吧。如果你碰到一个被killed的事务一直处于回滚状态，你认为是应该直接把MySQL进程强行重启，</p>
<p>还是应该让它自己执行完成呢？为什么呢？你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章末尾，给你留下的问题是，希望你分享一下误删数据的处理经验。@苍茫 同学提到了一个例子，我觉得值得跟大家分享一下。运维的同学直接拷贝文本去执</p>
<p>行，SQL语句截断，导致数据库执行出错。从浏览器拷贝文本执行，是一个非常不规范的操作。除了这个例子里面说的SQL语句截断问题，</p>
<p>还可能存在乱码问题。一般这种操作，如果脚本的开发和执行不是同一个人，需要开发同学把脚本放到git上，然后把</p>
<p>git地址，以及文件的md5发给运维同学。这样就要求运维同学在执行命令之前，确认要执行的文件的md5，跟之前开发同学提供的md5相</p>
<p>同才能继续执行。另外，我要特别点赞一下@苍茫 同学复现问题的思路和追查问题的态度。@linhui0705 同学提到的“四个脚本”的方法，我非常推崇。这四个脚本分别是：备份脚本、</p>
<p>执行脚本、验证脚本和回滚脚本。如果能够坚持做到，即使出现问题，也是可以很快恢复的，一</p>
<p>定能降低出现故障的概率。不过，这个方案最大的敌人是这样的思想：这是个小操作，不需要这么严格。@Knight²º¹  给了一个保护文件的方法，我之前没有用过这种方法，不过这确实是一个不错的</p>
<p>思路。为了数据安全和服务稳定，多做点预防方案的设计讨论，总好过故障处理和事后复盘。方案设计</p>
<p>讨论会和故障复盘会，这两种会议的会议室气氛完全不一样。经历过的同学一定懂的。Leon    2</p>
<p>kill connection本质上只是把客户端的sql连接断开，后面的执行流程还是要走kill query的，是这</p>
<p>样理解吧</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>这个理解非常到位 </p>
<p>额外的一个不同就是show processlist的时候，kill connection会显示“killed”</p>
<p>这两句加起来可以用来替换我们文中的描述 </p>
<p>2019-01-30</p>
<p>Mr.sylar   2</p>
<p>老师，我想问下这些原理的”渔”的方法除了看源码，还有别的建议吗</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>不同的知识点不太一样哈，</p>
<p>有些可以看文档；</p>
<p>有些可以自己验证；</p>
<p>还有就是看其他人文章，加验证；（就是我们这个专栏的方法^_^）</p>
<p>2019-01-25</p>
<p>夹心面包   2</p>
<p>对于结尾的问题,我觉得肯定是等待,即便是mysql重启,也是需要对未提交的事务进行回滚操作的</p>
<p>,保证数据库的一致性</p>
<p>2019-01-25</p>
<p>Ryoma   1</p>
<p>想得简单点：既然事务处于回滚状态了，重启MySQL这部分事务还是需要回滚。私以为让它执</p>
<p>行完成比较好。2019-01-25</p>
<p>斜面镜子 Bill   0</p>
<p>“采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端</p>
<p>变慢” 这个怎么理解？2019-01-28</p>
<p> 作者回复</p>
<p>堵住了不就变慢了 </p>
<p>2019-01-28</p>
<p>700   0</p>
<p>精选留言</p>
<p> 0</p>
<p>老师，您好。客户端版本如下：</p>
<p>mysql Ver 14.14 Distrib 5.7.24, for linux-glibc2.12 (x86_64) using EditLine wrapper</p>
<p>老师，再请教另一个问题。并非所有的 DDL 操作都可以通过主从切换来实现吧？不适用的场景</p>
<p>有哪些呢？2019-01-27</p>
<p> 作者回复</p>
<p>对，其实只有 改索引、 加最后一列、删最后一列</p>
<p>其他的大多数不行，比如删除中间一列这种</p>
<p>2019-01-28</p>
<p>千年孤独   0</p>
<p>可能不是本章讨论的问题，我想请问老师“MySQL使用自增ID和UUID作为主键的优劣”，基于什</p>
<p>么样的业务场景用哪种好?</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<p>后面会有文章会提到这个问题哈：）</p>
<p>2019-01-27</p>
<p>Geek_a67865   0</p>
<p>老师好，我猜发条橙子的问题 因为很多日志监控会统计error日志，这样并不很优雅，觉得他是</p>
<p>想有什么办法规避这种并发引起的问题，</p>
<p>2019-01-26</p>
<p> 作者回复</p>
<p>嗯嗯 不过我也确实没有想到更好的方法</p>
<p>毕竟两个线程要同时发起一个insert操作，这个服务端也拦不住呀 </p>
<p>2019-01-26</p>
<p>路过   0</p>
<p>老师，kill语法是：</p>
<p>KILL [CONNECTION | QUERY] processlist_id</p>
<p>processlist_id是conn_id，不是thd_id.通过对比sys.processlist表中的信息就可以知道了。通过查询官方文档也说明了：</p>
<p>thd_id：The thread ID.</p>
<p>conn_id：The connection ID.</p>
<p>所以，这篇文章开头的：</p>
<p>在 MySQL 中有两个 kill 命令：一个是 kill query + 线程 id</p>
<p>感觉有点不对。请老师指正。谢谢！</p>
<p>2019-01-26</p>
<p> 作者回复</p>
<p>这两个是一样的吧？都是对应show processlist这个命令结果里的第一列</p>
<p>2019-01-26</p>
<p>HuaMax   0</p>
<p>课后题。我认为需要看当时的业务场景。重启会导致其他的连接也断开，返回给其他业务连接</p>
<p>丢失的错误。如果有很多事务在等待该事务的锁，则应该重启，让其他事务快速重试获取锁。另外如果是RR的事务隔离级别，长事务会因为数据可见性的问题，对于多版本的数据需要找到</p>
<p>正确的版本，对读性能是不是也会有影响，这时候重启也更好。个人理解，请老师指正。2019-01-26</p>
<p> 作者回复</p>
<p>有考虑到对其他线程的影响，这个 </p>
<p>其实这种时候往往是要先考虑切换（当然重启也是切换的）</p>
<p>如果只看恢复时间的话，等待会更快 </p>
<p>2019-01-26</p>
<p>Geek_a67865   0</p>
<p>也遇到@发条橙子一样的问题，例如队列两个消息同时查询库存，发现都不存在，然后就都执</p>
<p>行插入语句，一条成功，一条报唯一索引异常，这样程序日志会一直显示一个唯一索引报错，</p>
<p>然后重试执行更新，我暂时是强制查主库</p>
<p>2019-01-26</p>
<p> 作者回复</p>
<p>“我暂时是强制查主库” 从这就看你是因为读是读的备库，才出现这个问题的是吧。发条橙子的问题是，他都是操作主库。其实如果索引有唯一键，就直接上insert。然后碰到违反唯一键约束就报错，这个应该就是唯一键约束正常的用法吧 </p>
<p>2019-01-26</p>
<p>gaohueric   0</p>
<p>老师您好，一个表中 1个主键，2个唯一索引，1个普通索引 4个普通字段，当插入一条全部字</p>
<p>段不为空的数据时，此时假设有4个索引文件，分别对应 主键 唯一性索引，普通索引，假设内</p>
<p>存中没有这个数据页，那么server是直接调用innodb的接口，然后依次校验 （读取磁盘数据，</p>
<p>验证唯一性）主键，唯一性索引，然后确认无误A时刻之后，吧主键和唯一性索引的写入内存</p>
<p>，再把普通索引写入change buffer？那普通数据呢，是不是跟着主键一块写入内存了？2019-01-26</p>
<p> 作者回复</p>
<ol>
<li><p>是的，如果普通索引上的数据页这时候没有在内存中，就会使用change buffer</p>
</li>
<li><p>“那普通数据呢，是不是跟着主键一块写入内存了？” 你说的是无索引的字段是吧，这些数据</p>
</li>
</ol>
<p>就在主键索引上，其实改的就是主键索引。2019-01-26</p>
<p>700   0</p>
<p>老师，您好。我继续接着我上条留言。关于2），因为是测试机，我是直接 tail -0f 观察 general log 输出的。确实没看到 KILL QUERY </p>
<p>等字眼。数据库版本是 MySQL 5.7.24。关于4），文中您不是这样说的吗？2.但是 session D 执行的 kill query C 命令却没什么效果， </p>
<p>3.直到 session E 执行了 kill connection 命令，才断开了 session C 的连接，提示“Lost connec</p>
<p>tion to MySQL server during query”， </p>
<p>感谢您的解答。2019-01-26</p>
<p> 作者回复</p>
<ol>
<li><p>你的客户端版本是什么 mysql –version 看看</p>
</li>
<li><p>嗯，是的，连接会断开，但是这个语句在server端还是会继续执行 （如果kill query 无效的话</p>
</li>
</ol>
<p>）</p>
<p>2019-01-26</p>
<p>700   0</p>
<p>老师，请教。1）文中开头说“当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的”。我个人</p>
<p>在平时使用中就是按默认的执行，不管这个线程有无正在执行语句。不知这样会有什么潜在问</p>
<p>题？2）文中说“实际上，执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 </p>
<p>kill query 命令“。这个怎么解释呢？我开启 general log 的时候执行 Ctrl+C 或 Ctrl+D 并没有看到有另外启动一个连接，也没有看到 </p>
<p>kill query 命令。general log 中仅看到对应线程 id 和 Quit。3）MySQL 为什么要同时存在 kill query 和 kill connection，既然 kill query 有无效的场景，干嘛</p>
<p>不直接存在一个 kill connection 命令就好了？那它俩分别对应的适用场景是什么，什么时候考</p>
<p>虑 kill query，什么时候考虑 kill connection？我个人觉得连接如果直接被 kill 掉大不了再重连一</p>
<p>次好了。也没啥损失。4）小小一个总结，不知对否？kill query - 会出现无法 kill 掉的情况，只能再次执行 kill connection。kill connection - 会出现 Command 列显示成 Killed 的情况。2019-01-25</p>
<p> 作者回复</p>
<ol>
<li><p>一般你执行kill就是要停止正在执行的语句，所以问题不大 </p>
</li>
<li><p>不应该呀， KILL QUERY 是大写哦，你再grep一下日志；</p>
</li>
<li><p>多提供一种方法嘛。kill query是指你只是想停止这个语句，但是事务不会回滚。一般kill quer</p>
</li>
</ol>
<p>y是发生在客户端执行ctrl+c的时候啦。平时紧急处理确实直接用kill + thread_id。 好问题</p>
<ol start="4">
<li>对，另外，在kill query无效的时候，其实kill connection也是无效的</li>
</ol>
<p>2019-01-26</p>
<p>Justin   0</p>
<p>想咨询一个问题 如果走索引找寻比如age&#x3D;11的人的时候是只会锁age&#x3D;10到age&#x3D;12吗 如果那个</p>
<p>索引页包含了从5到13的数据 是只会锁离11最近的还是说二分查找时候每一个访问到的都会锁</p>
<p>呢</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>只会锁左右。2019-01-26</p>
<p>往事随风，顺其自然   0</p>
<p>12 号线程的等待逻辑是这样的：每 10 毫秒判断一下是否可以进入 InnoDB 执行，如果不行，</p>
<p>如果不行，就调用 nanosleep 函数进入 sleep状态。这里为什么是10毫秒判断一下？怎么查看</p>
<p>和设置这个参数？2019-01-25</p>
<p>发条橙子 。   0</p>
<p>老师我这里问一下唯一索引的问题 ，希望老师能给点思路</p>
<p>背景 ： 一张商品库存表 ， 如果表里没这个商品则插入 ，如果已经存在就更新库存 。同步这</p>
<p>个库存表是异步的 ，每次添加商品库存成功后会发消息 ， 收到消息后会去表里新增&#x2F;更新库存</p>
<p>问题 ： </p>
<p>商品库存表会有一个 商品的唯一索引。当我们批量添加同一商品库存后会批量发消息 ，消息同时生效后去处理就有了并发的问题 。这</p>
<p>时候两个消息都判断表里没有该商品记录， 但是插入的时候就会有一个消息插入成功，另一个</p>
<p>消息执行失败报唯一索引的错误， 之后消息重试走更新的逻辑。这个这样做对业务没有影响 ，但是现在批量添加的需求量上来了 ，线上一直报这种错误日志也</p>
<p>不是个办法， 我能想到的除了 catch 掉这个异常就没什么其他思路了。 </p>
<p>老师能给一些其他的思路么</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>有唯一索引了，就直接插入，然后出现唯一性约束就放弃，这个逻辑的问题是啥，我感觉挺好</p>
<p>的呀 </p>
<p>是不是我没有get到问题的点</p>
<p>2019-01-25</p>
<p>AI杜嘉嘉   0</p>
<p>我想请问下老师，一个事务执行很长时间，我去kill。那么，执行这个事务过程中的数据会不会</p>
<p>回滚？2019-01-25</p>
<p> 作者回复</p>
<p>这个事务执行过程中新生成的数据吗？ 会回滚的</p>
<p>2019-01-25</p>
<p>曾剑   0</p>
<p>曾剑  0</p>
<p>今天的问题，我觉得得让他自己执行完成后自动恢复。因为强制重启后该做的回滚还是会继续</p>
<p>做。2019-01-25</p>
<p>Dkey   0</p>
<p>老师，请教一个 第八章 的问题。关于可见性判断，文中都是说事务id大于高水位都不可见。如</p>
<p>果等于是不是也不可见。还有一个，readview中是否不包含当前事务id。谢谢老师</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>代码实现上，事务生成trxid后，trxid的分配器会+1，以这个加1以后的数作为高水位，所以“等</p>
<p>于”是不算的。其实有没有包含是一样的，实现上没有包含。2019-01-25</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-为什么这些SQL语句逻辑相同性能却差异巨大</title>
    <url>/posts/ca522c4d.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大？2018-12-24 林晓斌</p>
<p>在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的</p>
<p>话，就会不经意间导致整个数据库的压力变大。我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速</p>
<p>解决问题。案例一：条件字段函数操作</p>
<p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员</p>
<p>id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个</p>
<p>表的建表语句如下：</p>
<p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发</p>
<p>生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么</p>
<p>写：</p>
<p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了</p>
<p>特别久，才返回了结果。如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就</p>
<p>用不上索引了，这是MySQL的规定。现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where</p>
<p>t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成where month(t_modified)&#x3D;7的时候就不行</p>
<p>了？下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。mysql&gt; CREATE TABLE t̀radelog  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  t̀radeid  ̀varchar(32) DEFAULT NULL,</p>
<p>  &#96;operator̀  int(11) DEFAULT NULL,</p>
<p>  t̀_modified  ̀datetime DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY t̀radeid  ̀(̀ tradeid )̀,</p>
<p>  KEY t̀_modified  ̀(̀ t_modified )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>mysql&gt; select count(*) from tradelog where month(t_modified)&#x3D;7;</p>
<p>图1 t_modified索引示意图</p>
<p>如果你的SQL语句条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的</p>
<p>路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃</p>
<p>走树搜索功能。需要注意的是，优化器并不是要放弃使用这个索引。在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引</p>
<p>t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引</p>
<p>来得更快。因此最终还是会选择索引t_modified。接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。图2 explain 结果</p>
<p>key&#x3D;”t_modified”表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数</p>
<p>据，rows&#x3D;100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的</p>
<p>是使用了覆盖索引。也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引</p>
<p>的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化</p>
<p>器就能按照我们预期的，用上t_modified索引的快速定位能力了。当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他</p>
<p>年份补齐。到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只</p>
<p>能使用全索引扫描。不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索</p>
<p>引。比如，对于select * from tradelog where id + 1 &#x3D; 10000这个SQL语句，这个加1操作并不会</p>
<p>改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写</p>
<p>SQL语句的时候，手动改写成 where id &#x3D; 10000 -1才可以。案例二：隐式类型转换</p>
<p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。我们一起看一下这条SQL语句：</p>
<p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表</p>
<p>扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做</p>
<p>类型转换。那么，现在这里就有两个问题：</p>
<p>mysql&gt; select count(*) from tradelog where</p>
<pre><code>-&gt; (t_modified &gt;= &#39;2016-7-1&#39; and t_modified&lt;&#39;2016-8-1&#39;) or

-&gt; (t_modified &gt;= &#39;2017-7-1&#39; and t_modified&lt;&#39;2017-8-1&#39;) or 

-&gt; (t_modified &gt;= &#39;2018-7-1&#39; and t_modified&lt;&#39;2018-8-1&#39;);
</code></pre>
<p>mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<ol>
<li>数据类型转换的规则是什么？2. 为什么有数据类型转换，就需要走全索引扫描？先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不</li>
</ol>
<p>住，应该怎么办呢？这里有一个简单的方法，看 select “10” &gt; 9的结果：</p>
<ol>
<li><p>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</p>
</li>
<li><p>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。验证结果如图3所示。图3 MySQL中字符串和数字转换的效果示意图</p>
</li>
</ol>
<p>从图中可知，select “10” &gt; 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL</p>
<p>中，字符串和数字做比较的话，是将字符串转换成数字。这时，你再看这个全表扫描的语句：</p>
<p>就知道对于优化器来说，这个语句相当于：</p>
<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜</p>
<p>索功能。现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？mysql&gt; select * from tradelog where tradeid&#x3D;110717;</p>
<p>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717;</p>
<p>select * from tradelog where id&#x3D;”83126”;</p>
<p>你可以先自己分析一下，再到数据库里面去验证确认。接下来，我们再来看一个稍微复杂点的例子。案例三：隐式字符编码转换</p>
<p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复</p>
<p>现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p>
<p>mysql&gt; CREATE TABLE t̀rade_detail  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  t̀radeid  ̀varchar(32) DEFAULT NULL,</p>
<p>  t̀rade_step  ̀int(11) DEFAULT NULL, &#x2F;<em>操作步骤</em>&#x2F;</p>
<p>  &#96;step_info  ̀varchar(32) DEFAULT NULL, &#x2F;<em>步骤信息</em>&#x2F;</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY t̀radeid  ̀(̀ tradeid )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</p>
<p>insert into tradelog values(1, ‘aaaaaaaa’, 1000, now());</p>
<p>insert into tradelog values(2, ‘aaaaaaab’, 1000, now());</p>
<p>insert into tradelog values(3, ‘aaaaaaac’, 1000, now());</p>
<p>insert into trade_detail values(1, ‘aaaaaaaa’, 1, ‘add’);</p>
<p>insert into trade_detail values(2, ‘aaaaaaaa’, 2, ‘update’);</p>
<p>insert into trade_detail values(3, ‘aaaaaaaa’, 3, ‘commit’);</p>
<p>insert into trade_detail values(4, ‘aaaaaaab’, 1, ‘add’);</p>
<p>insert into trade_detail values(5, ‘aaaaaaab’, 2, ‘update’);</p>
<p>insert into trade_detail values(6, ‘aaaaaaab’, 3, ‘update again’);</p>
<p>insert into trade_detail values(7, ‘aaaaaaab’, 4, ‘commit’);</p>
<p>insert into trade_detail values(8, ‘aaaaaaac’, 1, ‘add’);</p>
<p>insert into trade_detail values(9, ‘aaaaaaac’, 2, ‘update’);</p>
<p>insert into trade_detail values(10, ‘aaaaaaac’, 3, ‘update again’);</p>
<p>insert into trade_detail values(11, ‘aaaaaaac’, 4, ‘commit’);</p>
<p>mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2; &#x2F;<em>语句Q1</em>&#x2F;</p>
<p>图4 语句Q1的explain 结果</p>
<p>我们一起来看下这个结果：</p>
<ol>
<li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索</li>
</ol>
<p>引，rows&#x3D;1表示只扫描一行；</p>
<ol start="2">
<li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫</li>
</ol>
<p>描。在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因</p>
<p>此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。接下来，我们看下这个explain结果表示的执行流程：</p>
<p>图5 语句Q1的执行过程</p>
<p>图中：</p>
<p>第1步，是根据id在tradelog表里找到L2这一行；</p>
<p>第2步，是从L2中取出tradeid字段的值；</p>
<p>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的</p>
<p>key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是</p>
<p>否匹配。进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引</p>
<p>的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是</p>
<p>utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问</p>
<p>题时会得到的答案。但是你应该再追问一下，为什么字符集不同就用不上索引呢？我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p>
<p>其中，$L2.tradeid.value的字符集是utf8mb4。参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字</p>
<p>符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再</p>
<p>跟L2做比较。也就是说，实际上这个语句等同于下面这个写法：</p>
<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。到这里，你终于明确了，字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段</p>
<p>上加函数操作，是直接导致对被驱动表做全表扫描的原因。mysql&gt; select * from trade_detail where tradeid&#x3D;$L2.tradeid.value; </p>
<p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换</p>
<p>的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方</p>
<p>向”进行转换的。select * from trade_detail  where CONVERT(traideid USING utf8mb4)&#x3D;$L2.tradeid.value; </p>
<p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id&#x3D;4的操作，对应的操作者是</p>
<p>谁”，再来看下这个语句和它的执行计划。图6 explain 结果</p>
<p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了</p>
<p>被驱动表tradelog里的索引(tradeid)，扫描行数是1。这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一</p>
<p>下。假设驱动表trade_detail里id&#x3D;4的行记为R4，那么在连接的时候（图5的第3步），被驱动表</p>
<p>tradelog上执行的就是类似这样的SQL 语句：</p>
<p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程</p>
<p>就被改写成：</p>
<p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。理解了原理以后，就可以用来指导操作了。如果要优化语句</p>
<p>的执行过程，有两种做法：</p>
<p>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就</p>
<p>没有字符集转换的问题了。mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;</p>
<p>select operator from tradelog  where traideid &#x3D;$R4.tradeid.value; </p>
<p>select operator from tradelog  where traideid &#x3D;CONVERT($R4.tradeid.value USING utf8mb4); </p>
<p>select d.* from tradelog l, trade_detail d where d.tradeid&#x3D;l.tradeid and l.id&#x3D;2;</p>
<p>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不</p>
<p>能做这个DDL的话，那就只能采用修改SQL语句的方法了。图7 SQL语句优化后的explain结果</p>
<p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看</p>
<p>到，这次索引走对了。小结</p>
<p>今天我给你举了三个例子，其实是在说同一件事儿，即：对索引字段做函数操作，可能会破坏</p>
<p>索引值的有序性，因此优化器就决定放弃走树搜索功能。第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为</p>
<p>要求在索引字段上做函数操作而导致了全索引扫描。MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1&#x3D;1000改写成where id&#x3D;1000-1就</p>
<p>能够用上索引快速查找，也不会主动做这个语句重写。因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习</p>
<p>惯。最后，又到了思考题时间。今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什</p>
<p>么，又是怎么解决的呢？你可以把你经历和分析写在留言区里，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得</p>
<p>alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</p>
<p>mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid&#x3D;CONVERT(l.tradeid USING utf8) and l.id&#x3D;2; </p>
<p>到需要的数据，你觉得有没有进一步的优化方法。这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后</p>
<p>执行下面这条SQL语句：</p>
<p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以</p>
<p>的。@倪大人 同学在评论区就提到了这个方法。这次评论区出现了很多很棒的留言：</p>
<p>老杨同志   20</p>
<p>感谢老师鼓励，我本人工作时间比较长，有一定的基础，听老师的课还是收获很大。每次公司</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>@老杨同志 提出了重新整理的方法、@雪中鼠[悠闲] 提到了用rowid的方法，是类似的思路，</p>
<p>就是让表里面保存一个无空洞的自增值，这样就可以用我们的随机算法1来实现；</p>
<p>@吴宇晨 提到了拿到第一个值以后，用id迭代往下找的方案，利用了主键索引的有序性。精选留言</p>
<p>内部有技术分享，我都去听课，但是多数情况，一两个小时的分享，就只有一两句话受益。老</p>
<p>师的每篇文章都能命中我的知识盲点，感觉太别爽。对应今天的隐式类型转换问题也踩过坑。我们有个任务表记录待执行任务，表结构简化后如下：</p>
<p>CREATE TABLE <code>task</code> (</p>
<p><code>task_id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增主键’,</p>
<p><code>task_type</code> int(11) DEFAULT NULL COMMENT ‘任务类型id’,</p>
<p><code>task_rfid</code> varchar(50) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT ‘关联外键1’,</p>
<p>PRIMARY KEY (<code>task_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci COMME</p>
<p>NT&#x3D;’任务表’;</p>
<p>task_rfid 是业务主键，当然都是数字，查询时使用sql：</p>
<p>select * from task where task_rfid &#x3D;123;</p>
<p>其实这个语句也有隐式转换问题，但是待执行任务只有几千条记录，并没有什么感觉。这个表还有个对应的历史表，数据有几千万</p>
<p>忽然有一天，想查一下历史记录，执行语句</p>
<p>select * from task_history where task_rfid &#x3D;99;</p>
<p>直接就等待很长时间后超时报错了。如果仔细看，其实我的表没有task_rfid 索引，写成task_rfid &#x3D;‘99’也一样是全表扫描。运维时的套路是，猜测主键task_id的范围，怎么猜，我原表有creat_time字段，我会先查</p>
<p>select max(task_id) from task_history 然后再看看 select * from task_history where task_id &#x3D; m</p>
<p>axId - 10000的时间，估计出大概的id范围。然后语句变成</p>
<p>select * from task_history where task_rfid &#x3D;99 and id between ？ and ？;</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>你最后这个id预估，加上between ，</p>
<p>有种神来之笔的感觉 </p>
<p>感觉隐约里面有二分法的思想</p>
<p>  </p>
<p>2018-12-24</p>
<p>可凡不凡   1</p>
<p>1.老师好</p>
<p>2.如果在用一个 MySQL 关键字做字段,并且字段上索引,当我用这个索引作为唯一查询条件的时</p>
<p>候 ,会 造 成隐式的转换吗? </p>
<p>例如:SELECT * FROM b_side_order WHERE CODE &#x3D; 332924 ; (code 上有索引)</p>
<ol start="3">
<li>mysql5.6 code 上有索引 intime 上没有索引</li>
</ol>
<p>语句一:</p>
<p>SELECT * FROM b_side_order WHERE CODE &#x3D; 332924 ;</p>
<p>语句二;</p>
<p>UPDATE b_side_order SET in_time &#x3D; ‘2018-08-04 08:34:44’ WHERE 1&#x3D;2 or CODE &#x3D; 332924;</p>
<p>这两个语句 执行计划走 select 走了索引,update 没有走索引 是执行计划的bug 吗??</p>
<p>2018-12-25</p>
<p> 作者回复</p>
<ol>
<li><p>你好 </p>
</li>
<li><p>CODE不是关键字呀， 另外优化器选择跟关键字无关哈，关键字的话，要用 反‘ 括起来</p>
</li>
<li><p>不是bug, update如果把 or 改成 and , 就能走索引 </p>
</li>
</ol>
<p>2018-12-25</p>
<p>冠超   0</p>
<p>非常感谢老师分享的内容，实打实地学到了。这里提个建议，希望老师能介绍一下设计表的时</p>
<p>候要怎么考虑这方面的知识哈 </p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p>是这样的，其实我们整个专栏大部分的文章，最后都是为了说明 “怎么设计表”、“怎么考虑优化</p>
<p>SQL语句”</p>
<p>但是因为这个不是一成不变的，很多是需要考虑现实的情况，</p>
<p>所以这个专栏就是想把对应的原理说一下，这样大家在应对不同场景的时候，可以组合来考虑</p>
<p>。也就是说没有一段话可以把“怎么设计表”讲清楚（或者说硬写出来很可能就是一些general的没</p>
<p>有什么针对性作用的描述）</p>
<p>你可以把你的业务背景抽象说下，我们来具体讨论吧</p>
<p>2019-01-28</p>
<p>700   0</p>
<p>老师您好，有个问题恳请指教。背景如下，我长话短说：</p>
<p>mysql&gt;select @@version;</p>
<p>5.6.30-log</p>
<p>CREATE TABLE <code>t1</code> ( <code>id</code> int(11) unsigned NOT NULL AUTO_INCREMENT,</p>
<p><code>user_id</code> int(11) NOT NULL, <code>plan_id</code> int(11) NOT NULL DEFAULT ‘0’ , PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>userid</code> (<code>user_id</code>) USING BTREE, KEY <code>idx_planid</code> (<code>plan_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;gb2312;</p>
<p>CREATE TABLE <code>t3</code> (</p>
<p><code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p><code>status</code> int(4) NOT NULL DEFAULT ‘0’,</p>
<p><code>ootime</code> varchar(11) DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>idx_xxoo</code> (<code>status</code>,<code>ootime</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</p>
<p>t1 和 t3 表的字符集不一样</p>
<p>sql 执行计划如下：</p>
<p>explain</p>
<p>SELECT t1.id, t1.user_id</p>
<p>FROM t1, t3</p>
<p>WHERE t1.plan_id &#x3D; t3.id</p>
<p>AND t3.ootime &lt; UNIX_TIMESTAMP(‘2022-01-18’)</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>| 1 | SIMPLE | t3 | index | PRIMARY | idx_xxoo | 51 | NULL | 39106 | Using where; Using index</p>
<p>|</p>
<p>| 1 | SIMPLE | t1 | ref | idx_planid | idx_planid | 4 | t3.id | 401 | Using join buffer (Batched Key Ac</p>
<p>cess) |</p>
<p>+—-+————-+——-+——-+—————+————–+———+————–+——-+—————-</p>
<p>————————+</p>
<p>我的疑惑是</p>
<p>1)t3 的 status 没出现在 where 条件中，但执行计划为什么用到了 idex_xxoo 索引？2)为什么 t3.ootime 也用到索引了，从 key_len 看出。t3.ootime 是 varchar 类型的，而 UNIX_TI</p>
<p>MESTAMP(‘2022-01-18’) 是数值，不是发生了隐式转换吗？请老师指点。2019-01-18</p>
<p> 作者回复</p>
<p>这个查询语句会对t3做全索引扫描，是使用了索引的，只是没有用上快速搜索功能</p>
<p>2019-01-19</p>
<p>赖阿甘   0</p>
<p>“mysql&gt;select l.operator from tradelog l , trade_detail d where d.tradeid&#x3D;l.tradeid and d.id&#x3D;4;”</p>
<p>图6上面那句sql是不是写错了。d.tradeid&#x3D;l.tradeid是不是该写成l.tradeid &#x3D; d.tradeid？不然函数</p>
<p>会作用在索引字段上，就只能全表扫描了</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>这个问题不是等号顺序决定的哈</p>
<p>好问题</p>
<p>2018-12-24</p>
<p>Leon    16</p>
<p>索引字段不能进行函数操作，但是索引字段的参数可以玩函数，一言以蔽之</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>精辟 </p>
<p>2018-12-24</p>
<p>探索无止境   5</p>
<p>多表连接时，mysql是怎么选择驱动表和被驱动表的？这个很重要，希望老师可以讲讲</p>
<p>2018-12-25</p>
<p>可凡不凡   5</p>
<p>1.老师对于多表联合查询中,MySQL 对索引的选择 以后会详细介绍吗?</p>
<p>2018-12-24</p>
<p> 作者回复</p>
<p>额，你是第三个提这个问题的了，我得好好考虑下安排 </p>
<p>2018-12-24</p>
<p>某、人   4</p>
<p>SQL逻辑相同,性能差异较大的,通过老师所讲学习到的,和平时碰到的,大概有以下几类:</p>
<p>一.字段发生了转换,导致本该使用索引而没有用到索引</p>
<p>1.条件字段函数操作</p>
<p>2.隐式类型转换</p>
<p>3.隐式字符编码转换</p>
<p>(如果驱动表的字符集比被驱动表得字符集小，关联列就能用到索引,如果更大,需要发生隐式编</p>
<p>码转换,则不能用到索引,latin&lt;gbk&lt;utf8&lt;utf8mb4)</p>
<p>二.嵌套循环,驱动表与被驱动表选择错误</p>
<p>1.连接列上没有索引,导致大表驱动小表,或者小表驱动大表(但是大表走的是全表扫描) –连接列</p>
<p>上建立索引</p>
<p>2.连接列上虽然有索引,但是驱动表任然选择错误。–通过straight_join强制选择关联表顺序</p>
<p>3.子查询导致先执行外表在执行子查询,也是驱动表与被驱动表选择错误。 </p>
<p>–可以考虑把子查询改写为内连接,或者改写内联视图(子查询放在from后组成一个临时表,在于</p>
<p>其他表进行关联)</p>
<p>4.只需要内连接的语句,但是写成了左连接或者右连接。比如select * from t left join b on t.id&#x3D;b.id</p>
<p>where b.name&#x3D;’abc’驱动表被固定,大概率会扫描更多的行,导致效率降低. </p>
<p>–根据业务情况或sql情况,把左连接或者右连接改写为内连接</p>
<p>三.索引选择不同,造成性能差异较大</p>
<p>1.select * from t where aid&#x3D; and create_name&gt;’’ order by id limit 1;</p>
<p>选择走id索引或者选择走(aid,create_time)索引,性能差异较大.结果集都有可能不一致</p>
<p>–这个可以通过where条件过滤的值多少来大概判断,该走哪个索引</p>
<p>四.其它一些因素</p>
<p>1.比如之前学习到的是否有MDL X锁</p>
<p>2.innodb_buffer_pool设置得太小,innodb_io_capacity设置得太小,刷脏速度跟不上</p>
<p>3.是否是对表做了DML语句之后,马上做select,导致change buffer收益不高</p>
<p>4.是否有数据空洞</p>
<p>5.select选取的数据是否在buffer_pool中</p>
<p>6.硬件原因,资源抢占</p>
<p>原因多种多样,还需要慢慢补充。老师我问一个问题:</p>
<p>连接列上一个是int一个是bigint或者一个是char一个varchar,为什么被驱动表上会出现(using inde</p>
<p>x condition)?</p>
<p>2018-12-24</p>
<p>Destroy、   2</p>
<p>老师，对于最后回答上一课的问题：mysql&gt; select * from t limit N, M-N+1;</p>
<p>这个语句也不是取3条记录。 没理解。2018-12-27</p>
<p> 作者回复</p>
<p>取其中三条…</p>
<p>2018-12-27</p>
<p>风轨   2</p>
<p>刚试了文中穿插得思考题:当主键是整数类型条件是字符串时，会走索引。文中提到了当字符串和数字比较时会把字符串转化为数字，所以隐式转换不会应用到字段上，</p>
<p>所以可以走索引。另外，select ‘a’ &#x3D; 0 ; 的结果是1，说明无法转换成数字的字符串都被转换成0来处理了。2018-12-24</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-24</p>
<p>匿名的朋友   1</p>
<p>丁奇老师，我有个疑问，就是sql语句执行时那些order by group by limit 以及where条件，有执</p>
<p>行的先后顺序吗？2019-01-05</p>
<p> 作者回复</p>
<p>有，先where ,再order by 最后limit</p>
<p>2019-01-05</p>
<p>大坤   1</p>
<p>之前遇到过按时间范围查询大表不走索引的情况，如果缩小时间范围，又会走索引，记得在一</p>
<p>些文章中看到过结果数据超过全表的30%就会走全表扫描，但是前面说的时间范围查询大表，</p>
<p>这个时间范围绝对是小于30%的情况，想请教下老师，这个优化器都是在什么情况下会放弃索</p>
<p>引呢？2018-12-25</p>
<p> 作者回复</p>
<p>总体来说就是判断哪种方式消耗更小，选哪种</p>
<p>2018-12-25</p>
<p>Leon    1</p>
<p>老师，经常面试被问到工作中做了什么优化，有没有好的业务表的设计，请问老师课程结束后</p>
<p>能不能给我们一个提纲挈领的大纲套路，让我们有个脉络和思路来应付这种面试套路</p>
<p>2018-12-25</p>
<p> 作者回复</p>
<p>有没有好的业务表的设计，这类问题我第一次听到，能不能展开一下，这样说不要清楚面试官</p>
<p>的考核点是啥…</p>
<p>2018-12-25</p>
<p>果然如此   1</p>
<p>我想问一个上期的问题，随机算法2虽然效率高，但是还是有个瑕疵，比如我们的随机出题算法</p>
<p>无法直接应用，因为每次随机一个试题id，多次随机没有关联，会产生重复id，有没有更好的解</p>
<p>决方法？2018-12-25</p>
<p> 作者回复</p>
<p>内存里准备个set这样的数据结构，重读的不算，这样可以不 </p>
<p>2018-12-25</p>
<p>长杰   1</p>
<p>这里我给出一种方法，取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，</p>
<p>然后执行下面这条 SQL 语句：</p>
<p>mysql&gt; select * from t limit N, M-N+1;</p>
<p>再加上取整个表总行数的 C 行，这个方案的扫描行数总共只需要 C+M 行。优化后的方案应该是C+M+1行吧？2018-12-24</p>
<p> 作者回复</p>
<p>你说的对  ，我改下</p>
<p>2018-12-25</p>
<p>asdf100   1</p>
<p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_mo</p>
<p>dified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得</p>
<p>更快。优化器如何对比的，根据参与字段字段类型占用空间大小吗？2018-12-24</p>
<p> 作者回复</p>
<p>优化器信息是引擎给的，</p>
<p>引擎是这么判断的</p>
<p>2018-12-24</p>
<p>约书亚   1</p>
<p>谁是驱动表谁是被驱动表，是否大多数情况看where条件就可以了？这是否本质上涉及到mysql</p>
<p>底层决定用什么算法进行级联查询的问题？后面会有课程详细说明嘛？2018-12-24</p>
<p> 作者回复</p>
<p>可以简单看where之后剩下的行数（预判不一定准哈）</p>
<p>2018-12-24</p>
<p>Lukia   0</p>
<p>老师好，之前看了《数据索引与优化》，提到表之间的连接操作可以有嵌套循环连接（本文中</p>
<p>提到的驱动表和被驱动表）和合并扫描连接（先在临时表中针对谓词作排序）还有哈希连接。请问MySQL中是否存在后面两种方式的连接，如果有的话优化器会在什么情况下选择呢？谢谢</p>
<p>！</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<p>第34、35两篇就会说到了，今晚关注下 </p>
<p>2019-01-29</p>
<p>涛哥哥   0</p>
<p>老师，您好！我是做后端开发的。想问一下 mysql in关键字 的内部原理，能抽一点点篇幅讲一</p>
<p>下吗？比如：select * from T where id in (a,b,d,c,,e,f); id是主键。1、为什么查询出来的结果集</p>
<p>会按照id排一次序呢（是跟去重有关系么）？2、如果 in 里面的值较多的时候，就会比较慢啊（</p>
<p>是还不如全表扫描么）？问我们公司很多后端的，都不太清楚，问我们DBA，他说默认就是这</p>
<p>样（这不跟没说一样吗）。希望老师可以帮忙解惑。祝老师身体健康！微笑~</p>
<p>2019-01-26</p>
<p> 作者回复</p>
<ol>
<li>优化器会排个序，目的是如果这几个记录对应的数据都不在内存里，可以触发顺序读盘，后</li>
</ol>
<p>面文章我们介绍到join的时候，会提到MRR，你关注下</p>
<ol start="2">
<li>in里面值多就是多次执行树搜索，跟全表扫描的速度对比，就看in里面的数据个数的比例了。你的in里面一般多少个value呀</li>
</ol>
<p>2019-01-26</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-事务到底是隔离的还是不隔离的</title>
    <url>/posts/c6101e2f.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>08 | 事务到底是隔离的还是不隔离的？2018-11-30 林晓斌</p>
<p>我在第3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时</p>
<p>候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的</p>
<p>仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无</p>
<p>争，不受外界影响。但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外</p>
<p>一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进</p>
<p>入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？我给你举一个例子吧。下面是一个只有两行的表的初始化语句。mysql&gt; CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>k</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t(id, k) values(1,1),(2,2);</p>
<p>图1 事务A、B、C的执行流程</p>
<p>这里，我们需要注意的是事务的启动时机。begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表</p>
<p>的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with</p>
<p>consistent snapshot 这个命令。还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认</p>
<p>autocommit&#x3D;1。在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，</p>
<p>语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时</p>
<p>间顺序上是在事务B的查询之后。这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕</p>
<p>呢？所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能</p>
<p>够帮助你对InnoDB的事务和锁有更进一步的理解。在MySQL里，有两个“视图”的概念：</p>
<p>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持</p>
<p>RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。在第3篇文章《事务隔离：为什么你改了我还看不见？》中，我跟你解释过一遍MVCC的实现逻</p>
<p>辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这</p>
<p>两篇文章的说明来更深一步地理解MVCC。“快照”在MVCC里是怎么工作的？在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷</p>
<p>贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向</p>
<p>InnoDB的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且</p>
<p>把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，</p>
<p>并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。如图2所示，就是一个记录被多个事务连续更新后的状态。图2 行状态变更图</p>
<p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id</p>
<p>为25的事务更新的，因此它的row trx_id也是25。你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，undo log</p>
<p>在哪呢？实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而</p>
<p>是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依</p>
<p>次执行U3、U2算出来。明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照</p>
<p>的。按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这</p>
<p>个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我</p>
<p>启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版</p>
<p>本”。当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数</p>
<p>据，它自己还是要认的。在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活</p>
<p>跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水</p>
<p>位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。这个视图数组把所有的row trx_id 分成了几种不同的情况。图3 数据版本可见性规则</p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是</li>
</ol>
<p>可见的；</p>
<ol start="2">
<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>
</li>
<li><p>如果落在黄色部分，那就包括两种情况</p>
</li>
</ol>
<p>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；</p>
<p>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据</p>
<p>时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版</p>
<p>本是不存在的，所以这个事务的快照，就是“静态”的了。所以你现在知道了，InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建</p>
<p>快照”的能力。接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k&#x3D;1。这里，我们不妨做如下假设：</p>
<ol>
<li><p>事务A开始前，系统里面只有一个活跃事务ID是99；</p>
</li>
<li><p>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</p>
</li>
<li><p>三个事务开始前，(1,1）这一行数据的row trx_id是90。这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是</p>
</li>
</ol>
<p>[99,100,101,102]。为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p>
<p>图4 事务A查询数据逻辑图</p>
<p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最</p>
<p>新版本的row trx_id是102，而90这个版本已经成为了历史版本。第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row</p>
<p>trx_id）是101，而102又成为了历史版本。你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已</p>
<p>经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起</p>
<p>的。所以，事务A查询语句的读数据流程是这样的：</p>
<p>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</p>
<p>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</p>
<p>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据</p>
<p>的结果都是一致的，所以我们称之为一致性读。这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以</p>
<p>外，有三种情况：</p>
<ol>
<li><p>版本未提交，不可见；</p>
</li>
<li><p>版本已提交，但是是在视图创建后提交的，不可见；</p>
</li>
<li><p>版本已提交，而且是在视图创建前提交的，可见。现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的</p>
</li>
</ol>
<p>时候生成的，这时候：</p>
<p>(1,3)还没提交，属于情况1，不可见；</p>
<p>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</p>
<p>(1,1)是在视图数组创建之前提交的，可见。你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们</p>
<p>就都用这个规则来分析。更新逻辑</p>
<p>细心的同学可能有疑问了：事务B的update语句，如果按照一致性读，好像结果不对哦？你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能</p>
<p>算出(1,3)来？图5 事务B更新逻辑图</p>
<p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。所以，这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的</p>
<p>值，称为“当前读”（current read）。因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本</p>
<p>的row trx_id是101。所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是</p>
<p>自己的更新，可以直接使用，所以查询得到的k的值是3。这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是</p>
<p>当前读。所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或</p>
<p>for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是</p>
<p>分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？图6 事务A、B、C’的执行流程</p>
<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过</p>
<p>了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事</p>
<p>务B的更新语句会怎么处理呢？这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)</p>
<p>这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被</p>
<p>锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。mysql&gt; select k from t where id&#x3D;1 lock in share mode;</p>
<p>mysql&gt; select k from t where id&#x3D;1 for update;</p>
<p>图7 事务B更新逻辑图（配合事务C’）</p>
<p>到这里，我们把一致性读、当前读和行锁就串起来了。现在，我们再回到文章开头的问题：事务的可重复读的能力是怎么实现的？可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如</p>
<p>果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<p>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询</p>
<p>都共用这个一致性视图；</p>
<p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多</p>
<p>少呢？这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创</p>
<p>建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于</p>
<p>普通的start transaction。下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图</p>
<p>中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p>
<p>图8 读提交隔离级别下的事务状态图</p>
<p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成</p>
<p>时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<p>(1,3)还没提交，属于情况1，不可见；</p>
<p>(1,2)提交了，属于情况3，可见。所以，这时候事务A查询语句返回的是k&#x3D;2。显然地，事务B查询结果k&#x3D;3。小结</p>
<p>InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一</p>
<p>致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的</p>
<p>可见性。对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</p>
<p>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</p>
<p>而当前读，总是读取已经提交完成的最新版本。你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有</p>
<p>row trx_id，因此只能遵循当前读的逻辑。当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复</p>
<p>读。又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情</p>
<p>况。请你构造出这种情况，并说明其原理。mysql&gt; CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>c</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);</p>
<p>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码</p>
<p>会不会掉进这个“坑”里，你又是怎么解决的呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后，留给你的问题是：怎么删除表的前10000行。比较多的留言都选择了第二</p>
<p>种方式，即：在一个连接中循环执行20次 delete from T limit 500。确实是这样的，第二种方式是相对较好的。第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也</p>
<p>比较长；而且大事务还会导致主从延迟。第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。评论区留言点赞板：</p>
<p>@Tony Du的评论，详细而且准确。@Knight²º¹  提到了如果可以加上特定条件，将这10000行天然分开，可以考虑第三种。是</p>
<p>的，实际上在操作的时候我也建议你尽量拿到ID再删除。@荒漠甘泉 提了一个不错的问题，大家需要区分行锁、MDL锁和表锁的区别。对InnoDB表更</p>
<p>新一行，可能过了MDL关，却被挡在行锁阶段。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-主库出问题了从库怎么办</title>
    <url>/posts/fc93d163.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>27 | 主库出问题了，从库怎么办？2019-01-14 林晓斌</p>
<p>在前面的第24、25和26篇文章中，我和你介绍了MySQL主备复制的基础结构，但这些都是一主</p>
<p>一备的结构。大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性</p>
<p>能的问题。而在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构：一主多</p>
<p>从。今天这篇文章，我们就先聊聊一主多从的切换正确性。然后，我们在下一篇文章中再聊聊解决一</p>
<p>主多从的查询逻辑正确性的方法。如图1所示，就是一个基本的一主多从结构。图1 一主多从基本结构</p>
<p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一</p>
<p>主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分</p>
<p>担。今天我们要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。如图2所示，就是主库发生故障，主备切换后的结果。图2 一主多从基本结构–主备切换</p>
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也</p>
<p>要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增</p>
<p>加了。接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。基于位点的主备切换</p>
<p>这里，我们需要先来回顾一个知识点。当我们把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p>
<p>CHANGE MASTER TO </p>
<p>MASTER_HOST&#x3D;$host_name </p>
<p>MASTER_PORT&#x3D;$port </p>
<p>MASTER_USER&#x3D;$user_name </p>
<p>MASTER_PASSWORD&#x3D;$password </p>
<p>MASTER_LOG_FILE&#x3D;$master_log_name </p>
<p>MASTER_LOG_POS&#x3D;$master_log_pos  </p>
<p>这条命令有这么6个参数：</p>
<p>MASTER_HOST、MASTER_PORT、MASTER_USER和MASTER_PASSWORD四个参</p>
<p>数，分别代表了主库A’的IP、端口、用户名和密码。最后两个参数MASTER_LOG_FILE和MASTER_LOG_POS表示，要从主库的</p>
<p>master_log_name文件的master_log_pos这个位置的日志继续同步。而这个位置就是我们所</p>
<p>说的同步位点，也就是主库对应的文件名和日志偏移量。那么，这里就有一个问题了，节点B要设置成A’的从库，就要执行change master命令，就不可</p>
<p>避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同</p>
<p>的。因此，从库B要切换的时候，就需要先经过“找同步位点”这个逻辑。这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通</p>
<p>过判断跳过那些在从库B上已经执行过的事务。一种取同步位点的方法是这样的：</p>
<ol>
<li><p>等待新主库A’把中转日志（relay log）全部同步完成；</p>
</li>
<li><p>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</p>
</li>
<li><p>取原主库A故障的时刻T；</p>
</li>
<li><p>用mysqlbinlog工具解析A’的File，得到T时刻的位点。图3 mysqlbinlog 部分输出结果</p>
</li>
</ol>
<p>图中，end_log_pos后面的值“123”，表示的就是A’这个实例，在T时刻写入新的binlog的位置。然后，我们就可以把123这个值作为$master_log_pos ，用在节点B的change master命令里。mysqlbinlog File –stop-datetime&#x3D;T –start-datetime&#x3D;T</p>
<p>当然这个值并不精确。为什么呢？你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一</p>
<p>行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。那么，这时候系统的状态是这样的：</p>
<ol>
<li><p>在从库B上，由于同步了binlog， R这一行已经存在；</p>
</li>
<li><p>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</p>
</li>
<li><p>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行</p>
</li>
</ol>
<p>数据的binlog又同步到从库B去执行。这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出</p>
<p>现了主键冲突，然后停止同步。所以，通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方</p>
<p>法。一种做法是，主动跳过一个事务。跳过命令的写法是：</p>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库</p>
<p>A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情</p>
<p>况，以此来跳过可能涉及的所有事务。另外一种方式是，通过设置slave_skip_errors参数，直接设置跳过指定的错误。在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<p>1062错误是插入数据时唯一键冲突；</p>
<p>1032错误是删除数据时找不到行。因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳</p>
<p>过。这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同</p>
<p>步位点，所以只能采用这种方法来创建从库和新主库的主备关系。这个背景是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，所以</p>
<p>set global sql_slave_skip_counter&#x3D;1;</p>
<p>start slave;</p>
<p>才可以这么设置slave_skip_errors参数。等到主备间的同步关系建立完成，并稳定执行一段时间</p>
<p>之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。GTID</p>
<p>通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以</p>
<p>建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6</p>
<p>版本引入了GTID，彻底解决了这个困难。那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍</p>
<p>一下。GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成</p>
<p>的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<p>其中：</p>
<p>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</p>
<p>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。这里我需要和你说明一下，在MySQL的官方文档里，GTID格式是这么定义的：</p>
<p>这里的source_id就是server_uuid；而后面的这个transaction_id，我觉得容易造成误导，所以我</p>
<p>改成了gno。为什么说使用transaction_id容易造成误解呢？因为，在MySQL里面我们说transaction_id就是指事务id，事务id是在事务执行过程中分配的，如</p>
<p>果这个事务回滚了，事务id也会递增，而gno是在事务提交的时候才会分配。从效果上看，GTID往往是连续的，因此我们用gno来表示更容易理解。GTID模式的启动也很简单，我们只需要在启动一个MySQL实例的时候，加上参数gtid_mode&#x3D;on</p>
<p>和enforce_gtid_consistency&#x3D;on就可以了。在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种</p>
<p>方式取决于session变量gtid_next的值。1. 如果gtid_next&#x3D;automatic，代表使用默认值。这时，MySQL就会把server_uuid:gno分配给</p>
<p>GTID&#x3D;server_uuid:gno</p>
<p>GTID&#x3D;source_id:transaction_id</p>
<p>这个事务。a. 记录binlog的时候，先记录一行 SET @@SESSION.GTID_NEXT&#x3D;‘server_uuid:gno’;</p>
<p>b. 把这个GTID加入本实例的GTID集合。2. 如果gtid_next是一个指定的GTID的值，比如通过set gtid_next&#x3D;’current_gtid’指定为</p>
<p>current_gtid，那么就有两种可能：</p>
<p>a. 如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽</p>
<p>略；</p>
<p>b. 如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执</p>
<p>行的事务，也就是说系统不需要给这个事务生成新的GTID，因此gno也不用加1。注意，一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要</p>
<p>执行set 命令，把gtid_next设置成另外一个gtid或者automatic。这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明GTID的基本用法。我们在实例X中创建一个表t。图4 初始化数据的binlog</p>
<p>可以看到，事务的BEGIN之前有一条SET @@SESSION.GTID_NEXT命令。这时，如果实例X</p>
<p>有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先</p>
<p>执行这两个SET命令， 这样被加入从库的GTID集合的，就是图中的这两个GTID。CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(1,1);</p>
<p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p>
<p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同</p>
<p>步线程停止。这时，我们应该怎么处理呢？处理方法就是，你可以执行下面的这个语句序列：</p>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。如</p>
<p>图5所示，就是执行完这个空事务之后的show master status的结果。图5 show master status结果</p>
<p>可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID。这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y</p>
<p>传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集</p>
<p>合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。在上面的这个语句序列中，start slave命令之前还有一句set gtid_next&#x3D;automatic。这句话的作</p>
<p>用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分</p>
<p>配方式，继续分配gno&#x3D;3。insert into t values(1,1);</p>
<p>set gtid_next&#x3D;’aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10’;</p>
<p>begin;</p>
<p>commit;</p>
<p>set gtid_next&#x3D;automatic;</p>
<p>start slave;</p>
<p>基于GTID的主备切换</p>
<p>现在，我们已经理解GTID的概念，再一起来看看基于GTID的主备复制的用法。在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p>
<p>其中，master_auto_position&#x3D;1就表示这个主备关系使用的是GTID协议。可以看到，前面让我</p>
<p>们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。我们把现在这个时刻，实例A’的GTID集合记为set_a，实例B的GTID集合记为set_b。接下来，</p>
<p>我们就看看现在的主备切换逻辑。我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p>
<ol>
<li>实例B指定主库A’，基于主备协议建立连接。2. 实例B把set_b发给主库A’。3. 实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GITD的</li>
</ol>
<p>集合，判断A’本地是否包含了这个差集需要的所有binlog事务。a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误；</p>
<p>b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；</p>
<ol start="4">
<li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备</li>
</ol>
<p>关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存</p>
<p>在，A’就拒绝把日志发给B。这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就</p>
<p>发哪个位点，不做日志的完整性判断。基于上面的介绍，我们再来看看引入GTID后，一主多从的切换场景下，主备切换是如何实现</p>
<p>的。CHANGE MASTER TO </p>
<p>MASTER_HOST&#x3D;$host_name </p>
<p>MASTER_PORT&#x3D;$port </p>
<p>MASTER_USER&#x3D;$user_name </p>
<p>MASTER_PASSWORD&#x3D;$password </p>
<p>master_auto_position&#x3D;1 </p>
<p>由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令指向实例A’即可。其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例A’内部就已经自</p>
<p>动完成了。但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。之后这个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：</p>
<p>server_uuid_of_A’:1-M。如果之前从库B的GTID集合格式是 server_uuid_of_A:1-N， 那么切换之后GTID集合的格式就变</p>
<p>成了server_uuid_of_A:1-N, server_uuid_of_A’:1-M。当然，主库A’之前也是A的备库，因此主库A’和从库B的GTID集合是一样的。这就达到了我们预</p>
<p>期。GTID和在线DDL</p>
<p>接下来，我再举个例子帮你理解GTID。之前在第22篇文章《MySQL有哪些“饮鸩止渴”提高性能的方法？》中，我和你提到业务高峰期</p>
<p>的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来</p>
<p>解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再</p>
<p>切换。当时我说，在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影</p>
<p>响，要通过set sql_log_bin&#x3D;off关掉binlog。评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是binlog并没有记</p>
<p>录下这一个更新，是不是会导致数据和日志不一致？这个问题提得非常好。当时，我在留言的回复中就引用了GTID来说明。今天，我再和你展开说</p>
<p>明一下。假设，这两个互为主备关系的库还是实例X和实例Y，且当前主库是X，并且都打开了GTID模</p>
<p>式。这时的主备切换流程可以变成下面这样：</p>
<p>在实例X上执行stop slave。在实例Y上执行DDL语句。注意，这里并不需要关闭binlog。执行完成后，查出这个DDL语句对应的GTID，并记为 server_uuid_of_Y:gno。到实例X上执行以下语句序列：</p>
<p>这样做的目的在于，既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这</p>
<p>条更新。接下来，执行完主备切换，然后照着上述流程再执行一遍即可。小结</p>
<p>在今天这篇文章中，我先和你介绍了一主多从的主备切换流程。在这个过程中，从库找新主库的</p>
<p>位点是一个痛点。由此，我们引出了MySQL 5.6版本引入的GTID模式，介绍了GTID的基本概念</p>
<p>和用法。可以看到，在GTID模式下，一主多从切换就非常方便了。因此，如果你使用的MySQL版本支持GTID的话，我都建议你尽量使用GTID模式来做一主多从</p>
<p>的切换。在下一篇文章中，我们还能看到GTID模式在读写分离场景的应用。最后，又到了我们的思考题时间。你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经</p>
<p>被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？你可以把你的方法写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上一篇文章最后，我给你留的问题是，如果主库都是单线程压力模式，在从库追主库的过程</p>
<p>中，binlog-transaction-dependency-tracking 应该选用什么参数？这个问题的答案是，应该将这个参数设置为WRITESET。由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER</p>
<p>模式的话，从库也只能单线程执行。同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须</p>
<p>set GTID_NEXT&#x3D;”server_uuid_of_Y:gno”;</p>
<p>begin;</p>
<p>commit;</p>
<p>set gtid_next&#x3D;automatic;</p>
<p>start slave;</p>
<p>与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。所以，应该将binlog-transaction-dependency-tracking 设置为WRITESET。评论区留言点赞板：</p>
<p>Mr.Strive.Z.H.L   1</p>
<p>老师您好：</p>
<p>在实际工作中，主从备份似乎是mysql用的最多的高可用方案。但是个人认为主从备份这个方案的问题实在太多了：</p>
<ol>
<li>binlog数据传输前，主库宕机，导致提交了的事务数据丢失。2. 一主多从，即使采用半同步，也只能保证binlog至少在两台机器上，没有一个机制能够选出</li>
</ol>
<p>拥有最完整binlog的从库作为新的主库。3. 主从切换涉及到 人为操作，而不是全自动化的。即使在使用GTID的情况下，也会有binlog被</p>
<p>删除，需要重新做从库的情况。4. 互为主备，如果互为主备的两个实例全部宕机，mysql直接不可用。@慧鑫coming 问了一个好问题，对同一行作更新的几个事务，如果commit_id相同，是不是在</p>
<p>备库并行执行的时候会导致数据不一致？这个问题的答案是更新同一行的事务是不可能同时进</p>
<p>入commit状态的。@老杨同志 对这个问题给出了更详细的回答，大家可以去看一下。精选留言</p>
<p>mysql应该有更强大更完备的高可用方案（类似于zab协议或者raft协议这种），而在实际环境</p>
<p>下，为什么主从备份用得最多呢？2019-01-18</p>
<p> 作者回复</p>
<p>3 这个应该是可以做到自动化的。4 这个概率比较小，其实即使是别的三节点的方案，也架不住挂两个实例，所以这个不是MyS</p>
<p>QL主备的锅。前面两点提得很对哈。其实MySQL到现在，还是提供了很多方案可选的。很多是业务权衡的结果。比如说，异步复制，在主库异常掉电的时候可能会丢数据。这个大家知道以后，有一些就改成semi-sync了，但是还是有一些就留着异步复制的模式，因为</p>
<p>semi-sync有性能影响（一开始35%，现在好点15%左右，看具体环境），而可能这些业务认为</p>
<p>丢一两行，可以从应用层日志去补。 就保留了异步复制模式。最后，为什么主从备份用得最多，我觉得有历史原因。多年前MySQL刚要开始火的时候，大家</p>
<p>发现这个主备模式好方便，就都用了。而基于其他协议的方案，都是后来出现的，并且还是陆陆续续出点bug。涉及到线上服务，大家使用新方案的热情总是局限在测试环境的多。semi-sync也是近几年才开始稳定并被一些公司开始作为默认配置。新技术的推广，在数据库上，确实比其他领域更需要谨慎些，也算是业务决定的吧^_^</p>
<p>好问题 </p>
<p>以上仅一家之言哈 </p>
<p>2019-01-18</p>
<p>某、人   1</p>
<p>1.如果业务允许主从不一致的情况那么可以在主上先show global variables like ‘gtid_purged’;然</p>
<p>后在从上执行set global gtid_purged &#x3D;’ ‘.指定从库从哪个gtid开始同步,binlog缺失那一部分,数据</p>
<p>在从库上会丢失,就会造成主从不一致</p>
<p>2.需要主从数据一致的话,最好还是通过重新搭建从库来做。3.如果有其它的从库保留有全量的binlog的话，可以把从库指定为保留了全量binlog的从库为主</p>
<p>库(级联复制)</p>
<p>4.如果binlog有备份的情况,可以先在从库上应用缺失的binlog,然后在start slave</p>
<p>2019-01-15</p>
<p> 作者回复</p>
<p>非常好 </p>
<p>2019-01-15</p>
<p>悟空   0</p>
<p>看过上篇后想到一个问题:</p>
<p>级联复制A-&gt;B-&gt;C结构下, 从库C的Seconds_Behind_Master的时间计算问题.</p>
<p>假定当前主库A仅有一个DDL要进行变更,耗时1分钟.那么从库C的SBM值最大应该是多少时间?</p>
<p>是1分钟, 2分钟, 还是3分钟呢 ?</p>
<p>带着疑问看了一下测试从库C的binlog文件中的时间戳,得出结论应该是3分钟.</p>
<p>打破之前认知  ♀  . 请老师解惑 , 谢谢 !</p>
<p>2019-01-14</p>
<p> 作者回复</p>
<p>是的，因为算的是：当前执行时间，跟<em>日志时间</em>的差距</p>
<p>而这个日志时间，是在A上执行出来的。好问题，很好的验证过程。2019-01-14</p>
<p>张永志   2</p>
<p>今天问题回答：</p>
<p>GTID主从同步设置时，主库A发现需同步的GTID日志有删掉的，那么A就会报错。解决办法：</p>
<p>从库B在启动同步前需要设置 gtid_purged，指定GTID同步的起点，使用备份搭建从库时需要这</p>
<p>样设置。如果在从库上执行了单独的操作，导致主库上缺少GTID，那么可以在主库上模拟一个与从库B</p>
<p>上GTID一样的空事务，这样主从同步就不会报错了。2019-01-14</p>
<p> 作者回复</p>
<p>你已经理解GTID的机制啦 </p>
<p>2019-01-15</p>
<p>时隐时现   0</p>
<p>其实基于gtid复制有个大坑，在主库上千万不要执行reset master，否则从库不会报错，只会跳</p>
<p>过gno &lt; current_no的事务，造成一个现象就是主库复制没有中断，但是主库上的数据无法同步</p>
<p>到从库。2019-01-31</p>
<p> 作者回复</p>
<p>是的，</p>
<p>不过reset master这种语句。。就算是基于position的协议，谁在线上主库上执行，也是直接当</p>
<p>做删数据论处的了 </p>
<p>2019-01-31</p>
<p>Leon    0</p>
<p>从的执行是</p>
<p>CHANGE MASTER TO </p>
<p>MASTER_HOST&#x3D;”172.27.27.2”,</p>
<p>MASTER_PORT&#x3D;3306,</p>
<p>MASTER_USER&#x3D;”ming”,</p>
<p>MASTER_PASSWORD&#x3D;”123456”,</p>
<p>master_auto_position&#x3D;1;</p>
<p>start slave</p>
<p>2019-01-24</p>
<p>Leon    0</p>
<p>老师，我这边docker起了两个msyql，一主一从</p>
<p>主: </p>
<p>create user ‘ming‘@’172.27.27.2’ identified by ‘123456’;</p>
<p>GRANT REPLICATION SLAVE,RELOAD,SUPER ON <em>.</em> TO ‘ming‘@’%’ WITH GRANT OPTIO</p>
<p>N;</p>
<p>master 172.27.27.2 slave 172.27.27.3</p>
<p>从那边无法同步</p>
<p>Last_SQL_Errno: 1410</p>
<p>Last_SQL_Error: Error ‘You are not allowed to create a user with GRANT’ on query. Default dat</p>
<p>abase: ‘test’. Query: ‘GRANT REPLICATION SLAVE, REPLICATION CLIENT ON <em>.</em> TO ‘slave’</p>
<p>@’%’’</p>
<p>网上查询是授权问题，但是从容器内可以用ming的用户名和密码登录主mysql</p>
<p>我增加了授权还是这样，请问是什么情况</p>
<p>2019-01-24</p>
<p> 作者回复</p>
<p>你把这个create 语句直接到备库执行能执行吗？2019-01-28</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>之前讲过 互为主备 的场景下，会出现循环复制的问题，今天这节讲了GTID。如果使用GTID，那么 循环复制 的问题自然而然就解决了呀？？！！</p>
<p>2019-01-18</p>
<p> 作者回复</p>
<p>哈哈，you got it</p>
<p>2019-01-18</p>
<p>春困秋乏夏打盹   0</p>
<p>回答undifined的第二个问题</p>
<p>A-A’-B这样的级联结构</p>
<p>A (binlog：A:1-M)</p>
<p>A’(binlog: A:1-M,B:1-N) ,A’上面的操作记为B:1-N</p>
<p>B (binlog: A:1-M,B:1-N,C:1-X) B上面的操作记为C:1-X</p>
<p>—A,B,C分别为A-A’-B的uuid</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>对的</p>
<p>总之就是，一个主备关系里，备库的GTID集合应该包含主库的GTID集合。2019-01-16</p>
<p>tchz   0</p>
<p>1.purge gtid，2.重做备库数据</p>
<p>2019-01-15</p>
<p> 作者回复</p>
<p>2 是ok的</p>
<p>purge gtid是啥</p>
<p>2019-01-15</p>
<p>fuyu   0</p>
<p>seta 和 setb 里的集合大小不会很大？2019-01-15</p>
<p> 作者回复</p>
<p>大没关系呀，是分段的，比如 server_uuid_of_a:1-1000000，就一个段</p>
<p>2019-01-15</p>
<p>Leo   0</p>
<p>老师你好，PingCAP的大牛说分布式数据库的一个难点是时间同步。此话怎讲？mysql主从架构</p>
<p>下时间不同步会有哪些问题？2019-01-15</p>
<p> 作者回复</p>
<p>今晚发布的第28篇会提到哈</p>
<p>2019-01-15</p>
<p>_CountingStars   0</p>
<p>老师我有一个问题 如果数据库已经有完成了很多事务 实例 A’的 GTID集合和 实例 B的 GTID集</p>
<p>合 是不是很大，这个GTID是从binglog里一点一点的解析出来所有的事务的吗？这样是不是会</p>
<p>很慢 ？在所有binlog里定位某个GTID是不是效率也很低</p>
<p>2019-01-15</p>
<p> 作者回复</p>
<p>好问题， </p>
<p>在binlog文件开头，有一个Previous_gtids, 用于记录 “生成这个binlog的时候，实例的Executed_</p>
<p>gtid_set”, 所以启动的时候只需要解析最后一个文件；</p>
<p>同样的，由于有这个Previous_gtids，可以快速地定位GTID在哪个文件里。2019-01-15</p>
<p>小超   0</p>
<p>老师，问个上一篇的问题，从库不是只根据binlog来做相应的操作么，这个并行复制策略根据</p>
<p>事务相同commit_id判断好理解，但是根据同时进入redo log prepare 和 commit 来判断这个怎</p>
<p>么理解？事务提交的时候，其他事务的redo log处于prepare的状态事务的某个标识也会记录到</p>
<p>每一个事务的binlog中么？2019-01-14</p>
<p>PengfeiWang   0</p>
<p>老师，您好： 文中对于sql_slave_skip_counter&#x3D;1的理解似乎有偏差，官方文档中的解释是：</p>
<p>When you use SET GLOBAL sql_slave_skip_counter to skip events and the result is in the mid</p>
<p>dle of a group, the slave continues to skip events until it reaches the end of the group. Executio</p>
<p>n then starts with the next event group.</p>
<p>按照官方文档的解释，命令sql_slave_skip_counter&#x3D;1 应该是跳过一个事务中的1个event，除非</p>
<p>这个事务是有单个event组成的，才会跳过一个事务。2019-01-14</p>
<p> 作者回复</p>
<p>你这个是好问题，</p>
<p>确实只是跳过一个event，不过文档中说了呀</p>
<p>“the slave continues to skip events until it reaches the end of the group. ”， </p>
<p>所以效果上等效于跳过一个事务哦</p>
<p>2019-01-14</p>
<p>PengfeiWang   0</p>
<p>老师，你好：在生产环境（基于位点的主备切换）中，经常会遇到这样的场景：备库由于硬件</p>
<p>或其他原因异常宕机，恢复后重启备库，执行start slave命令，总会遇到1062主键重复的报错</p>
<p>，一直解释不清楚为什么？2019-01-14</p>
<p> 作者回复</p>
<p>看一下这个语句的结果, 会受这几个参数的影响哈</p>
<p>select * from information_schema.GLOBAL_VARIABLES where VARIABLE_NAME in (‘master_</p>
<p>info_repository’,’relay_log_info_repository’,’sync_master_info’,’sync_relay_log_info’, ‘sync_binl</p>
<p>og’, ‘innodb_flush_log_at_trx_commit’);</p>
<p>2019-01-14</p>
<p>路过   0</p>
<p>老师，请教：</p>
<p>show slave status\G的输出中，包含如下：</p>
<p>Executed_Gtid_Set: 572ece6c-e3ed-11e8-92c4-005056a509d8:1-1136659,</p>
<p>ecb34895-e3eb-11e8-80e9-005056a55d62:1-1015</p>
<p>是不是表示当前slave曾经和两个master同步过？2019-01-14</p>
<p> 作者回复</p>
<p>一个是它自己吧？select @@server_uuid 看看</p>
<p>2019-01-14</p>
<p>undifined   0</p>
<p>老师 有几个问题：</p>
<ol>
<li>会不会出现主库切换后，B 中已经执行过的事务，而 A’由于网络延迟还没有收到，此时已经</li>
</ol>
<p>对 B 执行切换主库，这时候，B 中有该 GTID，但是 A’中没有，这种情况会怎么处理</p>
<ol start="2">
<li>如果 A 是主库，A’ 备库，B 是 A’的从库，此时 B 的 GTID 集合应该是 server_uuid_of_A’:1-N</li>
</ol>
<p>，此时 A’宕机，B 改为监听 A，这时候A 和 B 的 GTID 集合没有交集，会不会发生 A 将所有的b</p>
<p>inlog 重新发给B</p>
<ol start="3">
<li>思考题我的理解是从主库中 dump 出相关的数据，在备库中执行后再次执行 start slave；评</li>
</ol>
<p>论中说到从其他从库获取，但是如果只有一主一从，有 binlog 丢失，是不是只要 dump 文件恢</p>
<p>复这一个办法</p>
<p>2019-01-14</p>
<p> 作者回复</p>
<ol>
<li>这个也是异步复制导致的，只有semi-sync能解了。。2. 不是哦，如果“ A 是主库，A’ 备库，B 是 A’的从库”，那所有A的更新也都会通过A’传给B，所</li>
</ol>
<p>以B的GTID集合正常就是包含了A和A’的</p>
<ol start="3">
<li>“如果只有一主一从，有 binlog 丢失”，是的，就只有备库重做了</li>
</ol>
<p>2019-01-16</p>
<p>亮   0</p>
<p>老师您好，假如a宕机了，需要把从切换到a’，这时候业务已经有感知了吧？怎么能让业务尽量</p>
<p>没有感知呢？谢谢老师</p>
<p>2019-01-14</p>
<p> 作者回复</p>
<p>这种情况下，不可能业务完全无感知，</p>
<p>但是如果业务代码有“重连并重试”的逻辑，并且切换足够快，就可以对业务无影响，前提是要</p>
<p>解决主备延迟问题，就是25、26两篇提到的</p>
<p>2019-01-14</p>
<p>大坤   0</p>
<p>今天问题回答，由于GTID具有全局唯一性，那么其它正常的gtid已经被复制到了其他从库上了</p>
<p>，只需要切换gtid到其他从库，等待同步完毕后在切换回主库即可</p>
<p>2019-01-14</p>
<p> 作者回复</p>
<p>这个想法很不错  </p>
<p>2019-01-14</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-什么时候会使用内部临时表</title>
    <url>/posts/e01f4df8.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>37 | 什么时候会使用内部临时表？2019-02-06 林晓斌</p>
<p>今天是大年初二，在开始我们今天的学习之前，我要先和你道一声春节快乐！</p>
<p>在第16和第34篇文章中，我分别和你介绍了sort buffer、内存临时表和join buffer。这三个数据</p>
<p>结构都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行的。其中，我们在排序的</p>
<p>时候用到了sort buffer，在使用join语句的时候用到了join buffer。然后，你可能会有这样的疑问，MySQL什么时候会使用内部临时表呢？今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作</p>
<p>的。然后，我们再来分析，什么情况下会使用内部临时表。union 执行流程</p>
<p>为了便于量化分析，我用下面的表t1来举例。然后，我们执行下面这条语句：</p>
<p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合</p>
<p>加起来，重复的行只保留一行。下图是这个语句的explain结果。图1 union语句explain 结果</p>
<p>可以看到：</p>
<p>第二行的key&#x3D;PRIMARY，说明第二个子句用到了索引id。第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using</p>
<p>temporary)。这个语句的执行流程是这样的：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。create table t1(id int primary key, a int, b int, index(a));</li>
</ol>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;1000)do</p>
<pre><code>insert into t1 values(i, i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>(select 1000 as f) union (select id from t1 order by id desc limit 2);</p>
<ol start="2">
<li>执行第一个子查询，得到1000这个值，并存入临时表中。3. 执行第二个子查询：</li>
</ol>
<p>拿到第一行id&#x3D;1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违</p>
<p>反了唯一性约束，所以插入失败，然后继续执行；</p>
<p>取到第二行id&#x3D;999，插入临时表成功。4. 从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和</p>
<p>999。这个过程的流程图如下所示：</p>
<p>图 2 union 执行流程</p>
<p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯</p>
<p>一性约束，实现了union的语义。顺便提一下，如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执</p>
<p>行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不</p>
<p>需要临时表了。图3 union all的explain结果</p>
<p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表</p>
<p>了。group by 执行流程</p>
<p>另外一个常见的使用临时表的例子是group by，我们来看一下这个语句：</p>
<p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。它</p>
<p>的explain结果如下：</p>
<p>图4 group by 的explain结果</p>
<p>在Extra字段里面，我们可以看到三个信息：</p>
<p>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；</p>
<p>Using temporary，表示使用了临时表；</p>
<p>Using filesort，表示需要排序。这个语句的执行流程是这样的：</p>
<ol>
<li><p>创建内存临时表，表里有两个字段m和c，主键是m；</p>
</li>
<li><p>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；</p>
</li>
</ol>
<p>如果临时表中没有主键为x的行，就插入一个记录(x,1);</p>
<p>如果表中有主键为x的行，就将x这一行的c值加1；</p>
<ol start="3">
<li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。这个流程的执行图如下：</li>
</ol>
<p>select id%10 as m, count(*) as c from t1 group by m;</p>
<p>图5 group by执行流程</p>
<p>图中最后一步，对内存临时表的排序，在第17篇文章中已经有过介绍，我把图贴过来，方便你</p>
<p>回顾。图6 内存临时表排序流程</p>
<p>其中，临时表的排序过程就是图6中虚线框内的过程。接下来，我们再看一下这条语句的执行结果：</p>
<p>图 7 group by执行结果</p>
<p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改</p>
<p>成：</p>
<p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图8所示。图8 group + order by null 的结果（内存临时表）</p>
<p>由于表t1中的id值是从1开始的，因此返回的结果集中第一行是id&#x3D;1；扫描到id&#x3D;10的时候才插入</p>
<p>m&#x3D;0这一行，因此结果集里最后一行才是m&#x3D;0。这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内</p>
<p>存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。如果我执行下面这个语句序列：</p>
<p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数</p>
<p>据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临</p>
<p>时表大小到达了上限（1024字节）。那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这</p>
<p>select id%10 as m, count(*) as c from t1 group by m order by null;</p>
<p>set tmp_table_size&#x3D;1024;</p>
<p>select id%100 as m, count(*) as c from t1 group by m order by null limit 10;</p>
<p>时，返回的结果如图9所示。图9 group + order by null 的结果（磁盘临时表）</p>
<p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。group by 优化方法 –索引</p>
<p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的</p>
<p>表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by语句执行起来就会很</p>
<p>慢，我们有什么优化的方法呢？要解决group by语句的优化问题，你可以先想一下这个问题：执行group by语句为什么需要临时</p>
<p>表？group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序</p>
<p>的，所以我们就需要有一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？假设，现在有一个类似图10的这么一个数据结构，我们来看看group by可以怎么做。图10 group by算法优化-有序输入</p>
<p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，</p>
<p>顺序扫描，依次累加。也就是下面这个过程：</p>
<p>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X);</p>
<p>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第一行就是(1,Y);</p>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时</p>
<p>表，也不需要再额外排序。你一定想到了，InnoDB的索引，就可以满足这个输入有序的条件。在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的</p>
<p>方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建</p>
<p>普通列和索引，来解决这个问题）。这样，索引z上的数据就是类似图10这样有序的了。上面的group by语句就可以改成：</p>
<p>alter table t1 add column z int generated always as(id % 100), add index(z);</p>
<p>优化后的group by语句的explain结果，如下图所示：</p>
<p>图11 group by 优化的explain结果</p>
<p>从Extra字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。group by优化方法 –直接排序</p>
<p>所以，如果可以通过加索引来完成group by逻辑就再好不过了。但是，如果碰上不适合创建索引</p>
<p>的场景，我们还是要老老实实做排序的。那么，这时候的group by要怎么优化呢？如果我们明明知道，一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先</p>
<p>放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就</p>
<p>有点儿傻。那么，我们就会想了，MySQL有没有让我们直接走磁盘临时表的方法呢？答案是，有的。在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉</p>
<p>及的数据量很大，请直接用磁盘临时表。MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉</p>
<p>我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。因此，下面这个语句</p>
<p>的执行流程就是这样的：</p>
<ol>
<li><p>初始化sort_buffer，确定放入一个整型字段，记为m；</p>
</li>
<li><p>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</p>
</li>
<li><p>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临</p>
</li>
</ol>
<p>时文件辅助排序）；</p>
<p>select z, count(*) as c from t1 group by z;</p>
<p>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</p>
<ol start="4">
<li>排序完成后，就得到了一个有序数组。根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面</li>
</ol>
<p>的图10中了解过了。下面两张图分别是执行流程图和执行explain命令得到的结果。图12 使用 SQL_BIG_RESULT的执行流程图</p>
<p>图13 使用 SQL_BIG_RESULT的explain 结果</p>
<p>从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。基于上面的union、union all和group by语句的执行过程的分析，我们来回答文章开头的问题：</p>
<p>MySQL什么时候会使用内部临时表？1. 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要</p>
<p>额外的内存，来保存中间结果；</p>
<ol start="2">
<li><p>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</p>
</li>
<li><p>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union</p>
</li>
</ol>
<p>需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。小结</p>
<p>通过今天这篇文章，我重点和你讲了group by的几种实现算法，从中可以总结一些使用的指导原</p>
<p>则：</p>
<ol>
<li><p>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</p>
</li>
<li><p>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using</p>
</li>
</ol>
<p>filesort；</p>
<ol start="3">
<li>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大</li>
</ol>
<p>tmp_table_size参数，来避免用到磁盘临时表；</p>
<ol start="4">
<li>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法</li>
</ol>
<p>得到group by的结果。最后，我给你留下一个思考题吧。文章中图8和图9都是order by null，为什么图8的返回结果里面，0是在结果集的最后一行，而图</p>
<p>9的结果里面，0是在结果集的第一行？你可以把你的分析写在留言区里，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎</p>
<p>你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是：为什么不能用rename修改临时表的改名。在实现上，执行rename table语句的时候，要求按照“库名&#x2F;表名.frm”的规则去磁盘找文件，但是</p>
<p>临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}<em>{线程id}</em></p>
<p>序列号.frm”，因此会报“找不到文件名”的错误。评论区留言点赞板：</p>
<p>@poppy 同学，通过执行语句的报错现象推测了这个实现过程。老杨同志   1</p>
<p>请教一个问题：如果只需要去重，不需要执行聚合函数，distinct 和group by那种效率高一些呢</p>
<p>？课后习题:</p>
<p>图8，把统计结果存内存临时表，不排序。id是从1到1000，模10的结果顺序就是1、2、3、4、</p>
<p>5。。。图9，老师把tmp_table_size改小了，内存临时表装不下，改用磁盘临时表。根据老师讲的流程</p>
<p>，id取模的结果，排序后存入临时表，临时的数据应该是0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,</p>
<p>……</p>
<p>从这个磁盘临时表读取数据汇总的结果的顺序就是0,1,2,3,4,5。。。2019-02-06</p>
<p> 作者回复</p>
<p>新年好</p>
<p>好问题，我加到后面文章中。简单说下结论，只需要去重的话，如果没有limit，是一样的；</p>
<p>有limit的话，distinct 快些。漂亮的回答 </p>
<p>精选留言</p>
<p>2019-02-07</p>
<p>Long   0</p>
<p>老师，新年好！ :-)</p>
<p>有几个版本差异的问题：</p>
<p>（1）图1中的执行计划应该是5.7版本以后的吧，貌似没找到说在哪个环境，我在5.6和5.7分别</p>
<p>测试了，id &#x3D; 2的那个rows，在5.6版本（5.6.26）是1000，在5.7版本是2行。应该是5.7做的优</p>
<p>化吧？（2）图 9 group + order by null 的结果（此盘临时表），这里面mysql5.6里面执行的结果是（1</p>
<p>，10），（2，10）…(10，10)，执行计划都是只有一样，没找到差异。跟踪下了下optimizer trace，发现问题应该是在临时表空间满的的时候，mysql5.7用的是：con</p>
<p>verting_tmp_table_to_ondisk “location”: “disk (InnoDB)”,，而mysql 5.6用的是converting_tmp_t</p>
<p>able_to_myisam “location”: “disk (MyISAM)”的原因导致的。查了下参数：</p>
<p>default_tmp_storage_engine。（5.6，5.7当前值都是innodb）</p>
<p>internal_tmp_disk_storage_engine（只有5.7有这个参数，当前值是innodb），5.6应该是默认磁</p>
<p>盘临时表就是MyISAM引擎的了，由于本地测试环境那个临时表的目录下找不到临时文件，也</p>
<p>没法继续分析了。。。至于为什么MySQL 5.6中结果展示m字段不是0-9而是1-10，还得请老师帮忙解答下了。还有几个小问题，为了方便解答，序号统一了：</p>
<p>（3）在阅读mysql执行计划的时候，看了网上有很多说法，也参考了mysql官网对id（select_id</p>
<p>）的解释：</p>
<p>id (JSON name: select_id)</p>
<p>The SELECT identifier. This is the sequential number of the SELECT within the query.（感觉这</p>
<p>个读起来也有点歧义，这个sequential字面解释感觉只有顺序的号码，并咩有说执行顺序）</p>
<p>比如图1，文中解释就是从ID小的往大的执行的，网上有很多其他说法，有的是说ID从大到小执</p>
<p>行，遇到ID一样的，就从上往下执行。有的说是从小往大顺序执行。不知道老师是否可以官方</p>
<p>讲解下。（4）我发现想搞懂一个原理，并且讲清楚让别人明白，真的是很有难度，非常感谢老师的分享</p>
<p>。这次专栏结束，还会推出的新的专栏吗？ 非常期待。2019-02-10</p>
<p>Laputa   0</p>
<p>老师好，文中说的不需要排序为什么不直接把orderby去掉而是写order by null</p>
<p>2019-02-08</p>
<p> 作者回复</p>
<p>MySQL 语义上这么定义的…</p>
<p>2019-02-08</p>
<p>HuaMax   0</p>
<p>课后题解答。图8是用内存临时表，文中已经提到，是按照表t1的索引a顺序取出数据，模10得0</p>
<p>的id是最后一行；图9是用硬盘临时表，默认用innodb 的索引，主键是id%10，因此存入硬盘后</p>
<p>再按主键树顺序取出，0就排到第一行了。2019-02-07</p>
<p>Li Shunduo   0</p>
<p>请问Group By部分的第一个语句 explain select id%10 as m, count(*) as c from t1 group by m；</p>
<p>为什么选择的是索引a，而不是primary key？如果字段a上有空值，使用索引a岂不是就不能取</p>
<p>到所有的id值了？2019-02-07</p>
<p> 作者回复</p>
<p>因为索引c的信息也足够，而且比主键索引小，使用索引c更会好。“如果字段a上有空值，使用索引a岂不是就不能取到所有的id值了？”，不会的</p>
<p>2019-02-07</p>
<p>牛牛   0</p>
<p>新年快乐～、感谢有您～^_^～</p>
<p>2019-02-06</p>
<p> 作者回复</p>
<p>新年快乐~ </p>
<p>2019-02-07</p>
<p>poppy   0</p>
<p>老师，春节快乐，过年还在更新，辛苦辛苦。关于思考题，我的理解是图8中的查询是使用了内存临时表，存储的顺序就是id%10的值的插入</p>
<p>顺序，而图9中的查询，由于内存临时表大小无法满足，所以使用了磁盘临时表，对于InnoDB</p>
<p>来说，就是对应B+树这种数据结构，这里会按照id%100(即m)的大小顺序来存储的，所以返回</p>
<p>的结果当然也是有序的</p>
<p>2019-02-06</p>
<p> 作者回复</p>
<p>新年好~ </p>
<p> </p>
<p>2019-02-07</p>
<p>张八百   0</p>
<p>春节快乐，老师。谢谢你让我学到不少知识</p>
<p>2019-02-06</p>
<p> 作者回复</p>
<p>新年快乐 </p>
<p>2019-02-06</p>
<p>某、人   0</p>
<p>老师春节快乐，辛苦了</p>
<p>2019-02-06</p>
<p> 作者回复</p>
<p>春节快乐， </p>
<p>2019-02-06</p>
<p>长杰   0</p>
<p>图九使用的是磁盘临时表，磁盘临时表使用的引擎是innodb，innodb是索引组织表，按主键顺</p>
<p>序存储数据，所以是按照m字段有序的。2019-02-06</p>
<p> 作者回复</p>
<p>  </p>
<p>春节快乐</p>
<p>2019-02-06</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-到底可不可以使用join</title>
    <url>/posts/db4372f3.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>34 | 到底可不可以使用join？2019-01-30 林晓斌</p>
<p>在实际生产中，关于join语句使用的问题，一般会集中在以下两类：</p>
<ol>
<li>我们DBA不让使用join，使用join有什么问题呢？2. 如果有两个大小不同的表做join，应该用哪个表做驱动表呢？今天这篇文章，我就先跟你说说join语句到底是怎么执行的，然后再来回答这两个问题。为了便于量化分析，我还是创建两个表t1和t2来和你说明。可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2</li>
</ol>
<p>里插入了1000行数据，在表t1里插入的是100行数据。Index Nested-Loop Join</p>
<p>我们来看一下这个语句：</p>
<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析</p>
<p>SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用straight_join让</p>
<p>MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句</p>
<p>CREATE TABLE t̀2  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;a  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;b  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;a  ̀(̀ a )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>drop procedure idata;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;1;</p>
<p>  while(i&lt;&#x3D;1000)do</p>
<pre><code>insert into t2 values(i, i, i);

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>create table t1 like t2;</p>
<p>insert into t1 (select * from t2 where id&lt;&#x3D;100)</p>
<p>select * from t1 straight_join t2 on (t1.a&#x3D;t2.a);</p>
<p>里，t1 是驱动表，t2是被驱动表。现在，我们来看一下这条语句的explain结果。图1 使用索引字段join的 explain结果</p>
<p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语</p>
<p>句的执行流程是这样的：</p>
<ol>
<li><p>从表t1中读入一行数据 R；</p>
</li>
<li><p>从数据行R中，取出a字段到表t2里去查找；</p>
</li>
<li><p>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</p>
</li>
<li><p>重复执行步骤1到3，直到表t1的末尾循环结束。这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的</p>
</li>
</ol>
<p>记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，</p>
<p>所以我们称之为“Index Nested-Loop Join”，简称NLJ。它对应的流程图如下所示：</p>
<p>图2 Index Nested-Loop Join算法的执行流程</p>
<p>在这个流程里：</p>
<ol>
<li><p>对驱动表t1做了全表扫描，这个过程需要扫描100行；</p>
</li>
<li><p>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一</p>
</li>
</ol>
<p>对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</p>
<ol start="3">
<li>所以，整个执行流程，总扫描行数是200。现在我们知道了这个过程，再试着回答一下文章开头的两个问题。先看第一个问题：能不能使用join?</li>
</ol>
<p>假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实</p>
<p>现。1. 执行select * from t1，查出表t1的所有数据，这里有100行；</p>
<ol start="2">
<li>循环遍历这100行数据：</li>
</ol>
<p>从每一行R取出字段a的值$R.a；</p>
<p>执行select * from t2 where a&#x3D;$R.a；</p>
<p>把返回的结果和R构成结果集的一行。可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了</p>
<p>100次交互。除此之外，客户端还要自己拼接SQL语句和结果。显然，这么做还不如直接join好。我们再来看看第二个问题：怎么选择驱动表？在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每</p>
<p>次搜索一棵树近似复杂度是以2为底的M的对数，记为log M，所以在被驱动表上查一行的时间复</p>
<p>杂度是 2*log M。假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一</p>
<p>次。因此整个执行过程，近似复杂度是 N + N<em>2</em>log M。显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。到这里小结一下，通过上面的分析我们得到了两个结论：</p>
<ol>
<li><p>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；</p>
</li>
<li><p>如果使用join语句的话，需要让小表做驱动表。但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。接下来，我们再看看被驱动表用不上索引的情况。Simple Nested-Loop Join</p>
</li>
</ol>
<p>现在，我们把SQL语句改成这样：</p>
<p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次</p>
<p>2</p>
<p>2</p>
<p>2</p>
<p>如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大</p>
<p>1000倍；而M扩大1000倍，扫描行数扩大不到10倍。select * from t1 straight_join t2 on (t1.a&#x3D;t2.b);</p>
<p>全表扫描。你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结</p>
<p>果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000&#x3D;10万行。这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫</p>
<p>描100亿行，这个算法看上去太“笨重”了。当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block</p>
<p>Nested-Loop Join”的算法，简称BNL。Block Nested-Loop Join</p>
<p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整</li>
</ol>
<p>个表t1放入了内存；</p>
<ol start="2">
<li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为</li>
</ol>
<p>结果集的一部分返回。这个过程的流程图如下：</p>
<p>图3 Block Nested-Loop Join 算法的执行流程</p>
<p>对应地，这条SQL语句的explain结果如下所示：</p>
<p>图4 不使用索引字段join的 explain结果</p>
<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于</p>
<p>join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要</p>
<p>在内存中做的判断次数是：100*1000&#x3D;10万次。前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因</p>
<p>此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的这10万</p>
<p>次判断是内存操作，速度上会快很多，性能也更好。接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。假设小表的行数是N，大表的行数是M，那么在这个算法里：</p>
<ol>
<li><p>两个表都做一次全表扫描，所以总的扫描行数是M+N；</p>
</li>
<li><p>内存中的判断次数是M*N。可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗</p>
</li>
</ol>
<p>时是一样的。然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，join_buffer放不</p>
<p>下怎么办呢？join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数</p>
<p>据话，策略很简单，就是分段放。我把join_buffer_size改成1200，再执行：</p>
<p>执行过程就变成了：</p>
<ol>
<li><p>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</p>
</li>
<li><p>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结</p>
</li>
</ol>
<p>果集的一部分返回；</p>
<ol start="3">
<li><p>清空join_buffer；</p>
</li>
<li><p>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。执行流程图也就变成这样：</p>
</li>
</ol>
<p>select * from t1 straight_join t2 on (t1.a&#x3D;t2.b);</p>
<p>图5 Block Nested-Loop Join – 两段</p>
<p>图中的步骤4和5，表示清空join_buffer再复用。这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成</p>
<p>两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)<em>1000&#x3D;10万次。我们再来看下，在这种情况下驱动表的选择问题。假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ</em>N，显然λ的取值范围是(0,1)。所以，在这个算法的执行过程中：</p>
<ol>
<li><p>扫描行数是 N+λ<em>N</em>M；</p>
</li>
<li><p>内存判断 N*M次。显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确</p>
</li>
</ol>
<p>定的情况下，N小一些，整个算式的结果会更小。所以结论是，应该让小表当驱动表。当然，你会发现，在N+λ<em>N</em>M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就</p>
<p>是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段</p>
<p>数也就越少，对被驱动表的全表扫描次数就越少。这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改</p>
<p>大。理解了MySQL执行join的两种算法，现在我们再来试着回答文章开头的两个问题。第一个问题：能不能使用join语句？1. 如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是</p>
<p>没问题的；</p>
<ol start="2">
<li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这</li>
</ol>
<p>样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block</p>
<p>Nested Loop”字样。第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？1. 如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</p>
<ol start="2">
<li>如果是Block Nested-Loop Join算法：</li>
</ol>
<p>在join_buffer_size足够大的时候，是一样的；</p>
<p>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。所以，这个问题的结论就是，总是应该使用小表做驱动表。当然了，这里我需要说明下，什么叫作“小表”。我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id&lt;&#x3D;50这个限定条件，再来</p>
<p>看下这两条语句：</p>
<p>select * from t1 straight_join t2 on (t1.b&#x3D;t2.b) where t2.id&lt;&#x3D;50;</p>
<p>select * from t2 straight_join t1 on (t1.b&#x3D;t2.b) where t2.id&lt;&#x3D;50;</p>
<p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2</p>
<p>的前50行”是那个相对小的表，也就是“小表”。我们再来看另外一组例子：</p>
<p>这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中</p>
<p>的数据是不一样的：</p>
<p>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</p>
<p>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和</p>
<p>b。这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，“只需要一列参与join的表t1”是那</p>
<p>个相对小的表。所以，更准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过</p>
<p>滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该</p>
<p>作为驱动表。小结</p>
<p>今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法是由能否使用被驱动表的</p>
<p>索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到</p>
<p>了文章开头两个问题的答案：</p>
<ol>
<li><p>如果可以使用被驱动表的索引，join语句还是有其优势的；</p>
</li>
<li><p>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要</p>
</li>
</ol>
<p>使用；</p>
<ol start="3">
<li>在使用join的时候，应该让小表做驱动表。最后，又到了今天的问题时间。我们在上文说到，使用Block Nested-Loop Join算法，可能会因为join_buffer不够大，需要对被</li>
</ol>
<p>select t1.b,t2.* from  t1  straight_join t2 on (t1.b&#x3D;t2.b) where t2.id&lt;&#x3D;100;</p>
<p>select t1.b,t2.* from  t2  straight_join t1 on (t1.b&#x3D;t2.b) where t2.id&lt;&#x3D;100;</p>
<p>驱动表做多次全表扫描。我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压</p>
<p>力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇文</p>
<p>章的知识点）</p>
<p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留下的问题是，如果客户端由于压力过大，迟迟不能接收数据，会对服务端</p>
<p>造成什么严重的影响。这个问题的核心是，造成了“长事务”。至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC的知识点了。如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；</p>
<p>当然读的事务也有问题，就是会导致undo log不能被回收，导致回滚段空间膨胀。评论区留言点赞板：</p>
<p>@老杨同志 提到了更新之间会互相等锁的问题。同一个事务，更新之后要尽快提交，不要做</p>
<p>没必要的查询，尤其是不要执行需要返回大量数据的查询；</p>
<p>@长杰 同学提到了undo表空间变大，db服务堵塞，服务端磁盘空间不足的例子。没时间了ngu   0</p>
<p>join这种用的多的，看完还是有很大收获的。像之前讲的锁之类，感觉好抽象，老是记不住，唉</p>
<p>。2019-01-30</p>
<p> 作者回复</p>
<p>嗯嗯，因为其实每个同学的只是背景不一样。这45讲里，每个同学都能从部分文章感觉到有收获，我觉得也很好了 </p>
<p>不过 锁其实用得也多的。。我以前负责业务库的时候，被开发同学问最多的问题之一就是，为啥死锁了^_^</p>
<p>2019-01-30</p>
<p>抽离の    8</p>
<p>早上听老师一节课感觉获益匪浅</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>好早呀 </p>
<p>2019-01-30</p>
<p>信信   6</p>
<p>老师好，回答本期问题：如果驱动表分段，那么被驱动表就被多次读，而被驱动表又是大表，</p>
<p>循环读取的间隔肯定得超1秒，这就会导致上篇文章提到的：“数据页在LRU_old的存在时间超</p>
<p>过1秒，就会移到young区”。最终结果就是把大部分热点数据都淘汰了，导致“Buffer pool hit rat</p>
<p>e”命中率极低，其他请求需要读磁盘，因此系统响应变慢，大部分请求阻塞。2019-01-30</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-30</p>
<p>老杨同志   3</p>
<p>对被驱动表进行全表扫描，会把冷数据的page加入到buffer pool.,并且block nested-loop要扫描</p>
<p>多次，两次扫描的时间可能会超过1秒，使lru的那个优化失效，把热点数据从buffer pool中淘汰</p>
<p>掉，影响正常业务的查询效率</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>漂亮 </p>
<p>2019-01-30</p>
<p>萤火虫   3</p>
<p>精选留言</p>
<p>萤火虫   3</p>
<p>年底了有一种想跳槽的冲动 身在武汉的我想出去看看 可一想到自身的能力和学历 又不敢去了 </p>
<p>苦恼…</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>今年这情况还是要先克制一下^_^ </p>
<p>先把内功练起来 </p>
<p>2019-01-30</p>
<p>清风浊酒   2</p>
<p>老师您好，left join 和 right join 会固定驱动表吗？2019-01-30</p>
<p> 作者回复</p>
<p>不会强制，但是由于语义的关系，大概率上是按照语句上写的关系去驱动，效率是比较高的</p>
<p>2019-01-30</p>
<p>柚子   2</p>
<p>join在热点表操作中，join查询是一次给两张表同时加锁吧，会不会增大锁冲突的几率？业务中肯定要使用被驱动表的索引，通常我们是先在驱动表查出结果集，然后再通过in被驱动</p>
<p>表索引字段，分两步查询，这样是否比直接join委托点？2019-01-30</p>
<p> 作者回复</p>
<p>join也是普通查询，都不需要加锁哦，参考下MVCC那篇；</p>
<p>就是我们文中说的，“分两步查询，先查驱动表，然后查多个in”，如果可以用上被驱动表的索引</p>
<p>，我觉得可以用上Index Nested-Loop Join算法，其实效果是跟拆开写类似的</p>
<p>2019-01-30</p>
<p>郝攀刚จุ๊บ   1</p>
<p>业务逻辑关系，一个SQL中left join7，8个表。这我该怎么优化。每次看到这些脑壳就大！</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p> </p>
<p>Explain下，没用用index nested-loop 的全要优化</p>
<p>2019-01-31</p>
<p>Zzz   1</p>
<p>林老师，我没想清楚为什么会进入young区域。假设大表t大小是M页&gt;old区域N页，由于Block </p>
<p>Nested-Loop Join需要对t进行k次全表扫描。第一次扫描时，1~N页依次被放入old区域，访问</p>
<p>N+1页时淘汰1页，放入N+1页，以此类推，第一次扫描结束后old区域存放的是M-N+1~M页。第二次扫描开始，访问1页，淘汰M-N+1页，放入1页。可以把M页想象成一个环，N页想象成</p>
<p>在这个环上滑动的窗口，由于M&gt;N，不管是哪次扫描，需要访问的页都不会在滑动窗口上，所</p>
<p>以不会存在“被访问的时候数据页在 LRU 链表中存在的时间超过了 1 秒“而被放入young的情况</p>
<p>。我能想到的会被放入young区域的情况是，在当次扫描中，由于一页上有多行数据，需要对</p>
<p>该页访问多次，超过了1s，不管这种情况就和t大小没关系了，而是由于page size太大，而一行</p>
<p>数据太少。2019-01-30</p>
<p> 作者回复</p>
<p>你说得对，分两类情况，</p>
<p>小于bp 3&#x2F;8的情况会跑到young，</p>
<p>大于3&#x2F;8的会影响young部分的更新</p>
<p>2019-01-30</p>
<p>700   1</p>
<p>老师，您好。看完文章后有如下问题请教：</p>
<p>1）文章内容「可以看到，在这个查询过程，也是扫描了 200 行，但是总共执行了 101 条语句</p>
<p>，比直接 join 多了 100 次交互。除此之外，客户端还要自己拼接 SQL 语句和结果。」</p>
<p>这个有没有啥方法来仅通过1次交互就将这101条语句发到服务端执行？2）文章内容「每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱</p>
<p>动表上查一行的时间复杂度是 2*log2M。」</p>
<p>这个复杂度的计算难理解，为什么是这么计算？假设 M &#x3D; 256，则搜索树的复杂度为8？3）文章内容「因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。」</p>
<p>驱动表的复杂度直接记为 N？4）文中提到索引扫描需扫1行数据，全表扫描需扫1000行数据。这是由统计信息决定的？提前感谢老师！</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<ol>
<li><p>用 in，但是不建议语句太长</p>
</li>
<li><p>看一下前面我们介绍索引的文章哈</p>
</li>
<li><p>因为是在叶子索引上直接顺序扫描，是一个大致值哈</p>
</li>
<li><p>不是呀，因为表t2是1000行哦</p>
</li>
</ol>
<p>2019-01-30</p>
<p>Ryoma   1</p>
<p>前提：冷数据表 &amp; 大表</p>
<p>buffer pool 中的old区会被持续刷新，并且基本没有升级到young区的可能性。一定程度上会降低hit rate</p>
<p>2019-01-30</p>
<p>403   0</p>
<p>用那个作为驱动表，mysql会自己优化么？2019-02-09</p>
<p> 作者回复</p>
<p>会的</p>
<p>2019-02-10</p>
<p>陈华应   0</p>
<p>老师，放完88行就满了，88是怎么计算得来的呢？2019-02-02</p>
<p> 作者回复</p>
<p>这个是实际跑出来的效果</p>
<p>如果说计算的话，每一行固定长度，你用1024除一下 </p>
<p>2019-02-02</p>
<p>库淘淘   0</p>
<p>set optimizer_switch&#x3D;’mrr&#x3D;on,mrr_cost_based&#x3D;off,batched_key_access&#x3D;on’;</p>
<p>create index idx_c on t2(c);</p>
<p>create index idx_a_c on t1(a,c);</p>
<p>create index idx_b_c on t3(b,c);</p>
<p>mysql&gt; explain select * from t2 </p>
<p>-&gt; straight_join t1 on(t1.a&#x3D;t2.a)</p>
<p>-&gt; straight_join t3 on(t2.b&#x3D;t3.b) </p>
<p>-&gt; where t1.c&gt; 800 and t2.c&gt;&#x3D;600 and t3.c&gt;&#x3D;500;</p>
<p>+—-+————-+——-+————+——-+—————+———+———+———–+——+———-+</p>
<p>—————————————————————+</p>
<p>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | </p>
<p>Extra |</p>
<p>+—-+————-+——-+————+——-+—————+———+———+———–+——+———-+</p>
<p>—————————————————————+</p>
<p>| 1 | SIMPLE | t2 | NULL | range | idx_c | idx_c | 5 | NULL | 401 | 100.00 | Using index condition</p>
<p>; Using where; Using MRR |</p>
<p>| 1 | SIMPLE | t1 | NULL | ref | idx_a_c | idx_a_c | 5 | test.t2.a | 1 | 33.33 | Using index conditio</p>
<p>n; Using join buffer (Batched Key Access) |</p>
<p>| 1 | SIMPLE | t3 | NULL | ref | idx_b_c | idx_b_c | 5 | test.t2.b | 1 | 33.33 | Using index conditio</p>
<p>n; Using join buffer (Batched Key Access) |</p>
<p>+—-+————-+——-+————+——-+—————+———+———+———–+——+———-+</p>
<p>—————————————————————+</p>
<p>3 rows in set, 1 warning (0.00 sec)</p>
<p>以自己理解考虑如下，有问题请老师能够指出</p>
<p>1.根据查询因是select * 肯定回表的，其中在表t2创建索引idx_c,为了能够使用ICP,MRR，如果c</p>
<p>字段重复率高或取值行数多，可以考虑不建索引</p>
<p>2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得</p>
<p>出结果 再各回t2,t3表取出 得到结果集（之前理解都是t1和t2join得结果集再与t3join，本次理解</p>
<p>太确定）</p>
<p>3.t2、t3表建立联合查询目的能够使用ICP</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>“2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得</p>
<p>出结果 再各回t2,t3表取出 得到结果集”</p>
<p>即使是用t1做驱动表，也是可能可以都用上BKA的哈</p>
<p>新春快乐~</p>
<p>2019-02-04</p>
<p>郭健   0</p>
<p>老师，太棒了！！终于讲join了！！！作为一个实际开发人员，索引了解是必须得，单表索引有</p>
<p>所掌握，始终对join没法理解，这节课对我的帮助是最大的。谢谢老师</p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-01</p>
<p>辣椒   0</p>
<p>我是开发，但是看了老师的专栏，对怎么写数据库应用更有心得了</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p> ，如果有有趣的经验也放到这里跟大家分享哦</p>
<p>2019-02-01</p>
<p>泡泡爱dota   0</p>
<p>explain select * from t1 straight_join t2 on (t1.a&#x3D;t2.a) where t1.a &lt; 50; </p>
<p>老师, 这条sql为什么t1.a的索引没有用上, t1还是走全表</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>如果数据量不够多，并且满足a&lt;50的行，占比比较高的话，优化器有可能会认为“还要回表，还</p>
<p>不如直接扫主键id”</p>
<p>2019-01-31</p>
<p>剃刀吗啡   0</p>
<p>我们某个业务使用infobright这种列式存储，字段没用索引。我在想这种引擎在join的时候是否也</p>
<p>会遵守类似的规则？但列式存储并不是按行扫描，所以有点困惑。2019-01-31</p>
<p> 作者回复</p>
<p>是的，只是获取数据的时候，不会去读整行。但是没有索引就也只能用BNL，可以explain看看</p>
<p>2019-01-31</p>
<p>一大只    0</p>
<p>老师，我想问下，如果使用的是Index Nested-Loop Join，是不是就不会使用join_buffer了？直</p>
<p>接将循环结果放到net_buffer_length中，边读边发哈？2019-01-31</p>
<p> 作者回复</p>
<p>是的，Index Nested-Loop Join没有用到join buffer</p>
<p>不过35篇马上会介绍到一个优化，把join buffer用上，晚上关注下哦 </p>
<p>2019-01-31</p>
<p>斜面镜子 Bill   0</p>
<p>因为 join_buffer 不够大，需要对被驱动表做多次全表扫描，也就造成了“长事务”。除了老师上</p>
<p>节课提到的导致undo log 不能被回收，导致回滚段空间膨胀问题，还会出现：1. 长期占用DML</p>
<p>锁，引发DDL拿不到锁堵慢连接池； 2. SQL执行socket_timeout超时后业务接口重复发起，导</p>
<p>致实例IO负载上升出现雪崩；3. 实例异常后，DBA kill SQL因繁杂的回滚执行时间过长，不能</p>
<p>快速恢复可用；4. 如果业务采用select *作为结果集返回，极大可能出现网络拥堵，整体拖慢服</p>
<p>务端的处理；5. 冷数据污染buffer pool，block nested-loop多次扫描，其中间隔很有可能超过1</p>
<p>s，从而污染到lru 头部，影响整体的查询体验。2019-01-31</p>
<p> 作者回复</p>
<p> 很赞</p>
<p>之前知识点的也都加进来啦</p>
<p>2019-01-31</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-如何判断一个数据库是不是出问题了</title>
    <url>/posts/e5c71a8.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>29 | 如何判断一个数据库是不是出问题了？2019-01-18 林晓斌</p>
<p>我在第25和27篇文章中，和你介绍了主备切换流程。通过这些内容的讲解，你应该已经很清楚</p>
<p>了：在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，</p>
<p>主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出</p>
<p>问题了，由HA系统发起的。这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？你一定会说，这很简单啊，连上MySQL，执行个select 1就好了。但是select 1成功返回了，就</p>
<p>表示主库没问题吗？select 1判断</p>
<p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们</p>
<p>来看一下这个场景。图1 查询blocked</p>
<p>我们设置innodb_thread_concurrency参数的目的是，控制InnoDB的并发线程上限。也就是说，</p>
<p>一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程</p>
<p>退出。这里，我把innodb_thread_concurrency设置成3，表示InnoDB只允许3个线程并行执行。而在我</p>
<p>们的例子中，前三个session 中的sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大</p>
<p>查询。你看到了， session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是</p>
<p>说，如果这时候我们用select 1来检测实例是否正常的话，是检测不出问题的。在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下</p>
<p>文切换的成本就会太高。所以，通常情况下，我们建议把innodb_thread_concurrency设置为64~128之间的值。这时，你</p>
<p>一定会有疑问，并发线程上限数设置为128够干啥，线上的并发连接数动不动就上千了。产生这个疑问的原因，是搞混了并发连接和并发查询。set global innodb_thread_concurrency&#x3D;3;</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p> insert into t values(1,1)</p>
<p>并发连接和并发查询，并不是同一个概念。你在show processlist的结果里，看到的几千个连</p>
<p>接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为</p>
<p>并发查询太高才是CPU杀手。这也是为什么我们需要设置innodb_thread_concurrency参数的原</p>
<p>因。然后，你可能还会想起我们在第7篇文章中讲到的热点更新和死锁检测的时候，如果把</p>
<p>innodb_thread_concurrency设置为128的话，那么出现同一行热点更新的问题时，是不是很快就</p>
<p>把128消耗完了，这样整个系统是不是就挂了呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙</p>
<p>锁）的线程是不算在128里面的。MySQL这样设计是非常有意义的。因为，进入锁等待的线程已经不吃CPU了；更重要的是，必</p>
<p>须这么设计，才能避免整个系统锁死。为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：</p>
<ol>
<li>线程1执行begin; update t set c&#x3D;c+1 where id&#x3D;1, 启动了事务trx1， 然后保持这个状态。这时</li>
</ol>
<p>候，线程处于空闲状态，不算在并发线程里面。2. 线程2到线程129都执行 update t set c&#x3D;c+1 where id&#x3D;1; 由于等行锁，进入等待状态。这样</p>
<p>就有128个线程处于等待状态；</p>
<ol start="3">
<li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其他语句</li>
</ol>
<p>进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系</p>
<p>统就堵住了。下图2显示的就是这个状态。图2 系统锁死状态（假设等行锁的语句占用并发计数）</p>
<p>这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此</p>
<p>时占用的CPU却是0，而这明显不合理。所以，我们说InnoDB在设计时，遇到进程进入锁等待的</p>
<p>情况时，将并发线程的计数减1的设计，是合理而且是必要的。虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中</p>
<p>前三个事务中的select sleep(100) from t，还是要算进并发线程的计数的。在这个例子中，同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统</p>
<p>其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。因此，我们使用select 1的判断逻辑要修改一下。查表判断</p>
<p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场</p>
<p>景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放</p>
<p>一行数据，然后定期执行：</p>
<p>mysql&gt; select * from mysql.health_check; </p>
<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。但是，我们马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。我们知道，更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更</p>
<p>新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的</p>
<p>效果。更新判断</p>
<p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执</p>
<p>行检测的时间。这条更新语句类似于：</p>
<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新</p>
<p>检测。但，备库的检测也是要写binlog的。由于我们一般会把数据库A和B的主备关系设计为双M结构，</p>
<p>所以在备库B上执行的检测命令，也要发回给主库A。但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同</p>
<p>步停止。所以，现在看来mysql.health_check 这个表就不能只有一行数据了。为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用</p>
<p>A、B的server_id做主键。由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这</p>
<p>mysql&gt; update mysql.health_check set t_modified&#x3D;now();</p>
<p>mysql&gt; CREATE TABLE &#96;health_check  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  t̀_modified  ̀timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>&#x2F;* 检测命令 *&#x2F;</p>
<p>insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified&#x3D;now();</p>
<p>样就可以保证主、备库各自的检测命令不会发生冲突。更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让DBA</p>
<p>头疼的问题。你一定会疑惑，更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定</p>
<p>慢的问题呢？其实，这里涉及到的是服务器IO资源分配的问题。首先，所有的检测逻辑都需要一个超时时间N。执行一条update语句，超过N秒后还不返回，就</p>
<p>认为系统不可用。你可以设想一个日志盘的IO利用率已经是100%的场景。这时候，整个系统响应非常慢，已经需</p>
<p>要做主备切换了。但是你要知道，IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行</p>
<p>自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时</p>
<p>候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。也就是说，这时候在业务系统上正常的SQL语句已经执行得很慢了，但是DBA上去一看，HA系</p>
<p>统还在正常工作，并且认为主库现在处于可用状态。之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天</p>
<p>然有一个问题，就是随机性。因为，外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起</p>
<p>执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还</p>
<p>不能发现，这就会导致切换慢的问题。所以，接下来我要再和你介绍一种在MySQL内部发现数据库问题的方法。内部统计</p>
<p>针对磁盘利用率这个问题，如果MySQL可以告诉我们，内部每一次IO请求的时间，那我们判断</p>
<p>数据库是否出问题的方法就可靠得多了。其实，MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name</p>
<p>表里统计了每次IO请求的时间。file_summary_by_event_name表里有很多行数据，我们先来看看</p>
<p>event_name&#x3D;’wait&#x2F;io&#x2F;file&#x2F;innodb&#x2F;innodb_log_file’这一行。图3 performance_schema.file_summary_by_event_name的一行</p>
<p>图中这一行表示统计的是redo log的写入时间，第一列EVENT_NAME 表示统计的类型。接下来的三组数据，显示的是redo log操作的时间统计。第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具</p>
<p>体的统计项， 单位是皮秒；前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、</p>
<p>平均值和最大值。第二组六列，是读操作的统计。最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共</p>
<p>从redo log里读了多少个字节。第三组六列，统计的是写操作。最后的第四组数据，是对其他类型数据的统计。在redo log里，你可以认为它们就是对fsync的统</p>
<p>计。在performance_schema库的file_summary_by_event_name表里，binlog对应的是event_name &#x3D;</p>
<p>“wait&#x2F;io&#x2F;file&#x2F;sql&#x2F;binlog”这一行。各个字段的统计逻辑，与redo log的各个字段完全相同。这里，我</p>
<p>就不再赘述了。因为我们每一次操作数据库，performance_schema都需要额外地统计这些信息，所以我们打开</p>
<p>这个统计功能是有性能损耗的。我的测试结果是，如果打开所有的performance_schema项，性能大概会下降10%左右。所以，</p>
<p>我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统</p>
<p>计。如果要打开redo log的时间监控，你可以执行这个语句：</p>
<p>假设，现在你已经开启了redo log和binlog这两个统计信息，那要怎么把这个信息用在实例状态</p>
<p>诊断上呢？很简单，你可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单</p>
<p>次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。发现异常后，取到你需要的信息，再通过下面这条语句：</p>
<p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值</p>
<p>了。小结</p>
<p>今天，我和你介绍了检测一个MySQL实例健康状态的几种方法，以及各种方法存在的问题和演</p>
<p>进的逻辑。你看完后可能会觉得，select 1这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的</p>
<p>MHA（Master High Availability），默认使用的就是这个方法。MHA中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。不过据我所</p>
<p>知，选择这个方法的很少。其实，每个改进的方案，都会增加额外损耗，并不能用“对错”做直接判断，需要你根据业务实际</p>
<p>情况去做权衡。我个人比较倾向的方案，是优先考虑update系统表，然后再配合增加检测performance_schema</p>
<p>的信息。最后，又到了我们的思考题时间。今天，我想问你的是：业务系统一般也有高可用的需求，在你开发和维护过的服务中，你是怎么</p>
<p>判断服务有没有出问题的呢？mysql&gt; update setup_instruments set ENABLED&#x3D;’YES’, Timed&#x3D;’YES’ where name like ‘%wait&#x2F;io&#x2F;file&#x2F;innodb&#x2F;innodb_log_file%’;</p>
<p>mysql&gt; select event_name,MAX_TIMER_WAIT  FROM performance_schema.file_summary_by_event_name where event_name in (‘wait&#x2F;io&#x2F;file&#x2F;innodb&#x2F;innodb_log_file’,’wait&#x2F;io&#x2F;file&#x2F;sql&#x2F;binlog’) and MAX_TIMER_WAIT&gt;200*1000000000;</p>
<p>mysql&gt; truncate table performance_schema.file_summary_by_event_name;</p>
<p>你可以把你用到的方法和分析写在留言区，我会在下一篇文章中选取有趣的方案一起来分享和分</p>
<p>析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，如果使用GTID等位点的方案做读写分离，在对大表做DDL的时候会怎么样。假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的大事务）。那</p>
<p>么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求</p>
<p>都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库。通过这个思考题，我主要想让关注的是，大事务对等位点方案的影响。当然了，使用gh-ost方案来解决这个问题也是不错的选择。评论区留言点赞板：</p>
<p>@曾剑、@max 同学提到的备库先做，再切主库的方法也是可以的。精选留言</p>
<p>某、人   6</p>
<p>目前是只有一台服务器来做判断,是否数据库出问题了,就是采用的update的方式。如果是主从架</p>
<p>构就一条语句,如果是双主的话就是两条update语句。但是这种方式有很大的弊端,只有一个进程</p>
<p>来判断数据库出问题的话,会出现单点判断的问题。所以后续准备多个单数进程来做判断,如果超</p>
<p>过了半数以上的监控进程都认为数据库出问题,才做切换。老师我有两个问题:</p>
<p>1.innodb_thread_concurrency的设置是不是应该跟计算机核数成正比,一般是1.5倍-2倍左右？2.怎么之前遇到空间满了,数据库都登不上了,所有的连接都连不上,更不用执行select语句了,这个</p>
<p>是什么原因啊？2019-01-20</p>
<p> 作者回复</p>
<ol>
<li>虽然理论上是核数的2倍左右最好，但是现在很多人把MySQL创建在虚拟机上，就分1~2个</li>
</ol>
<p>核，我怕那么写，有同学会认为innodb_thread_concurrency建议设置成4。。2. 空间满本身是不会导致连不上的。但是因为空间满，事务无法提交，可能会导致接下来外部</p>
<p>事务重试，新重试的业务还是堵在提交阶段，持续累积可能会把连接数用满</p>
<p>2019-01-21</p>
<p>IceGeek17   1</p>
<p>对于使用 GTID 等位点的方案做读写分离，对大表做DDL的问题，</p>
<p>有一种做法是先在从库上设置 set_log_bin &#x3D; off，在从库上先做DDL，完成后做一下主从切换。然后再在之前的主库上同样操作一遍。但这会有一个问题，当先在从库上做DDL（大表DDL时间会比较长，比如10分钟），在这段时</p>
<p>间内，此时如果读写请求都走主库的话，如果写请求对于DDL的改动是有依赖的，那这些写请</p>
<p>求在主库就可能会失败；同样此时对于主库上的读请求，也可能会读到“过期”的数据（读请求</p>
<p>希望读到DDL之后的数据，但此时DDL在从库执行，主库上还是DDL之前的），老师怎么看这</p>
<p>个问题 ？2019-01-29</p>
<p> 作者回复</p>
<p>是这样的，我们说DDL，一般是指加减索引，增加字段在最后一列，这种操作…</p>
<p>2019-01-31</p>
<p>Mr.Strive.Z.H.L   1</p>
<p>老师您好：</p>
<p>本章有个疑惑：</p>
<p>”外部检测的时候，主备使用同一条更新语句，造成行冲突，导致主备同步停止”</p>
<p>上面这句话实在想不通。外部检测是只是看更新语句的返回时间，health_check表在主库备库</p>
<p>都有，为啥会造成行冲突？为啥会导致主备同步停止？即使是相同的binlog，也没啥影响呀。2019-01-22</p>
<p> 作者回复</p>
<p>比如两个表刚开始都是空表，</p>
<p>然后第一个语句执行</p>
<p>insert into mysql.health_check(id, t_modified) values (1, now()) on duplicate key update t_modifi</p>
<p>ed&#x3D;now();</p>
<p>就会两边各写入一个insert语句的binlog日志，传到对面就导致同步停止了</p>
<p>2019-01-22</p>
<p>慧鑫coming   1</p>
<p>老师，文中提到的“但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也</p>
<p>就是可能会导致主备同步停止。”，这个能展开说一下吗，这个行冲突指什么？它们会都更新各</p>
<p>自检测表的同一字段我觉得会带来不准确的问题，怎么导致主从同步停止了呢？2019-01-22</p>
<p> 作者回复</p>
<p>好问题</p>
<p>比如两个表刚开始都是空表，</p>
<p>然后第一个语句执行</p>
<p>insert into mysql.health_check(id, t_modified) values (1, now()) on duplicate key update t_modifi</p>
<p>ed&#x3D;now();</p>
<p>就会两边各写入一个insert语句的binlog日志，传到对面就导致同步停止了</p>
<p>2019-01-22</p>
<p>heat nan   1</p>
<p>老师，一直有个疑问，想咨询下。innodb buffer 会缓存表的数据页和索引页。现在我想知道如</p>
<p>何确认一个查询的行已经被缓存在内存中了。 我想了一下，第一种方法是直接去内存中遍历这</p>
<p>个表相关的数据页。这样的话，因为内存中的页可能是分散的，可能不构成一个完成的索引结</p>
<p>构，可能不能利用b+树叶子节点的路由功能。 这里有点模糊，希望老师有空可以解释一下</p>
<p>2019-01-19</p>
<p> 作者回复</p>
<p>“因为内存中的页可能是分散的，可能不构成一个完成的索引结构，可能不能利用b+树叶子节点</p>
<p>的路由功能。”</p>
<p>这里不对哈</p>
<p>放在内存里是b+树组织的，可以利用b+树叶子节点的路由功能的</p>
<p>2019-01-19</p>
<p>老杨同志   1</p>
<p>现在很多公司都是使用dubbo或者类似dubbo的rpc调用。说说我对dubbo的理解 </p>
<p>dubbo 存活检测感觉分为下面三个层面</p>
<p>服务端与注册中心的链接状态</p>
<p>通常注册中心是zookeeper，服务端注册临时节点，客户端注册这个节点的watch事件，一但服</p>
<p>务端失联，</p>
<p>客户端将把该服务从自己可用服务列表中移除。（一个服务通常有多个提供者，只是把失联的</p>
<p>提供者移除）。zookeeper是通过心跳发现服务提供者失联的，心跳实际上就是以固定的频率（比如每秒）发</p>
<p>送检测的数据包；</p>
<p>客户端与注册中心的链接状态</p>
<p>客户端与zookeeper失联，会暂时使用自己缓存的服务提供者列表。如果每个提供者多次调不</p>
<p>通，把它移除。客户端与服务单的链接状态</p>
<p>服务端提供类似于echo的方法，客户定时调用。部分返回正常，认为服务处于亚健康状态，如</p>
<p>果超过阀值，会被降级</p>
<p>从服务提供者列表移除。被移除的方法可能会在超过一定时间后，拿回来重试，可以恢复成正</p>
<p>常服务，也可能继续降级。2019-01-18</p>
<p> 作者回复</p>
<p>很好的实践分享。是不是还有配套一些服务的RT时间的报告？毕竟echo是一个比较轻量的调用，正确率可能比实际业务调用的正确率高</p>
<p>2019-01-20</p>
<p>强哥   1</p>
<p>1.基础监控，包括硬盘，CPU，网络，内存等。2.服务监控，包括jvm，服务端口，接入上下游服务的超时监控等。3.业务监控，主要是监控业务的流程是否出现问题。2019-01-18</p>
<p> 作者回复</p>
<p> ，这里的“超时监控”，是怎么得到的？是单独有命令检测，还是去看业务请求的返回时间？2019-01-18</p>
<p>长杰   1</p>
<p>老师请教一个问题，在gtid模式下，对于大的ddl操作，采用在备库执行sql_log_bin&#x3D;0的方式先</p>
<p>执行，然后再切换主备的方式在主库再执行，这种情况下，ddl操作是不记录binlog的，不知道</p>
<p>对gtid的计数有什么影响，是按顺序递增还是会跳过这个序列号？另外补充一下有些dl操作是不适合这个主备切换的方式，比如drop一个列，如果先在备库执行</p>
<p>就可能导致主备同步异常。这个场景适合osc方式或把读请求切到主库，先在主库执行这两种</p>
<p>方案。2019-01-18</p>
<p> 作者回复</p>
<p>如果set sql_log_bin&#x3D;0， 就不记录binlog，就不会给这个事务分配gtid。你说得对，drop列是很麻烦的，尽量不做。毕竟业务代码直接无视这个列就好了。。2019-01-18</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>关于 主备同步停止 的问题，看了您的回复。我是这么理解的：</p>
<p>insert into mysql.health_check(id, t_modified) values (1, now()) on duplicate key update t_modifi</p>
<p>ed&#x3D;now(); </p>
<p>按照您说的场景，主备分别执行这句话后，复制给彼此。如果单单看这句话，就算是主库执行备库复制过来的这句话，也不会出现异常呀。（因为如果</p>
<p>主键冲突就会更新时间）</p>
<p>但是这种场景会导致 主备同步停止， 所以实际上主库在应用备库这句话的binlog的时候，发现</p>
<p>主键冲突，自然就会报错。不知道是不是这样，因为如果单单看这句sql，即使主键冲突也没关系呀？2019-01-22</p>
<p> 作者回复</p>
<p>啊 主键冲突为啥没关系？是这样的，这两个语句如果同时执行，那么在主库和备库上就都是“insert行为”</p>
<p>写到binlog里面就都是Write rows event</p>
<p>这个冲突就会导致主备同步停止哦</p>
<p>2019-01-23</p>
<p>一大只    0</p>
<p>老师，我想问下，我的ECS上是8核CPU，只跑一个MySQL实例，那innodb_thread_concurren</p>
<p>cy如果设成2倍，那就是16哈。看并发查询的数量，是不是关注Threads_running是否超过innod</p>
<p>b_thread_concurrency就可以了。2019-01-21</p>
<p> 作者回复</p>
<p>Thread running 是包含“锁等待”状态的线程的，</p>
<p>超过点也没事 </p>
<p>2019-01-22</p>
<p>小橙橙   0</p>
<p>老师，我工作中遇到一个奇怪的问题，java客户端执行查询语句报错：ResultSet is from UPDA</p>
<p>TE. No Data。用navicat执行相同语句，很快就查询结束，但是没有结果显示。请问可能什么问</p>
<p>题造成的呢？2019-01-18</p>
<p> 作者回复</p>
<p>？这两个不是一致的吗</p>
<p>意思就是你要upate的语句找不到呀</p>
<p>你把update改成select，先确定一下是不是能看到你要更新的数据（根据你这个描述，应该是没</p>
<p>有）</p>
<p>2019-01-18</p>
<p>悟空   0</p>
<p>可以大致从DB监控图上判断业务有没有问题：</p>
<p>QPS&#x2F;连接数&#x2F;慢查询&#x2F;查询响应时间(query_response_time插件)等……..</p>
<p>老师请教一个问题： </p>
<p>物理机器是128G内存，DB实例数据量是1.2T，磁盘是pcie ssd</p>
<p>业务查询场景是简单的select * from table where id in (1,2,3….);</p>
<p>实例QPS在1000以下时,数据库看上去一切正常</p>
<p>当QPS大于2000+时, %util持续90+, r&#x2F;s持续2W左右, rMB&#x2F;s持续600+, 伴随着连接数&#x2F;慢查询等报</p>
<p>警</p>
<p>这个时候这个数据库实例可以说是出问题了吧，这类问题该怎么排查根因呢？是由于buffer pool与磁盘大量换入换出冷数据导致的吗，有相关的状态值监控项可以查吗？innodb buffer pool是mysql很重要的一个模块，老师后面有单独的章节来解惑吗，期待 ！！</p>
<p>2019-01-18</p>
<p> 作者回复</p>
<p>有的， 敬请期待</p>
<p>不过buffer pool内部细节很多，只能挑大家使用的时候，可能会用到的知识点来讲哈</p>
<p>2019-01-18</p>
<p>One day   0</p>
<p>作为一个开发我也很想了解一下我们自己生产库上的监控情况，接触到最多的就是Datasource,</p>
<p>以及user，password,port（基本上是基于连接那种级别，最多就是加锁），等等参数，大部分</p>
<p>都是基于业务开发。站在个人层面或者业务开发层面（很少能接触到DBA，以及看到DBA是怎</p>
<p>么设置这些参数情况，除非库挂掉了就会和DBA一起看这些）怎么去修改和观看以及使用这些</p>
<p>参数鸭</p>
<p>2019-01-18</p>
<p> 作者回复</p>
<p>有DBA就不要自己去修改线上的参数啦</p>
<p>如果说观察，一个比较好的管控系统，是会能够让你看到这些值的</p>
<p>如果没有，就让dba给你一份线上的my.cnf的配置，然后你在测试环境自己用这个配置启动实例</p>
<p>来观察</p>
<p>2019-01-18</p>
<p>Ryoma   0</p>
<p>现在的服务中只加了一个healthCheck的接口，和MySQL中使用select判断比较类似。当服务依</p>
<p>赖的MySQL及Redis等第三方资源发生问题时，还是不能有效的判断</p>
<p>2019-01-18</p>
<p>爸爸回来了   0</p>
<p>之前也用select 1。后来发现，硬盘意外塞满时，本地链接很有可能超时导致判断失败。想问问老师，mysqladmin ping这个机制用来判断如何？2019-01-18</p>
<p> 作者回复</p>
<p>跟select 1 属于一类</p>
<p>2019-01-18</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-如何正确地显示随机消息(1)</title>
    <url>/posts/e1069275.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>17 | 如何正确地显示随机消息？2018-12-21 林晓斌</p>
<p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习</p>
<p>App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL</p>
<p>中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，</p>
<p>然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选</p>
<p>单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。现在，如果让你来设计这个SQL语句，你会怎么写呢？为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻</p>
<p>辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p>
<p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择</p>
<p>3个单词，有什么方法实现，存在什么问题以及如何改进。内存临时表</p>
<p>首先，你会想到用order by rand()来实现这个逻辑。这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点</p>
<p>复杂的。我们先用explain命令来看看这个语句的执行情况。mysql&gt; CREATE TABLE &#96;words  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  &#96;word  ̀varchar(64) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;0;</p>
<p>  while i&lt;10000 do</p>
<pre><code>insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select word from words order by rand() limit 3;</p>
<p>图1 使用explain命令查看语句的执行情况</p>
<p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行</p>
<p>排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。这里，你可以先回顾一下上一篇文章中全字段排序和rowid排序的内容。我把上一篇文章的两个</p>
<p>流程图贴过来，方便你复习。图2 全字段排序</p>
<p>图3 rowid排序</p>
<p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一</p>
<p>下上一篇文章的一个结论：对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被</p>
<p>优先选择。我强调了“InnoDB表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位</p>
<p>置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它</p>
<p>会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们</p>
<p>来尝试分析一下语句的扫描行数。这条语句的执行流程是这样的：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是</li>
</ol>
<p>double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段</p>
<p>W。并且，这个表没有建索引。2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一</p>
<p>个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到</p>
<p>此，扫描行数是10000。3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排</p>
<p>序。4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信</p>
<p>息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时</p>
<p>扫描行数增加10000，变成了20000。6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫</p>
<p>描行数。7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户</p>
<p>端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分</p>
<p>析得出的结论。这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行</p>
<p>数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有</p>
<p>趣，分析对了开心，分析错了但是弄清楚了也很开心。现在，我来把完整的排序执行流程图画出来。# Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</p>
<p>SET timestamp&#x3D;1541402277;</p>
<p>select word from words order by rand() limit 3;</p>
<p>图4 随机排序完整流程图1</p>
<p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章</p>
<p>中，我们对InnoDB表排序的时候，明明用的还是ID字段。这时候，我们就要回到一个基本概念：MySQL的表是用什么方法来定位“一行数据”的。在前面第4和第5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是</p>
<p>不是就没有主键，就没办法回表了？其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成</p>
<p>一个长度为6字节的rowid来作为主键。这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行</p>
<p>的信息。对于有主键的InnoDB表来说，这个rowid就是主键ID；</p>
<p>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</p>
<p>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个</p>
<p>rowid其实就是数组的下标。到这里，我来稍微小结一下：order by rand()使用了内存临时表，内存临时表排序的时候使</p>
<p>用了rowid排序方法。磁盘临时表</p>
<p>那么，是不是所有的临时表都是内存表呢？其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大</p>
<p>小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把</p>
<p>max_length_for_sort_data 设置成16。set tmp_table_size&#x3D;1024;</p>
<p>set sort_buffer_size&#x3D;32768;</p>
<p>set max_length_for_sort_data&#x3D;16;</p>
<p>&#x2F;* 打开 optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select word from words order by rand() limit 3;</p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM ìnformation_schema .̀&#96;OPTIMIZER_TRACE \̀G</p>
<p>图5 OPTIMIZER_TRACE部分结果</p>
<p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到</p>
<p>sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字</p>
<p>段组成的行。这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于</p>
<p>为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，</p>
<p>超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道</p>
<p>不需要用临时文件吗？这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，</p>
<p>即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序</p>
<p>算法，而是采用了优先队列排序算法。其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的</p>
<p>话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，</p>
<p>想一下就明白了，这浪费了非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li>
</ol>
<p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p>
<ol>
<li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中</li>
</ol>
<p>去掉，换成(R’,rowid’)；</p>
<ol start="2">
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。这里我简单画了一个优先队列排序过程的示意图。图6 优先队列排序算法示例</li>
</ol>
<p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程</p>
<p>中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的</p>
<p>chosen&#x3D;true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的</p>
<p>number_of_tmp_files是0。这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它</p>
<p>们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一</p>
<p>样了。我们再看一下上面一篇文章的SQL查询语句：</p>
<p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是</p>
<p>limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超</p>
<p>过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要</p>
<p>大量的扫描行数，因此排序过程的资源消耗也会很大。再回到我们文章开头的问题，怎么正确地随机排序呢？随机排序方法</p>
<p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p>
<ol>
<li><p>取得这个表的主键id的最大值M和最小值N;</p>
</li>
<li><p>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</p>
</li>
<li><p>取不小于X的第一个ID的行。我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p>
</li>
</ol>
<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用</p>
<p>索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要</p>
<p>求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>mysql&gt; select max(id),min(id) into @M,@N from t ;</p>
<p>set @X&#x3D; floor((@M-@N+1)*rand() + @N);</p>
<p>select * from t where id &gt;&#x3D; @X limit 1;</p>
<p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取</p>
<p>得其他行概率的两倍。如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<ol>
<li>取得整个表的行数，并记为C。2. 取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。3. 再用limit Y,1 取得一行。我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。这个随机算法2，解决了算法1里面明显的概率不均匀问题。MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为</li>
</ol>
<p>返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，</p>
<p>执行代价比随机算法1的代价要高。当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那</p>
<p>扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小</p>
<p>很多呢？我就把这个问题留给你去课后思考吧。现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p>
<ol>
<li><p>取得整个表的行数，记为C；</p>
</li>
<li><p>根据相同的随机方法得到Y1、Y2、Y3；</p>
</li>
</ol>
<p>mysql&gt; select count(*) into @C from t;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @sql &#x3D; concat(“select * from t limit “, @Y, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>execute stmt;</p>
<p>DEALLOCATE prepare stmt;</p>
<ol start="3">
<li>再执行三个limit Y, 1语句得到三行数据。我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。小结</li>
</ol>
<p>今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代</p>
<p>价往往是比较大的。所以，在设计的时候你要量避开这种写法。今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在</p>
<p>实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读</p>
<p>写数据”的事情。因此，这类方法的应用还是比较广泛的。最后，我给你留下一个思考题吧。上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来</p>
<p>进一步减少扫描行数的。我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，</p>
<p>并说明你的方案需要的扫描行数。你可以把你的设计和结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，select * from t where city in (“杭州”,” 苏州 “) order by</p>
<p>name limit 100;这个SQL语句是否需要排序？有什么方案可以避免排序？虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要</p>
<p>单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不</p>
<p>是递增的了。也就是说，这条SQL语句需要排序。mysql&gt; select count(*) into @C from t;</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>set @Y3 &#x3D; floor(@C * rand());</p>
<p>select * from t limit @Y1，1； &#x2F;&#x2F;在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</p>
<p>select * from t limit @Y2，1；</p>
<p>select * from t limit @Y3，1；</p>
<p>那怎么避免排序呢？这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p>
<ol>
<li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客</li>
</ol>
<p>户端用一个长度为100的内存数组A保存结果。2. 执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存</p>
<p>进了内存数组B。3. 现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就</p>
<p>是我们需要的结果了。如果把这条SQL语句里“limit 100”改成“limit 10000,100”的话，处理方式其实也差不多，即：要把</p>
<p>上面的两条语句改成写：</p>
<p>和</p>
<p>这时候数据量较大，可以同时起两个连接一行行读结果，用归并排序算法拿到这两个结果集里，</p>
<p>按顺序取第10001~10100的name值，就是需要的结果了。当然这个方案有一个明显的损失，就是从数据库返回给客户端的数据量变大了。所以，如果数据的单行比较大的话，可以考虑把这两条SQL语句改成下面这种写法：</p>
<p>和</p>
<p>然后，再用归并排序的方法取得按name顺序第10001~10100的name、id的值，然后拿着这100</p>
<p>个id到数据库中去查出所有记录。上面这些方法，需要你根据性能需求和开发的复杂度做出权衡。select * from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p> select * from t where city&#x3D;”苏州” order by name limit 10100。select id,name from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p>select id,name from t where city&#x3D;”苏州” order by name limit 10100。评论区留言点赞板：</p>
<p>老杨同志   21</p>
<p>对应单词这种总量不是很多的数据，第一感觉应该装jdk缓存或者redis缓存。由于需要随机访问</p>
<p>，数组比较好。假如一个单词平均10个字节，10*10000，不到1M就装下了。如果一定要用数据库来做，老师的方案1比较好，空洞的问题，如果单词库不变，可以在上线前</p>
<p>整理数据，把空洞处理调。比如：原来单词存在A表，新建B表 ，执行 insert into B(word) selec</p>
<p>t word from A. B的id是自增的，就会生成连续的主键。当然如果A表写比较频繁，且数据量较大</p>
<p>，业务上禁用 这种写法，RR的隔离级别会锁A表 </p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>重新整理表这个思路很赞  </p>
<p>看得出你是业务经验很丰富啊，这几次问题，对底层实现和业务功能的平衡，考虑点很不错</p>
<p>评论区很多同学都提到不能排序，说明各位对索引的存储都理解对了。@峰 同学提到了归并排序，是我们这个问题解法的核心思想；</p>
<p>@老杨同志 的回答中提到了“从业务上砍掉功能”，这个也确实是在业务设计中可以考虑的一个</p>
<p>方向；</p>
<p>@某、人 帮忙回答了@发条橙子同学的问题，尤其是对问题一的回答，非常精彩。精选留言</p>
<p>2018-12-21</p>
<p>雪中鼠[悠闲]   4</p>
<p>如果按照业务需求，随机取三个，数据库还在设计阶段,可以增加一个主键字段,用来记录每行记</p>
<p>录的rowid，这样一万行，那就是连续的一万，然后随机，用该随机rowid回表查询该行记录</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>这个也是个好方法，就是确保连续，可以快速的得到C和几个偏移量</p>
<p>2018-12-21</p>
<p>吴宇晨   16</p>
<p>我觉得可以按Y排个序，第一条取完，拿到对应id，然后有一条语句就是where id大于xxx，limit </p>
<p>y2-y1，1</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>抓住了关键点  </p>
<p>2018-12-21</p>
<p>慧鑫coming   10</p>
<p>又到周五了，开心 </p>
<p>2018-12-21</p>
<p>HuaMax   7</p>
<p>假设Y1，Y2，Y3是由小到大的三个数，则可以优化成这样，这样扫描行数为Y3</p>
<p>id1 &#x3D; select * from t limit @Y1，1；</p>
<p>id2&#x3D; select * from t where id &gt; id1 limit @Y2-@Y1，1；</p>
<p>select * from t where id &gt; id2 limit @Y3 - @Y2，1；</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-21</p>
<p>freesia   4</p>
<p>从上一讲到这一讲，我发现老师在处理问题时，提出的方法就不再是单纯依靠MySQL解决，因</p>
<p>为可能会耗费很多资源，而是把问题分担一部分到客户端，比如客户端拿到数据后再排序，或</p>
<p>者客户端产生随机数再到MySQL中去查询。2018-12-23</p>
<p> 作者回复</p>
<p>嗯嗯，MySQL 的代码和业务代码都是代码  配合起来用</p>
<p>2018-12-23</p>
<p>李皮皮皮皮皮   4</p>
<p>我经常在文中看到多个事务的执行时序。线下做实验的时候，是怎么保证能按这个时序执行呢</p>
<p>？2018-12-21</p>
<p> 作者回复</p>
<p>开两个窗口，按顺序执行命令哦</p>
<p>2018-12-21</p>
<p>岁月安然   2</p>
<p>为什么随机算法2比order by rand()的代价小很多？因为随机算法2进行limit获取数据的时候是根据主键排序获取的，主键天然索引排序。获取到第</p>
<p>9999条的数据也远比order by rand()方法的组成临时表R字段排序再获取rowid代价小的多。2018-12-21</p>
<p> 作者回复</p>
<p>对的，</p>
<p>你是第一个回答正文中间问题的   </p>
<p>2018-12-21</p>
<p>倪大人   2</p>
<p>课后题可以在随机出Y1、Y2、Y3后，算出Ymax、Ymin</p>
<p>再用 select id from t limit Ymin，(Ymax - Ymin)；</p>
<p>得到id集后算出Y1、Y2、Y3对应的三个id</p>
<p>最后 select * from t where id in (id1, id2, id3)</p>
<p>这样扫描的行数应该是C+Ymax+3</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>漂亮</p>
<p>2018-12-21</p>
<p>董航   2</p>
<p>堆结构，大顶树，小顶树！！！</p>
<p>2018-12-21</p>
<p>王飞洋   2</p>
<p>归并排序，优先队列，算法无处不在。2018-12-21</p>
<p> 作者回复</p>
<p>要说算法还是隔壁王老师讲的专业，这里咱们就只追求MySQL 里面用到的，能给大家讲明白</p>
<p>就行了 </p>
<p>2018-12-21</p>
<p>某、人   1</p>
<p>今天这个问题我的理解转换成sql是:</p>
<p>mysql&gt; select count(*) into @C from t1;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>select LEAST(@Y,@Y1,@Y2) into @Y4;</p>
<p>select GREATEST(@Y,@Y1,@Y2) into @Y6;</p>
<p>select floor((@Y6+@Y4)&#x2F;2) into @Y5;</p>
<p>set @sql &#x3D; concat(“select id into @id from t1 limit “, @Y4, “,1”);</p>
<p>set @sql1 &#x3D; concat(“select id into @id1 from t1 where id&gt;@id limit “, @Y5-@Y4, “,1”);</p>
<p>set @sql2 &#x3D; concat(“select id into @id2 from t1 where id&gt;@id1 limit “, @Y6-@Y5, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>prepare stmt1 from @sql1;</p>
<p>prepare stmt2 from @sql2;</p>
<p>execute stmt;</p>
<p>execute stmt1;</p>
<p>execute stmt2;</p>
<p>DEALLOCATE prepare stmt;</p>
<p>DEALLOCATE prepare stmt1;</p>
<p>DEALLOCATE prepare stmt2;</p>
<p>select * from t1 where id in (@id,@id1,@id2);</p>
<p>感觉mysql不太适合处理随机数的问题,稍稍有点复杂。不过这两节课收获很多,对order by排序理解又深入不少,原来堆排序是放limit m,m行如果比sort_</p>
<p>buffer占用空间小,则先把m行放进数据集里,然后在把表里的数据一行一行取出来做比较。得出</p>
<p>的结果,在根据MRR回表取数据。老师,我有一个问题:</p>
<p>堆排序,如果比较的值是相等的情况下,会不会替换在sort_buffer里？我感觉是不会,如果不会才能</p>
<p>解释得通排序值相等,id不等的情况,不管是大顶堆还是小顶堆,得到的结果集都是id相对更小的</p>
<p>2018-12-23</p>
<p>路过   1</p>
<p>老师，我为快速执行存储过程。把参数位置为：</p>
<p>innodb_flush_log_at_trx_commit&#x3D;2</p>
<p>sync_binlog&#x3D;0</p>
<p>执行马上就结束了。否则要等很久。请教老师，上面修改后，数据和log还没有真正刷到磁盘。请问我在哪里可以看到相关的信息。使用show engine innodb status\G 看到：</p>
<p>0 pending log flushes, 0 pending chkp writes</p>
<p>20197 log i&#x2F;o’s done, 0.00 log i&#x2F;o’s&#x2F;second</p>
<p>谢谢！</p>
<p>2018-12-22</p>
<p> 作者回复</p>
<p>确实没地方看 </p>
<p>2018-12-22</p>
<p>风动草   1</p>
<p>老师好！您说的在建二级索引的过程中，是把主键取出来构造二级索引，而且要读全表，这个</p>
<p>读全表意思是不是，读了主键，就意味着主键的叶子节点也一起读出来了？2018-12-22</p>
<p> 作者回复</p>
<p>是的</p>
<p>2018-12-22</p>
<p>无眠   1</p>
<p>一直比较疑惑什么情况下会产生临时表Using temporary，希望老师指点下</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>查询需要临时表，比如我们这个例子里，需要临时表来放rand()结果</p>
<p>2018-12-21</p>
<p>银太@巨益科技   1</p>
<p>请教下老师：</p>
<p>表A有sku和warehouse两个字段组成的唯一索引,udx_sku_warehouse，高并发下容易死锁</p>
<p>执行的语句：update A set quantity&#x3D;quantity+1 where sku&#x3D;xx and warehouse&#x3D;xx</p>
<p>查看死锁的日志：两个事务都在等待udx_sku_warehouse的X锁，但两个事务修改的并不是同</p>
<p>一条记录，不是很明白，可以讲解一下吗？多谢</p>
<p>*** (1) TRANSACTION:</p>
<p>TRANSACTION 466841895, ACTIVE 0.021 sec starting index read</p>
<p>mysql tables in use 1, locked 1</p>
<p>LOCK WAIT 11 lock struct(s), heap size 2936, 9 row lock(s), undo log entries 11</p>
<p>LOCK BLOCKING MySQL thread id: 1927379 block 1895984</p>
<p>MySQL thread id 1895984, OS thread handle 0x2b2ffed85700, query id 783954740 10.27.8.222 </p>
<p>oms updating</p>
<p>UPDATE oms_stock</p>
<p>SET quantity &#x3D; quantity + -1</p>
<p>WHERE sku_id &#x3D; 13978218638755841</p>
<p>AND virtual_warehouse_id &#x3D; 13867758969455616</p>
<p>*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 297 page no 89 n bits 424 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841895 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 18 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>*** (2) TRANSACTION:</p>
<p>TRANSACTION 466841901, ACTIVE 0.015 sec starting index read</p>
<p>mysql tables in use 1, locked 1</p>
<p>11 lock struct(s), heap size 2936, 8 row lock(s), undo log entries 9</p>
<p>MySQL thread id 1927379, OS thread handle 0x2b2f97440700, query id 783954758 10.27.8.222 </p>
<p>oms updating</p>
<p>UPDATE oms_stock</p>
<p>SET quantity &#x3D; quantity + -1</p>
<p>WHERE sku_id &#x3D; 1809040003028</p>
<p>AND virtual_warehouse_id &#x3D; 13867758969455616</p>
<p>*** (2) HOLDS THE LOCK(S):</p>
<p>RECORD LOCKS space id 297 page no 89 n bits 424 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841901 lock_mode X locks rec but not gap</p>
<p>Record lock, heap no 18 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 297 page no 74 n bits 400 index <code>udx_sku_id_warehouse_id</code> of tabl</p>
<p>e <code>oms_biz</code>.<code>oms_stock</code> trx id 466841901 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 12 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>你一个事务里面是不是不止一个这样的update 语句?</p>
<p>2018-12-21</p>
<p>penelopewu   1</p>
<p>运行老师给的存储过程特别慢，怎么排查原因呢，mysql版本是8.0.13</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>把innodb_flush_at_trx_commit设置成2，sync_binlog设置成1000看看</p>
<p>2018-12-21</p>
<p>往事随风，顺其自然   1</p>
<p>临时表设置参数单位是k还是m?</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>字节</p>
<p>2018-12-21</p>
<p>奋斗心   0</p>
<p>20000行是指：扫描10000行到内存临时表，还有10000行是随机排序吗</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>第一个10000是扫描原表，第二个10000是扫描内存表；</p>
<p>排序过程本身是不增加扫描行数的</p>
<p>2019-02-03</p>
<p>阿狸爱JAVA   0</p>
<p>感觉老师的思路很宽广，就像一个大宝藏，方案一不行还有方案二，方案二不行还有方案三，</p>
<p>并且每个方案都能给出具体的性能比较与证据，而自己自能顺着老师的思路还能明白，可是一</p>
<p>旦扩展开来，便大脑一片空白</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>加油慢慢来哈~~ </p>
<p>2019-01-31</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-如何正确地显示随机消息</title>
    <url>/posts/d1d469cd.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>17 | 如何正确地显示随机消息？2018-12-21 林晓斌</p>
<p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习</p>
<p>App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL</p>
<p>中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，</p>
<p>然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选</p>
<p>单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。现在，如果让你来设计这个SQL语句，你会怎么写呢？为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻</p>
<p>辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p>
<p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择</p>
<p>3个单词，有什么方法实现，存在什么问题以及如何改进。内存临时表</p>
<p>首先，你会想到用order by rand()来实现这个逻辑。这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点</p>
<p>复杂的。我们先用explain命令来看看这个语句的执行情况。mysql&gt; CREATE TABLE <code>words</code> (</p>
<p>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>word</code> varchar(64) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>delimiter ;;</p>
<p>create procedure idata()</p>
<p>begin</p>
<p>  declare i int;</p>
<p>  set i&#x3D;0;</p>
<p>  while i&lt;10000 do</p>
<pre><code>insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));

set i=i+1;
</code></pre>
<p>  end while;</p>
<p>end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>mysql&gt; select word from words order by rand() limit 3;</p>
<p>图1 使用explain命令查看语句的执行情况</p>
<p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行</p>
<p>排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。这里，你可以先回顾一下上一篇文章中全字段排序和rowid排序的内容。我把上一篇文章的两个</p>
<p>流程图贴过来，方便你复习。图2 全字段排序</p>
<p>图3 rowid排序</p>
<p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一</p>
<p>下上一篇文章的一个结论：对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被</p>
<p>优先选择。我强调了“InnoDB表”，你肯定想到了，对于内存表，回表过程只是简单地根据数据行的位</p>
<p>置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它</p>
<p>会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们</p>
<p>来尝试分析一下语句的扫描行数。这条语句的执行流程是这样的：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是</li>
</ol>
<p>double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段</p>
<p>W。并且，这个表没有建索引。2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一</p>
<p>个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到</p>
<p>此，扫描行数是10000。3. 现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排</p>
<p>序。4. 初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。5. 从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信</p>
<p>息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时</p>
<p>扫描行数增加10000，变成了20000。6. 在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫</p>
<p>描行数。7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户</p>
<p>端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分</p>
<p>析得出的结论。这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行</p>
<p>数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有</p>
<p>趣，分析对了开心，分析错了但是弄清楚了也很开心。现在，我来把完整的排序执行流程图画出来。# Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</p>
<p>SET timestamp&#x3D;1541402277;</p>
<p>select word from words order by rand() limit 3;</p>
<p>图4 随机排序完整流程图1</p>
<p>图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章</p>
<p>中，我们对InnoDB表排序的时候，明明用的还是ID字段。这时候，我们就要回到一个基本概念：MySQL的表是用什么方法来定位“一行数据”的。在前面第4和第5篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是</p>
<p>不是就没有主键，就没办法回表了？其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成</p>
<p>一个长度为6字节的rowid来作为主键。这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行</p>
<p>的信息。对于有主键的InnoDB表来说，这个rowid就是主键ID；</p>
<p>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</p>
<p>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个</p>
<p>rowid其实就是数组的下标。到这里，我来稍微小结一下：order by rand()使用了内存临时表，内存临时表排序的时候使</p>
<p>用了rowid排序方法。磁盘临时表</p>
<p>那么，是不是所有的临时表都是内存表呢？其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大</p>
<p>小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把</p>
<p>max_length_for_sort_data 设置成16。set tmp_table_size&#x3D;1024;</p>
<p>set sort_buffer_size&#x3D;32768;</p>
<p>set max_length_for_sort_data&#x3D;16;</p>
<p>&#x2F;* 打开 optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select word from words order by rand() limit 3;</p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM <code>information_schema</code>.<code>OPTIMIZER_TRACE</code>\G</p>
<p>图5 OPTIMIZER_TRACE部分结果</p>
<p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到</p>
<p>sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字</p>
<p>段组成的行。这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于</p>
<p>为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，</p>
<p>超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道</p>
<p>不需要用临时文件吗？这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，</p>
<p>即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序</p>
<p>算法，而是采用了优先队列排序算法。其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的</p>
<p>话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，</p>
<p>想一下就明白了，这浪费了非常多的计算量。而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li>
</ol>
<p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p>
<ol>
<li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中</li>
</ol>
<p>去掉，换成(R’,rowid’)；</p>
<ol start="2">
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。这里我简单画了一个优先队列排序过程的示意图。图6 优先队列排序算法示例</li>
</ol>
<p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程</p>
<p>中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的</p>
<p>chosen&#x3D;true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的</p>
<p>number_of_tmp_files是0。这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它</p>
<p>们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一</p>
<p>样了。我们再看一下上面一篇文章的SQL查询语句：</p>
<p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是</p>
<p>limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超</p>
<p>过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要</p>
<p>大量的扫描行数，因此排序过程的资源消耗也会很大。再回到我们文章开头的问题，怎么正确地随机排序呢？随机排序方法</p>
<p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p>
<ol>
<li><p>取得这个表的主键id的最大值M和最小值N;</p>
</li>
<li><p>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</p>
</li>
<li><p>取不小于X的第一个ID的行。我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p>
</li>
</ol>
<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用</p>
<p>索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要</p>
<p>求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>mysql&gt; select max(id),min(id) into @M,@N from t ;</p>
<p>set @X&#x3D; floor((@M-@N+1)*rand() + @N);</p>
<p>select * from t where id &gt;&#x3D; @X limit 1;</p>
<p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取</p>
<p>得其他行概率的两倍。如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<ol>
<li>取得整个表的行数，并记为C。2. 取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。3. 再用limit Y,1 取得一行。我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。这个随机算法2，解决了算法1里面明显的概率不均匀问题。MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为</li>
</ol>
<p>返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，</p>
<p>执行代价比随机算法1的代价要高。当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那</p>
<p>扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小</p>
<p>很多呢？我就把这个问题留给你去课后思考吧。现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p>
<ol>
<li><p>取得整个表的行数，记为C；</p>
</li>
<li><p>根据相同的随机方法得到Y1、Y2、Y3；</p>
</li>
</ol>
<p>mysql&gt; select count(*) into @C from t;</p>
<p>set @Y &#x3D; floor(@C * rand());</p>
<p>set @sql &#x3D; concat(“select * from t limit “, @Y, “,1”);</p>
<p>prepare stmt from @sql;</p>
<p>execute stmt;</p>
<p>DEALLOCATE prepare stmt;</p>
<ol start="3">
<li>再执行三个limit Y, 1语句得到三行数据。我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。小结</li>
</ol>
<p>今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代</p>
<p>价往往是比较大的。所以，在设计的时候你要量避开这种写法。今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在</p>
<p>实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读</p>
<p>写数据”的事情。因此，这类方法的应用还是比较广泛的。最后，我给你留下一个思考题吧。上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来</p>
<p>进一步减少扫描行数的。我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，</p>
<p>并说明你的方案需要的扫描行数。你可以把你的设计和结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给你的问题是，select * from t where city in (“杭州”,” 苏州 “) order by</p>
<p>name limit 100;这个SQL语句是否需要排序？有什么方案可以避免排序？虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要</p>
<p>单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不</p>
<p>是递增的了。也就是说，这条SQL语句需要排序。mysql&gt; select count(*) into @C from t;</p>
<p>set @Y1 &#x3D; floor(@C * rand());</p>
<p>set @Y2 &#x3D; floor(@C * rand());</p>
<p>set @Y3 &#x3D; floor(@C * rand());</p>
<p>select * from t limit @Y1，1； &#x2F;&#x2F;在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行</p>
<p>select * from t limit @Y2，1；</p>
<p>select * from t limit @Y3，1；</p>
<p>那怎么避免排序呢？这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p>
<ol>
<li>执行select * from t where city&#x3D;“杭州” order by name limit 100; 这个语句是不需要排序的，客</li>
</ol>
<p>户端用一个长度为100的内存数组A保存结果。2. 执行select * from t where city&#x3D;“苏州” order by name limit 100; 用相同的方法，假设结果被存</p>
<p>进了内存数组B。3. 现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就</p>
<p>是我们需要的结果了。如果把这条SQL语句里“limit 100”改成“limit 10000,100”的话，处理方式其实也差不多，即：要把</p>
<p>上面的两条语句改成写：</p>
<p>和</p>
<p>这时候数据量较大，可以同时起两个连接一行行读结果，用归并排序算法拿到这两个结果集里，</p>
<p>按顺序取第10001~10100的name值，就是需要的结果了。当然这个方案有一个明显的损失，就是从数据库返回给客户端的数据量变大了。所以，如果数据的单行比较大的话，可以考虑把这两条SQL语句改成下面这种写法：</p>
<p>和</p>
<p>然后，再用归并排序的方法取得按name顺序第10001~10100的name、id的值，然后拿着这100</p>
<p>个id到数据库中去查出所有记录。上面这些方法，需要你根据性能需求和开发的复杂度做出权衡。select * from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p> select * from t where city&#x3D;”苏州” order by name limit 10100。select id,name from t where city&#x3D;”杭州” order by name limit 10100; </p>
<p>select id,name from t where city&#x3D;”苏州” order by name limit 10100。评论区留言点赞板：</p>
<p>评论区很多同学都提到不能排序，说明各位对索引的存储都理解对了。@峰 同学提到了归并排序，是我们这个问题解法的核心思想；</p>
<p>@老杨同志 的回答中提到了“从业务上砍掉功能”，这个也确实是在业务设计中可以考虑的一个</p>
<p>方向；</p>
<p>@某、人 帮忙回答了@发条橙子同学的问题，尤其是对问题一的回答，非常精彩。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-幻读是什么幻读有什么问题</title>
    <url>/posts/97b6038b.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>20 | 幻读是什么，幻读有什么问题？2018-12-28 林晓斌</p>
<p>在上一篇文章最后，我给你留了一个关于加锁规则的问题。今天，我们就从这个问题说起吧。为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。建表和初始化语句如下（为</p>
<p>了便于本期的例子说明，我把上篇文章中用到的表结构做了点儿修改）：</p>
<p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;d  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;c  ̀(̀ c )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(0,0,0),(5,5,5),</p>
<p>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p>
<p>比较好理解的是，这个语句会命中d&#x3D;5的这一行，对应的主键id&#x3D;5，因此在select 语句执行完成</p>
<p>后，id&#x3D;5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释</p>
<p>放。由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足</p>
<p>条件的5行记录上，会不会被加锁呢？我们知道，InnoDB的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都</p>
<p>是设定在可重复读隔离级别下。幻读是什么？现在，我们就来分析一下，如果只在id&#x3D;5这一行加锁，而其他行的不加锁的话，会怎么样。下面先来看一下这个场景（注意：这是我假设的一个场景）：</p>
<p>图 1 假设只在id&#x3D;5这一行加行锁</p>
<p>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是</p>
<p>select * from t where d&#x3D;5 for update。这个语句的意思你应该很清楚了，查所有d&#x3D;5的行，而且</p>
<p>使用的是当前读，并且加上写锁。现在，我们来看一下这三条SQL语句，分别会返回什么结果。1. Q1只返回id&#x3D;5这一行；</p>
<p>begin;</p>
<p>select * from t where d&#x3D;5 for update;</p>
<p>commit;</p>
<ol start="2">
<li>在T2时刻，session B把id&#x3D;0这一行的d值改成了5，因此T3时刻Q2查出来的是id&#x3D;0和id&#x3D;5这</li>
</ol>
<p>两行；</p>
<ol start="3">
<li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id&#x3D;0、id&#x3D;1和id&#x3D;5的</li>
</ol>
<p>这三行。其中，Q3读到id&#x3D;1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查</p>
<p>询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。这里，我需要对“幻读”做一个说明：</p>
<ol>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，</li>
</ol>
<p>幻读在“当前读”下才会出现。2. 上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。如果只从第8篇文章《事务到底是隔离的还是不隔离的？》我们学到的事务可见性规则来分析的</p>
<p>话，上面这三条SQL语句的返回结果都没有问题。因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提</p>
<p>交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就</p>
<p>是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。但是，这是不是真的没问题呢？不，这里还真就有问题。幻读有什么问题？首先是语义上的。session A在T1时刻就声明了，“我要把所有d&#x3D;5的行锁住，不准别的事务进行</p>
<p>读写操作”。而实际上，这个语义被破坏了。如果现在这样看感觉还不明显的话，我再往session B和session C里面分别加一条SQL语句，你</p>
<p>再看看会出现什么现象。图 2 假设只在id&#x3D;5这一行加行锁–语义被破坏</p>
<p>session B的第二条语句update t set c&#x3D;5 where id&#x3D;0，语义是“我把id&#x3D;0、d&#x3D;5这一行的c值，改成</p>
<p>了5”。由于在T1时刻，session A 还只是给id&#x3D;5这一行加了行锁， 并没有给id&#x3D;0这行加上锁。因</p>
<p>此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语</p>
<p>句要锁住所有d&#x3D;5的行的加锁声明。session C也是一样的道理，对id&#x3D;1这一行的修改，也是破坏了Q1的加锁声明。其次，是数据一致性的问题。我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此</p>
<p>刻的一致性，还包含了数据和日志在逻辑上的一致性。为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d&#x3D;100 where</p>
<p>d&#x3D;5。图 3 假设只在id&#x3D;5这一行加行锁–数据一致性问题</p>
<p>update的加锁语义和select …for update 是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d&#x3D;5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把</p>
<p>它认为加上了锁的这一行的d值修改成了100。现在，我们来分析一下图3执行完成后，数据库里会是什么结果。1. 经过T1时刻，id&#x3D;5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</p>
<ol start="2">
<li><p>经过T2时刻，id&#x3D;0这一行变成(0,5,5);</p>
</li>
<li><p>经过T4时刻，表里面多了一行(1,5,5);</p>
</li>
<li><p>其他行跟这个执行序列无关，保持不变。这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。1. T2时刻，session B事务提交，写入了两条语句；</p>
</li>
<li><p>T4时刻，session C事务提交，写入了两条语句；</p>
</li>
<li><p>T6时刻，session A事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。我统一放到一起的话，就是这样的：</p>
</li>
</ol>
<p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个</p>
<p>库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。也就是说，id&#x3D;0和id&#x3D;1这两行，发生了数据不一致。这个问题很严重，是不行的。到这里，我们再回顾一下，这个数据不一致到底是怎么引入的？我们分析一下可以知道，这是我们假设“select * from t where d&#x3D;5 for update这条语句只给d&#x3D;5这</p>
<p>一行，也就是id&#x3D;5的这一行加锁”导致的。所以我们认为，上面的设定不合理，要改。那怎么改呢？我们把扫描过程中碰到的行，也都加上写锁，再来看看执行效果。update t set d&#x3D;5 where id&#x3D;0; &#x2F;<em>(0,0,5)</em>&#x2F;</p>
<p>update t set c&#x3D;5 where id&#x3D;0; &#x2F;<em>(0,5,5)</em>&#x2F;</p>
<p>insert into t values(1,1,5); &#x2F;<em>(1,1,5)</em>&#x2F;</p>
<p>update t set c&#x3D;5 where id&#x3D;1; &#x2F;<em>(1,5,5)</em>&#x2F;</p>
<p>update t set d&#x3D;100 where d&#x3D;5;&#x2F;<em>所有d&#x3D;5的行，d改成100</em>&#x2F;</p>
<p>图 4 假设扫描到的行都被加上了行锁</p>
<p>由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住</p>
<p>了。需要等到T6时刻session A提交以后，session B才能继续执行。这样对于id&#x3D;0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：</p>
<p>可以看到，按照日志顺序执行，id&#x3D;0这一行的最终结果也是(0,5,5)。所以，id&#x3D;0这一行的问题解</p>
<p>决了。但同时你也可以看到，id&#x3D;1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是</p>
<p>(1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都</p>
<p>上了锁，还是阻止不了id&#x3D;1这一行的插入和更新呢？原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上</p>
<p>锁。也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻</p>
<p>读”会被单独拿出来解决的原因。到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。接下来，我们再看看InnoDB怎么解决幻读的问题。如何解决幻读？现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记</p>
<p>录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap</p>
<p>Lock)。顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，</p>
<p>这就产生了7个间隙。insert into t values(1,1,5); &#x2F;<em>(1,1,5)</em>&#x2F;</p>
<p>update t set c&#x3D;5 where id&#x3D;1; &#x2F;<em>(1,5,5)</em>&#x2F;</p>
<p>update t set d&#x3D;100 where d&#x3D;5;&#x2F;<em>所有d&#x3D;5的行，d改成100</em>&#x2F;</p>
<p>update t set d&#x3D;5 where id&#x3D;0; &#x2F;<em>(0,0,5)</em>&#x2F;</p>
<p>update t set c&#x3D;5 where id&#x3D;0; &#x2F;<em>(0,5,5)</em>&#x2F;</p>
<p>图 5 表t主键索引上的行锁和间隙锁</p>
<p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记</p>
<p>录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上</p>
<p>了间隙锁。现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是</p>
<p>间隙锁跟我们之前碰到过的锁都不太一样。比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。图6 两种行锁间的冲突关系</p>
<p>也就是说，跟行锁有冲突关系的是“另外一个行锁”。但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操</p>
<p>作。间隙锁之间都不存在冲突关系。这句话不太好理解，我给你举个例子：</p>
<p>图7 间隙锁之间不互锁</p>
<p>这里session B并不会被堵住。因为表t里并没有c&#x3D;7这个记录，因此session A加的是间隙锁</p>
<p>(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允</p>
<p>许插入值。但，它们之间是不冲突的。间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始</p>
<p>化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key</p>
<p>lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。你可能会问说，这个supremum从哪儿来的呢？这是因为+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值supremum，这样</p>
<p>才符合我们前面说的“都是前开后闭区间”。间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。在前面的文章中，就有同学提到了这个问题。我把他的问题转述一下，对应到我们这个例子的表</p>
<p>来说，业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新</p>
<p>它的数据，代码如下：</p>
<p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开</p>
<p>后闭区间。begin;</p>
<p>select * from t where id&#x3D;N for update;</p>
<p>&#x2F;<em>如果行不存在</em>&#x2F;</p>
<p>insert into t values(N,N,N);</p>
<p>&#x2F;<em>如果行存在</em>&#x2F;</p>
<p>update t set d&#x3D;N set id&#x3D;N;</p>
<p>commit;</p>
<p>可能你会说，这个不是insert … on duplicate key update 就能解决吗？但其实在有多个唯一键的时</p>
<p>候，这个方法是不能满足这位提问同学的需求的。至于为什么，我会在后面的文章中再展开说</p>
<p>明。现在，我们就只讨论这个逻辑。这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每</p>
<p>次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？这里，我用两个session来模拟并发，并假设N&#x3D;9。图8 间隙锁导致的死锁</p>
<p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来</p>
<p>分析一下：</p>
<ol>
<li>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁</li>
</ol>
<p>(5,10);</p>
<ol start="2">
<li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因</li>
</ol>
<p>此这个语句可以执行成功；</p>
<ol start="3">
<li><p>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</p>
</li>
<li><p>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对</p>
</li>
</ol>
<p>死锁关系，让session A的insert语句报错返回了。你现在知道了，间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并</p>
<p>发度的。其实，这还只是一个简单的例子，在下一篇文章中我们还会碰到更多、更复杂的例</p>
<p>子。你可能会说，为了解决幻读的问题，我们引入了这么一大串内容，有没有更简单一点的处理方法</p>
<p>呢。我在文章一开始就说过，如果没有特别说明，今天和你分析的问题都是在可重复读隔离级别下</p>
<p>的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，</p>
<p>就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置</p>
<p>为row。这，也是现在不少公司使用的配置组合。前面文章的评论区有同学留言说，他们公司就使用的是读提交隔离级别加binlog_format&#x3D;row的</p>
<p>组合。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用</p>
<p>呀。所以，这个同学在评论区就问说，这个配置到底合不合理。关于这个问题本身的答案是，如果读提交隔离级别够用，也就是说，业务不需要可重复读的保</p>
<p>证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。但其实我想说的是，配置是否合理，跟业务场景有关，需要具体问题具体分析。但是，如果DBA认为之所以这么用的原因是“大家都这么用”，那就有问题了，或者说，迟早会出</p>
<p>问题。比如说，大家都用读提交，可是逻辑备份的时候，mysqldump为什么要把备份线程设置成可重复</p>
<p>读呢？（这个我在前面的文章中已经解释过了，你可以再回顾下第6篇文章《全局锁和表锁 ：给</p>
<p>表加个字段怎么有这么多阻碍？》的内容）</p>
<p>然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔</p>
<p>离级别，会不会有问题？进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这</p>
<p>个结论是怎么得到的？如果业务开发和运维团队这些问题都没有弄清楚，那么“没问题”这个结论，本身就是有问题的。小结</p>
<p>今天我们从上一篇文章的课后问题说起，提到了全表扫描的加锁方式。我们发现即使给所有的行</p>
<p>都加上行锁，仍然无法解决幻读问题，因此引入了间隙锁的概念。我碰到过很多对数据库有一定了解的业务开发人员，他们在设计数据表结构和业务SQL语句的时</p>
<p>候，对行锁有很准确的认识，但却很少考虑到间隙锁。最后的结果，就是生产库上会经常出现由</p>
<p>于间隙锁导致的死锁现象。行锁确实比较直观，判断规则也相对简单，间隙锁的引入会影响系统的并发度，也增加了锁分析</p>
<p>的复杂度，但也有章可循。下一篇文章，我就会为你讲解InnoDB的加锁规则，帮你理顺这其中</p>
<p>的“章法”。作为对下一篇文章的预习，我给你留下一个思考题。图9 事务进入锁等待状态</p>
<p>如果你之前没有了解过本篇文章的相关内容，一定觉得这三个语句简直是风马牛不相及。但实际</p>
<p>上，这里session B和session C的insert 语句都会进入锁等待状态。你可以试着分析一下，出现这种情况的原因是什么？这里需要说明的是，这其实是我在下一篇文章介绍加锁规则后才能回答的问题，是留给你作为预</p>
<p>习的，其中session C被锁住这个分析是有点难度的。如果你没有分析出来，也不要气馁，我会</p>
<p>在下一篇文章和你详细说明。你也可以说说，你的线上MySQL配置的是什么隔离级别，为什么会这么配置？你有没有碰到什</p>
<p>么场景，是必须使用可重复读隔离级别的呢？你可以把你的碰到的场景和分析写在留言区里，我会在下一篇文章选取有趣的评论跟大家一起分</p>
<p>享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我们在本文的开头回答了上期问题。有同学的回答中还说明了读提交隔离级别下，在语句执行完</p>
<p>成后，是只有行锁的。而且语句执行完成后，InnoDB就会把不满足条件的行行锁去掉。当然了，c&#x3D;5这一行的行锁，还是会等到commit的时候才释放的。评论区留言点赞板：</p>
<p>@薛畅 、@张永志同学给出了正确答案。而且提到了在读提交隔离级别下，是只有行锁的。@帆帆帆帆帆帆帆帆、@欧阳成 对上期的例子做了验证，需要说明一下，需要在启动配置里</p>
<p>令狐少侠   5</p>
<p>老师，今天的文章对我影响很大，发现之前掌握的知识有些错误的地方，课后我用你的表结构</p>
<p>根据以前不清楚的地方实践了一遍，现在有两个问题，麻烦您解答下</p>
<p>1.我在事务1中执行 begin;select * from t where c&#x3D;5 for update;事务未提交，然后事务2中begin;</p>
<p>update t set c&#x3D;5 where id&#x3D;0;执行阻塞，替换成update t set c&#x3D;11 where id&#x3D;0;执行不阻塞，我觉</p>
<p>得原因是事务1执行时产生next-key lock范围是(0,5].(5,10]。我想问下update set操作c&#x3D;xxx是会</p>
<p>加锁吗？以及加锁的原理。2.一直以为gap只会在二级索引上，看了你的死锁案例，发现主键索引上也会有gap锁？2018-12-28</p>
<p> 作者回复</p>
<ol>
<li>好问题。你可以理解为要在索引c上插入一个(c&#x3D;5,id&#x3D;0)这一行，是落在(0,5],(5,10]里面的，1</li>
</ol>
<p>1可以对吧</p>
<ol start="2">
<li>嗯，主键索引的间隙上也要有Gap lock保护的</li>
</ol>
<p>2018-12-28</p>
<p>xuery   0</p>
<p>老师之前的留言说错了，重新梳理下：</p>
<p>面增加performance_schema&#x3D;on，才能用上这个功能，performance_schema库里的表才有</p>
<p>数据。精选留言</p>
<p>图8：间隙锁导致的死锁；我把innodb_locks_unsafe_for_binlog设置为1之后，session B并不</p>
<p>会blocked，session A insert会阻塞住，但是不会提示死锁；然后session B提交执行成功，ses</p>
<p>sion A提示主键冲突</p>
<p>这个是因为将innodb_locks_unsafe_for_binlog设置为1之后，什么原因造成的？2019-01-28</p>
<p> 作者回复</p>
<p>对， innodb_locks_unsafe_for_binlog 这个参数就是这个意思 “不加gap lock”，</p>
<p>这个已经要被废弃了（8.0就没有了），所以不建议设置哈，容易造成误会。如果真的要去掉gap lock，可以考虑改用RC隔离级别+binlog_format&#x3D;row</p>
<p>2019-02-01</p>
<p>薛畅   8</p>
<p>可重复读隔离级别下，经试验：</p>
<p>SELECT * FROM t where c&gt;&#x3D;15 and c&lt;&#x3D;20 for update; 会加如下锁：</p>
<p>next-key lock:(10, 15], (15, 20]</p>
<p>gap lock:(20, 25)</p>
<p>SELECT * FROM t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc for update; 会加如下锁：</p>
<p>next-key lock:(5, 10], (10, 15], (15, 20]</p>
<p>gap lock:(20, 25)</p>
<p>session C 被锁住的原因就是根据索引 c 逆序排序后多出的 next-key lock:(5, 10]</p>
<p>同时我有个疑问：加不加 next-key lock:(5, 10] 好像都不会影响到 session A 可重复读的语义，</p>
<p>那么为什么要加这个锁呢？2018-12-29</p>
<p> 作者回复</p>
<p>是的，这个其实就是为啥总结规则有点麻烦，有时候只是因为代码是这么写的 </p>
<p>2018-12-29</p>
<p>AI杜嘉嘉   7</p>
<p>说真的，这一系列文章实用性真的很强，老师非常负责，想必牵扯到老师大量精力，希望老师</p>
<p>再出好文章，谢谢您了，辛苦了</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>精力花了没事，睡一觉醒来还是一条好汉 </p>
<p>主要还是得大家有收获，我就值了 </p>
<p>2018-12-28</p>
<p>郭江伟   7</p>
<p>郭江伟   7</p>
<p>insert into t values(0,0,0),(5,5,5),</p>
<p>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p>
<p>运行mysql&gt; begin;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc for update;</p>
<p>c 索引会在最右侧包含主键值，c索引的值为(0,0) (5,5) (10,10) (15,15) (20,20) (25,25)</p>
<p>此时c索引上锁的范围其实还要匹配主键值 。思考题答案是，上限会扫到c索引(20,20) 上一个键，为了防止c为20 主键值小于25 的行插入，</p>
<p>需要锁定(20,20) (25,25) 两者的间隙；开启另一会话(26,25,25)可以插入，而(24,25,25)会被堵塞</p>
<p>。下限会扫描到(15,15)的下一个键也就是(10,10),测试语句会继续扫描一个键就是(5,5) ，此时会</p>
<p>锁定，(5,5) 到(15,15)的间隙，由于id是主键不可重复所以下限也是闭区间；</p>
<p>在本例的测试数据中添加(21,25,25)后就可以正常插入(24,25,25)</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>感觉你下一篇看起来会很轻松了哈  </p>
<p>2018-12-28</p>
<p>沉浮   5</p>
<p>通过打印锁日志帮助理解问题</p>
<p>锁信息见括号里的说明。TABLE LOCK table <code>guo_test</code>.<code>t</code> trx id 105275 lock mode IX</p>
<p>RECORD LOCKS space id 31 page no 4 n bits 80 index c of table <code>guo_test</code>.<code>t</code> trx id 105275 lo</p>
<p>ck_mode X</p>
<p>Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 —-(Next-</p>
<p>Key Lock，索引锁c（5，10])</p>
<p>0: len 4; hex 8000000a; asc ;;</p>
<p>1: len 4; hex 8000000a; asc ;;</p>
<p>Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 —-(Next-</p>
<p>Key Lock，索引锁c (10,15]) </p>
<p>0: len 4; hex 8000000f; asc ;;</p>
<p>1: len 4; hex 8000000f; asc ;;</p>
<p>Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 —-(Next-</p>
<p>Key Lock，索引锁c (15,20]) </p>
<p>0: len 4; hex 80000014; asc ;;</p>
<p>1: len 4; hex 80000014; asc ;;</p>
<p>Record lock, heap no 7 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 —-(Next-</p>
<p>Key Lock，索引锁c (20,25]) </p>
<p>0: len 4; hex 80000019; asc ;;</p>
<p>1: len 4; hex 80000019; asc ;;</p>
<p>RECORD LOCKS space id 31 page no 3 n bits 80 index PRIMARY of table <code>guo_test</code>.<code>t</code> trx id </p>
<p>105275 lock_mode X locks rec but not gap</p>
<p>Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0 </p>
<p>—-(记录锁 锁c&#x3D;15对应的主键）</p>
<p>0: len 4; hex 8000000f; asc ;;</p>
<p>1: len 6; hex 0000000199e3; asc ;;</p>
<p>2: len 7; hex ca000001470134; asc G 4;;</p>
<p>3: len 4; hex 8000000f; asc ;;</p>
<p>4: len 4; hex 8000000f; asc ;;</p>
<p>Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</p>
<p>0: len 4; hex 80000014; asc ;;</p>
<p>—-(记录锁 锁c&#x3D;20对应的主键）</p>
<p>1: len 6; hex 0000000199e3; asc ;;</p>
<p>2: len 7; hex ca000001470140; asc G @;;</p>
<p>3: len 4; hex 80000014; asc ;;</p>
<p>4: len 4; hex 80000014; asc ;;</p>
<p>由于字数限制，正序及无排序的日志无法帖出，倒序日志比这两者，多了范围(Next-Key Lock</p>
<p>，索引锁c（5，10])，个人理解是，加锁分两次，第一次，即正序的锁，第二次为倒序的锁，</p>
<p>即多出的(5,10],在RR隔离级别，</p>
<p>innodb在加锁的过程中会默认向后锁一个记录，加上Next-Key Lock,第一次加锁的时候10已经</p>
<p>在范围，由于倒序，向后，即向5再加Next-key Lock,即多出的(5,10]范围</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>优秀</p>
<p>2018-12-28</p>
<p>慧鑫coming   4</p>
<p>这篇需要多读几遍，again</p>
<p>2018-12-28</p>
<p>往事随风，顺其自然   2</p>
<p>总结：for update 是锁住所有行还有间隙锁，但是间隙 之间互不冲突，但是互不冲突，为什么</p>
<p>插入9这一行会被间隙锁等待，原来没有这一行，这和查询9这一行不是一样？2018-12-28</p>
<p>en   1</p>
<p>老师您好，我mysql的隔离级别是可重复读，数据是(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,</p>
<p>20),(25,25,25)，使用了begin;select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc for update</p>
<p>;然后sessionB的11阻塞了，但是(6,6,6)的插入成功了这是什么原因呢？2018-12-31</p>
<p>郭健   1</p>
<p>老师，想请教您几个问题。1.在第六章MDL锁的时候，您说给大表增加字段和增加索引的时候</p>
<p>要小心，之前做过测试，给一个一千万的数据增加索引有时需要40分钟，但是增加索引不会对</p>
<p>表增加MDL锁吧。除了增加索引慢，还会对数据库有什么影响吗，我问我们dba，他说就开始</p>
<p>和结束的时候上一下锁，没什么影响，我个人是持怀疑态度的。2，老师讲到表锁除了MDL锁</p>
<p>，还有显示命令lock table的命令的表锁，老师我可以认为，在mysql中如果不显示使用lock tabl</p>
<p>e表锁的话，那么mysql是永远不会使用表锁的，如果锁的条件没有索引，使用的是锁住行锁+</p>
<p>间隙控制并发。2018-12-30</p>
<p> 作者回复</p>
<ol>
<li>在锁方面你们dba说的基本是对的。一开始和结束有写锁，执行中间40分钟只有读锁</li>
</ol>
<p>但是1000万的表要做40分钟，可能意味着系统压力大（或者配置偏小），这样可能不是没影响</p>
<p>对，比较这个操作还是要吃IO和CPU的</p>
<ol start="2">
<li>嗯，innodb引擎是这样的。2018-12-30</li>
</ol>
<p>滔滔   1</p>
<p>老师，听了您的课收获满满～～感谢您的付出！您可不可以在分析死锁的时候讲一下如何分析</p>
<p>死锁日志，期待～～ </p>
<p>2018-12-29</p>
<p> 作者回复</p>
<p>谢谢你的肯定。嗯死锁分析会有一篇专门说。不过你可以提前说一下碰到的疑问 </p>
<p>2018-12-29</p>
<p>胡月    1</p>
<p>老师，今天线上遇上了一个死锁的问题，您能帮我分析下吗。根据前面文章的理解：死锁产生的原因如下</p>
<p>线程1：update语句where c&#x3D; 1 然后 update语句where c&#x3D;2</p>
<p>线程2：update语句where c&#x3D;2然后 update语句where c&#x3D;1</p>
<p>如果线程1获取c&#x3D;1的锁，等待c&#x3D;2的锁，线程2获取了c&#x3D;2的锁，等待c&#x3D;1的锁，就会产生死锁</p>
<p>。但是线上的情况是</p>
<p>线程1：update语句where c&#x3D; 1 然后 update语句where c&#x3D;2</p>
<p>线程2：update语句where c&#x3D;1然后 update语句where c&#x3D;2</p>
<p>按说不会产生死锁啊，因为如果线程1获取了c&#x3D;1的锁，线程2就阻塞了。线程1执行完之后，线</p>
<p>程2执行就可以了死锁日志如下：</p>
<p>(1) TRANSACTION:</p>
<p>TRANSACTION 9418928, ACTIVE 0.088 sec fetching rows</p>
<p>mysql tables in use 1, locked 1</p>
<p>LOCK WAIT 66 lock struct(s), heap size 13864, 8 row lock(s)</p>
<p>LOCK BLOCKING MySQL thread id: 11495130 block 11105198</p>
<p>MySQL thread id 11105198, OS thread handle 0x2b086bf45700, query id 88822589 39.106.161.</p>
<p>89 daogou Searching rows for update</p>
<p>UPDATE union_pid</p>
<p>SET USE_TIMES &#x3D; USE_TIMES + 1</p>
<p>WHERE PID &#x3D; ‘mm_128160800_40474215_33107450401’</p>
<p>(1) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 134 page no 93 n bits 192 index <code>PRIMARY</code> of table <code>shanfan</code>.&#96;uni</p>
<p>on_pid&#96; trx id 9418928 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 86 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</p>
<p>(2) TRANSACTION:</p>
<p>TRANSACTION 9418929, ACTIVE 0.088 sec fetching rows</p>
<p>mysql tables in use 1, locked 1</p>
<p>280 lock struct(s), heap size 46632, 17 row lock(s), undo log entries 1</p>
<p>MySQL thread id 11495130, OS thread handle 0x2b086be41700, query id 88822594 39.106.161.</p>
<p>89 daogou Searching rows for update</p>
<p>UPDATE union_pid</p>
<p>SET USE_TIMES &#x3D; USE_TIMES + 1</p>
<p>WHERE PID &#x3D; ‘1000501132_0_1432392817’</p>
<p>(2) HOLDS THE LOCK(S):</p>
<p>RECORD LOCKS space id 134 page no 93 n bits 192 index <code>PRIMARY</code> of table <code>shanfan</code>.&#96;uni</p>
<p>on_pid&#96; trx id 9418929 lock_mode X locks rec but not gap</p>
<p>Record lock, heap no 86 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</p>
<p>(2) WAITING FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 134 page no 68 n bits 264 index <code>PRIMARY</code> of table <code>shanfan</code>.&#96;uni</p>
<p>on_pid&#96; trx id 9418929 lock_mode X locks rec but not gap waiting</p>
<p>Record lock, heap no 116 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</p>
<p>WE ROLL BACK TRANSACTION (1)</p>
<p>2018-12-29</p>
<p> 作者回复</p>
<p>PID是唯一索引吗？ 给一下表结构。这两个语句分别对应的主键ID如果单独查出来分别是多少</p>
<p>2018-12-29</p>
<p>高枕   1</p>
<p>林老师，今天我又回头看第四节 深入浅出谈索引（上），里面有这样一段话：为了让一个查询</p>
<p>尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，</p>
<p>而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。我想问的是，</p>
<p>一 mysql是以page为最小单位的，mysql一次磁盘io能只读一个块吗？还是多个块组成的page？二 若一次只能读一个page，也就是多个块的话，这个N的大小是不是应该取决于page的大小呢</p>
<p>？三 主键索引叶子结点存放的实际数据，应该是通过指针跟叶子结点连接的吗？还是直接存在叶</p>
<p>子结点所在的页里吗？2018-12-29</p>
<p>信信   1</p>
<p>老师你好，如果图1的字段d有索引，按前面说的T1时刻后，只有id等于5这一行加了写锁。那么</p>
<p>session B 操作的是id等于0这一行，应该不会被阻断吧？如果没阻断的话，仍然会产生语义问</p>
<p>题及数据不一致的情况啊。想不明白。。。2018-12-29</p>
<p> 作者回复</p>
<p>如果d有索引，而且写法是d&#x3D;5，那么其他语句要把其他行的d改成5，也是不行的哦</p>
<p>2018-12-29</p>
<p>某、人   1</p>
<p>按照我的理解select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc for update;</p>
<p>这条语句的加锁顺序的以及范围应该是[25,20),[20,15],(15,10],但是通过实验得出来多了(10,5)ga</p>
<p>p锁</p>
<p>而且不管是用二级索引还是用主键索引,都会加这段gap锁.</p>
<p>有点不太清楚为什么倒序扫描就需要加上了这段gap锁,目的又是为了什么?</p>
<p>不会气磊,期待老师下一期的答案。 </p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>嗯嗯下周一见 </p>
<p>2018-12-28</p>
<p>可凡不凡   1</p>
<p>老师</p>
<p>update tab1 set name &#x3D;(select name from tab2 where status &#x3D;2)…</p>
<p>tab2.status 上有二级非唯一索引,rr 隔离级别</p>
<p>上述情况</p>
<p>tab2.id 上的的索引会被锁吗?</p>
<p>实际开发 看到的死锁情况 是这条语句在等待 s 锁 但是没有 gap 锁,也没有设置 semi-consistent</p>
<p>read</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>Tab2满足条件的航上会加读锁</p>
<p>2018-12-28</p>
<p>小新   1</p>
<p>这篇文章真的需要多啃几遍，</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>嗯嗯，而且这篇是下篇的基础 </p>
<p>2018-12-28</p>
<p>Justin   1</p>
<p>下一章老师会不会讲走普通索引，锁普通索引的时候，主键索引，以及其他索引的加锁顺序或</p>
<p>者规则呢？很是好奇</p>
<p>2018-12-28</p>
<p> 作者回复</p>
<p>嗯嗯，就是这些内容 </p>
<p>这篇文章末尾的问题如果一眼看懂的同学应该看起来就轻松的</p>
<p>2018-12-28</p>
<p>林   0</p>
<p>总结就是并发加可重复读引起了数据不一致，也就是幻读的产生，通过间隙锁解决。2019-02-01</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-02</p>
<p>胡楚坚   0</p>
<p>我对于左开右闭的意义(如果是数学那肯定造的)一直有点迷糊，闭和开有什么区别？然后自己</p>
<p>去搜索下:（a，b]代表着会锁住a跟b之间，不让插入数据，还会锁住数据b本身，但不会锁住数</p>
<p>据a(即开和闭对应着要不要锁住数据本身)。老师，我理解的对吗？至于为什么左开右闭，说是迎合自增主键特性，这就不是很理解了，希望老师有空能回答下。2019-01-31</p>
<p> 作者回复</p>
<p>非常正确，就是gap 再加上它右边的那个记录。要让整个区间连续，总要有一边闭区间哈，二选一。然后MySQL 一直支持的是升序索引 </p>
<p>2019-01-31</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-怎么最快地复制一张表</title>
    <url>/posts/be046cd8.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>41 | 怎么最快地复制一张表？2019-02-15 林晓斌</p>
<p>我在上一篇文章最后，给你留下的问题是怎么在两张表中拷贝数据。如果可以控制对源表的扫描</p>
<p>行数和加锁范围很小的话，我们简单地使用insert … select 语句即可实现。当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标</p>
<p>表。这时，有两种常用的方法。接下来的内容，我会和你详细展开一下这两种方法。为了便于说明，我还是先创建一个表db1.t，并插入1000行数据，同时创建一个相同结构的表</p>
<p>db2.t。假设，我们要把db1.t里面a&gt;900的数据行导出来，插入到db2.t中。mysqldump方法</p>
<p>一种方法是，使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p>
<p>把结果输出到临时文件。这条命令中，主要参数含义如下：</p>
<ol>
<li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START</li>
</ol>
<p>TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</p>
<ol start="2">
<li><p>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES t WRITE;” ；</p>
</li>
<li><p>–no-create-info的意思是，不需要导出表结构；</p>
</li>
</ol>
<p>create database db1;</p>
<p>use db1;</p>
<p>create table t(id int primary key, a int, b int, index(a))engine&#x3D;innodb;</p>
<p>delimiter ;;</p>
<p>  create procedure idata()</p>
<p>  begin</p>
<pre><code>declare i int;

set i=1;

while(i&lt;=1000)do

  insert into t values(i,i,i);

  set i=i+1;

end while;
</code></pre>
<p>  end;;</p>
<p>delimiter ;</p>
<p>call idata();</p>
<p>create database db2;</p>
<p>create table db2.t like db1.t</p>
<p>mysqldump -h$host -P$port -u$user –add-locks&#x3D;0 –no-create-info –single-transaction  –set-gtid-purged&#x3D;OFF db1 t –where&#x3D;”a&gt;900” –result-file&#x3D;&#x2F;client_tmp&#x2F;t.sql</p>
<ol start="4">
<li><p>–set-gtid-purged&#x3D;off表示的是，不输出跟GTID相关的信息；</p>
</li>
<li><p>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。图1 mysqldump输出文件的部分结果</p>
</li>
</ol>
<p>可以看到，一条INSERT语句里面会包含多个value对，这是为了后续用这个文件来写入数据的时</p>
<p>候，执行速度可以更快。如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令</p>
<p>时，加上参数–skip-extended-insert。然后，你可以通过下面这条命令，将这些INSERT语句放到db2库里去执行。需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令</p>
<p>的流程是这样的：</p>
<ol>
<li><p>打开文件，默认以分号为结尾读取一条条的SQL语句；</p>
</li>
<li><p>将SQL语句发送到服务端执行。也就是说，服务端执行的并不是这个“source t.sql”语句，而是INSERT语句。所以，不论是在慢</p>
</li>
</ol>
<p>查询日志（slow log），还是在binlog，记录的都是这些要被真正执行的INSERT语句。导出CSV文件</p>
<p>另一种方法是直接将结果导出成.csv文件。MySQL提供了下面的语法，用来将查询结果导出到服</p>
<p>务端本地目录：</p>
<p>我们在使用这条语句时，需要注意如下几点。1. 这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机</p>
<p>器上，客户端机器的临时目录下是不会生成t.csv文件的。mysql -h127.0.0.1 -P13000  -uroot db2 -e “source &#x2F;client_tmp&#x2F;t.sql”</p>
<p>select * from db1.t where a&gt;900 into outfile ‘&#x2F;server_tmp&#x2F;t.csv’;</p>
<ol start="2">
<li>into outfile指定了文件的生成位置（&#x2F;server_tmp&#x2F;），这个位置必须受参数secure_file_priv的</li>
</ol>
<p>限制。参数secure_file_priv的可选值和作用分别是：</p>
<p>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</p>
<p>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者</p>
<p>它的子目录；</p>
<p>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。3. 这条命令不会帮你覆盖文件，因此你需要确保&#x2F;server_tmp&#x2F;t.csv这个文件不存在，否则执行</p>
<p>语句时就会因为有同名文件的存在而报错。4. 这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包</p>
<p>含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟</p>
<p>上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。这条语句的执行流程如下所示。1. 打开文件&#x2F;server_tmp&#x2F;t.csv，以制表符(\t)作为字段间的分隔符，以换行符（\n）作为记录之</p>
<p>间的分隔符，进行数据读取；</p>
<ol start="2">
<li>启动事务。3. 判断每一行的字段数与表db2.t是否相同：</li>
</ol>
<p>若不相同，则直接报错，事务回滚；</p>
<p>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。4. 重复步骤3，直到&#x2F;server_tmp&#x2F;t.csv整个文件读入完成，提交事务。你可能有一个疑问，如果binlog_format&#x3D;statement，这个load语句记录到binlog里以后，</p>
<p>怎么在备库重放呢？由于&#x2F;server_tmp&#x2F;t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，</p>
<p>在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。所以，这条语句执行的完整流程，其实是下面这样的。1. 主库执行完成后，将&#x2F;server_tmp&#x2F;t.csv文件的内容直接写到binlog文件中。load data infile ‘&#x2F;server_tmp&#x2F;t.csv’ into table db2.t;</p>
<ol start="2">
<li>往binlog文件中写入语句load data local infile ‘&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0’ INTO TABLE</li>
</ol>
<p><code>db2 .̀̀ t</code>。3. 把这个binlog日志传到备库。4. 备库的apply线程在执行这个事务日志时：</p>
<p>a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0</p>
<p>中；</p>
<p>b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。执行流程如图2所示：</p>
<p>图2 load data的同步流程</p>
<p>注意，这里备库执行的load data语句里面，多了一个“local”。它的意思是“将执行这条命令的客</p>
<p>户端所在机器的本地文件&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中”。也就是说，load data命令有两种用法：</p>
<ol>
<li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录</li>
</ol>
<p>下；</p>
<ol start="2">
<li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时</li>
</ol>
<p>候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。另外需要注意的是，select …into outfile方法不会生成表结构文件, 所以我们导数据时还需要</p>
<p>单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和</p>
<p>csv数据文件。这条命令的使用方法如下：</p>
<p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个</p>
<p>t.txt文件保存CSV数据。物理拷贝方法</p>
<p>前面我们提到的mysqldump方法和导出CSV文件的方法，都是逻辑导数据的方法，也就是将数据</p>
<p>从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。你可能会问，有物理导数据的方法吗？比如，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目</p>
<p>录下，是否可行呢？答案是不行的。因为，一个InnoDB表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两</p>
<p>个文件的话，因为数据字典中没有db2.t这个表，系统是不会识别和接受它们的。不过，在MySQL 5.6版本引入了可传输表空间(transportable tablespace)的方法，可以通过导出</p>
<p>+导入表空间的方式，实现物理拷贝表的功能。假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p>
<ol>
<li><p>执行 create table r like t，创建一个相同表结构的空表；</p>
</li>
<li><p>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</p>
</li>
<li><p>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</p>
</li>
<li><p>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令（这里需要注意的是，拷贝得到的</p>
</li>
</ol>
<p>两个文件，MySQL进程要有读写权限）；</p>
<ol start="5">
<li><p>执行unlock tables，这时候t.cfg文件会被删除；</p>
</li>
<li><p>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件</p>
</li>
</ol>
<p>mysqldump -h$host -P$port -u$user —single-transaction  –set-gtid-purged&#x3D;OFF db1 t –where&#x3D;”a&gt;900” –tab&#x3D;$secure_file_priv</p>
<p>的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。至此，拷贝表数据的操作就完成了。这个流程的执行过程图如下：</p>
<p>图3 物理拷贝表</p>
<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol>
<li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令</li>
</ol>
<p>后才释放读锁；</p>
<ol start="2">
<li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改</li>
</ol>
<p>r.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件</p>
<p>（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些</p>
<p>时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。小结</p>
<p>今天这篇文章，我和你介绍了三种将一个表的数据导入到另外一个表中的方法。我们来对比一下这三种方法的优缺点。1. 物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，</p>
<p>用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快</p>
<p>的方法。但是，这种方法的使用也有一定的局限性：</p>
<p>必须是全表拷贝，不能只拷贝部分数据；</p>
<p>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</p>
<p>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。2. 用mysqldump生成包含INSERT语句文件的方法，可以在where参数增加过滤条件，来实现</p>
<p>只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。3. 用select … into outfile的方法是最灵活的，支持所有的SQL写法。但，这个方法的缺点之一就</p>
<p>是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。后两种方式都是逻辑备份方式，是可以跨引擎使用的。最后，我给你留下一个思考题吧。我们前面介绍binlog_format&#x3D;statement的时候，binlog记录的load data命令是带local的。既然这</p>
<p>条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如</p>
<p>果写到binlog中的命令不带local，又会出现什么问题呢？你可以把你的分析写在评论区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上篇文章最后给你留下的思考题，已经在今天这篇文章的正文部分做了回答。上篇文章的评论区有几个非常好的留言，我在这里和你分享一下。@huolang 同学提了一个问题：如果sessionA拿到c&#x3D;5的记录锁是写锁，那为什么sessionB和</p>
<p>sessionC还能加c&#x3D;5的读锁呢？这是因为next-key lock是先加间隙锁，再加记录锁的。加间隙锁成功了，加记录锁就会被堵住。如果你对这个过程有疑问的话，可以再复习一下第30篇文章中的相关内容。@一大只 同学做了一个实验，验证了主键冲突以后，insert语句加间隙锁的效果。比我在上篇文</p>
<p>章正文中提的那个回滚导致死锁的例子更直观，体现了他对这个知识点非常好的理解和思考，很</p>
<p>赞。@roaming 同学验证了在MySQL 8.0版本中，已经能够用临时表处理insert … select写入原表的语</p>
<p>句了。@老杨同志 的回答提到了我们本文中说到的几个方法。poppy   4</p>
<p>关于思考题，我理解是备库的同步线程其实相当于备库的一个客户端，由于备库的会把binlog</p>
<p>中t.csv的内容写到&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0中，如果load data命令不加’local’表示读取服务端</p>
<p>的文件，文件必须在secure_file_priv指定的目录或子目录，此时可能找不到该文件，主备同步</p>
<p>执行会失败。而加上local的话，表示读取客户端的文件，既然备份线程都能在该目录下创建临</p>
<p>时文件&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0,必然也有权限访问，把该文件传给服务端执行。2019-02-15</p>
<p> 作者回复</p>
<p> 这是其中一个原因</p>
<p>2019-02-16</p>
<p>☆appleう   3</p>
<p>通知对方更新数据的意思是: 针对事务内的3个操作:插入和更新两个都是本地操作，第三个操作</p>
<p>是远程调用，这里远程调用其实是想把本地操作的那两条通知对方(对方:远程调用)，让对方把</p>
<p>数据更新，这样双方(我和远程调用方)的数据达到一致，如果对方操作失败，事务的前两个操</p>
<p>作也会回滚，主要是想保证双方数据的一致性，因为远程调用可能会出现网络延迟超时等因素</p>
<p>，极端情况会导致事务10s左右才能处理完毕，想问的是这样耗时的事务会带来哪些影响呢？设计的初衷是想这三个操作能原子执行，只要有不成功就可以回滚，保证两方数据的一致性</p>
<p>精选留言</p>
<p>耗时长的远程调用不放在事务中执行，会出现我这面数据完成了，而对方那面由于网络等问题</p>
<p>，并没有更新，这样两方的数据就出现不一致了</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>嗯 了解了</p>
<p>这种设计我觉得就是会对并发性有比较大的影响。一般如果网络状态不好的，会建议把这个更新操作放到消息队列。就是说</p>
<ol>
<li><p>先本地提交事务。2. 把通知这个动作放到消息队列，失败了可以重试；</p>
</li>
<li><p>远端接收事件要设置成可重入的，就是即使同一个消息收到两次，也跟收到一次是相同的效</p>
</li>
</ol>
<p>果。2 和3 配合起来保证最终一致性。这种设计我见到得比较多，你评估下是否符合你们业务的需求哈</p>
<p>2019-02-15</p>
<p>undifined   3</p>
<p>老师，用物理导入的方式执行 alter table r import tablespace 时 提示ERROR 1812 (HY000): Ta</p>
<p>blespace is missing for table <code>db1</code>.<code>r</code>. 此时 db1&#x2F; 下面的文件有 db.opt r.cfg r.frm r.ibd t.frm t.ibd</p>
<p>；这个该怎么处理</p>
<p>执行步骤：</p>
<p>mysql&gt; create table r like t;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; alter table r discard tablespace;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; flush table t for export;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>cp t.cfg r.cfg</p>
<p>cp t.ibd r.ibd</p>
<p>mysql&gt; unlock tables;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; alter table r import tablespace;</p>
<p>ERROR 1812 (HY000): Tablespace is missing for table <code>db1</code>.<code>r</code>.</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>应该就是评论区其他同学帮忙回复的权限问题了吧？2019-02-15</p>
<p>lionetes   2</p>
<p>mysql&gt; select * from t;</p>
<p>+—-+——+</p>
<p>| id | name |</p>
<p>+—-+——+</p>
<p>| 1 | Bob |</p>
<p>| 2 | Mary |</p>
<p>| 3 | Jane |</p>
<p>| 4 | Lisa |</p>
<p>| 5 | Mary |</p>
<p>| 6 | Jane |</p>
<p>| 7 | Lisa |</p>
<p>+—-+——+</p>
<p>7 rows in set (0.00 sec)</p>
<p>mysql&gt; create table tt like t;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; alter table tt discard tablespace;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; flush table t for export;</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; unlock tables;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; alter table tt import tablespace;</p>
<p>Query OK, 0 rows affected (0.03 sec)</p>
<p>mysql&gt; show tables;</p>
<p>+—————-+</p>
<p>| Tables_in_test |</p>
<p>+—————-+</p>
<p>| t |</p>
<p>| t2 |</p>
<p>| tt |</p>
<p>+—————-+</p>
<p>3 rows in set (0.00 sec)</p>
<p>mysql&gt; select * from t;</p>
<p>+—-+——+</p>
<p>| id | name |</p>
<p>+—-+——+</p>
<p>| 1 | Bob |</p>
<p>| 2 | Mary |</p>
<p>| 3 | Jane |</p>
<p>| 4 | Lisa |</p>
<p>| 5 | Mary |</p>
<p>| 6 | Jane |</p>
<p>| 7 | Lisa |</p>
<p>+—-+——+</p>
<p>7 rows in set (0.00 sec)</p>
<p>mysql&gt; select * from tt;</p>
<p>+—-+——+</p>
<p>| id | name |</p>
<p>+—-+——+</p>
<p>| 1 | Bob |</p>
<p>| 2 | Mary |</p>
<p>| 3 | Jane |</p>
<p>| 4 | Lisa |</p>
<p>| 5 | Mary |</p>
<p>| 6 | Jane |</p>
<p>| 7 | Lisa |</p>
<p>+—-+——+</p>
<p>7 rows in set (0.00 sec)</p>
<p>ll 后 查看 tt.cfg 文件没有自动删除 5.7mysql</p>
<p>-rw-r—–. 1 mysql mysql 380 2月 15 09:51 tt.cfg</p>
<p>-rw-r—–. 1 mysql mysql 8586 2月 15 09:49 tt.frm</p>
<p>-rw-r—–. 1 mysql mysql 98304 2月 15 09:51 tt.ibd</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>你说得对， 细致</p>
<p>import动作 不会自动删除cfg文件，我图改一下</p>
<p>2019-02-15</p>
<p>☆appleう   2</p>
<p>老师，我想问一个关于事务的问题，一个事务中有3个操作，插入一条数据(本地操作),更新一条</p>
<p>数据(本地操作)，然后远程调用，通知对方更新上面数据(如果远程调用失败会重试，最多3次，</p>
<p>如果遇到网络等问题，远程调用时间会达到5s,极端情况3次会达到15s)，那么极端情况事务将</p>
<p>长达5-15s，这样会带来什么影响吗？2019-02-15</p>
<p> 作者回复</p>
<p>“通知对方更新上面数据” 是啥概念，如果你这个事务没提交，其他线程也看不到前两个操作的</p>
<p>结果的。设计上不建议留这么长的事务哈，最好是可以先把事务提交了，再去做耗时的操作。2019-02-15</p>
<p>AstonPutting   1</p>
<p>老师，mysqlpump能否在平时代替mysqldump的使用？2019-02-22</p>
<p> 作者回复</p>
<p>我觉得是</p>
<p>2019-02-23</p>
<p>PengfeiWang   1</p>
<p>老师，您好：</p>
<p>文中“–add-locks 设置为 0，表示在输出的文件结果里，不增加” LOCK TABLES t WRITE;” 是否</p>
<p>是笔误，–add-locks应该是在insert语句前后添加锁，我的理解此处应该是–skip-add-locks，不</p>
<p>知道是否是这样？2019-02-18</p>
<p> 作者回复</p>
<p>嗯嗯，命令中写错了，是–add-locks&#x3D;0，</p>
<p>效果上跟–skip-add-locks是一样的哈</p>
<p> 细致</p>
<p>2019-02-19</p>
<p>长杰   1</p>
<p>课后题答案</p>
<p>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</p>
<p>而备库的apply线程执行时先讲csv内容读出生成tmp目录下的临时文件，这个目录容易受secure</p>
<p>_file_priv的影响，如果备库改参数设置为Null或指定的目录，可能导致load操作失败，加local则</p>
<p>不受这个影响。2019-02-17</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-18</p>
<p>尘封   1</p>
<p>老师mysqldump导出的文件里，单条sql里的value值有什么限制吗默认情况下，假如一个表有</p>
<p>几百万，那mysql会分为多少个sql导出？问题：因为从库可能没有load的权限，所以local</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>好问题，</p>
<p>会控制单行不会超过参数net_buffer_length，这个参数是可以通过–net_buffer_length 传给mysql</p>
<p>dump 工具的</p>
<p>2019-02-28</p>
<p>佳   0</p>
<p>老师好，这个&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0 是应该在主库上面，还是备库上面？为啥我执行完是在</p>
<p>主库上面出现了这个文件呢？2019-03-14</p>
<p> 作者回复</p>
<p>就是在MySQL的运行进程所在的主机上</p>
<p>2019-03-16</p>
<p>xxj123go   0</p>
<p>传输表空间方式对主从同步会有影响么</p>
<p>2019-03-12</p>
<p> 作者回复</p>
<p>你可以看下执行以后，进不进binlog  </p>
<p>2019-03-13</p>
<p>王显伟   0</p>
<p>第一位留言的朋友报错我也复现了，原因是用root复制的文件，没有修改属组导致的</p>
<p>2019-02-16</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-17</p>
<p>夜空中最亮的星（华仔）   0</p>
<p>学习完老师的课都想做dba了</p>
<p>2019-02-15</p>
<p>undifined   0</p>
<p>老师 错误信息的截屏 <a href="https://www.dropbox.com/s/8wyet4bt9yfjsau/mysqlerror.png?dl=0">https://www.dropbox.com/s/8wyet4bt9yfjsau/mysqlerror.png?dl=0</a></p>
<p>MySQL 5.7，Mac 上的 Docker 容器里面跑的，版本是 5.7.17</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>额，打不开。。可否发个微博贴图 </p>
<p>2019-02-16</p>
<p>晨思暮语   0</p>
<p>不好意思，第一条留言中，实验三的最后一天语句还是少了，在这里贴一下，</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 3 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>2019-02-15</p>
<p>晨思暮语   0</p>
<p>老师好，由于字数限制，分两条：</p>
<p>我用的是percona数据库，问题是第15章中的思考题。根据我做的实验，结论应该是：</p>
<p>MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更</p>
<p>新，直接返回</p>
<p>一直没有想明白，老师再帮忙看看，谢谢！</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>我两个留言连在一起看没看明白你对哪个步骤的哪个结果有疑虑，</p>
<p>可以写在现象里面（用注释即可）哈</p>
<p>2019-02-16</p>
<p>晨思暮语   0</p>
<p>mysql&gt; select version();</p>
<p>+————+</p>
<p>| version() |</p>
<p>+————+</p>
<p>| 5.7.22-log |</p>
<p>+————+</p>
<p>实验1:</p>
<p>SESSION A:</p>
<p>mysql&gt; begin;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>SESSION B:</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 1 row affected (0.01 sec)</p>
<p>Rows matched: 1 Changed: 1 Warnings: 0</p>
<p>SESSION A:</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>实验2:</p>
<p>SESSION A:</p>
<p>mysql&gt; begin;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>SESSION B:</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>Rows matched: 1 Changed: 1 Warnings: 0</p>
<p>SESSION A:</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>BLOCKED</p>
<p>SESSION B:</p>
<p>mysql&gt; commit;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>SESSION A:UPDATE</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 0 rows affected (5.43 sec)</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>mysql&gt; </p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>实验3:</p>
<p>SESSION A:</p>
<p>mysql&gt; begin;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from t where id&#x3D;1;</p>
<p>+—-+——+</p>
<p>| id | a |</p>
<p>+—-+——+</p>
<p>| 1 | 2 |</p>
<p>+—-+——+</p>
<p>1 row in set (0.00 sec)</p>
<p>SESSION B:</p>
<p>mysql&gt; begin;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 1 row affected (0.00 sec)</p>
<p>Rows matched: 1 Changed: 1 Warnings: 0</p>
<p>SESSION A:</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>blocked</p>
<p>SESSION B:</p>
<p>mysql&gt; rollback;</p>
<p>Query OK, 0 rows affected (0.00 sec)</p>
<p>SESSION A:UPDATE</p>
<p>mysql&gt; update t set a&#x3D;3 where id&#x3D;1;</p>
<p>Query OK, 1 row affected (5.21 sec)</p>
<p>Rows matched: 1 C</p>
<p>2019-02-15</p>
<p>库淘淘   0</p>
<p>如果不加local 如secure_file_priv 设置为null 或者路径 可能就不能成功,这样加了之后可以保证</p>
<p>执行成功率不受参数secure_file_priv影响。 还有发现物理拷贝文件后，权限所属用户还得改下</p>
<p>，不然import tablespace 会报错找不到文件，老师是不是应该补充上去，不然容易踩坑。2019-02-15</p>
<p> 作者回复</p>
<p>嗯嗯，有同学已经踩了，</p>
<p>我加个说明进去，多谢提醒</p>
<p>2019-02-15</p>
<p>lionetes   0</p>
<p>@undifined 看下是否是 权限问题引起的 cp 完后 是不是mysql 权限</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>  经验丰富</p>
<p>如果进程用mysql用户启动，命令行是在root账号下，确实会出现这种情况</p>
<p>2019-02-15</p>
<p>Ryoma   0</p>
<p>问老师一个主题无关的问题：现有数据库中有个表字段为text类型，但是目前发现text中的数据</p>
<p>有点不太对。请问在MySQL中有没有办法确认在插入时是否发生截断数据的情况么？（因为该字段被修改过</p>
<p>，我现在不方便恢复当时的现场）</p>
<p>2019-02-15</p>
<p> 作者回复</p>
<p>看那个语句的binlog （是row吧？）  </p>
<p>2019-02-15</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-我查这么多数据会不会把数据库内存打爆</title>
    <url>/posts/f0491e2a.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>33 | 我查这么多数据，会不会把数据库内存打爆？2019-01-28 林晓斌</p>
<p>我经常会被问到这样一个问题：我的主机内存只有100G，现在要对一个200G的大表做全表扫</p>
<p>描，会不会把数据库主机的内存用光了？这个问题确实值得担心，被系统OOM（out of memory）可不是闹着玩的。但是，反过来想想，</p>
<p>逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？全表扫描对server层的影响</p>
<p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。当然，你要把扫描结果</p>
<p>保存在客户端，会使用类似这样的命令：</p>
<p>你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主</p>
<p>键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里</p>
<p>面，然后返回给客户端。那么，这个“结果集”存在哪里呢？mysql -h$host -P$port -u$user -p$pwd -e “select * from db1.t” &gt; $target_file</p>
<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>
<ol>
<li>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是</li>
</ol>
<p>16k。2. 重复获取行，直到net_buffer写满，调用网络接口发出去。3. 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。4. 如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send</p>
<p>buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。这个过程对应的流程图如下所示。图1 查询结果发送流程</p>
<p>从这个流程中，你可以看到：</p>
<ol>
<li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不</li>
</ol>
<p>会达到200G；</p>
<ol start="2">
<li>socket send buffer 也不可能达到200G（默认定义&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_default），如</li>
</ol>
<p>果socket send buffer被写满，就会暂停读数据的流程。也就是说，MySQL是“边读边发的”，这个概念很重要。这就意味着，如果客户端接收得慢，会</p>
<p>导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。比如下面这个状态，就是我故意让客户端不去读socket receive buffer中的内容，然后在服务端</p>
<p>show processlist看到的结果。图2 服务端发送阻塞</p>
<p>如果你看到State的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。我在上一篇文章中曾提到，如果客户端使用–quick参数，会使用mysql_use_result方法。这个方</p>
<p>法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要</p>
<p>处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如图2所示</p>
<p>的这种情况。因此，对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使</p>
<p>用mysql_store_result这个接口，直接把查询结果保存到本地内存。当然前提是查询返回结果不多。在第30篇文章评论区，有同学说到自己因为执行了一个大查询</p>
<p>导致客户端占用内存近20G，这种情况下就需要改用mysql_use_result接口了。另一方面，如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状</p>
<p>态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一</p>
<p>个可选方案。与“Sending to client”长相很类似的一个状态是“Sending data”，这是一个经常被误会的问题。有同学问我说，在自己维护的实例上看到很多查询语句的状态是“Sending data”，但查看网络也</p>
<p>没什么问题啊，为什么Sending data要这么久？实际上，一个查询语句的状态变化是这样的（注意：这里，我略去了其他无关的状态）：</p>
<p>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；</p>
<p>然后，发送执行结果的列相关的信息（meta data) 给客户端；</p>
<p>再继续执行语句的流程；</p>
<p>执行完成后，把状态设置成空字符串。也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶</p>
<p>段。比如，你可以构造一个锁等待的场景，就能看到Sending data状态。图3 读全表被锁</p>
<p>图 4 Sending data状态</p>
<p>可以看到，session B明显是在等锁，状态显示为Sending data。也就是说，仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如</p>
<p>果显示成“Sending data”，它的意思只是“正在执行”。现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会</p>
<p>把内存打爆。在server层的处理逻辑我们都清楚了，在InnoDB引擎里面又是怎么处理的呢？ 扫描全表会不会</p>
<p>对引擎系统造成影响呢？全表扫描对InnoDB的影响</p>
<p>在第2和第15篇文章中，我介绍WAL机制的时候，和你分析了InnoDB内存的一个作用，是保存</p>
<p>更新的结果，再配合redo log，就避免了随机写盘。内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而</p>
<p>实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。在第2篇文章的评论区有同学问道，由于有WAL机制，当事务提交的时候，磁盘上的数据页是旧</p>
<p>的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把redo log应用到数据页</p>
<p>呢？答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。你看，这时候</p>
<p>查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool还有加速查询</p>
<p>的作用。而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：内存命中率。你可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一</p>
<p>个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。执行show engine innodb status ，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中</p>
<p>率。比如图5这个命中率，就是99.0%。图5 show engine innodb status显示内存命中率</p>
<p>如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是100%。但，这在实际生产上是很难做到的。InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理</p>
<p>内存的60%~80%。在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有</p>
<p>128G甚至更高的内存，但是单机的数据量却达到了T级别。所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而</p>
<p>又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是</p>
<p>淘汰最久未使用的数据。下图是一个LRU算法的基本模型。图6 基本LRU算法</p>
<p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。1. 在图6的状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能</p>
<p>放下这么多数据页；</p>
<ol start="2">
<li><p>这时候有一个读请求访问P3，因此变成状态2，P3被移到最前面；</p>
</li>
<li><p>状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个</p>
</li>
</ol>
<p>数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表</p>
<p>末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。4. 从效果上看，就是最久没有被访问的数据页Pm，被淘汰了。这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？假设按照这个算法，我们要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访</p>
<p>问它。那么，按照这个算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中</p>
<p>访问到的数据页的内容。也就是说Buffer Pool里面主要放的是这个历史数据表的数据。对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool的内存命中率急剧下降，磁盘</p>
<p>压力增加，SQL语句响应变慢。所以，InnoDB不能直接使用这个LRU算法。实际上，InnoDB对LRU算法做了改进。图 7 改进的LRU算法</p>
<p>在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指</p>
<p>向的就是old区域的第一个位置，是整个链表的5&#x2F;8处。也就是说，靠近链表头部的5&#x2F;8是young区</p>
<p>域，靠近链表尾部的3&#x2F;8是old区域。改进后的LRU算法执行流程变成了下面这样。1. 图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将</p>
<p>其移到链表头部，变成状态2。2. 之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新</p>
<p>插入的数据页Px，是放在LRU_old处。3. 处于old区域的数据页，每次被访问的时候都要做下面这个判断：</p>
<p>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</p>
<p>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由</p>
<p>参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。这个策略，就是为了处理类似全表扫描的操作量身定制的。还是以刚刚的扫描200G的历史数据</p>
<p>表为例，我们看看改进后的LRU算法的操作逻辑：</p>
<ol>
<li><p>扫描过程中，需要新插入的数据页，都被放到old区域;</p>
</li>
<li><p>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页</p>
</li>
</ol>
<p>第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</p>
<ol start="3">
<li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到</li>
</ol>
<p>链表头部（也就是young区域），很快就会被淘汰出去。可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但</p>
<p>是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。小结</p>
<p>今天，我用“大查询会不会把内存用光”这个问题，和你介绍了MySQL的查询结果，发送给客户端</p>
<p>的过程。由于MySQL采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在server端保</p>
<p>存完整的结果集。所以，如果客户端读结果不及时，会堵住MySQL的查询过程，但是不会把内</p>
<p>存打爆。而对于InnoDB引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于InnoDB对</p>
<p>LRU算法做了改进，冷数据的全表扫描，对Buffer Pool的影响也能做到可控。当然，我们前面文章有说过，全表扫描还是比较耗费IO资源的，所以业务高峰期还是不能直接在</p>
<p>线上主库执行全表扫描的。最后，我给你留一个思考题吧。我在文章中说到，如果由于客户端压力太大，迟迟不能接收结果，会导致MySQL无法发送结果</p>
<p>而影响语句执行。但，这还不是最糟糕的情况。你可以设想出由于客户端的性能问题，对数据库影响更严重的例子吗？或者你是否经历过这样的</p>
<p>场景？你又是怎么优化的？你可以把你的经验和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，如果一个事务被kill之后，持续处于回滚状态，从恢复速度的角度看，你是应该重</p>
<p>启等它执行结束，还是应该强行重启整个MySQL进程。因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行</p>
<p>的话，就需要先做主备切换，切到新主库提供服务。切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于</p>
<p>我们在文章中说到的，减少系统压力，加速终止逻辑。评论区留言点赞板：</p>
<p>700   2</p>
<p>老师，您好。根据文章内容，提炼如下信息：</p>
<p>@HuaMax 的回答中提到了对其他线程的影响；</p>
<p>@夹心面包 @Ryoma @曾剑 同学提到了重启后依然继续做回滚操作的逻辑。精选留言</p>
<p>如果你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。如何处理？1)使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。2)优化查询结果，并评估这么多的返回结果是否合理。3)而如果要快速减少处于这个状态的线程的话，将 net_buffer_length 参数设置为一个更大的值</p>
<p>是一个可选方案。对于第3)方案不是很懂，“Sending to client” 表示服务器端的网路栈写满了，那不是应该加大 so</p>
<p>cket send buffer 吗？跟加大 net_buffer_length 有什么关系？net_buffer_length 加再大，但 sock</p>
<p>et send buffer 很小的话，网络栈不还是处于写满状态？2019-01-28</p>
<p> 作者回复</p>
<p>好问题  很好的思考 </p>
<p>是这样的，net_buffer_length 的最大值是 1G，这个值比 socket send buffer大（一般是几M）</p>
<p>比如假设一个业务，他的平均查询结果都是10M （当然这个业务有有问题，最终是要通过业务</p>
<p>解决）</p>
<p>但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。虽然网络栈还</p>
<p>是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”</p>
<p>。2019-01-28</p>
<p>Long   4</p>
<p>最近没时间看，今天终于补完了几天的课。2019-01-28</p>
<p>长杰   3</p>
<p>遇到过一个场景，用mysqldump对业务db做逻辑备份保存在客户端，客户端是虚拟机，磁盘很</p>
<p>快满了，导致server端出现sending to client状态，更糟糕的是业务db更新频繁，导致undo表空</p>
<p>间变大，db服务堵塞，服务端磁盘空间不足。2019-01-28</p>
<p> 作者回复</p>
<p>非常好，正是我要说明的一个场景呢，直接用你的例子放在下篇答疑部分哈</p>
<p>2019-01-29</p>
<p>Sinyo   1</p>
<p>@700 的置顶提问 </p>
<p>老师你说：”但是如果把 net_buffer_length 改成 10M，就不会有“Sending to client”的情况。虽然</p>
<p>网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经</p>
<p>写出去了”。”</p>
<p>假如数据量有1G，而如果要快速减少处于这个状态的线程的话，我们把net_buffer_length 从10</p>
<p>M改成1G，快速减少的那部分操作是不是只有服务端发送到net_buffer的这部分？这样就不会有</p>
<p>“Sending to client”的情况么？2019-01-29</p>
<p> 作者回复</p>
<p>还是会显示为“Sending to client”，但是语句已经执行完了。不会占着资源（比如MDL读锁）</p>
<p>2019-01-29</p>
<p>700   1</p>
<p>老师，您好。感谢解答。接上个问题。Sending to client 是发生在下面哪个阶段的事件呢？1)是 “获取一行，写到 net_buffer 中。”</p>
<p>2)还是“直到 net_buffer 写满，调用网络接口发出去。” &#x2F;&#x2F;即数据从 net_buffer 发到 socket send b</p>
<p>uffer？3)还是“将 socket send buffer 的数据发送给 socket receive buffer”</p>
<p>从您的回答“但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。”，</p>
<p>我感觉应该是属于第1)阶段的事件。但感觉这又与您说的“Sending to client 表示的是服务器端</p>
<p>的网络栈写满了”相矛盾。2019-01-28</p>
<p> 作者回复</p>
<p>写net_buffer – &gt; net_buffer满了，调用网络接口发 –&gt;发不出去</p>
<p>这个是同一个调用链条呀</p>
<p>“哪个阶段”没看懂，是同一个时刻</p>
<p>2019-01-28</p>
<p>慕塔   0</p>
<p>young区域其实还有优化，频道调整LRU页的顺序为影响性能(LRU很长)，如果要读页在young</p>
<p>区域某位置，其实是没有必要将要读页拿到头部，本身已在热点区。页的属性有一个时间戳字</p>
<p>段，可以用于计算处于old区域的时间。 </p>
<p>2019-02-03</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>我看到评论的问题，有个疑惑：</p>
<p>“</p>
<p>之前有特殊功能需要从主要业务库拉取指定范围的数据到另外同一个库的其他数据表的动作（i</p>
<p>nsert into xxxxx select xxx from xxx 这种操作）数据量在万级或者十万级，对于这种操作，和本</p>
<p>文讲的应该有些不同吧？能否帮分析一下这种场景的大致情况呢？或者有什么好的建议吗？作者回复: 嗯，这个不会返回结果到客户端，所以网络上不会有问题</p>
<p>引擎内部的扫描机制是差不多的</p>
<p>唯一不同是这个过程可能对原表有行锁（如果设置的是RR）</p>
<p>万或者十万还好，是小数据，可以考虑拿到客户端再写回去，避免锁的问题</p>
<p>”</p>
<p>先把数据拿回客户端，再insert到另一个库。是为了避免锁的问题。这里从原库拉取数据就是select语句，没有涉及到next-key锁呀，为啥会有锁的问题呢？2019-02-01</p>
<p> 作者回复</p>
<p>好问题 ，第40篇会说这个问题哈，新年快乐</p>
<p>2019-02-01</p>
<p>梁中华   0</p>
<p>感觉young 和old 的叫法反了，后面的应该叫young 才好理解。另外文中的old 区也会有类似yo</p>
<p>ung 区域的淘汰策略吧</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>好几个同学这么说，我都方了 </p>
<p>这句是官方文档上的</p>
<p>“Accessing a page in the old sublist makes it “young”, moving it to the head of the buffer pool”</p>
<p>2019-01-30</p>
<p>Leon    0</p>
<p>如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。这个是指客户</p>
<p>端的tcp滑动窗口处理没有及时确认，导致server端的网络协议栈没有多余的空间可以发送数据</p>
<p>，导致server的处理线程停止从db读取数据发送给client，是这样理解吗</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>对的</p>
<p>2019-01-30</p>
<p>Richie   0</p>
<p>老师，怎么才能了解什么地方占用内存，查了很多资料都没有这方面的信息，MySQL5.6</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>这个官方版本确实是还没有系统的地方查看~</p>
<p>2019-02-04</p>
<p>changshan   0</p>
<p>老师好，咨询一个于之前文章有关的问题，在rr隔离级别下会产生幻读，然而这个幻读mysql是</p>
<p>通过什么机制来解决的呢？有的说是mvcc，有的说是next-key锁。有点疑惑了。另外，怎么能</p>
<p>够验证mysql使用具体的哪种技术解决了幻读？2019-01-29</p>
<p> 作者回复</p>
<p>看一下20和21篇哈</p>
<p>2019-01-29</p>
<p>天使梦泪   0</p>
<p>老师好，针对我上次问您的mysql缓存中的数据储存问题，您回答可以一直保存的，具体是怎</p>
<p>么实现一直保存的（也不是储存在磁盘上，是使用的内存）？内存重启了之后，缓存不就也丢</p>
<p>失了，是怎么做到持久化保存的，老师可以帮忙详细解答下么？2019-01-29</p>
<p> 作者回复</p>
<p>InnoDB 的是buffer pool，是在内存里。”内存重启了之后，缓存不就也丢失了，是怎么做到持久化保存的，老师可以帮忙详细解答下么</p>
<p>？“</p>
<p>没有保存，重启就没有了，要访问的时候需要重新去磁盘读</p>
<p>2019-01-29</p>
<p>有铭   0</p>
<p>感觉mysql的做法有点流式读取的意思。但是，老师，虽然这篇文章讲述了Mysql是如何“边读边发”。但是更复杂的情况没有说明，比如</p>
<p>我现在要执行一个复杂的查询，而且查询是排序的，这意味着mysql需要对整个结构排序，然</p>
<p>后才能一条条的发出去，如果数据量极大的情况，Mysql如何完成排序过程，需要把数据全部</p>
<p>载入内存吗？还是存储在缓存文件里搞分而治之的排序，然后再“边读边发”</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<p>看一下 <a href="https://time.geekbang.org/column/article/73479">https://time.geekbang.org/column/article/73479</a> 这篇文章的图5哈</p>
<p>有说到哦</p>
<p>2019-01-29</p>
<p>Max   0</p>
<p>林Sir,你好。曾经发生过二个问题</p>
<p>第一个问题是show columns from table带来的临时表产生和移除</p>
<p>大量的session opening tmp tables 和removing tmp tables</p>
<p>也kill不掉会话，首先主从先切，让原主停止对外服务。在kill掉所有用户会话。问题解决，同时修改innodb_thread_concurrency参数数量。另外一个感觉是mysql bug引起的。当时环境是percona-mysql-20-21主从环境</p>
<p>没有高并发所，所有的用户会话状态都是query end，会话不释放。造成会话连接数暴涨。撑满了所有的会话。查看engine innodb status，发现latch等待非常高 </p>
<p>OS WAIT ARRAY INFO: signal count 5607657</p>
<p>RW-shared spins 0, rounds 2702261, OS waits 70377</p>
<p>RW-excl spins 0, rounds 216191633, OS waits 1802414</p>
<p>RW-sx spins 1588, rounds 5965, OS waits 70</p>
<p>Spin rounds per wait: 2702261.00 RW-shared, 216191633.00 RW-excl, 3.76 RW-sx</p>
<p>MySQL thread id 79467374, OS thread handle 140327525230336, query id 949505008 10.0.2.6 </p>
<p>apirwuser query end</p>
<p>INSERT INTO <code>xxxxxx</code> (<code>xxxx</code>,<code>xxxx</code>,<code>xxxx</code>,<code>xxxx</code>) VALUES (‘c2aab326-adf9-470b-940e-133fa2</p>
<p>c7f685’,’android’,’862915033153129’,1535597836)</p>
<p>—TRANSACTION 1154797559, ACTIVE (PREPARED) 1 sec</p>
<p>mysql tables in use 1, locked 1</p>
<p>第二个问题一直没有解决，后来把mysql 5.7 降到mysql 5.6</p>
<p>还有一个关于out of memory问题</p>
<p>sql如下: a是父表，b是子表</p>
<p>select a.id,a.name,b.title from a inner join b on a.id&#x3D;b.aid </p>
<p>where a.create_time&gt;’2010-08-01 00:00:00’ and a.create_time&lt;’2010-08-10 23:59:59’ </p>
<p>它的执行计划应该是</p>
<p>1 a表和b表生产迪卡集产生虚列集合T。2从集合T筛选出 a.id(主键)&#x3D;b.aid(外键)产生虚集合V 3</p>
<p>最后从集合v筛选出where条件，得到最终结果。如果二个表都超过千万条记录，产生的集合数据应该是放到内存中。如果是这样会不会打暴内</p>
<p>存</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<ol>
<li><p>是的，show columns 其实不是一个好操作 </p>
</li>
<li><p>这个没见过，也没印象在社区中碰到这种现象，降成5.6就好了是吗？3. 不会的，34、35两篇就是说这个问题的哈</p>
</li>
</ol>
<p>2019-01-31</p>
<p>PHP-SICUN   0</p>
<p>老师，您好，有两个问题麻烦解惑一下</p>
<p>1.扫描200G的表时数据会先放到InnoDB buffer pool,然后发送时在读取到net_buffer吗？2.如果是的话，异常情况导致socket send buffer被写满，是不是会出现InnoDB buffer中的某一</p>
<p>页有可能出现读取后面的行时，超过1s，而被放到yong区域的情况？不知道这样表述或者理解的对吗</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<ol>
<li><p>是 ，但是也不是“全部放到buffer pool以后”才发，读的时候是一个page 一个page 地读的</p>
</li>
<li><p>会，好在这个是“某一页”而已，量不大。 好问题</p>
</li>
</ol>
<p>很好的思考</p>
<p>2019-01-29</p>
<p>Ryoma   0</p>
<p>有两个问题：</p>
<p>0：MySQL 中的新生代和老生代的名字这么反人类的么</p>
<p>1：我在使用show engine innodb status看Buffer Pool时，发现Buffer Pool有8个（0~8），请问</p>
<p>老师这个是什么策略呢？2019-01-28</p>
<p> 作者回复</p>
<p>0  </p>
<ol>
<li>搜一下 innodb_buffer_pool_instances 这个参数的解释哈</li>
</ol>
<p>2019-01-28</p>
<p>老杨同志   0</p>
<p>老师提示考虑两个客户端都进行update的情况。如果第一个客户端执行select * from t for update 而迟迟不读取返回的数据，会造成server端长</p>
<p>期占用记录的行锁，如果其他线程要更新被锁定的记录，会报锁等待超时的错误</p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-28</p>
<p>天使梦泪   0</p>
<p>老师，我有个问题不明白，mysql从缓存中取数据，缓存里的数据是怎么实现可以保存一段时</p>
<p>间的？2019-01-28</p>
<p> 作者回复</p>
<p>“保存一段时间”是啥意思，LRU算法不是按照时间的哈，如果没人来淘汰，是可以一直保存的</p>
<p>。2019-01-28</p>
<p>如明如月   0</p>
<p>之前有特殊功能需要从主要业务库拉取指定范围的数据到另外同一个库的其他数据表的动作（i</p>
<p>nsert into xxxxx select xxx from xxx 这种操作）数据量在万级或者十万级，对于这种操作，和本</p>
<p>文讲的应该有些不同吧？能否帮分析一下这种场景的大致情况呢？或者有什么好的建议吗？2019-01-28</p>
<p> 作者回复</p>
<p>嗯，这个不会返回结果到客户端，所以网络上不会有问题</p>
<p>引擎内部的扫描机制是差不多的</p>
<p>唯一不同是这个过程可能对原表有行锁（如果设置的是RR）</p>
<p>万或者十万还好，是小数据，可以考虑拿到客户端再写回去，避免锁的问题</p>
<p>2019-01-28</p>
<p>garming   0</p>
<p>老师你好，如果是MyISAM存储引擎，大查询会导致内存暴涨吗？如果过，是什么原因呢？2019-01-28</p>
<p> 作者回复</p>
<p>也是不会的，跟InnoDB一样</p>
<p>2019-01-28</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-普通索引和唯一索引，应该怎么选择</title>
    <url>/posts/5ec5b1a0.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>09 | 普通索引和唯一索引，应该怎么选择？2018-12-03 林晓斌</p>
<p>今天的正文开始前，我要特意感谢一下评论区几位留下高质量留言的同学。用户名是 @某、人 的同学，对文章的知识点做了梳理，然后提了关于事务可见性的问题，就是</p>
<p>先启动但是后提交的事务，对数据可见性的影响。@夏日雨同学也提到了这个问题，我在置顶评</p>
<p>论中回复了，今天的文章末尾也会再展开说明。@Justin和@倪大人两位同学提了两个好问题。对于能够引发更深一步思考的问题，我会在回复的内容中写上“好问题”三个字，方便你搜索，你</p>
<p>也可以去看看他们的留言。非常感谢大家很细致地看文章，并且留下了那么多和很高质量的留言。知道文章有给大家带来一</p>
<p>些新理解，对我来说是一个很好的鼓励。同时，也让其他认真看评论区的同学，有机会发现一些</p>
<p>自己还没有意识到的、但可能还不清晰的知识点，这也在总体上提高了整个专栏的质量。再次谢</p>
<p>谢你们。好了，现在就回到我们今天的正文内容。在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引</p>
<p>的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写</p>
<p>入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语</p>
<p>句：</p>
<p>所以，你一定会考虑在id_card字段上建索引。由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给</p>
<p>id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的</p>
<p>身份证号，那么这两个选择逻辑上都是正确的。现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么</p>
<p>呢？简单起见，我们还是用第4篇文章《深入浅出索引（上）》中的例子来说明，假设字段 k 上的值</p>
<p>都不重复。图1 InnoDB的索引组织结构</p>
<p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。查询过程</p>
<p>select name from CUser where id_card &#x3D; ‘xxxxxxxyyyyyyzzzzz’;</p>
<p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先</p>
<p>是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认</p>
<p>为数据页内部通过二分法来定位记录。对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰</p>
<p>到第一个不满足k&#x3D;5条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继</p>
<p>续检索。那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，</p>
<p>并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每</p>
<p>个数据页的大小默认是16KB。因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针</p>
<p>寻找和一次计算。当然，如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下</p>
<p>一个数据页，这个操作会稍微复杂一些。但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概</p>
<p>率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以</p>
<p>忽略不计。更新过程</p>
<p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change</p>
<p>buffer。当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中</p>
<p>的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样</p>
<p>就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内</p>
<p>存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正</p>
<p>确性。需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是</p>
<p>说，change buffer在内存中有拷贝，也会被写入到磁盘上。将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据</p>
<p>页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，</p>
<p>也会执行merge操作。显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显</p>
<p>的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提</p>
<p>高内存利用率。那么，什么条件下可以使用change buffer呢？对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入</p>
<p>(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存</p>
<p>才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer</p>
<p>了。因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通</p>
<p>过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change</p>
<p>buffer的大小最多只能占用buffer pool的50%。现在，你已经理解了change buffer的机制，那么我们再一起来看看如果要在这张表中插入一个</p>
<p>新记录(4,400)的话，InnoDB的处理流程是怎样的。第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：</p>
<p>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</p>
<p>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的</p>
<p>CPU时间。但，这不是我们关注的重点。第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB的处理流程如下：</p>
<p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结</p>
<p>束；</p>
<p>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer</p>
<p>因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突</p>
<p>然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现</p>
<p>这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。change buffer的使用场景</p>
<p>通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change</p>
<p>buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通</p>
<p>索引的所有场景，使用change buffer都可以起到加速作用吗？因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动</p>
<p>作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面</p>
<p>上要更新的次数越多），收益就越大。因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change</p>
<p>buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记</p>
<p>录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问</p>
<p>IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来</p>
<p>说，change buffer反而起到了副作用。索引选择和实践</p>
<p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上</p>
<p>是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在</p>
<p>其他情况下，change buffer都能提升更新性能。在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优</p>
<p>化还是很明显的。特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个</p>
<p>类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索</p>
<p>引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入</p>
<p>速度。change buffer 和 redo log</p>
<p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机</p>
<p>制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个</p>
<p>流程里来说明，便于你区分这两个概念。现在，我们要在表上执行这个插入语句：</p>
<p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer</p>
<p>pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。图2 带change buffer的更新过程</p>
<p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间</p>
<p>（t.ibd）、系统表空间（ibdata1）。这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li><p>Page 1在内存中，直接更新内存；</p>
</li>
<li><p>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个</p>
</li>
</ol>
<p>信息</p>
<p>备注：这里，你可以再回顾下第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中</p>
<p>的相关内容。mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</p>
<ol start="3">
<li>将上述两个动作记入redo log中（图中3和4）。做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了</li>
</ol>
<p>两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。那在这之后的读请求，要怎么处理呢？比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程</p>
<p>图。如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表</p>
<p>空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。图3 带change buffer的读过程</p>
<p>从图中可以看到：</p>
<ol>
<li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果</li>
</ol>
<p>读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其</p>
<p>实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从</p>
<p>内存返回结果，结果是正确的。2. 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作</p>
<p>日志，生成一个正确的版本并返回结果。可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随</p>
<p>机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消</p>
<p>耗。小结</p>
<p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了</p>
<p>change buffer的机制以及应用场景，最后讲到了索引选择的实践。由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建</p>
<p>议你优先考虑非唯一索引。最后，又到了思考题时间。通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不</p>
<p>会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了</p>
<p>merge过程，就等于是数据丢失了。会不会出现这种情况呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。补充：</p>
<p>评论区大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。这里，我再说明一下：</p>
<p>首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况</p>
<p>下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，</p>
<p>必须创建唯一索引。这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存</p>
<p>命中率低的时候，可以给你多提供一个排查思路。然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半</p>
<p>年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高</p>
<p>归档效率，可以考虑把表里面的唯一索引改成普通索引。上期问题时间</p>
<p>上期的问题是：如何构造一个“数据无法修改”的场景。评论区里已经有不少同学给出了正确答</p>
<p>案，这里我再描述一下。这样，session A看到的就是我截图的效果了。其实，还有另外一种场景，同学们在留言区都还没有提到。这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的</p>
<p>事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活</p>
<p>跃事务的判断”，我是准备留到这里再补充的。当我试图在这里讲述完整规则的时候，发现第8篇文章《事务到底是隔离的还是不隔离的？》中</p>
<p>的解释引入了太多的概念，以致于分析起来非常复杂。因此，我重写了第8篇，这样我们人工去判断可见性的时候，才会更方便。【看到这里，我建议</p>
<p>你能够再重新打开第8篇文章并认真学习一次。如果学习的过程中，有任何问题，也欢迎你给我</p>
<p>留言】</p>
<p>用新的方式来分析session B’的更新为什么对session A不可见就是：在session A视图数组创建</p>
<p>的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况。业务中如果要绕过这类问题，@约书亚提供了一个“乐观锁”的解法，大家可以去上一篇的留言区</p>
<p>看一下。评论区留言点赞板：</p>
<p>@某、人、@夏日雨、@周巘、@李金刚 等同学提了一个很好的问题，就是我们今天答案的</p>
<p>session B’ 的情况；</p>
<p>@justin 提到了提交和未提交版本的区别对待，@倪大人 提到了读提交和当前读的区别，都是</p>
<p>经过了思考后提出的好问题，大家可以去留言区看看。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-答疑文章（三）：说一说这些好问题</title>
    <url>/posts/67a42e4.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>44 | 答疑文章（三）：说一说这些好问题</p>
<p>2019-02-22 林晓斌</p>
<p>这是我们专栏的最后一篇答疑文章，今天我们来说说一些好问题。在我看来，能够帮我们扩展一个逻辑的边界的问题，就是好问题。因为通过解决这样的问题，能</p>
<p>够加深我们对这个逻辑的理解，或者帮我们关联到另外一个知识点，进而可以帮助我们建立起自</p>
<p>己的知识网络。在工作中会问好问题，是一个很重要的能力。经过这段时间的学习，从评论区的问题我可以感觉出来，紧跟课程学习的同学，对SQL语句执行</p>
<p>性能的感觉越来越好了，提出的问题也越来越细致和精准了。接下来，我们就一起看看同学们在评论区提到的这些好问题。在和你一起分析这些问题的时候，</p>
<p>我会指出它们具体是在哪篇文章出现的。同时，在回答这些问题的过程中，我会假设你已经掌握</p>
<p>了这篇文章涉及的知识。当然，如果你印象模糊了，也可以跳回文章再复习一次。join的写法</p>
<p>在第35篇文章《join语句怎么优化？》中，我在介绍join执行顺序的时候，用的都是</p>
<p>straight_join。@郭健 同学在文后提出了两个问题：</p>
<ol>
<li>如果用left join的话，左边的表一定是驱动表吗？2. 如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到</li>
</ol>
<p>on里面，其他条件写到where部分？为了同时回答这两个问题，我来构造两个表a和b：</p>
<p>表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。然后，我往两个表中都插入了6条</p>
<p>记录，其中在表a和b中同时存在的数据有4行。@郭健 同学提到的第二个问题，其实就是下面这两种写法的区别：</p>
<p>我把这两条语句分别记为Q1和Q2。首先，需要说明的是，这两个left join语句的语义逻辑并不相同。我们先来看一下它们的执行结</p>
<p>果。create table a(f1 int, f2 int, index(f1))engine&#x3D;innodb;</p>
<p>create table b(f1 int, f2 int)engine&#x3D;innodb;</p>
<p>insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</p>
<p>insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</p>
<p>select * from a left join b on(a.f1&#x3D;b.f1) and (a.f2&#x3D;b.f2); &#x2F;<em>Q1</em>&#x2F;</p>
<p>select * from a left join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;b.f2);&#x2F;<em>Q2</em>&#x2F;</p>
<p>图1 两个join的查询结果</p>
<p>可以看到：</p>
<p>语句Q1返回的数据集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一</p>
<p>行，并将表b的各个字段值填成NULL。语句Q2返回的是4行。从逻辑上可以这么理解，最后的两行，由于表b中没有匹配的字段，结</p>
<p>果集里面b.f2的值是空，不满足where 部分的条件判断，因此不能作为结果集的一部分。接下来，我们看看实际执行这两条语句时，MySQL是怎么做的。我们先一起看看语句Q1的explain结果：</p>
<p>图2 Q1的explain结果</p>
<p>可以看到，这个结果符合我们的预期：</p>
<p>驱动表是表a，被驱动表是表b；</p>
<p>由于表b的f1字段上没有索引，所以使用的是Block Nexted Loop Join（简称BNL） 算法。看到BNL算法，你就应该知道这条语句的执行流程其实是这样的：</p>
<ol>
<li>把表a的内容读入join_buffer 中。因为是select * ，所以字段f1和f2都被放入join_buffer了。2. 顺序扫描表b，对于每一行数据，判断join条件（也就是a.f1&#x3D;b.f1 and a.f2&#x3D;b.f2)是否满足，</li>
</ol>
<p>满足条件的记录, 作为结果集的一行返回。如果语句中有where子句，需要先判断where部分</p>
<p>满足条件后，再返回。3. 表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩</p>
<p>余字段补上NULL，再放入结果集中。对应的流程图如下：</p>
<p>图3 left join -BNL算法</p>
<p>可以看到，这条语句确实是以表a为驱动表，而且从执行效果看，也和使用straight_join是一样</p>
<p>的。你可能会想，语句Q2的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤3去掉</p>
<p>呢？我们还是先看一下语句Q2的expain结果吧。图4 Q2的explain结果</p>
<p>这里先和你说一句题外话，专栏马上就结束了，我也和你一起根据explain结果“脑补”了很多次一</p>
<p>条语句的执行流程了，所以我希望你已经具备了这个能力。今天，我们再一起分析一次SQL语句</p>
<p>的explain结果。可以看到，这条语句是以表b为驱动表的。而如果一条join语句的Extra字段什么都没写的话，就</p>
<p>表示使用的是Index Nested-Loop Join（简称NLJ）算法。因此，语句Q2的执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后</p>
<p>判断a.f2&#x3D;b.f2是否满足，满足条件的话就作为结果集的一部分返回。那么，为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？其实，这是因为优化器</p>
<p>基于Q2这个查询的语义做了优化。为了理解这个问题，我需要再和你交代一个背景知识点：在MySQL里，NULL跟任何值执行等值</p>
<p>判断和不等值判断的结果，都是NULL。这里包括， select NULL &#x3D; NULL 的结果，也是返回</p>
<p>NULL。因此，语句Q2里面where a.f2&#x3D;b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个</p>
<p>left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不</p>
<p>到的行，就放弃”。这样，这条语句虽然用的是left join，但是语义跟join是一致的。因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱</p>
<p>动表，这样就可以用上NLJ 算法。在执行explain之后，你再执行show warnings，就能看到这个</p>
<p>改写的结果，如图5所示。图5 Q2的改写结果</p>
<p>这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接</p>
<p>的。也就是说，使用left join时，左边的表不一定是驱动表。这样看来，如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值</p>
<p>判断或不等值判断，必须都写在on里面。那如果是join语句呢？这时候，我们再看看这两条语句：</p>
<p>我们再使用一次看explain 和 show warnings的方法，看看优化器是怎么做的。select * from a join b on(a.f1&#x3D;b.f1) and (a.f2&#x3D;b.f2); &#x2F;<em>Q3</em>&#x2F;</p>
<p>select * from a join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;b.f2);&#x2F;<em>Q4</em>&#x2F;</p>
<p>图6 join语句改写</p>
<p>可以看到，这两条语句都被改写成：</p>
<p>执行计划自然也是一模一样的。也就是说，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。Simple Nested Loop Join 的性能问题</p>
<p>我们知道，join语句使用不同的算法，对语句的性能影响会很大。在第34篇文章《到底可不可以</p>
<p>使用join？》的评论区中，@书策稠浊 和 @朝夕心 两位同学提了一个很不错的问题。我们在文中说到，虽然BNL算法和Simple Nested Loop Join 算法都是要判断M*N次（M和N分别</p>
<p>是join的两个表的行数），但是Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此</p>
<p>性能上BNL算法执行起来会快很多。为了便于说明，我还是先为你简单描述一下这两个算法。BNL算法的执行逻辑是：</p>
<ol>
<li><p>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；</p>
</li>
<li><p>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成</p>
</li>
</ol>
<p>功则作为结果集的一部分返回。select * from a join b where (a.f1&#x3D;b.f1) and (a.f2&#x3D;b.f2);</p>
<p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做</p>
<p>全表扫描匹配，匹配成功则作为结果集的一部分返回。这两位同学的疑问是，Simple Nested Loop Join算法，其实也是把数据读到内存里，然后按照匹</p>
<p>配条件进行判断，为什么性能差距会这么大呢？解释这个问题，需要用到MySQL中索引结构和Buffer Pool的相关知识点：</p>
<ol>
<li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从</li>
</ol>
<p>磁盘读入；</p>
<p>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被</p>
<p>驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部（请参考第35篇文</p>
<p>章中的相关内容)；</p>
<ol start="2">
<li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而</li>
</ol>
<p>join_buffer中是数组，遍历的成本更低。所以说，BNL算法的性能会更好。distinct 和 group by的性能</p>
<p>在第37篇文章《什么时候会使用内部临时表？》中，@老杨同志 提了一个好问题：如果只需要</p>
<p>去重，不需要执行聚合函数，distinct 和group by哪种效率高一些呢？我来展开一下他的问题：如果表t的字段a上没有索引，那么下面这两条语句：</p>
<p>的性能是不是相同的?</p>
<p>首先需要说明的是，这种group by的写法，并不是SQL标准的写法。标准的group by语句，是需</p>
<p>要在select部分加一个聚合函数，比如：</p>
<p>这条语句的逻辑是：按照字段a分组，计算每组的a出现的次数。在这个结果里，由于做的是聚</p>
<p>合计算，相同的a只出现一次。select a from t group by a order by null;</p>
<p>select distinct a from t;</p>
<p>select a,count(*) from t group by a order by null;</p>
<p>备注：这里你可以顺便复习一下第37篇文章中关于group by的相关内容。没有了count(*)以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：</p>
<p>按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函</p>
<p>数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。这两条语句的执行流程是下面这样的。1. 创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；</p>
<ol start="2">
<li>遍历表t，依次取数据插入临时表中：</li>
</ol>
<p>如果发现唯一键冲突，就跳过；</p>
<p>否则插入成功；</p>
<ol start="3">
<li>遍历完成后，将临时表作为结果集返回给客户端。备库自增主键问题</li>
</ol>
<p>除了性能问题，大家对细节的追问也很到位。在第39篇文章《自增主键为什么不是连续</p>
<p>的？》评论区，@帽子掉了 同学问到：在binlog_format&#x3D;statement时，语句A先获取id&#x3D;1，然后</p>
<p>语句B获取id&#x3D;2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，</p>
<p>是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？首先，这个问题默认了“自增id的生成顺序，和binlog的写入顺序可能是不同的”，这个理解是正</p>
<p>确的。其次，这个问题限定在statement格式下，也是对的。因为row格式的binlog就没有这个问题</p>
<p>了，Write row event里面直接写了每一行的所有字段的值。而至于为什么不会发生不一致的情况，我们来看一下下面的这个例子。图7 insert 语句的binlog</p>
<p>可以看到，在insert语句之前，还有一句SET INSERT_ID&#x3D;1。这条命令的意思是，这个线程里下</p>
<p>一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。create table t(id int auto_increment primary key);</p>
<p>insert into t values(null);</p>
<p>这个SET INSERT_ID语句是固定跟在insert语句之前的，比如@帽子掉了同学提到的场景，主库</p>
<p>上语句A的id是1，语句B的id是2，但是写入binlog的顺序先B后A，那么binlog就变成：</p>
<p>你看，在备库上语句B用到的INSERT_ID依然是2，跟主库相同。因此，即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。小结</p>
<p>今天这篇答疑文章，我选了4个好问题和你分享，并做了分析。在我看来，能够提出好问题，首</p>
<p>先表示这些同学理解了我们文章的内容，进而又做了深入思考。有你们在认真的阅读和思考，对</p>
<p>我来说是鼓励，也是动力。说实话，短短的三篇答疑文章无法全部展开同学们在评论区留下的高质量问题，之后有的同学还</p>
<p>会二刷，也会有新的同学加入，大家想到新的问题就请给我留言吧，我会继续关注评论区，和你</p>
<p>在评论区交流。老规矩，答疑文章也是要有课后思考题的。在第8篇文章的评论区， @XD同学提到一个问题：他查看了一下innodb_trx，发现这个事务的</p>
<p>trx_id是一个很大的数（281479535353408），而且似乎在同一个session中启动的会话得到的</p>
<p>trx_id是保持不变的。当执行任何加写锁的语句后，trx_id都会变成一个很小的数字</p>
<p>（118378）。你可以通过实验验证一下，然后分析看看，事务id的分配规则是什么，以及MySQL为什么要这么</p>
<p>设计呢？你可以把你的结论和分析写在留言区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，怎么给分区表t创建自增主键。由于MySQL要求主键包含所有的分区字段，所以</p>
<p>肯定是要创建联合主键的。这时候就有两种可选：一种是(ftime, id)，另一种是(id, ftime)。如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都</p>
<p>SET INSERT_ID&#x3D;2;</p>
<p>语句B；</p>
<p>SET INSERT_ID&#x3D;1;</p>
<p>语句A；</p>
<p>是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。这时的建表语句是：</p>
<p>当然，我的建议是你要尽量使用InnoDB引擎。InnoDB表要求至少有一个索引，以自增字段作为</p>
<p>第一个字段，所以需要加一个id的单独索引。当然把字段反过来，创建成：</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  f̀time  ̀datetime NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ ftime ,̀ ìd )̀</p>
<p>) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;latin1</p>
<p>PARTITION BY RANGE (YEAR(ftime))</p>
<p>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE &#x3D; MyISAM,</p>
<p> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE &#x3D; MyISAM,</p>
<p> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE &#x3D; MyISAM,</p>
<p> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE &#x3D; MyISAM);</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  f̀time  ̀datetime NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ ftime ,̀ ìd )̀,</p>
<p>  KEY ìd  ̀(̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</p>
<p>PARTITION BY RANGE (YEAR(ftime))</p>
<p>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE &#x3D; InnoDB,</p>
<p> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE &#x3D; InnoDB,</p>
<p> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE &#x3D; InnoDB,</p>
<p> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE &#x3D; InnoDB);</p>
<p>  PRIMARY KEY (̀ id ,̀ f̀time )̀,</p>
<p>  KEY ìd  ̀(̀ ftime )̀</p>
<p>也是可以的。评论区留言点赞板：</p>
<p>永恒记忆   2</p>
<p>老师，看评论包括您的回复说“ left join 后加上 where 的话， 肯定会被优化器优化成 join where </p>
<p>的形式， 那是否下次写 left join ..where 的时候， 不如直接写成 join .. where”，这个也是分情况</p>
<p>的吧比如还是文章中的2张表，select * from a left join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;2);&#x2F;<em>Q5</em>&#x2F;和se</p>
<p>lect * from a join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;2);&#x2F;<em>Q6</em>&#x2F; 这个left join和join的语意和返回结果都不</p>
<p>一样，怎么能直接写成join呢，如果是where b.f2&#x3D;xx 的where条件可以直接写成join因为根据结</p>
<p>果是不需要left的。@夹心面包 、@郭江伟 同学提到了最后一种方案。@aliang 同学提了一个好问题，关于open_files_limit和innodb_open_files的关系，我在回复中</p>
<p>做了说明，大家可以看一下。@万勇 提了一个好问题，实际上对于现在官方的版本，将字段加在中间还是最后，在性能上</p>
<p>是没差别的。但是，我建议大家养成习惯（如果你是DBA就帮业务开发同学养成习惯），将</p>
<p>字段加在最后面，因为这样还是比较方便操作的。这个问题，我也在评论的答复中做了说明，</p>
<p>你可以看一下。精选留言</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>嗯 我的意思是，如果where条件里面，用到了b.f2的判断，干脆就直接写成join，不需要left join</p>
<p>了</p>
<p>如果业务逻辑需要left join， 就要把条件都放到on里面</p>
<p>业务逻辑正确性还是优先的</p>
<p>2019-02-25</p>
<p>还一棵树   1</p>
<p>看到 BNL 算法，你就应该知道这条语句的执行流程其实是这样</p>
<p>文章中的流程是写错了？还是我理解的有问题</p>
<p>1、如果是a表数据放入join buffer，根据b的每一条记录去判断是否在a中 如果在则保留记录</p>
<p>这个更像是b left join a。 而不是a left join b</p>
<p>2、如果按照这个流程，比如a里面有2行重复的数据， 如果拿b的数据在a中判断，存在则保留</p>
<p>，那结果集只有一条数据， 而按照a left join b 会出现2条结果的</p>
<p>2019-02-26</p>
<p> 作者回复</p>
<p>“如果按照这个流程，比如a里面有2行重复的数据， 如果拿b的数据在a中判断，存在则保留，</p>
<p>那结果集只有一条数据，”</p>
<p>不会呀，你看它是这样的：</p>
<p>假设join buffer中有两个行1</p>
<p>然后被驱动表取出一个1，</p>
<p>跟join buffer中第一个1比较，发现满足条件，放到结果集；</p>
<p>跟join buffer中第二个1比较，发现满足条件，放到结果集；</p>
<p>是得到两行的</p>
<p>2019-03-01</p>
<p>宝玉   1</p>
<p>老师，BNl算法，如果where条件中有驱动表的过滤条件，也不会在join时候全部载入内存吧？2019-02-25</p>
<p> 作者回复</p>
<p>对，驱动表现过滤，然后进join buffer</p>
<p>2019-02-25</p>
<p>千木   1</p>
<p>千木  1</p>
<p>老师您好，join使用join_buffer和内存区别那个问题的第一点解释我还是有些纳闷，你说由于从</p>
<p>磁盘拿数据到内存里面会导致等等的性能问题我能够理解，但是说即使使用nbl算法也会涉及到</p>
<p>从磁盘拿数据到内存吧，所以这点导致两种算法执行差异貌似不太合理，您觉得呢？2019-02-23</p>
<p> 作者回复</p>
<p>BNL算法拿的数据是确定的只会拿一次（遍历一遍）</p>
<p>而simple nested loop join是会遍历多次的</p>
<p>2019-02-24</p>
<p>白永伟   1</p>
<p>老师，关于备库自增id我有一个问题。既然binlog不管是statement模式还是row模式，里面的in</p>
<p>sert语句跟着的自增id都是固定的。那假如发生主备切换，备库变成主库后，客户端往新主库里</p>
<p>插入数据时，自增id的起始值是多少，有没有可能跟已有的记录id冲突？尤其是备库还没有处理</p>
<p>完同步过来的binlog就开始接受客户端请求时。如果要求备库必须处理完binlog才能接受客户端</p>
<p>请求，那么怎么保证主备切换的过程中，不影响用户使用。谢谢。2019-02-22</p>
<p> 作者回复</p>
<p>“自增id的起始值是多少，有没有可能跟已有的记录id冲突？” </p>
<p>如果没有主备延迟就不会出现；</p>
<p>“尤其是备库还没有处理完同步过来的binlog就开始接受客户端请求时。” ， 对，这种情况就会</p>
<p>。“如果要求备库必须处理完binlog才能接受客户端请求，那么怎么保证主备切换的过程中，不影</p>
<p>响用户使用” 一般都是有这个要求的。要尽量减少影响，就是控制主备延迟。2019-02-24</p>
<p>Chris   0</p>
<p>这两天在线上遇到一个比较诡异的事情，突然有几分钟连不上MySQL，通过error日志和监控的</p>
<p>processlist显示，MySQL把很多链接都kill掉了，但处于sleep状态和show status的语句没有kill</p>
<p>，看监控的资源使用情况不是很高，只是innodb rows read指标特别高，现在完全是没头绪了</p>
<p>2019-03-15</p>
<p> 作者回复</p>
<p>看看是不是有什么外部工具在工作</p>
<p>2019-03-16</p>
<p>长杰   0</p>
<p>select * from a left join b on(a.f1&#x3D;b.f1) where (a.f2&#x3D;b.f2);</p>
<p>老师，这个语句是否可以理解为:先按照on后面的条件关联，获取结果集，然后对结果集用wher</p>
<p>e条件进行二次过滤？2019-03-02</p>
<p> 作者回复</p>
<p>要看索引哈</p>
<p>如果b上的索引只有f1 是的，</p>
<p>如果b上的索引是(f1,f2)，就两个一起关联了</p>
<p>【咱们文中说了，这个语句会被转成普通join哦】</p>
<p>2019-03-02</p>
<p>长杰   0</p>
<p>把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了</p>
<p>。顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 a.f1&#x3D;b.f1 and a.f2&#x3D;b.f2) 是否满足，满</p>
<p>足条件的记录, 作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满</p>
<p>足条件后，再返回。表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把</p>
<p>剩余字段补上 NULL，再放入结果集中。是否可以理解为:假如有where条件的情况下，对与满足on条件的行，再去过滤where条件，满</p>
<p>足就返回；对于不满足on条件的行，b字段补Null后返回，不需要再过滤where条件</p>
<p>2019-03-02</p>
<p> 作者回复</p>
<p>不是，如果有where,并且where里面有用到b.f1或b.f2, 那就要求结果集里面没有这些null的行。就是说where a.f2&#x3D;b.f2的意思是</p>
<p>Where (a.f2 is not null) and (b.f2 is not null) and (a.f2 &#x3D;b.f2)</p>
<p>2019-03-02</p>
<p>梦康   0</p>
<p> 留言的人太多，辛苦老实答疑了。虽然我的问题没能被翻牌子</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>不好意思，确实你的问题比较难一些</p>
<p>最近在做收尾的工作，后面一定会把问题都清理掉的哈。你的问题质量高，是我喜欢回答的问题类型 </p>
<p>2019-02-25</p>
<p>PYH   0</p>
<p>你好 我想问一下mysql能实现oracle的拉链表么。如果能前提条件是什么？2019-02-24</p>
<p>龙文   0</p>
<p>明白了 谢谢老师！</p>
<p>2019-02-24</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-24</p>
<p>滔滔   0</p>
<p>老师您好，想请问下在innodb引擎rr隔离级别下，单独的一条update语句是不是默认就是一个事</p>
<p>务(在执行update前不输入begin)，而单独的一条select语句是不是不会开启一个事务，哪怕是”</p>
<p>当前读”也不会开启一个事务，更进一步，是不是对表的增删改操作默认都会开启一个事务？ </p>
<p>2019-02-24</p>
<p> 作者回复</p>
<ol>
<li><p>单独一个update，会启动一个事务</p>
</li>
<li><p>单独一个select，也会启动一个事务</p>
</li>
<li><p>innodb表，增删改查都会启动一个事务</p>
</li>
</ol>
<p>2019-02-24</p>
<p>发条橙子 。   0</p>
<p>啧啧， 原来我写的 left join 一直都不是标准的，每次后面都会加上 where ， 还一直以为左面是</p>
<p>驱动表 。既然实际上 left join 后加上 where 的话， 肯定会被优化器优化成 join where 的形式，</p>
<p>那是否下次写 left join ..where 的时候， 不如直接写成 join .. where ，省去优化器自己去优化，</p>
<p>这样是不是稍稍快些</p>
<p>2019-02-23</p>
<p> 作者回复</p>
<p>是的</p>
<p>如果原来就有where，说明原来其实也不用left join  </p>
<p>2019-02-23</p>
<p>龙文   0</p>
<p>老师你好，我在第21讲求助了一个死锁问题，当时你回复说后面会解答，不过我浏览了下后续</p>
<p>文章没找到解答，所以再次求助下。ps:用的阿里云的rds,提了工单没效果啊</p>
<p>作者回复: 有的，你看一下第40篇 “insert 唯一键冲突”这一段</p>
<p>ps:我已经离开阿里云挺久的了  </p>
<hr>
<p>谢谢老师,我看了第40篇,还是有地方不太明白,再打扰下</p>
<p>mysql 版本5.6</p>
<p>隔离级别为rc</p>
<p>CREATE TABLE <code>uk_test</code> (</p>
<p><code>id</code> bigint(20) NOT NULL AUTO_INCREMENT,</p>
<p><code>a</code> int(11) NOT NULL,</p>
<p><code>b</code> int(11) NOT NULL,</p>
<p><code>c</code> int(11) NOT NULL,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>UNIQUE KEY <code>uk_a_b</code> (<code>a</code>,<code>b</code>) USING BTREE</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;7 DEFAULT CHARSET&#x3D;utf8mb4</p>
<p>表中数据：</p>
<p>+—-+—+—+—+</p>
<p>| id | a | b | c |</p>
<p>+—-+—+—+—+</p>
<p>| 1 | 1 | 1 | 2 |</p>
<p>| 6 | 1 | 2 | 1 |</p>
<p>+—-+—+—+—+</p>
<p>sql:执行顺序</p>
<p>session1:begin;</p>
<p>session2:begin;</p>
<p>session1:select * from uk_test where a &#x3D; 1 and b &#x3D; 1 for update;</p>
<p>session2:select * from uk_test where a &#x3D; 1 and b &#x3D; 1 for update;</p>
<p>session1:insert into uk_test (a,b,c) values(1,1,2) on duplicate key update c &#x3D; 2;</p>
<p>session2:ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transacti</p>
<p>on</p>
<p>我的疑问是:</p>
<p>1.rc隔离级别下对唯一键的insert也会加next-key lock吗？2.死锁日志显示</p>
<p>session 1已经成功加上行锁(lock_mode X locks rec but not gap),</p>
<p>session 2在等待同一个行锁(lock_mode X locks rec but not gap waiting),</p>
<p>session1这时因为等待lock_mode X waiting而死锁。这里的lock_mode X waiting是指next-key lock吗？如果是的话，没想明白这里怎么形成资源循环等待了？我的猜测是session1 这时持有行锁，要next-key lock 所以要去加gap锁。session 2持有gap锁</p>
<p>在等行锁。但如果是这样为什么session2 在rc下select for update，且记录存在时会加gap锁?还</p>
<p>有gap锁加锁不是不互斥吗？2019-02-23</p>
<p> 作者回复</p>
<ol>
<li><p>会</p>
</li>
<li><p>你这里</p>
</li>
</ol>
<p>session 1 成功加锁一个record lock；</p>
<p>session 2执行的是一个select 语句，而且a&#x3D;1 and b&#x3D;1就只锁一行（a，b上有联合唯一索引）</p>
<p>，这里就是要申请一个记录行锁(but not gap waiting)。这里虽然没有加锁成功，但是已经加入了锁队列（只是这个锁是处于等待状态）</p>
<p>—这时候队列里面有两个锁对象了</p>
<p>然后session 1 再insert失败的时候，就要加next-key lock，（注意这个锁对象跟第一个锁对象</p>
<p>不同）。然后死锁检测看到，2号锁在等1号锁；3号要等2号，而3和1又是同一个session，就认为是死</p>
<p>锁了。2019-02-24</p>
<p>龙文   0</p>
<p>老师你好，我在第21讲求助了一个死锁问题，当时你回复说后面会解答，不过我浏览了下后续</p>
<p>文章没找到解答，所以再次求助下。ps:用的阿里云的rds,提了工单没效果啊</p>
<p>2019-02-23</p>
<p> 作者回复</p>
<p>有的，你看一下第40篇 “insert 唯一键冲突”这一段</p>
<p>ps:我已经离开阿里云挺久的了  </p>
<p>2019-02-23</p>
<p>夜空中最亮的星（华仔）   0</p>
<p>订阅了好几个专栏 mysql这个是最优先看的，别的专栏可以跟不上 这个必须跟上，老师计划出</p>
<p>第二季吗？2019-02-22</p>
<p>夜空中最亮的星（华仔）   0</p>
<p>这么快就要结束，好快啊</p>
<p>2019-02-22</p>
<p> 作者回复</p>
<p>跟进得很快啊大家 </p>
<p>2019-02-22</p>
<p>一大只    0</p>
<p>老师好，我做了下课后题的实验，不清楚为啥设计，下面记录了我看到的现象，不一定对哈。使用start transaction with consistent snapshot;</p>
<p>同一个session的开启快照事务后的trx_id很大并且一致，如果关闭这个session，开启另一个se</p>
<p>ssion使用snapshot，初始值的trx_id也是与之前的session一致的。如果再打开第二个session使用snapshot，第一次查询trx表，会发现第一个session还是很大只</p>
<p>，第二个打开的trx_id会很小，但这个很小的trx_id是第一个打开的session的最小trx_id+1。这</p>
<p>时，如果commit；再start snapshot，那么将会出现一个比第一个session还要大一点的trx_id，</p>
<p>我开了几个session，第一次是+24，随后都是加12，如下图：</p>
<p>+———————+—————–+</p>
<p>| trx_mysql_thread_id | trx_id |</p>
<p>+———————+—————–+</p>
<p>| 14672 | 421259275839776 |</p>
<p>| 14661 | 421259275838864 |</p>
<p>| 14645 | 421259275837952 |</p>
<p>| 14587 | 421259275837040 |</p>
<p>| 14578 | 421259275835216 |</p>
<p>+———————+—————–+</p>
<p>只有一个session打开snapshot情况下，trx_id在commit后会增加，但在事务内不会看到trx_id增</p>
<p>加,使用select,select lock in share mode不会导致trx_id增加。一个ddl操作应该是 trx_id+18</p>
<p>不在事务内的dml操作：</p>
<p>delete 1条 trx_id+2 </p>
<p>delete 多条 trx_id+6</p>
<p>insert 1条 trx_id+1</p>
<p>insert values (),()…多条trx_id+5</p>
<p>update 1条 trx_id+2</p>
<p>update 多条 trx_id+6</p>
<p>snapshot事务内的dml操作：</p>
<p>事务内先select * from tb for update;再delete from tb where id&#x3D;xxx;这样的delete trx_id+1</p>
<p>如果是事务内直接delete from tb where id&#x3D;xxx;或delete from tb;这样的delete trx_id+6</p>
<p>事务内update 1条 trx_id+2，如果先select * fom tb for update;再update 1条，有时候是trx_id+2</p>
<p>，有时候是trx_id+5</p>
<p>事务内update 多条 trx_id+6</p>
<p>2019-02-22</p>
<p> 作者回复</p>
<p>很好的验证</p>
<p>下一篇文章会讲到哈</p>
<p>2019-02-23</p>
<p>万勇   0</p>
<p>感谢老师上一期的解答，还请教一个分区表的问题，分区表创建的聚集索引是分区本地维护的</p>
<p>吧，但是主键索引要保证全局唯一性。那分区和主键索引之间是不是要建立一种关系？另外分</p>
<p>区表如果我们创建普通索引，按道理可以分区创建的，分区维护自己的普通索引，各分区之间</p>
<p>互不影响。2019-02-22</p>
<p> 作者回复</p>
<p>就是我这篇末尾建议的几种建表方法,就是建立联系了</p>
<p>2019-02-22</p>
<p>克劳德   0</p>
<p>老师好，如果group by用作数据去重，根据文章中描述的，流程2会遍历表依次插入进临时表。我理解的遍历表是通过扫描主键索引来做的，因此同一组的记录只会留下主键值最小的那个，</p>
<p>是否正确？能否通过扫描其他索引，来达到去重后的记录不按照主键值来决定？2019-02-22</p>
<p> 作者回复</p>
<p>1.对,就是扫描这个索引的过程中,第一个碰到的值</p>
<ol start="2">
<li>可以,你用force index试试</li>
</ol>
<p>2019-02-22</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-答疑文章（一）：日志和索引相关问题</title>
    <url>/posts/6d416b67.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>15 | 答疑文章（一）：日志和索引相关问题</p>
<p>2018-12-17 林晓斌</p>
<p>在今天这篇答疑文章更新前，MySQL实战这个专栏已经更新了14篇。在这些文章中，大家在评</p>
<p>论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点，</p>
<p>也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以</p>
<p>说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这</p>
<p>些被记下来的问题，就是我们今天这篇答疑文章的素材了。到目前为止，我已经收集了47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中</p>
<p>找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其</p>
<p>他问题，我们就留着后面慢慢展开吧。日志相关问题</p>
<p>我在第2篇文章《日志系统：一条SQL更新语句是如何执行的？》中，和你讲到binlog（归档日</p>
<p>志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提</p>
<p>交，会导致MySQL出现主备数据不一致等问题。在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎</p>
<p>么保证数据完整性的？现在，我们就从这个问题开始吧。我再放一次两阶段提交的图，方便你学习下面的内容。图1 两阶段提交示意图</p>
<p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句</p>
<p>的执行流程吗，怎么还会调用commit语句？他产生这个疑问的原因，是把两个“commit”的概念混淆了：</p>
<p>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin&#x2F;start</p>
<p>transaction 配对使用。而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一</p>
<p>步。当这个步骤执行完成后，这个事务就提交完成了。“commit语句”执行的时候，会包含“commit 步骤”。而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行</p>
<p>完成后提交事务时，就会用到这个“commit步骤“。接下来，我们就一起分析一下在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩</p>
<p>溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会</p>
<p>回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生</p>
<p>crash，那崩溃恢复的时候MySQL会怎么处理？我们先来看一下崩溃恢复时的判断规则。1. 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</p>
<ol start="2">
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：</li>
</ol>
<p>a. 如果是，则提交事务；</p>
<p>b. 否则，回滚事务。这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。现在，我们继续延展一下这个问题。追问1：MySQL怎么知道binlog是完整的?</p>
<p>回答：一个事务的binlog是有完整格式的：</p>
<p>statement格式的binlog，最后会有COMMIT；</p>
<p>row格式的binlog，最后会有一个XID event。另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确</p>
<p>性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验</p>
<p>checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。追问2：redo log 和 binlog是怎么关联起来的?</p>
<p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p>
<p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p>
<p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢</p>
<p>复，MySQL为什么要这么设计?</p>
<p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就</p>
<p>是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个</p>
<p>binlog恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写</p>
<p>binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能</p>
<p>覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回</p>
<p>滚不了，数据和binlog日志又不一致了。两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩</p>
<p>溃恢复，又能支持归档，不就可以了？回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内</p>
<p>存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？答案是不可以。如果说历史原因的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是</p>
<p>MyISAM，设计之初就有没有支持崩溃恢复。InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支</p>
<p>持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log</p>
<p>好了。而如果说实现上的原因的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流</p>
<p>程，我画了一张示意图，这里就没有redo log了。图2 只用binlog支持崩溃恢复</p>
<p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢</p>
<p>复“数据页”。如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生</p>
<p>了crash。重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经</p>
<p>认为提交完成了，不会再应用一次binlog1。但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此</p>
<p>时，binlog里面并没有记录数据页的更新细节，是补不回来的。你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又</p>
<p>做了一个redo log出来。所以，至少现在的binlog能力，还不能支持崩溃恢复。追问6：那能不能反过来，只用redo log，不要binlog？回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交</p>
<p>了，但系统依然是crash-safe的。但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是</p>
<p>开着的。因为binlog有着redo log无法替代的功能。一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保</p>
<p>留，redo log也就起不到归档的作用。一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新</p>
<p>自己的数据。关掉binlog的话，这些下游系统就没法输入了。总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo</p>
<p>log还做不到。你看，发展生态是多么重要。追问7：redo log一般设置多大？回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的</p>
<p>能力就发挥不出来了。所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文</p>
<p>件、每个文件1GB吧。追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的</p>
<p>还是从buffer pool更新过来的呢？回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也</p>
<p>就不存在“数据最终落盘，是由redo log更新过去”的情况。1. 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终</p>
<p>数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。2. 在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就</p>
<p>会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了</p>
<p>第一种情况的状态。追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？回答：这两个问题可以一起回答。在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在</p>
<p>还没commit的时候就直接写到redo log文件里。所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时</p>
<p>候，数据的内存被修改了，redo log buffer也写入了日志。但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候</p>
<p>做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被</p>
<p>动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章</p>
<p>《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过</p>
<p>程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。如</p>
<p>果你还有问题，可以在评论区继续留言补充。业务设计问题</p>
<p>接下来，我再和你分享@ithunter 同学在第8篇文章《事务到底是隔离的还是不隔离的？》的评</p>
<p>论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰</p>
<p>上这样的场景，在这里解答和分享一下。问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p>
<p>begin;</p>
<p>insert into t1 …</p>
<p>insert into t2 …</p>
<p>commit;</p>
<p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一</p>
<p>个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即</p>
<p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家</p>
<p>能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能</p>
<p>借鉴这种方式。接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索</p>
<p>uk_user_id_liker_id。语句执行逻辑是这样的：</p>
<p>以A关注B为例：</p>
<p>第一步，先查询对方有没有关注自己（B有没有关注A）</p>
<p>select * from like where user_id &#x3D; B and liker_id &#x3D; A;</p>
<p>如果有，则成为好友</p>
<p>insert into friend;</p>
<p>没有，则只是单向关注关系</p>
<p>insert into like;</p>
<p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对</p>
<p>方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在</p>
<p>MySQL锁层面有没有办法处理？CREATE TABLE <code>like</code> (</p>
<p>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>user_id</code> int(11) NOT NULL,</p>
<p>  <code>liker_id</code> int(11) NOT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>),</p>
<p>  UNIQUE KEY <code>uk_user_id_liker_id</code> (<code>user_id</code>,<code>liker_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>CREATE TABLE <code>friend</code> (</p>
<p>  id&#96; int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  <code>friend_1_id</code> int(11) NOT NULL,</p>
<p>  <code>firned_2_id</code> int(11) NOT NULL,</p>
<p>  UNIQUE KEY <code>uk_friend</code> (<code>friend_1_id</code>,<code>firned_2_id</code>)</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>引，为便于描述，我给加上唯一索引。顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功</p>
<p>加为朋友关系。现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：</p>
<p>图3 并发“喜欢”逻辑操作顺序</p>
<p>由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同</p>
<p>样是这个逻辑。这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在</p>
<p>friend表里面插入一行记录的。如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，</p>
<p>我想到了另外一个方法，来解决这个问题。首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。值是1的时候，表示user_id 关注 liker_id;</p>
<p>值是2的时候，表示liker_id 关注 user_id;</p>
<p>值是3的时候，表示互相关注。然后，当 A关注B的时候，逻辑改成如下所示的样子：</p>
<p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p>
<p>如果A&gt;B，则执行下面的逻辑</p>
<p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在</p>
<p>操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这</p>
<p>个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B</p>
<p>的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。mysql&gt; begin; &#x2F;<em>启动事务</em>&#x2F;</p>
<p>insert into <code>like</code>(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship&#x3D;relation_ship | 1;</p>
<p>select relation_ship from <code>like</code> where user_id&#x3D;A and liker_id&#x3D;B;</p>
<p>&#x2F;*代码中判断返回的 relation_ship，</p>
<p>  如果是1，事务结束，执行 commit</p>
<p>  如果是3，则执行下面这两个语句：</p>
<p>  *&#x2F;</p>
<p>insert ignore into friend(friend_1_id, friend_2_id) values(A,B);</p>
<p>commit;</p>
<p>mysql&gt; begin; &#x2F;<em>启动事务</em>&#x2F;</p>
<p>insert into <code>like</code>(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship&#x3D;relation_ship | 2;</p>
<p>select relation_ship from <code>like</code> where user_id&#x3D;B and liker_id&#x3D;A;</p>
<p>&#x2F;*代码中判断返回的 relation_ship，</p>
<p>  如果是2，事务结束，执行 commit</p>
<p>  如果是3，则执行下面这两个语句：</p>
<p>*&#x2F;</p>
<p>insert ignore into friend(friend_1_id, friend_2_id) values(B,A);</p>
<p>commit;</p>
<p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两</p>
<p>个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的</p>
<p>情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要</p>
<p>有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。小结</p>
<p>这是专栏的第一篇答疑文章。我针对前14篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了</p>
<p>今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇</p>
<p>文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。最后，虽然这篇是答疑文章，但课后问题还是要有的。我们创建了一个简单的表t，并插入一行，然后对这一行做修改。这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p>
<p>你会看到这样的结果：</p>
<p>结果显示，匹配(rows matched)了一行，修改(Changed)了0行。仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行</li>
</ol>
<p>mysql&gt; CREATE TABLE <code>t</code> (</p>
<p><code>id</code> int(11) NOT NULL primary key auto_increment,</p>
<p><code>a</code> int(11) DEFAULT NULL</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(1,2);</p>
<p>mysql&gt; update t set a&#x3D;2 where id&#x3D;1;</p>
<p>结束；</p>
<ol start="2">
<li>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不</li>
</ol>
<p>更新，直接返回；</p>
<ol start="3">
<li>InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以</li>
</ol>
<p>思考一下，MySQL为什么要选择这种策略呢？你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢</p>
<p>你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计</p>
<p>数值加1。逻辑实现上是启动一个事务，执行两个语句：</p>
<ol>
<li><p>insert into 数据表；</p>
</li>
<li><p>update 计数表，计数值加1。从系统并发能力的角度考虑，怎么安排这两个语句的顺序。这里，我直接复制 @阿建 的回答过来供你参考：</p>
</li>
</ol>
<p>评论区有同学说，应该把update计数表放后面，因为这个计数表可能保存了多个业务表的计数</p>
<p>值。如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会</p>
<p>更长。这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也</p>
<p>肯定会给表名字段加唯一索引。类似于下面这样的表结构：</p>
<p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。知识点在《行锁功过：怎么减少行锁对性能的影响？》</p>
<p>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升</p>
<p>并发度。在更新计数表的时候，一定会传入where table_name&#x3D;$table_name，使用主键索引，更新加行</p>
<p>锁只会锁在一行上。而在不同业务表插入数据，是更新不同的行，不会有行锁。评论区留言点赞板：</p>
<p>CREATE TABLE <code>rows_stat</code> (</p>
<p>  <code>table_name</code> varchar(64) NOT NULL,</p>
<p>  <code>row_count</code> int(10) unsigned NOT NULL,</p>
<p>  PRIMARY KEY (<code>table_name</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>@北天魔狼、@斜面镜子 Bil 和@Bin 等同学，都给出了正确答案；</p>
<p>@果然如此 同学提了一个好问题，虽然引入事务，避免看到”业务上还没提交的更新”，但是</p>
<p>Redis的计数被提前看到了。核心原因还是两个系统，不支持一致性视图；</p>
<p>@ 帆帆帆帆帆帆帆帆 同学的问题提醒了大家，count(id)也是可以走普通索引得到的。&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-答疑文章（二）：用动态的观点看加锁</title>
    <url>/posts/90c350b7.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>30 | 答疑文章（二）：用动态的观点看加锁</p>
<p>2019-01-21 林晓斌</p>
<p>在第20和21篇文章中，我和你介绍了InnoDB的间隙锁、next-key lock，以及加锁规则。在这两</p>
<p>篇文章的评论区，出现了很多高质量的留言。我觉得通过分析这些问题，可以帮助你加深对加锁</p>
<p>规则的理解。所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：用动态的观</p>
<p>点看加锁。为了方便你理解，我们再一起复习一下加锁规则。这个规则中，包含了两个“原则”、两</p>
<p>个“优化”和一个“bug”：</p>
<p>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。原则2：查找过程中访问到的对象才会加锁。优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock</p>
<p>退化为间隙锁。一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。接下来，我们的讨论还是基于下面这个表t：</p>
<p>不等号条件里的等值查询</p>
<p>有同学对“等值查询”提出了疑问：等值查询和“遍历”有什么区别？为什么我们文章的例子里</p>
<p>面，where条件是不等号，这个过程里也有等值查询？我们一起来看下这个例子，分析一下这条查询语句的加锁范围：</p>
<p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。也</p>
<p>就是说，id&#x3D;15这一行，并没有被加上行锁。为什么呢？我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值</p>
<p>查询，向右遍历的时候id&#x3D;15不满足条件，所以next-key lock退化为了间隙锁 (10, 15)。但是，我们的查询语句中where条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？要知道，加锁动作是发生在语句执行过程中的，所以你在分析加锁行为的时候，要从索引上的数</p>
<p>据结构开始。这里，我再把这个过程拆解一下。如图1所示，是这个表的索引id的示意图。CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;d  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;c  ̀(̀ c )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t values(0,0,0),(5,5,5),</p>
<p>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p>
<p>begin;</p>
<p>select * from t where id&gt;9 and id&lt;12 order by id desc for update;</p>
<p>图1 索引id示意图</p>
<ol>
<li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找</li>
</ol>
<p>到“第一个id&lt;12的值”。2. 这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id&#x3D;12的这个值，只</p>
<p>是最终没找到，但找到了(10,15)这个间隙。3. 然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id&#x3D;5这一行，所以会加一个</p>
<p>next-key lock (0,5]。也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。等值查询的过程</p>
<p>与上面这个例子对应的，是@发条橙子同学提出的问题：下面这个语句的加锁范围是什么？这条查询语句里用的是in，我们先来看这条语句的explain结果。begin;</p>
<p>select id from t where c in(5,20,10) lock in share mode;</p>
<p>图2 in语句的explain结果</p>
<p>可以看到，这条in语句使用了索引c并且rows&#x3D;3，说明这三个值都是通过B+树搜索定位的。在查找c&#x3D;5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c&#x3D;5，</p>
<p>就要向右遍历，找到c&#x3D;10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。同样的，执行c&#x3D;10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c&#x3D;20这个逻辑的时</p>
<p>候，加锁的范围是(15,20] 和 (20,25)。通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c&#x3D;5的记录</p>
<p>锁，再加c&#x3D;10的记录锁，最后加c&#x3D;20的记录锁。你可能会说，这个加锁范围，不就是从(5,25)中去掉c&#x3D;15的行锁吗？为什么这么麻烦地分段说</p>
<p>呢？因为我要跟你强调这个过程：这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。如果同时有另外一个语句，是这么写的：</p>
<p>此时的加锁范围，又是什么呢？我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引c上的c&#x3D;5、10、20这三行记录</p>
<p>上加记录锁。这里你需要注意一下，由于语句里面是order by c desc， 这三个记录锁的加锁顺序，是先锁</p>
<p>c&#x3D;20，然后c&#x3D;10，最后是c&#x3D;5。也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，</p>
<p>就可能出现死锁。关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。有同学在评论区留言到，希望我能展开一下怎么看死锁。现在，我就来简单分析一下上面这个例</p>
<p>子的死锁现场。select id from t where c in(5,20,10) order by c desc for update;</p>
<p>怎么看死锁？图3是在出现死锁后，执行show engine innodb status命令得到的部分输出。这个命令会输出很</p>
<p>多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。图3 死锁现场</p>
<p>我们来看看这图中的几个关键信息。1. 这个结果分成三部分：</p>
<p>(1) TRANSACTION，是第一个事务的信息；</p>
<p>(2) TRANSACTION，是第二个事务的信息；</p>
<p>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。2. 第一个事务的信息中：</p>
<p>WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；</p>
<p>index c of table t̀est .̀̀ t&#96;，说明在等的是表t的索引c上面的锁；</p>
<p>lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；</p>
<p>Record lock说明这是一个记录锁；</p>
<p>n_fields 2表示这个记录是两列，也就是字段c和主键字段id；</p>
<p>0: len 4; hex 0000000a; asc ;;是第一个字段，也就是c。值是十六进制a，也就是10；</p>
<p>1: len 4; hex 0000000a; asc ;;是第二个字段，也就是主键id，值也是10；</p>
<p>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印</p>
<p>字符，因此就显示空格。第一个事务信息就只显示出了等锁的状态，在等待(c&#x3D;10,id&#x3D;10)这一行的锁。当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出</p>
<p>来。别着急，我们从第二个事务的信息中推导出来。3. 第二个事务显示的信息要多一些：</p>
<p>“ HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁；</p>
<p>index c of table t̀est .̀̀ t  ̀表示锁是在表t的索引c上；</p>
<p>hex 0000000a和hex 00000014表示这个事务持有c&#x3D;10和c&#x3D;20这两个记录锁；</p>
<p>WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c&#x3D;5,id&#x3D;5)这个记录锁。从上面这些信息中，我们就知道：</p>
<ol>
<li><p>“lock in share mode”的这条语句，持有c&#x3D;5的记录锁，在等c&#x3D;10的锁；</p>
</li>
<li><p>“for update”这个语句，持有c&#x3D;20和c&#x3D;10的记录锁，在等c&#x3D;5的记录锁。因此导致了死锁。这里，我们可以得到两个结论：</p>
</li>
<li><p>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</p>
</li>
<li><p>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以InnoDB选</p>
</li>
</ol>
<p>择了回滚成本更小的lock in share mode语句，来回滚。怎么看锁等待？看完死锁，我们再来看一个锁等待的例子。在第21篇文章的评论区，@Geek_9ca34e 同学做了一个有趣验证，我把复现步骤列出来：</p>
<p>图4 delete导致间隙变化</p>
<p>可以看到，由于session A并没有锁住c&#x3D;10这个记录，所以session B删除id&#x3D;10这一行是可以</p>
<p>的。但是之后，session B再想insert id&#x3D;10这一行回去就不行了。现在我们一起看一下此时show engine innodb status的结果，看看能不能给我们一些提示。锁信</p>
<p>息是在这个命令输出结果的TRANSACTIONS这一节。你可以在文稿中看到这张图片</p>
<p>图 5 锁等待信息</p>
<p>我们来看几个关键信息。1. index PRIMARY of table t̀est .̀̀ t  ̀，表示这个语句被锁住是因为表t主键上的某个锁。2. lock_mode X locks gap before rec insert intention waiting 这里有几个信息：</p>
<p>insert intention表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理</p>
<p>解，你可以认为它就是这个插入动作本身。gap before rec 表示这是一个间隙锁，而不是记录锁。3. 那么这个gap是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。4. n_fields 5也表示了，这一个记录有5列：</p>
<p>0: len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id&#x3D;15。所以，这时我</p>
<p>们就知道了，这个间隙就是id&#x3D;15之前的，因为id&#x3D;10已经不存在了，它表示的就是</p>
<p>(5,15)。1: len 6; hex 000000000513; asc ;;第二列是长度为6字节的事务id，表示最后修改这一</p>
<p>行的是trx id为1299的事务。2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看</p>
<p>到，这里的acs后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。后面两列是c和d的值，都是15。因此，我们就知道了，由于delete操作把id&#x3D;10这一行删掉了，原来的两个间隙(5,10)、(10,15）</p>
<p>变成了一个(5,15)。说到这里，你可以联合起来再思考一下这两个现象之间的关联：</p>
<ol>
<li><p>session A执行完select语句后，什么都没做，但它加锁的范围突然“变大”了；</p>
</li>
<li><p>第21篇文章的课后思考题，当我们执行select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c</p>
</li>
</ol>
<p>desc lock in share mode; 向左扫描到c&#x3D;10的时候，要把(5, 10]锁起来。也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。update的例子</p>
<p>看过了insert和delete的加锁例子，我们再来看一个update语句的案例。在留言区中@信信 同学</p>
<p>做了这个试验：</p>
<p>图 6 update 的例子</p>
<p>你可以自己分析一下，session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和</p>
<p>(25,supremum]。之后session B的第一个update语句，要把c&#x3D;5改成c&#x3D;1，你可以理解为两步：</p>
<ol>
<li><p>插入(c&#x3D;1, id&#x3D;5)这个记录；</p>
</li>
<li><p>删除(c&#x3D;5, id&#x3D;5)这个记录。按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c&#x3D;10定义的。所以</p>
</li>
</ol>
<p>通过这个操作，session A的加锁范围变成了图7所示的样子：</p>
<p>注意：根据c&gt;5查到的第一个记录是c&#x3D;10，因此不会加(0,5]这个next-key lock。图 7 session B修改后， session A的加锁范围</p>
<p>好，接下来session B要执行 update t set c &#x3D; 5 where c &#x3D; 1这个语句了，一样地可以拆成两步：</p>
<ol>
<li><p>插入(c&#x3D;5, id&#x3D;5)这个记录；</p>
</li>
<li><p>删除(c&#x3D;1, id&#x3D;5)这个记录。第一步试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。小结</p>
</li>
</ol>
<p>今天这篇文章，我用前面第20和第21篇文章评论区的几个问题，再次跟你复习了加锁规则。并</p>
<p>且，我和你重点说明了，分析加锁范围时，一定要配合语句执行逻辑来进行。在我看来，每个想认真了解MySQL原理的同学，应该都要能够做到：通过explain的结果，就能</p>
<p>够脑补出一个SQL语句的执行流程。达到这样的程度，才算是对索引组织表、索引、锁的概念有</p>
<p>了比较清晰的认识。你同样也可以用这个方法，来验证自己对这些知识点的掌握程度。在分析这些加锁规则的过程中，我也顺便跟你介绍了怎么看show engine innodb status输出结果</p>
<p>中的事务信息和死锁信息，希望这些内容对你以后分析现场能有所帮助。老规矩，即便是答疑文章，我也还是要留一个课后问题给你的。上面我们提到一个很重要的点：所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义</p>
<p>的。那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？你可以把你关于分析和验证方法写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢</p>
<p>你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章最后留给的问题，是分享一下你关于业务监控的处理经验。在这篇文章的评论区，很多同学都分享了不错的经验。这里，我就选择几个比较典型的留言，和</p>
<p>你分享吧：</p>
<p>@老杨同志 回答得很详细。他的主要思路就是关于服务状态和服务质量的监控。其中，服务</p>
<p>状态的监控，一般都可以用外部系统来实现；而服务的质量的监控，就要通过接口的响应时</p>
<p>间来统计。@Ryoma 同学，提到服务中使用了healthCheck来检测，其实跟我们文中提到的select 1的模</p>
<p>式类似。@强哥 同学，按照监控的对象，将监控分成了基础监控、服务监控和业务监控，并分享了每</p>
<p>种监控需要关注的对象。这些都是很好的经验，你也可以根据具体的业务场景借鉴适合自己的方案。令狐少侠   2</p>
<p>有个问题想确认下，在死锁日志里，lock_mode X waiting是间隙锁+行锁，lock_mode X locks </p>
<p>rec but not gap这种加but not gap才是行锁？老师你后面能说下group by的原理吗，我看目录里面没有</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>对， 好问题</p>
<p>lock_mode X waiting表示next-key lock；</p>
<p>lock_mode X locks rec but not gap是只有行锁；</p>
<p>还有一种 “locks gap before rec”，就是只有间隙锁；</p>
<p>2019-01-23</p>
<p>Ryoma   2</p>
<p>删除数据，导致锁扩大的描述：“因此，我们就知道了，由于 delete 操作把 id&#x3D;10 这一行删掉了</p>
<p>，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。”</p>
<p>我觉得这个提到的(5, 10) 和 (10, 15)两个间隙会让人有点误解，实际上在删除之前间隙锁只有</p>
<p>一个(10, 15)，删除了数据之后，导致间隙锁左侧扩张成了5，间隙锁成为了(5, 15)。2019-01-22</p>
<p> 作者回复</p>
<p>嗯 所以我这里特别小心地没有写“锁“这个字。间隙 (5,10)、(10,15）是客观存在的。你提得也很对，“锁”是执行过程中才加的，是一个动态的概念。这个问题也能够让大家更了解我们标题的意思，置顶了哈  </p>
<p>2019-01-22</p>
<p>    1</p>
<p>老师好：</p>
<p>select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc for update;</p>
<p>为什么这种c&#x3D;20就是用来查数据的就不是向右遍历</p>
<p>select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 这种就是向右遍历</p>
<p>怎么去判断合适是查找数据，何时又是遍历呢，是因为第一个有order by desc，然后反向向左</p>
<p>遍历了吗？所以只需要[20,25)来判断已经是最后一个20就可以了是吧</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>索引搜索就是 “找到第一个值，然后向左或向右遍历”，</p>
<p>order by desc 就是要用最大的值来找第一个；</p>
<p>精选留言</p>
<p>order by就是要用做小的值来找第一个；</p>
<p>“所以只需要[20,25)来判断已经是最后一个20就可以了是吧”，</p>
<p>你描述的意思是对的，但是在MySQL里面不建议写这样的前闭后开区间哈，容易造成误解。可以描述为：</p>
<p>“取第一个id&#x3D;20后，向右遍历(25,25)这个间隙”^_^</p>
<p>2019-01-22</p>
<p>老杨同志   1</p>
<p>先说结论：空表锁 (-supernum，supernum],老师提到过mysql的正无穷是supernum，在没有数</p>
<p>据的情况下，next-key lock 应该是supernum前面的间隙加 supernum的行锁。但是前开后闭的</p>
<p>区间，前面的值是什么我也不知道，就写了一个-supernum。稍微验证一下</p>
<p>session 1）</p>
<p>begin;</p>
<p>select * from t where id&gt;9 for update;</p>
<p>session 2）</p>
<p>begin;</p>
<p>insert into t values(0,0,0),(5,5,5);</p>
<p>（block）</p>
<p>2019-01-21</p>
<p> 作者回复</p>
<p>赞</p>
<p>show engine innodb status 有惊喜 </p>
<p>2019-01-21</p>
<p>Long   0</p>
<p>感觉这篇文章以及前面加锁的文章，提升了自己的认知。还有，谢谢老师讲解了日志的对应细</p>
<p>节……还愿了</p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p>   </p>
<p>2019-01-28</p>
<p>滔滔   0</p>
<p>老师，有个疑问，select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode; </p>
<p>向左扫描到 c&#x3D;10 的时候，为什么要把 (5, 10] 锁起来？不锁也不会出现幻读或者逻辑上的不一</p>
<p>致吧 </p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>会加锁，insert into t values (6,6,6) 被堵住了</p>
<p>2019-01-23</p>
<p>尘封   0</p>
<p>尘封   0</p>
<p>老师，咨询个问题，本来想在后面分区表的文章问，发现大纲里没有分区表这一讲。1，timestamp类型为什么不支持分区？2，前面的文章讲过分区不要太多，这个多了会怎么样？比如一个表一千多个分区</p>
<p>谢谢</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>会讲的哈~</p>
<p>新春快乐~</p>
<p>2019-02-04</p>
<p>长杰   0</p>
<p>老师，还是select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc in share mode与select * fro</p>
<p>m t where id&gt;10 and id&lt;&#x3D;15 for update的问题，为何select * from t where id&gt;10 and id&lt;&#x3D;15 for </p>
<p>update不能解释为：根据id&#x3D;15来查数据，加锁(15, 20]的时候，可以使用优化2，</p>
<p>这个等值查询是根据什么规则来定的？ 如果select * from t where id&gt;10 and id&lt;&#x3D;15 for update</p>
<p>加上order by id desc是否可以按照id&#x3D;15等值查询，利用优化2？多谢指教。2019-01-22</p>
<p> 作者回复</p>
<ol>
<li><p>代码实现上，传入的就是id&gt;10里面的这个10</p>
</li>
<li><p>可以的，不过因为id是主键，而且id&#x3D;15这一行存在，我觉得用优化1解释更好哦</p>
</li>
</ol>
<p>2019-01-23</p>
<p>堕落天使   0</p>
<p>老师，您好：</p>
<p>我执行“explain select id from t where c in(5,20,10) lock in share mode;” 时，显示的rows对应的</p>
<p>值是4。为什么啊？我的mysql版本是：5.7.23-0ubuntu0.16.04.1，具体sql语句如下：</p>
<p>mysql&gt; select * from t;</p>
<p>+—-+——+——+</p>
<p>| id | c | d |</p>
<p>+—-+——+——+</p>
<p>| 0 | 0 | 0 |</p>
<p>| 5 | 5 | 5 |</p>
<p>| 10 | 10 | 10 |</p>
<p>| 15 | 15 | 15 |</p>
<p>| 20 | 20 | 20 |</p>
<p>| 25 | 25 | 25 |</p>
<p>| 30 | 10 | 30 |</p>
<p>+—-+——+——+</p>
<p>7 rows in set (0.00 sec)</p>
<p>mysql&gt; explain select id from t where c in(5,20,10) lock in share mode;</p>
<p>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+——–</p>
<p>——————+</p>
<p>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | </p>
<p>Extra |</p>
<p>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+——–</p>
<p>——————+</p>
<p>| 1 | SIMPLE | t | NULL | range | c | c | 5 | NULL | 4 | 100.00 | Using where; Using index |</p>
<p>+—-+————-+——-+————+——-+—————+——+———+——+——+———-+——–</p>
<p>——————+</p>
<p>1 row in set, 1 warning (0.00 sec)</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>你这个例子里面有两行c&#x3D;10</p>
<p>2019-01-23</p>
<p>Ivan   0</p>
<p>Jan 17 23:52:27 prod-mysql-01 kernel: [ pid ] uid tgid total_vm rss cpu oom_adj oom_score_adj</p>
<p>name</p>
<p>Jan 17 23:52:27 prod-mysql-01 kernel: [125254] 0 125254 27087 5 0 0 0 mysqld_safe</p>
<p>Jan 17 23:52:27 prod-mysql-01 kernel: [126004] 498 126004 24974389 22439356 5 0 0 mysqld</p>
<p>Jan 17 23:52:27 prod-mysql-01 kernel: [ 5733] 0 5733 7606586 6077037 7 0 0 mysql</p>
<p>—————————系统日志——————————————————————————–</p>
<p>老师你好，请教一个问题 ，我在mysql服务器上本地登录，执行了一个SQL（select b.id,b.statu</p>
<p>s from rb_bak b where id not in (select id from rb );该语句问了找不同数据， rb和 rb_bak 数据</p>
<p>量均为500万左右），SQL很慢，30分钟也没结果；</p>
<p>在SQL语句执行期间，发生了OOM，mysql服务被kill。查看系统日志发现 mysqld 占用内存基</p>
<p>本没有变，但是本机连接mysql的客户端进程（5733）却占用了内存近20G，这很让人费解，S</p>
<p>QL没有执行完，客户端怎么会占用这么多内存？用其他SQL查询查询不同数据，也就十几条数据，更不可能占用这么多内存呀。还请老师帮忙</p>
<p>分析一下，谢谢。2019-01-22</p>
<p> 作者回复</p>
<p>好问题，第33篇会说到哈</p>
<p>你可以在mysql客户端参数增加 –quick 再试试</p>
<p>2019-01-23</p>
<p>PengfeiWang   0</p>
<p>老师，您好：</p>
<p>对文中以下语句感到有困惑：</p>
<p>我们说加锁单位是 next-key lock，都是前开后闭区，但是这里用到了优化 2，即索引上的等值</p>
<p>查询，向右遍历的时候id&#x3D;15不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15)。SQL语句中条件中使用的是id字段（唯一索引），那么根据加锁规则这里不应该用的是优化 2，</p>
<p>而是优化 1，因为优化1中明确指出给唯一索引加锁，从而优化 2的字面意思来理解，它适用于</p>
<p>普通索引。不知道是不是我理解的不到位？2019-01-22</p>
<p> 作者回复</p>
<p>主要是这里这一行不存在。。如果能够明确找到一行锁住的话，使用优化1就更准确些</p>
<p>2019-01-23</p>
<p>Justin   0</p>
<p>想咨询一下 普通索引 如果索引中包括的元素都相同 在索引中顺序是怎么排解的呢 是按主键排</p>
<p>列的吗 比如(name ,age ) 索引 name age都一样 那索引中会按照主键排序吗？2019-01-22</p>
<p> 作者回复</p>
<p>会的</p>
<p>2019-01-23</p>
<p>ServerCoder   0</p>
<p>林老师我有个问题想请教一下，描述如下，望给予指点，先谢谢了！</p>
<p>环境：虚拟机，CPU 4核，内存8G，系统CentOS7.4，MySQL版本5.6.40</p>
<p>数据库配置：</p>
<p>bulk_insert_buffer_size &#x3D; 256M</p>
<p>sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>
<p>secure_file_priv&#x3D;’’</p>
<p>default-storage-engine&#x3D;MYISAM</p>
<p>测试场景修改过的参数(以下这些参数得调整对加载效率没有实质的提升)：</p>
<p>myisam_repair_threads&#x3D;3</p>
<p>myisam_sort_buffer_size&#x3D;256M</p>
<p>net_buffer_length&#x3D;1M</p>
<p>myisam_use_mmap&#x3D;ON</p>
<p>key_buffer_size&#x3D;256M</p>
<p>测试场景：测试程序多线程，通过客户端API，执行load data infile语句加载数据文件</p>
<p>三个线程，三个文件(每个文件100万条数据、150MB)，三张表(表结构相同，字段类型均为整</p>
<p>形，没有定义主键，有一个字段加了非唯一索引)，一一对应进行数据加载，数据库没有使用多</p>
<p>核，而是把一个核心的利用率均分给了三个线程。单个线程加载一个文件大约耗时3秒</p>
<p>单线程加载三个文件到三张表大约耗时9秒</p>
<p>三个线程分别加载三个文件到三张表，则每个线程均耗时大约9秒。从这个效果看，单线程顺序</p>
<p>加载和三线程并发加载耗时相同，没有提升效果。三线程加载过程中查看processlist发现时间主要耗费在了网络读取上。问题：为啥这种场景下MySQL不利用多核？这种并行加载的情况要如何才能让其利用多核，提</p>
<p>升加载速度</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>可以用到多核呀，你是怎么得到 “时间主要耗费在了网络读取上。”这个结论的？另外，把这三个文件先拷贝到数据库本地，然后本地执行load看看什么效果？2019-01-23</p>
<p>慕塔   0</p>
<p>是这样的 假设只有一主一从 1)是集群只有一个sysbench实例，产生的数据流通过中间件，主</p>
<p>机分全部写，和30%的读，另外70%的读全部分给从机。2)有两个sysbench，一个读写加压到</p>
<p>主机，另一个只有加压到从机。主从复制之间通过binlog。问题在1)的QPS累加与2)QPS累加 </p>
<p>意义一样吗 1)的一条事务有读写，而2)的情况，主机与1)一样，从机的读事务与主机里的读不</p>
<p>一样吧 </p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>我觉得这两个对比不太公平^_^</p>
<p>1）的测试可能会出现中间件瓶颈，</p>
<p>a)网络环节中间增加了一跳；</p>
<p>b) 如果是小查询，可能proxy先打到瓶颈</p>
<p>2)的测试结论一般会比1）好些</p>
<p>但是有这个架构，你肯定是从中间件访问数据库的，所以应该以1的测试结果为准</p>
<p>2019-01-23</p>
<p>Jason_鹏   0</p>
<p>最后一个update的例子，为没有加（0，5）的间隙呢？我理解应该是先拿c＝5去b+树搜索，按</p>
<p>照间隙索最右原则，应该会加（0，5]的间隙，然后c＝5不满足大于5条件，根据优化2原则退化</p>
<p>成（0，5）的间隙索，我是这样理解的</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>根据c&gt;5查到的第一个记录是c&#x3D;10，因此不会加(0,5]这个next-key lock。你提醒得对，我应该多说明这句， 我加到文稿中啦 </p>
<p>2019-01-22</p>
<p>长杰   0</p>
<p>老师，之前讲这个例子时，select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc in share m</p>
<p>ode;</p>
<p>最右边加的是 (20, 25)的间隙锁，</p>
<p>而这个例子select * from t where id&gt;10 and id&lt;&#x3D;15 for update中，最右边加的是(15,20]的next-k</p>
<p>ey锁，</p>
<p>这两个查询为何最后边一个加的gap锁，一个加的next-key锁，他们都是&lt;&#x3D;的等值范围查询，区</p>
<p>别在哪里？2019-01-22</p>
<p> 作者回复</p>
<p>select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc in share mode;</p>
<p>这个语句是根据 c&#x3D;20 来查数据的，所以加锁(20,25]的时候，可以使用优化2；</p>
<p>select * from t where id&gt;10 and id&lt;&#x3D;15 for update；</p>
<p>这里的id&#x3D;20，是用“向右遍历”的方式得到的，没有优化，按照“以next-key lock”为加锁单位来执</p>
<p>行</p>
<p>2019-01-22</p>
<p>库淘淘   0</p>
<p>对于问题 我理解是这样 </p>
<p>session 1：</p>
<p>delete from t;</p>
<p>begin; select * from t for update;</p>
<p>session 2:</p>
<p>insert into t values(1,1,1);发生等待</p>
<p>show engine innodb status\G; </p>
<p>…..</p>
<p>——- TRX HAS BEEN WAITING 5 SEC FOR THIS LOCK TO BE GRANTED:</p>
<p>RECORD LOCKS space id 75 page no 3 n bits 72 index PRIMARY of table <code>test</code>.<code>t</code> trx id 75209</p>
<p>0 lock_mode X insert intention waiting</p>
<p>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</p>
<p>0: len 8; hex 73757072656d756d; asc supremum;;</p>
<p>其中申请插入意向锁与间隙锁 冲突，supremum这个能否理解为 间隙右边的那个记录</p>
<p>2019-01-21</p>
<p> 作者回复</p>
<p>发现了  </p>
<p>2019-01-22</p>
<p>慕塔   0</p>
<p>大佬 请教下一主多从集群性能测试性能计算问题 如果使用基准测试工具sysbench。数据流有</p>
<p>两种</p>
<ol>
<li></li>
</ol>
<p>sysbench—mycat—mysql主机(读写) TPS QPS1</p>
<p>| |binlog</p>
<p>mysql从机(只读)QPS2</p>
<p>那性能指标 TPS QPS&#x3D;QPS1+QPS2</p>
<ol start="2">
<li></li>
</ol>
<p>sysbench—mysql主机(读写) TPS QPS1</p>
<p>| binlog</p>
<p>sysbench—mysql从机(只读)TPS QPS2</p>
<p>集群性能指标TPS QPS&#x3D;QPS1+QPS2</p>
<p>这两种哪种严谨些啊？mycat的损失忽略。生产中的集群性能怎么算的呢？？？(还是学生 谢谢！)</p>
<p>2019-01-21</p>
<p> 作者回复</p>
<p>TPS就看主库的写入</p>
<p>QPS就看所有从库的读能力加和</p>
<p>不过没看懂你问题中1）和2）的区别 </p>
<p>2019-01-22</p>
<p>HuaMax   0</p>
<p>删除导致锁范围扩大那个例子，id&gt;10 and id&lt;&#x3D;15，锁范围为什么没有10呢？不是应该（5，10]</p>
<p>吗？2019-01-21</p>
<p> 作者回复</p>
<p>不是的，要找id&gt;10的，并没有命中id&#x3D;10哦，你可以理解成就是查到了(10,15)这个间隙</p>
<p>2019-01-21</p>
<p>llx   0</p>
<p>回复@往事随风，顺其自然</p>
<p>前面有解释为什么，这篇文章有更详细的解释。Gap lock 由右值指定的，由于 c 不是唯一键，</p>
<p>需要到10，遍历到10的时候，就把 5-10 锁了</p>
<p>2019-01-21</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-21</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-自增id用完怎么办</title>
    <url>/posts/bd94ce79.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>45 | 自增id用完怎么办？2019-02-25 林晓斌</p>
<p>MySQL里有很多自增的id，每个自增id都是定义了初始值，然后不停地往上加步长。虽然自然数</p>
<p>是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无</p>
<p>符号整型(unsigned int)是4个字节，上限就是2 -1。既然自增id有上限，就有可能被用完。但是，自增id用完了会怎么样呢？今天这篇文章，我们就来看看MySQL里面的几种自增id，一起分析一下它们的值达到上限以后，</p>
<p>会出现什么情况。表定义自增值id</p>
<p>说到自增id，你第一个想到的应该就是表结构定义里的自增字段，也就是我在第39篇文章《自增</p>
<p>主键为什么不是连续的？》中和你介绍过的自增主键id。表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变。我们可以通过下面这个语句序列验证一下：</p>
<p>32</p>
<p>可以看到，第一个insert语句插入数据成功后，这个表的AUTO_INCREMENT没有改变（还是</p>
<p>4294967295），就导致了第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主</p>
<p>键冲突错误。2 -1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被</p>
<p>用完的。因此在建表的时候你需要考察你的表是否有可能达到这个上限，如果有可能，就应该创</p>
<p>建成8个字节的bigint unsigned。InnoDB系统自增row_id</p>
<p>如果你创建的InnoDB表没有指定主键，那么InnoDB会给你创建一个不可见的，长度为6个字节</p>
<p>的row_id。InnoDB维护了一个全局的dict_sys.row_id值，所有无主键的InnoDB表，每插入一行</p>
<p>数据，都将当前的dict_sys.row_id值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。实际上，在代码实现时row_id是一个长度为8字节的无符号长整型(bigint unsigned)。但</p>
<p>是，InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中时只放了最后6个</p>
<p>字节，所以row_id能写到数据表中的值，就有两个特征：</p>
<ol>
<li><p>row_id写入表中的值范围，是从0到2 -1；</p>
</li>
<li><p>当dict_sys.row_id&#x3D;2 时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个</p>
</li>
</ol>
<p>字节的话就是0。也就是说，写入表的row_id是从0开始到2 -1。达到上限后，下一个值就是0，然后继续循环。当然，2 -1这个值本身已经很大了，但是如果一个MySQL实例跑得足够久的话，还是可能达到</p>
<p>这个上限的。在InnoDB逻辑里，申请到row_id&#x3D;N后，就将这行数据写入表中；如果表中已经存</p>
<p>create table t(id int unsigned auto_increment primary key) auto_increment&#x3D;4294967295;</p>
<p>insert into t values(null);</p>
<p>&#x2F;&#x2F;成功插入一行 4294967295</p>
<p>show create table t;</p>
<p>&#x2F;* CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(10) unsigned NOT NULL AUTO_INCREMENT,</p>
<p>  PRIMARY KEY (̀ id )̀</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4294967295;</p>
<p>*&#x2F;</p>
<p>insert into t values(null);</p>
<p>&#x2F;&#x2F;Duplicate entry ‘4294967295’ for key ‘PRIMARY’</p>
<p>32</p>
<p>48</p>
<p>48</p>
<p>48</p>
<p>48</p>
<p>在row_id&#x3D;N的行，新写入的行就会覆盖原有的行。要验证这个结论的话，你可以通过gdb修改系统的自增row_id来实现。注意，用gdb改变量这个</p>
<p>操作是为了便于我们复现问题，只能在测试环境使用。图1 row_id用完的验证序列</p>
<p>图2 row_id用完的效果验证</p>
<p>可以看到，在我用gdb将dict_sys.row_id设置为2 之后，再插入的a&#x3D;2的行会出现在表t的第一</p>
<p>行，因为这个值的row_id&#x3D;0。之后再插入的a&#x3D;3的行，由于row_id&#x3D;1，就覆盖了之前a&#x3D;1的行，</p>
<p>因为a&#x3D;1这一行的row_id也是1。从这个角度看，我们还是应该在InnoDB表中主动创建自增主键。因为，表自增id到达上限后，</p>
<p>再插入数据时报主键冲突错误，是更能被接受的。毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是</p>
<p>可用性。而一般情况下，可靠性优先于可用性。Xid</p>
<p>48</p>
<p>在第15篇文章《答疑文章（一）：日志和索引相关问题》中，我和你介绍redo log和binlog相配</p>
<p>合的时候，提到了它们有一个共同的字段叫作Xid。它在MySQL中是用来对应事务的。那么，Xid在MySQL内部是怎么生成的呢？MySQL内部维护了一个全局变量global_query_id，每次执行语句的时候将它赋值给Query_id，</p>
<p>然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把</p>
<p>Query_id赋值给这个事务的Xid。而global_query_id是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实</p>
<p>例中，不同事务的Xid也是有可能相同的。但是MySQL重启之后会重新生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是</p>
<p>惟一的。虽然MySQL重启不会导致同一个binlog里面出现两个相同的Xid，但是如果global_query_id达到</p>
<p>上限后，就会继续从0开始计数。从理论上讲，还是就会出现同一个binlog里面出现相同Xid的场</p>
<p>景。因为global_query_id定义的长度是8个字节，这个自增值的上限是2 -1。要出现这种情况，必须</p>
<p>是下面这样的过程：</p>
<ol>
<li><p>执行一个事务，假设Xid是A；</p>
</li>
<li><p>接下来执行2 次查询语句，让global_query_id回到A；</p>
</li>
<li><p>再启动一个事务，这个事务的Xid也是A。不过，2 这个值太大了，大到你可以认为这个可能性只会存在于理论上。Innodb trx_id</p>
</li>
</ol>
<p>Xid和InnoDB的trx_id是两个容易混淆的概念。Xid是由server层维护的。InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关</p>
<p>联。但是，InnoDB自己的trx_id，是另外维护的。其实，你应该非常熟悉这个trx_id。它就是在我们在第8篇文章《事务到底是隔离的还是不隔离</p>
<p>的？》中讲事务可见性时，用到的事务id（transaction id）。InnoDB内部维护了一个max_trx_id全局变量，每次需要申请一个新的trx_id时，就获得</p>
<p>max_trx_id的当前值，然后并将max_trx_id加1。InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数</p>
<p>64</p>
<p>64</p>
<p>64</p>
<p>据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对</p>
<p>比。对于正在执行的事务，你可以从information_schema.innodb_trx表中看到事务的trx_id。我在上一篇文章的末尾留给你的思考题，就是关于从innodb_trx表里面查到的trx_id的。现在，我</p>
<p>们一起来看一个事务现场：</p>
<p>图3 事务的trx_id</p>
<p>session B里，我从innodb_trx表里查出的这两个字段，第二个字段trx_mysql_thread_id就是线程</p>
<p>id。显示线程id，是为了说明这两次查询看到的事务对应的线程id都是5，也就是session A所在</p>
<p>的线程。可以看到，T2时刻显示的trx_id是一个很大的数；T4时刻显示的trx_id是1289，看上去是一个比</p>
<p>较正常的数字。这是什么原因呢？实际上，在T1时刻，session A还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB</p>
<p>并不会分配trx_id。也就是说：</p>
<ol>
<li>在T1时刻，trx_id的值其实就是0。而这个很大的数，只是显示用的。一会儿我会再和你说说</li>
</ol>
<p>这个数据的生成逻辑。2. 直到session A 在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时</p>
<p>刻，session B查到的这个trx_id的值就是1289。需要注意的是，除了显而易见的修改类语句外，如果在select 语句后面加上for update，这个事</p>
<p>务也不是只读事务。在上一篇文章的评论区，有同学提出，实验的时候发现不止加1。这是因为：</p>
<ol>
<li>update 和 delete语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到purge</li>
</ol>
<p>队列里等待后续物理删除，这个操作也会把max_trx_id+1， 因此在一个事务中至少加2；</p>
<ol start="2">
<li>InnoDB的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可</li>
</ol>
<p>能看到，trx_id值并不是按照加1递增的。那么，T2时刻查到的这个很大的数字是怎么来的呢？其实，这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的</p>
<p>指针地址转成整数，再加上2 。使用这个算法，就可以保证以下两点：</p>
<ol>
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx还是</li>
</ol>
<p>在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的。2. 如果有并行的多个只读事务，每个事务的trx变量的指针地址肯定不同。这样，不同的并发只</p>
<p>读事务，查出来的trx_id就是不同的。那么，为什么还要再加上2 呢？在显示值里面加上2 ，目的是要保证只读事务显示的trx_id值比较大，正常情况下就会区别于读</p>
<p>写事务的id。但是，trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可</p>
<p>能出现一个读写事务与一个只读事务显示的trx_id相同的情况。不过这个概率很低，并且也没有</p>
<p>什么实质危害，可以不管它。另一个问题是，只读事务不分配trx_id，有什么好处呢？一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读</p>
<p>事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB就只需要</p>
<p>拷贝读写事务的trx_id。另一个好处是，可以减少trx_id的申请次数。在InnoDB里，即使你只是执行一个普通的select</p>
<p>语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句</p>
<p>不需要申请trx_id，就大大减少了并发事务申请trx_id的锁冲突。48</p>
<p>48</p>
<p>48</p>
<p>由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。但是，max_trx_id会持久化存储，重启也不会重置为0，那么从理论上讲，只要一个MySQL服务</p>
<p>跑得足够久，就可能出现max_trx_id达到2 -1的上限，然后从0开始的情况。当达到这个状态后，MySQL就会持续出现一个脏读的bug，我们来复现一下这个bug。首先我们需要把当前的max_trx_id先修改成2 -1。注意：这个case里使用的是可重复读隔离级</p>
<p>别。具体的操作流程如下：</p>
<p>图 4 复现脏读</p>
<p>由于我们已经把系统的max_trx_id设置成了2 -1，所以在session A启动的事务TA的低水位就是</p>
<p>48</p>
<p>48</p>
<p>48</p>
<p>48</p>
<p>2 -1。在T2时刻，session B执行第一条update语句的事务id就是2 -1，而第二条update语句的事务id</p>
<p>就是0了，这条update语句执行后生成的数据版本上的trx_id就是0。在T3时刻，session A执行select语句的时候，判断可见性发现，c&#x3D;3这个数据版本的trx_id，小于</p>
<p>事务TA的低水位，因此认为这个数据可见。但，这个是脏读。由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询</p>
<p>都会出现脏读的。并且，MySQL重启时max_trx_id也不会清0，也就是说重启MySQL，这个bug仍然存在。那么，这个bug也是只存在于理论上吗？假设一个MySQL实例的TPS是每秒50万，持续这个压力的话，在17.8年后，就会出现这个情</p>
<p>况。如果TPS更高，这个年限自然也就更短了。但是，从MySQL的真正开始流行到现在，恐怕</p>
<p>都还没有实例跑到过这个上限。不过，这个bug是只要MySQL实例服务时间够长，就会必然出现</p>
<p>的。当然，这个例子更现实的意义是，可以加深我们对低水位和数据可见性的理解。你也可以借此机</p>
<p>会再回顾下第8篇文章《事务到底是隔离的还是不隔离的？》中的相关内容。thread_id</p>
<p>接下来，我们再看看线程id（thread_id）。其实，线程id才是MySQL中最常见的一种自增id。平</p>
<p>时我们在查各种现场的时候，show processlist里面的第一列，就是thread_id。thread_id的逻辑很好理解：系统保存了一个全局变量thread_id_counter，每新建一个连接，就</p>
<p>将thread_id_counter赋值给这个新连接的线程变量。thread_id_counter定义的大小是4个字节，因此达到2 -1后，它就会重置为0，然后继续增加。但是，你不会在show processlist里看到两个相同的thread_id。这，是因为MySQL设计了一个唯一数组的逻辑，给新线程分配thread_id的时候，逻辑代码是这</p>
<p>样的：</p>
<p>48</p>
<p>48</p>
<p>32</p>
<p>do {</p>
<p>  new_id&#x3D; thread_id_counter++;</p>
<p>} while (!thread_ids.insert_unique(new_id).second);</p>
<p>这个代码逻辑简单而且实现优雅，相信你一看就能明白。小结</p>
<p>今天这篇文章，我给你介绍了MySQL不同的自增id达到上限以后的行为。数据库系统作为一个可</p>
<p>能需要7*24小时全年无休的服务，考虑这些边界是非常有必要的。每种自增id有各自的应用场景，在达到上限后的表现也不同：</p>
<ol>
<li>表的自增id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突</li>
</ol>
<p>的错误。2. row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写的数据会覆盖之前</p>
<p>的数据。3. Xid只需要不在同一个binlog文件中出现重复值即可。虽然理论上会出现重复值，但是概率极</p>
<p>小，可以忽略不计。4. InnoDB的max_trx_id 递增值每次MySQL重启都会被保存起来，所以我们文章中提到的脏读</p>
<p>的例子就是一个必现的bug，好在留给我们的时间还很充裕。5. thread_id是我们使用中最常见的，而且也是处理得最好的一个自增id逻辑了。当然，在MySQL里还有别的自增id，比如table_id、binlog文件序号等，就留给你去验证和探索</p>
<p>了。不同的自增id有不同的上限值，上限值的大小取决于声明的类型长度。而我们专栏声明的上限id</p>
<p>就是45，所以今天这篇文章也是我们的最后一篇技术文章了。既然没有下一个id了，课后也就没有思考题了。今天，我们换一个轻松的话题，请你来说说，读</p>
<p>完专栏以后有什么感想吧。这个“感想”，既可以是你读完专栏前后对某一些知识点的理解发生的变化，也可以是你积累的学</p>
<p>习专栏文章的好方法，当然也可以是吐槽或者对未来的期望。欢迎你给我留言，我们在评论区见，也欢迎你把这篇文章分享给更多的朋友一起阅读。Continue   12</p>
<p>跟着学了三个多月，受益匪浅，学到了很多新的知识和其中的原理！</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>早 </p>
<p>2019-02-25</p>
<p>克劳德   7</p>
<p>本人服务端工程师，在学习这门课之前数据库一直是我的短板，曾听朋友说MySQL或数据库中</p>
<p>涉及了很多方面的知识点，每一个拿出来展开讲几乎都能出一本书了，对数据库是越来越忌惮</p>
<p>，同时也因为工作上并没有过多接触，水平便一直停留在编写简单SQL层面。在面试中被问到数据库问题，只能无奈的说这块不太清楚，也曾在网上自学过，但网上的文章</p>
<p>知识点比较零散，很多都是给出一些结论性的观点，由于不了解其内部原理，记忆很难深刻。老实说，当初报这门课的时候就像买技术书籍一样，我相信大家都有这样的体会，以为买到了</p>
<p>就等于学到了，所以有一段时间没有点开看过，以至于后面开始学的时候都是在追赶老师和大</p>
<p>家的进度，唯一遗憾的地方就是没能跟老师及时留言互动。这门课虽然是文字授课，但字里行间给我的感觉就是很亲切很舒服，为什么呢，因为老师可以</p>
<p>把晦涩的知识变得通俗易懂，有时我在思考，如果让我来讲一个自己擅长的领域是否也能做到</p>
<p>这一点，如果要做到的话需要什么样的知识储备呢。最后真要感谢老师的这门课，让我从心里不再惧怕数据库问题，不管是工作还是面试中信心倍</p>
<p>增，现在时不时都敢和我们DBA“切磋切磋“了，哈哈。精选留言</p>
<p>祝好~</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p> “切磋切磋“</p>
<p>留言不会“过时”哈，在对应的章节下面提出相关的问题，我会持续关注评论区</p>
<p>2019-02-25</p>
<p>三胖   3</p>
<p>老师，我才学了四分之一的课程，但是这门课已经更新完了，我是直接跑到最后一节技术篇来</p>
<p>留言的！很想知道，后来者比如我在学到后面的课程时遇到问题留言，老师还会看会回复吗？（老师的课程超值！！）</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>会看的</p>
<p>后台系统是按照留言时间显示的</p>
<p>而且我在这事情上有强迫症，一定会让“未处理问题”变成0的 </p>
<p>只是说如果是其他同学评论区问过的问题，我可能就不会重复回复了</p>
<p>2019-02-25</p>
<p>某、人   2</p>
<p>很遗憾没能坚持到最后,但是也很庆幸能遇到这么好的专栏。以前了解mysql都是一些零散的知</p>
<p>识点,通过学习完专栏,不论是mysql整体架构还是基础的知识点,都有了更深的认识。以后就把老</p>
<p>师的文档当官方文档查,出现问题先来看看专栏。感触特别深的是,老师对于提到的每一个问题,都会严谨又认真的去回答,尽量帮助每一位同学都</p>
<p>能有所收获。要做到这一点，是特别耗费精力的。感谢老师的传道授业解惑,希望以后有机会能当面向老师请教问题。期待老师下一部杰作</p>
<p>2019-02-26</p>
<p> 作者回复</p>
<p>刚过完年都是很忙的， 找时间补上哈，等你的评论区留言^_^</p>
<p>2019-02-26</p>
<p>夜空中最亮的星（华仔）   2</p>
<p>不知道是最后一篇，否则的话就慢些读完了；</p>
<p>我是一名运维，公司也没有DBA，所以MySQL库也归我收拾；</p>
<p>读了老师的专栏，操作起数据库来，心情更好了；</p>
<p>老师的课，让我有了想看完《高性能MySQL》的兴趣；</p>
<p>听了老师的课，开发都来问我数据库的问题了，高兴；</p>
<p>老师你会有返场吗？我猜会  </p>
<p>可否透漏下接下来的安排，会有续集吗？进阶吗？不想这一别就是一生。您的从未谋面的学生。2019-02-25</p>
<p> 作者回复</p>
<p>谢谢你</p>
<p>“开发都来问我数据库的问题了”，当年我也是这么开始“入坑”，加油</p>
<p>2019-02-25</p>
<p>极客时间   2</p>
<p>通過這個專欄的系統學習，梳理很多知識點、擴展了我對MySQL的認識及以後使用。感謝老師</p>
<p>的諄諄教導！</p>
<p>2019-02-25</p>
<p>NoDBA   1</p>
<p>低版本thread_id超过2^32-1后，在general log显示是负数，高版本貌似没有这个问题，是否高</p>
<p>版本的thread_id是8字节呢？2019-02-27</p>
<p> 作者回复</p>
<p>主要不是定义的问题，而是打印的时候代码问题，按照这个代码输出的：</p>
<p>“%5ld “, (long) thread_id</p>
<p>是个bug， 超过2^31就变成负数了，</p>
<p>新版本改了</p>
<p>好问题 </p>
<p>2019-02-28</p>
<p>kun   1</p>
<p>感觉戛然而止哈 没学够，后面还会再回顾，老师辛苦！</p>
<p>2019-02-26</p>
<p>亮   1</p>
<p>老师，sql 的where里 &lt; 10001 和 &lt;&#x3D; 10000有什么区别吗？2019-02-25</p>
<p> 作者回复</p>
<p>这要看你关注的是什么</p>
<p>你这么问，应该这个字段是整型吧？从查询结果可能是一样的，</p>
<p>不过锁的范围不同，你可以看下21篇</p>
<p>2019-02-25</p>
<p>IceGeek17   1</p>
<p>IceGeek17   1</p>
<p>感谢老师，课程受益匪浅，</p>
<p>课程结束后，如果有问题，是继续在这里的评论区提问，还是会有另外一条答疑通道？另外，在第35篇我提了几个问题，老师还没有回答，我这里再贴一下，老师看一下</p>
<p>问题一：</p>
<p>对于BKA算法的流程理解，用文中的例子，先把t1表（小表）中查询需要的字段放入join_buffer,</p>
<p>然后把join_buffer里的字段值批量传给t2表，先根据索引a查到id，然后得到一批主键id，再根据</p>
<p>主键id排序，然后再根据排完序的id去主键索引查数据（这里用到MRR）</p>
<p>理解是否正确？这里对于主键id排序是在哪里做的，是在join_buffer里，还是另外再开辟一块临时内存？如果在j</p>
<p>oin_buffer里，那join_buffer里的每行内容是不是：t2.id + t1查询必须的字段，并且join_buffer里</p>
<p>是根据id排序的？问题二：</p>
<p>虽然MySQL官方没有支持hash join，但是之前看到文章说，MariaDB已经支持hash join，能不</p>
<p>能后续在答疑文章中简单总结下mariaDB支持的join算法</p>
<p>问题三：</p>
<p>在实际项目中，一个比较困惑的问题，看到过这样的类似写法：</p>
<p>select xxx from t1 join t2 on t1.id &#x3D; t2.id for update （目的是获取几个表上最新的数据，并且加</p>
<p>上锁，防止数据被更新）</p>
<p>这里有几个问题：</p>
<ol>
<li>像这样 join + for update，表上的加锁规则是怎么样的？是不是在需要join的两个表上根据具</li>
</ol>
<p>体的查询执行过程都加上锁？2）像这样 join + for update 的用法是否合理？碰到这样的场景，应该怎么去做？问题四：</p>
<p>看过阿里输出的开发手册里，强调 “最多不超过三表join”，实际项目中，给我感觉很难做到所有</p>
<p>业务都不超过三表join，那这里的问题就是，有什么相关的经验方法，可以尽量降低参与join的</p>
<p>数据表？比如，在数据表里添加冗余字段，可以降低参与join的数据表数量，还有什么其他好的方法？2019-02-25</p>
<p> 作者回复</p>
<p>就在我们评论区，提跟文章相关的内容，会继续关注。问题一、前面的过程理解正确，MRR过程用的是read_rnd_buffer </p>
<p>问题二、其实我们文中最后那个过程，你把他设想成在MySQL内部执行。。问题三、这种复杂的语句，你要把我们两部分知识点连起来看。一个原则：for update的话，执</p>
<p>行语句过程中扫到的间隙和记录都要加锁。 当然最好是不这么做，拆成两个语句会好些。问题四、还是我文中的建议，如果都用NLJ或BKA算法的join其实还好，所以看看explain。降低join表数量的方法，基本上行就是冗余字段和拆成多个语句这两个方向了</p>
<p>2019-02-25</p>
<p>Leon    1</p>
<p>跟着老师终于学到了最后，每天的地铁时间无比充实，我对mysql的基本原理和工作流程大致</p>
<p>有了初步的了解，而不是以前的增删查改，打算以后抽时间再二刷三刷，等全部搞懂后，再去</p>
<p>看看高性能mysql这本书，如果时间允许，打算再去自己参照教程实现一个简易的DB，课程虽</p>
<p>然结束了，仍然感觉意犹未尽，希望老师拉一个倍洽群，大家一起在里面讨论和学习</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>  </p>
<p>评论区一直会开放</p>
<p>大家到对应的文章去提相关问题  </p>
<p>二刷三刷我也一直在哦 </p>
<p>2019-02-25</p>
<p>Dkey   1</p>
<p>当前系统并无其他事务存在时，启动一个只读事务时（意味没有事务id），它的低高水位是怎</p>
<p>么样的老师。2019-02-25</p>
<p> 作者回复</p>
<p>假设当前没有其他事务存在，假设当前的max_trx_id&#x3D;N,</p>
<p>这时候启动一个只读事务，它的高低水位就都是N。2019-02-25</p>
<p>shawn   1</p>
<p>受益匪浅，最后几讲还想了解下null值如何建立索引，由于null直接不能比较和排序，MySQL能</p>
<p>区分出每一个null值吗</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>可以，因为普通索引上都有主键值对吧，</p>
<p>所以其实是 (null, id1), (null, id2) ….</p>
<p>2019-02-25</p>
<p>亢星东   0</p>
<p>id是有上限的，这个的id上限是45，这个结局可以，讲的不错，学到很多</p>
<p>2019-03-13</p>
<p>Bamboo   0</p>
<p>今天终于读完了，从对MySQL只停留在CRUD操作的水平，慢慢开始对MySQL底层的机制有</p>
<p>了一些认识，在遇到问题时，会首先从底层原理去分析，并结合explain来验证自己的分析，一</p>
<p>次很nice的学习之旅。感谢大神老师这么认真负责，节假日都不休息，哈哈！</p>
<p>2019-03-12</p>
<p> 作者回复</p>
<p> </p>
<p>2019-03-13</p>
<p>ArtistLu   0</p>
<p>相遇恨晚 ，安慰下自己，种树的最好时机是十年前，其次是现在！！！谢谢老师</p>
<p>2019-03-08</p>
<p> 作者回复</p>
<p> </p>
<p>2019-03-09</p>
<p>fighting   0</p>
<p>已经二刷了，准备三刷四刷</p>
<p>2019-03-07</p>
<p> 作者回复</p>
<p>   </p>
<p>2019-03-09</p>
<p>沙漠里的骆驼   0</p>
<p>讲的非常好，是我遇到课程讲授最好的了。今天刚和池老师说，希望可以有线下的课程，比如</p>
<p>完成一个数据库的完整设计，从最上层的sql语法解析器到底层的文件调度系统。在集中的时间</p>
<p>里面比如1个月或者2个月，线下组织大家一起，每个人都完成一个tiny_db的工程。我想这是最</p>
<p>好的成长了。不知道老师是否也有这方面的想法？不管如何，真的很感谢老师。如此娓娓道来，所谓的如沐春风便是如此吧。2019-03-06</p>
<p> 作者回复</p>
<p>谢谢你。后面只要还是在评论区继续和大家交流 </p>
<p>2019-03-07</p>
<p>芬   0</p>
<p>学习到了很多平时没有关注到的小细节，很赞！当然 师傅领进门 修行靠个人。剩下的就是自己</p>
<p>好好消化应用了，谢谢老师</p>
<p>2019-02-28</p>
<p>封建的风   0</p>
<p>之前很多知识点有点粗浅，尤其在行版本可见性，redo log&amp;bin log关系，加锁的原理章节，深</p>
<p>入浅出，受益匪浅。感谢老师精品专栏，后期再二刷</p>
<p>2019-02-27</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-自增主键为什么不是连续的</title>
    <url>/posts/1cc9aec2.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>39 | 自增主键为什么不是连续的？2019-02-11 林晓斌</p>
<p>在第4篇文章中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插</p>
<p>入，避免了页分裂，因此索引更紧凑。之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续</p>
<p>的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。自增值保存在哪儿？在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行show create table命</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL AUTO_INCREMENT,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;d  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  UNIQUE KEY &#96;c  ̀(̀ c )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>令，就可以看到如下图所示的结果：</p>
<p>图1 自动生成的AUTO_INCREMENT值</p>
<p>可以看到，表定义里面出现了一个AUTO_INCREMENT&#x3D;2，表示下一次插入数据时，如果需要</p>
<p>自动生成自增值，会生成id&#x3D;2。其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，表的结</p>
<p>构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。不同的引擎对于自增值的保存策略不同。MyISAM引擎的自增值保存在数据文件中。InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值</p>
<p>持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的</p>
<p>值”，具体情况是：</p>
<p>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一</p>
<p>次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的</p>
<p>自增值。举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT&#x3D;11。这时候，</p>
<p>我们删除id&#x3D;10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表</p>
<p>的AUTO_INCREMENT就会变成10。也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复</p>
<p>重启之前的值。理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。自增值修改机制</p>
<p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的</p>
<p>行为如下：</p>
<ol>
<li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的</li>
</ol>
<p>AUTO_INCREMENT值填到自增字段；</p>
<ol start="2">
<li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入</li>
</ol>
<p>的值是X，当前的自增值是Y。1. 如果X&lt;Y，那么这个表的自增值不变；</p>
<ol start="2">
<li>如果X≥Y，就需要把当前自增值修改为新的自增值。新的自增值生成算法是：从auto_increment_offset开始，以auto_increment_increment为步</li>
</ol>
<p>长，持续叠加，直到找到第一个大于X的值，作为新的自增值。其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自</p>
<p>增的初始值和步长，默认值都是1。当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简</p>
<p>单，就是：</p>
<ol>
<li><p>如果准备插入的值&gt;&#x3D;当前自增值，新的自增值就是“准备插入的值+1”；</p>
</li>
<li><p>否则，自增值不变。这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证</p>
</li>
</ol>
<p>是连续的，这是什么原因呢？自增值的修改时机</p>
<p>要回答这个问题，我们就要看一下自增值的修改时机。假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p>
<p>这个语句的执行流程就是：</p>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我</p>
<p>们就可能会设置成auto_increment_increment&#x3D;2，让一个库的自增id都是奇数，另一个库的自</p>
<p>增id都是偶数，避免两个库生成的主键发生冲突。insert into t values(null, 1, 1); </p>
<ol>
<li><p>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</p>
</li>
<li><p>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</p>
</li>
<li><p>将传入的行的值改成(2,1,1);</p>
</li>
<li><p>将表的自增值改成3；</p>
</li>
<li><p>继续执行插入数据操作，由于已经存在c&#x3D;1的记录，所以报Duplicate key error，语句返回。对应的执行流程图如下：</p>
</li>
</ol>
<p>图2 insert(null, 1,1)唯一键冲突</p>
<p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时</p>
<p>候，因为碰到唯一键c冲突，所以id&#x3D;2这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连</p>
<p>续的情况。如图3所示就是完整的演示结果。图3 一个自增主键id不连续的复现步骤</p>
<p>可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id&#x3D;2的行）。可见，唯一键</p>
<p>冲突是导致自增主键id不连续的第一种原因。同样地，事务回滚也会产生类似的现象，这就是第二种原因。下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id&#x3D;2的一行数据了吗？其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看自增</p>
<p>值为什么不能回退。假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯</p>
<p>定要加锁，然后顺序申请。1. 假设事务A申请到了id&#x3D;2， 事务B申请到id&#x3D;3，那么这时候表t的自增值是4，之后继续执</p>
<p>行。2. 事务B正确提交了，但事务A出现了唯一键冲突。3. 如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情</p>
<p>况：表里面已经有id&#x3D;3的行，而当前的自增id值是2。4. 接下来，继续执行的其他事务就会申请到id&#x3D;2，然后再申请到id&#x3D;3。这时，就会出现插入语</p>
<p>句报错“主键冲突”。而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这</li>
</ol>
<p>个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断</p>
<p>id是否存在。2. 把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增</p>
<p>id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自</p>
<p>增id回退”的前提导致的。因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保</p>
<p>证了自增id是递增的，但不保证是连续的。insert into t values(null,1,1);</p>
<p>begin;</p>
<p>insert into t values(null,2,2);</p>
<p>rollback;</p>
<p>insert into t values(null,2,2);</p>
<p>&#x2F;&#x2F;插入的行是(3,2,2)</p>
<p>自增锁的优化</p>
<p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申</p>
<p>请。其实，在MySQL 5.1版本之前，并不是这样的。接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。在MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自</p>
<p>增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。1. 这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释</p>
<p>放锁；</p>
<ol start="2">
<li>这个参数的值被设置为1时：</li>
</ol>
<p>普通insert语句，自增锁在申请之后就马上释放；</p>
<p>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</p>
<ol start="3">
<li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。你一定有两个疑问：为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参</li>
</ol>
<p>数的默认值不是2？答案是，这么设计还是为了数据的一致性。我们一起来看一下这个场景：</p>
<p>图4 批量插入数据的自增锁</p>
<p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session</p>
<p>同时执行向表t2中插入数据的操作。你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样</p>
<p>的情况：</p>
<p>session B先插入了两个记录，(1,1,1)、(2,2,2)；</p>
<p>然后，session A来申请自增id得到id&#x3D;3，插入了（3,5,5)；</p>
<p>之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟</p>
<p>session A相同。是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format&#x3D;statement，你可以设想</p>
<p>下，binlog会怎么记录呢？由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：</p>
<p>要么先记session A的，要么先记session B的。但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里</p>
<p>面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据</p>
<p>不一致。你可以分析一下，出现这个问题的原因是什么？其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格</p>
<p>式的binlog来串行执行，是执行不出来的。而要解决这个问题，有两种思路：</p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执</li>
</ol>
<p>行结束才释放，就是为了达到这个目的。2. 另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再</p>
<p>依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时</p>
<p>binlog_format设置为row。因此，在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性</p>
<p>能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode&#x3D;2 ，并且</p>
<p>binlog_format&#x3D;row.这样做，既能提升并发性，又不会出现数据一致性问题。需要注意的是，我这里说的批量插入数据，包含的语句类型是insert … select、replace …</p>
<p>select和load data语句。但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置</p>
<p>为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出</p>
<p>需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一</p>
<p>个select … insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请</p>
<p>自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p>
<ol>
<li><p>语句执行过程中，第一次申请自增id，会分配1个；</p>
</li>
<li><p>1个用完以后，这个语句第二次申请自增id，会分配2个；</p>
</li>
<li><p>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</p>
</li>
<li><p>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。举个例子，我们一起看看下面的这个语句序列：</p>
</li>
</ol>
<p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一</p>
<p>次申请到了id&#x3D;1，第二次被分配了id&#x3D;2和id&#x3D;3， 第三次被分配到id&#x3D;4到id&#x3D;7。由于这条语句实际只用上了4个id，所以id&#x3D;5到id&#x3D;7就被浪费掉了。之后，再执行insert into t2</p>
<p>values(null, 5,5)，实际上插入的数据就是（8,5,5)。这是主键id出现自增id不连续的第三种原因。小结</p>
<p>今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存</p>
<p>的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的</p>
<p>自增值不变。然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务</p>
<p>回滚的时候不能回收自增id。insert into t values(null, 1,1);</p>
<p>insert into t values(null, 2,2);</p>
<p>insert into t values(null, 3,3);</p>
<p>insert into t values(null, 4,4);</p>
<p>create table t2 like t;</p>
<p>insert into t2(c,d) select c,d from t;</p>
<p>insert into t2 values(null, 5,5);</p>
<p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范</p>
<p>围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前</p>
<p>面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多</p>
<p>了一个理由。最后，我给你留一个思考题吧。在最后一个例子中，执行insert into t2(c,d) select c,d from t;这个语句的时候，如果隔离级别是可</p>
<p>重复读（repeatable read），binlog_format&#x3D;statement。这个语句会对表t的所有记录和间隙加</p>
<p>锁。你觉得为什么需要这么做呢？你可以把你的思考和分析写在评论区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，如果你维护的MySQL系统里有内存表，怎么避免内存表突然丢数据，然后导致</p>
<p>主备同步停止的情况。我们假设的是主库暂时不能修改引擎，那么就把备库的内存表引擎先都改成InnoDB。对于每个</p>
<p>内存表，执行</p>
<p>这样就能避免备库重启的时候，数据丢失的问题。由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的</p>
<p>表数据也会被清空。因此，就不会出现主备同步停止的问题。如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的</p>
<p>主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内</p>
<p>存表就把引擎改了。同时，跟业务开发同学约定好建表规则，避免创建新的内存表。set sql_log_bin&#x3D;off;</p>
<p>alter table tbl_name engine&#x3D;innodb;</p>
<p>评论区留言点赞板：</p>
<p>长杰   6</p>
<p>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是</p>
<p>可重复读（repeatable read），binlog_format&#x3D;statement。这个语句会对表 t 的所有记录和间隙</p>
<p>加锁。你觉得为什么需要这么做呢？假如原库不对t表所有记录和间隙加锁，如果有其他事物新增数据并先与这个批量操作提交，由</p>
<p>于事物的隔离级别是可重复读，t2是看不到新增的数据的。但是记录的binlog是statement格式</p>
<p>，备库或基于binlog恢复的临时库，t2会看到新增的数据，出现数据不一致的情况。2019-02-11</p>
<p> 作者回复</p>
<p>  这是一个典型的场景</p>
<p>2019-02-11</p>
<p>大家在春节期间还坚持看专栏，并且深入地思考和回复，给大家点赞。@长杰 同学提到的将数据保存到InnoDB表用来持久化，也是一个方法。不过，我还是建议釜</p>
<p>底抽薪，直接修改备库的内存表的引擎。@老杨同志 提到的是主库异常重启的场景，这时候是不会报主备不一致的，因为主库重启的</p>
<p>时候写了delete from tbl_name，主备的内存表都清空了。精选留言</p>
<p>aliang   1</p>
<p>老师，我们这边有的开发不喜欢用mysql自带的主键自增功能，而是在程序中控制主键（时间+</p>
<p>业务+机器+序列，bigint类型，实际长度有17位，其中序列保存在内存中，每次递增，主键值不</p>
<p>连续）。理由是</p>
<p>（1）通过这样的主键可以直接定位数据，减少索引（2）如果自增，必须先存数据得到主键才</p>
<p>可继续下面的程序，如果自己计算主键，可以在入库前进行异步处理</p>
<p>（3）a表要insert得到主键，然后处理b表，然后根据条件还要update a表。如果程序自己控制</p>
<p>，就不用先insert a表，数据可以在内存中，直到最后一次提交。（对于a表，本来是insert+upd</p>
<p>ate，最后只是一条insert，少一次数据库操作）</p>
<p>我想请问的是：</p>
<p>（1）针对理由1，是否可以用组合索引替代？（2）针对理由2，是否mysql自身的主键自增分配逻辑就已经能实现了？（3）针对理由3，主键更长意味着更大的索引（主键索引和普通索引），你觉得怎样做会更好</p>
<p>呢</p>
<p>2019-02-12</p>
<p> 作者回复</p>
<p>“（时间+业务+机器+序列，bigint类型，实际长度有17位，其中序列保存在内存中，每次递增，</p>
<p>主键值不连续）。” —-bigint就是8位，这个你需要确定一下。如果是8位的还好，如果是17位的</p>
<p>字符串，就比较耗费空间；</p>
<p>（1）如果“序列”是递增的，还是不能直接用来体现业务逻辑吧？ 创建有业务意义的字段索引估</p>
<p>计还是省不了的 ？（2）mysql确实做不到“插入之前就先算好接下来的id是多少”，一般都是insert执行完成后，再</p>
<p>执行select last_insert_id</p>
<p>(3) 先insert a再update b再update a，确实看上去比较奇怪，不过感觉这个逻辑应该是可以优化</p>
<p>的，不应该作为“主键选择”的一个依据。你可否脱敏一下，把模拟的表结构和业务逻辑说下，</p>
<p>看看是不是可以优化的。总之，按照你说的“时间+业务+机器+序列”这种模式，有点像用uuid，主要的问题还是，如果这</p>
<p>个表的索引多，占用的空间比较大</p>
<p>2019-02-12</p>
<p>进阶的码农   0</p>
<p>上期问题解答，有点疑问</p>
<p>set sql_log_bin&#x3D;off;</p>
<p>alter table tbl_name engine&#x3D;innodb;</p>
<p>为什么备库需要执行set sql_log_bin&#x3D;off这一句</p>
<p>把表的引擎改成innodb不就能解决重启后内存表被删除的问题吗？2019-03-12</p>
<p>进阶的码农   0</p>
<p>课后题</p>
<p>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是</p>
<p>可重复读（repeatable read），binlog_format&#x3D;statement会加记录锁和间隙锁。啥我的binlog_f</p>
<p>ormat&#x3D;row也加锁了</p>
<p>2019-03-12</p>
<p>hetiu   0</p>
<p>老师，请问下innodb_autoinc_lock_mode配置是库级别的还是实例级别的？2019-03-05</p>
<p> 作者回复</p>
<p>全局的</p>
<p>2019-03-06</p>
<p>二十四桥仍在   0</p>
<p>UUID生成主键</p>
<p>2019-03-05</p>
<p>唐名之   0</p>
<p>老师，如果我业务场景必须需要一个带有序自增值，设业务为表A，另外添加一张表记录自增</p>
<p>为表B，表B包含3个字段（自增主键，表A唯一键，自增列）；伪代码如下；这样能实现吗？或</p>
<p>者有其他什么好的方案？begin；</p>
<p>insert into A values（字段1, 唯一键）；</p>
<p>insert into B value (表A唯一键，自增列)；</p>
<p>commit；</p>
<p>2019-02-25</p>
<p> 作者回复</p>
<p>这样思路上是ok的，</p>
<p>不过表b怎么有两个自增列？一个表只能有一个自增列。2019-02-25</p>
<p>AstonPutting   0</p>
<p>老师，innodb_autoinc_lock_mode &#x3D; 2，binlog_format &#x3D; statement 不也会出现数据不一致的问</p>
<p>题吗？不是很理解 binlog_format &#x3D; statement 的情况下，1 与 2 的区别。2019-02-21</p>
<p> 作者回复</p>
<p>innodb_autoinc_lock_mode &#x3D; 2的时候就要binlog_format &#x3D; row才好</p>
<p>2019-02-21</p>
<p>Ryoma   0</p>
<p>在8.0.3版本后，innodb_autoinc_lock_mode默认值已是2，在binlog_format默认值为row的前提</p>
<p>下，想来也是为了增加并发。 </p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock</a></p>
<p>_mode</p>
<p>2019-02-14</p>
<p> 作者回复</p>
<p>  大势所趋 </p>
<p>2019-02-16</p>
<p>帽子掉了   0</p>
<p>老师您好，我有一个时序问题，想请教一下。从这篇文章的介绍来看，获取自增id和写binlog是有先后顺序的。那么在binlog为statement的情况下。语句A先获取id&#x3D;1，然后B获取id&#x3D;2，接着B提交，写binlog，再A写binlog。这个时候如果binlog重放，是不是会发生B的id为1，而A的id为2的不一致的情况？2019-02-13</p>
<p> 作者回复</p>
<p>好问题，不会</p>
<p>因为binlog在记录这种带自增值的语句之前，会在前面多一句，用于指定“接下来这个语句要需</p>
<p>要的 自增ID值是多少”，而这个值，是在主库上这一行插入成功后对应的自增值，所以是一致的</p>
<p>2019-02-14</p>
<p>郭烊千玺   0</p>
<p>请教老师个额外话题 select concat(truncate(sum(data_length)&#x2F;1024&#x2F;1024,2),’MB’) as data_size,</p>
<p>concat(truncate(sum(max_data_length)&#x2F;1024&#x2F;1024,2),’MB’) as max_data_size,</p>
<p>concat(truncate(sum(data_free)&#x2F;1024&#x2F;1024,2),’MB’) as data_free,</p>
<p>concat(truncate(sum(index_length)&#x2F;1024&#x2F;1024,2),’MB’) as index_size</p>
<p>from information_schema.tables where TABLE_SCHEMA &#x3D; ‘databasename’; 网上广为流传的</p>
<p>这个统计的表大小的方法准确吗 mysql内部是怎么统计的？并且data_free这个mydql内部又是怎</p>
<p>么统计的 是采样8个页来评估整表吗 并且实验总感觉这样统计不准啊 到底靠谱吗 求赐教求赐</p>
<p>教啊 困惑好久了</p>
<p>2019-02-12</p>
<p>悟空   0</p>
<p>赶上了进度，把春节期间的补回来了</p>
<p>2019-02-12</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-12</p>
<p>we   0</p>
<p>insert into t values(null,1,1);</p>
<p>begin;</p>
<p>insert into t values(null,2,2);</p>
<p>rolllack;</p>
<p>insert into t values(null,2,2);</p>
<p>&#x2F;&#x2F; 插入的行是 (3,2,2)</p>
<p>老师 里面是 rollback 吧</p>
<p>2019-02-12</p>
<p> 作者回复</p>
<p>是的，我手残了。。多谢指出，发起勘误了哈</p>
<p>2019-02-12</p>
<p>牛在天上飞   0</p>
<p>老师，请问产生大量的event事件会对mysql服务器有什么影响？主要是哪几个方面的影响？2019-02-12</p>
<p> 作者回复</p>
<p>也没啥，主要就是不好管理。。毕竟event是写在MySQL里的，写程序的同学不一定会记得。比较建议将这类逻辑写在应用程序里面</p>
<p>2019-02-12</p>
<p>aliang   0</p>
<p>老师，执行SELECT <code>ID</code>, <code>USER</code>, <code>HOST</code>, <code>DB</code>, <code>COMMAND</code>, <code>TIME</code>, <code>STATE</code>, LEFT(&#96;INF</p>
<p>O<code>, 51200) AS </code>Info<code>FROM</code>information_schema<code>.</code>PROCESSLIST&#96;;后不时有COMMAND为kill</p>
<p>ed但info为null的进程，请问是怎么回事呢</p>
<p>2019-02-11</p>
<p> 作者回复</p>
<p>就表示还在“killed”状态，看一下32篇哈</p>
<p>2019-02-11</p>
<p>陈华应   0</p>
<p>防止insert语句执行过程中，原表有新增数据，进而导致的插入新表的数据比原表少</p>
<p>2019-02-11</p>
<p> 作者回复</p>
<p>确实是考虑并发 , 不过并不会有这个现象哦，因为一个语句执行期间还是有一致性视图的。把binlog加进去考虑下哈</p>
<p>2019-02-11</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-要不要使用分区表</title>
    <url>/posts/1ed24b5c.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>43 | 要不要使用分区表？2019-02-20 林晓斌</p>
<p>我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我</p>
<p>们就来聊聊分区表的使用行为，然后再一起回答这个问题。分区表是什么？为了说明分区表的组织形式，我先创建一个表t：</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  f̀time  ̀datetime NOT NULL,</p>
<p>  &#96;c  ̀int(11) DEFAULT NULL,</p>
<p>  KEY (̀ ftime )̀</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</p>
<p>PARTITION BY RANGE (YEAR(ftime))</p>
<p>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE &#x3D; InnoDB,</p>
<p> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE &#x3D; InnoDB,</p>
<p> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE &#x3D; InnoDB,</p>
<p>PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE &#x3D; InnoDB);</p>
<p>insert into t values(‘2017-4-1’,1),(‘2018-4-1’,1);</p>
<p>图1 表t的磁盘文件</p>
<p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019</p>
<p>这两个分区上。可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p>
<p>对于引擎层来说，这是4个表；</p>
<p>对于Server层来说，这是1个表。你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻</p>
<p>辑。分区表的引擎层行为</p>
<p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。图2 分区表间隙锁示例</p>
<p>这里顺便复习一下，我在第21篇文章和你介绍的间隙锁加锁规则。我们初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，</p>
<p>那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。图3 普通表的加锁范围</p>
<p>也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条</p>
<p>插入语句应该都要进入锁等待状态。但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因</p>
<p>为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是</p>
<p>2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状</p>
<p>态其实是图4这样的：</p>
<p>图4 分区表t的加锁范围</p>
<p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中</p>
<p>深绿色的部分。所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记</p>
<p>录，就要等session A的间隙锁。图5就是这时候的show engine innodb status的部分结果。图5 session B被锁住信息</p>
<p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。我首先用alter table t engine&#x3D;myisam，把表t改成MyISAM表；然后，我再用下面这个例子说</p>
<p>明，对于MyISAM引擎来说，这是4个表。图6 用MyISAM表锁验证</p>
<p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支</p>
<p>持表锁，所以这条update语句会锁住整个表t上的读。但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等</p>
<p>待状态。这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018</p>
<p>上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原</p>
<p>因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。接下来，我们一起看看手动分表和分区表有什么区别。比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻</p>
<p>辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差</p>
<p>别。分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪</p>
<p>个分表。因此，从引擎层看，这两种方式也是没有差别的。其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被</p>
<p>广为诟病的问题：打开表的行为。分区策略</p>
<p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。一个典型的报错情</p>
<p>况是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时</p>
<p>候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所</p>
<p>有的文件，导致打开表文件的个数超过了上限而报错。下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。图 7 insert 语句报错</p>
<p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的</p>
<p>话，并不会出现这个问题。MyISAM分区表使用的分区策略，我们称为通用分区策略（generic partitioning），每次访问分</p>
<p>区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件</p>
<p>管理、表管理的实现上很粗糙，因此有比较严重的性能问题。从MySQL 5.7.9开始，InnoDB引擎引入了本地分区策略（native partitioning）。这个策略是在</p>
<p>InnoDB内部自己管理打开分区的行为。MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始</p>
<p>不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略</p>
<p>的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。接下来，我们再看一下分区表在server层的行为。分区表的server层行为</p>
<p>如果从server层看的话，一个分区表就只是一个表。这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这</p>
<p>个例子的操作序列和执行结果图。图8 分区表的MDL锁</p>
<p>图9 show processlist结果</p>
<p>可以看到，虽然session B只需要操作p_2107这个分区，但是由于session A持有整个表t的MDL</p>
<p>锁，就导致了session B的alter语句被堵住。这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分</p>
<p>表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁</p>
<p>冲突。到这里我们小结一下：</p>
<ol>
<li><p>MySQL在第一次打开分区表的时候，需要访问所有的分区；</p>
</li>
<li><p>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</p>
</li>
<li><p>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必</p>
</li>
</ol>
<p>要的分区。而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如</p>
<p>我们上面的例子中，where ftime&#x3D;‘2018-4-1’，根据分区规则year函数算出来的值是2018，那么</p>
<p>就会落在p_2019这个分区。但是，如果这个where 条件改成 where ftime&gt;&#x3D;‘2018-4-1’，虽然查询结果相同，但是这时候根据</p>
<p>where条件，就要访问p_2019和p_others这两个分区。如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表</p>
<p>的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分</p>
<p>表。我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？分区表的应用场景</p>
<p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简</p>
<p>洁。还有，分区表可以很方便的清理历史数据。如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分</p>
<p>区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历</p>
<p>史数据。这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用</p>
<p>delete语句删除数据相比，优势是速度快、对系统影响小。小结</p>
<p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，</p>
<p>你能够对是否选择使用分区表，有更清晰的想法。需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、</p>
<p>list分区等分区方法。你可以在需要用到的时候，再翻翻手册。实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访</p>
<p>问所有分区，另一个是共用MDL锁。因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预</p>
<p>先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注</p>
<p>意：</p>
<ol>
<li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，</li>
</ol>
<p>对于现在的硬件能力来说都已经是小表了。2. 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时</p>
<p>再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是</p>
<p>分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外</p>
<p>的复杂性，对DBA也更直观，自然是更好的。最后，我给你留下一个思考题吧。我们举例的表中没有用到自增主键，假设现在要创建一个自增字段id。MySQL要求分区表中的主</p>
<p>键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这</p>
<p>么定义呢？你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上篇文章后面还不够多，可能很多同学还没来记得看吧，我们就等后续有更多留言的时候，再补</p>
<p>充本期的“上期问题时间”吧。@夹心面包 提到了在grant的时候是支持通配符的：”_”表示一个任意字符，“%”表示任意字符</p>
<p>串。这个技巧在一个分库分表方案里面，同一个分库上有多个db的时候，是挺方便的。不过我</p>
<p>个人认为，权限赋值的时候，控制的精确性还是要优先考虑的。夹心面包   5</p>
<p>我说下我的感想</p>
<p>1 经典的利用分区表的场景</p>
<p>1 zabbix历史数据表的改造,利用存储过程创建和改造</p>
<p>2 后台数据的分析汇总,比如日志数据,便于清理</p>
<p>这两种场景我们都在执行,我们对于分区表在业务采用的是hash 用户ID方式,不过大规模应用分</p>
<p>区表的公司我还没遇到过</p>
<p>2 分区表需要注意的几点</p>
<p>总结下</p>
<p>1 由于分区表都很大,DDL耗时是非常严重的,必须考虑这个问题</p>
<p>2 分区表不能建立太多的分区,我曾被分享一个因为分区表分区过多导致的主从延迟问题</p>
<p>3 分区表的规则和分区需要预先设置好,否则后来进行修改也很麻烦</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>  非常好</p>
<p>2019-02-20</p>
<p>aliang   2</p>
<p>老师，mysql还有一个参数是innodb_open_files，资料上说作用是限制Innodb能打开的表的数量</p>
<p>。它和open_files_limit之间有什么关系吗？2019-02-21</p>
<p>精选留言</p>
<p> 作者回复</p>
<p>好问题。在InnoDB引擎打开文件超过 innodb_open_files这个值的时候，就会关掉一些之前打开的文件。其实我们文章中 ，InnoDB分区表使用了本地分区策略以后，即使分区个数大于open_files_limit </p>
<p>，打开InnoDB分区表也不会报“打开文件过多”这个错误，就是innodb_open_files这个参数发挥</p>
<p>的作用。2019-02-21</p>
<p>怀刚   1</p>
<p>请教下采用”先做备库、切换、再做备库”DDL方式不支持AFTER COLUMN是因为BINLOG原因</p>
<p>吗？以上DDL方式会存在影响“有损”的吧？“无损”有哪些方案呢？如果备库承载读请求但又不能接受</p>
<p>“长时间”延时</p>
<p>2019-03-09</p>
<p> 作者回复</p>
<ol>
<li><p>对，binlog对原因</p>
</li>
<li><p>如果延迟算损失，确实是有损的。备库上的读流量要先切换到主库（也就是为什么需要在低</p>
</li>
</ol>
<p>峰期做做个操作）</p>
<p>2019-03-09</p>
<p>权恒星   1</p>
<p>这个只适合单机吧？集群没法即使用innodb引擎，又支持分区表吧，只能使用中间件了。之前</p>
<p>调研了一下，官方只有ndb cluster才支持分区表？2019-02-20</p>
<p> 作者回复</p>
<p>对这篇文章讲的是单机上的单表多分区</p>
<p>2019-02-20</p>
<p>One day   1</p>
<p>这次竟然只需要再读两次就能读懂，之前接触过mycat和sharding-jdbc实现分区,老师能否谈谈</p>
<p>这方面的呢</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>赞两次  </p>
<p>这个就是我们文章说的“分库分表中间件”</p>
<p>不过看到不少公司都会要在这基础上做点定制化</p>
<p>2019-02-20</p>
<p>于欣磊   0</p>
<p>阿里云的DRDS就是分库分表的中间件典型代表。自己实现了一个层Server访问层在这一层进</p>
<p>行分库分表（对透明），然后MySQL只是相当于存储层。一些Join、负载Order by&#x2F;Group by都</p>
<p>在DRDS中间件这层完成，简单的逻辑插叙计算完对应的分库分表后下推给MySQL <a href="https://ww/">https://ww</a></p>
<p>w.aliyun.com&#x2F;product&#x2F;drds</p>
<p>2019-02-25</p>
<p>    0</p>
<p>老师确认下，5.7.9之后的innodb分区表，是访问第一个表时不会去打开所有的分区表了吗？2019-02-25</p>
<p> 作者回复</p>
<p>第一次访问的时候，要打开所有分区的</p>
<p>2019-02-25</p>
<p>启程   0</p>
<p>老师，你好，请教你个分区表多条件查询建索引的问题；</p>
<p>表A,</p>
<p>列a,b,c,d,e,f,g,h (其中b是datetime，a是uuid,其余是varchar)</p>
<p>主键索引，(b,a),按月分区</p>
<p>查询情况1：</p>
<p>where b&gt;&#x3D;? and b&lt;&#x3D;? order by b desc limit 500;</p>
<p>查询情况2:</p>
<p>where b&gt;&#x3D;? and b&lt;&#x3D;? and c in(?) order by b desc limit 500;</p>
<p>查询情况3：</p>
<p>where b&gt;&#x3D;? and b&lt;&#x3D;? and d in(?) and e in(?) order by b desc limit 500;</p>
<p>查询情况4：</p>
<p>where b&gt;&#x3D;? and b&lt;&#x3D;? and c in(?) and d in(?) and e in(?) order by b desc limit 500;</p>
<p>自己尝试建过不少索引，效果不是很好，请问老师，我要怎么建索引？？？2019-02-25</p>
<p> 作者回复</p>
<p>这个还是得看不同的语句的执行次数哈</p>
<p>如果从语句类型上看，可以考虑加上(b,c)、(b,d)这两个联合索引</p>
<p>2019-02-26</p>
<p>NICK   0</p>
<p>老师，如果用户分区，业务要做分页过滤查询怎么做才好？2019-02-25</p>
<p> 作者回复</p>
<p>分区表的用法跟普通表，在sql语句上是相同的。2019-02-25</p>
<p>锋芒   0</p>
<p>老师，请问什么情况会出现间隙锁？能否专题讲一下锁呢？2019-02-23</p>
<p> 作者回复</p>
<p>20、21两篇看下</p>
<p>2019-02-23</p>
<p>daka   0</p>
<p>本期提到了ndb，了解了下，这个存储引擎高可用及读写可扩展性功能都是自带，感觉是不错</p>
<p>，为什么很少见人使用呢？生产不可靠？2019-02-21</p>
<p>helloworld.xs   0</p>
<p>请教个问题，一般mysql会有查询缓存，但是update操作也有缓存机制吗？使用mysql console</p>
<p>第一次执行一个update SQL耗时明显比后面执行相同update SQL要慢，这是为什么？2019-02-21</p>
<p> 作者回复</p>
<p>update的话，主要应该第一次执行的时候，数据都读入到了</p>
<p>2019-02-21</p>
<p>万勇   0</p>
<p>老师，请问add column after column_name跟add column不指定位置，这两种性能上有区别吗</p>
<p>？我们在add column 指定after column_name的情况很多。2019-02-21</p>
<p> 作者回复</p>
<p>仅仅看性能，是没什么差别的</p>
<p>但是建议尽量不要加after column_name，</p>
<p>也就是说尽量加到最后一列。因为其实没差别，但是加在最后有以下两个好处：</p>
<ol>
<li>开始有一些分支支持快速加列，就是说如果你加在最后一列，是瞬间就能完成，而加了after</li>
</ol>
<p>column_name，就用不上这些优化（以后潜在的好处）</p>
<ol start="2">
<li>我们在前面的文章有提到过，如果怕对线上业务造成影响，有时候是通过“先做备库、切换、</li>
</ol>
<p>再做备库”这种方式来执行ddl的，那么使用after column_name的时候用不上这种方式。实际上列的数据是不应该有影响的，还是要形成好习惯 </p>
<p>2019-02-21</p>
<p>Q   0</p>
<p>老师 请问下 网站开发数据库表是myisam和innodb混合引擎 考虑管理比较麻烦 想统一成innodb</p>
<p>请问是否影响数据库或带来什么隐患吗？ 网站是网上商城购物类型的</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>应该统一成innodb</p>
<p>网上商城购物类型更要用InnoDB，因为MyISAM并不是crash-safe的。测试环境改完回归下</p>
<p>2019-02-21</p>
<p>夹心面包   0</p>
<p>我觉得老师的问题可以提炼为 Mysql复合主键中自增长字段设置问题</p>
<p>复合索引可以包含一个auto_increment,但是auto_increment列必须是第一列。这样插入的话,只</p>
<p>需要指定非自增长的列</p>
<p>语法 alter table test1 change column id id int auto_increment;</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>“但是auto_increment列必须是第一列” 可以不是哦</p>
<p>2019-02-20</p>
<p>undifined   0</p>
<p>老师，有两个问题</p>
<ol>
<li>图三的间隙锁，根据“索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，</li>
</ol>
<p>next-key lock 退化为间隙锁”，不应该是 (-∞,2017-4-1],(2017-4-1,2018-4-1)吗，图4左边的也应</p>
<p>该是 (-∞,2017-4-1],(2017-4-1, supernum)，是不是图画错了</p>
<ol start="2">
<li>现有的一个表，一千万行的数据， InnoDB 引擎，如果以月份分区，即使有 MDL 锁和初次访</li>
</ol>
<p>问时会查询所有分区，但是综合来看，分区表的查询性能还是要比不分区好，这样理解对吗</p>
<p>思考题的答案 </p>
<p>ALTER TABLE t</p>
<p>ADD COLUMN (id INT AUTO_INCREMENT ),</p>
<p>ADD PRIMARY KEY (id, ftime);</p>
<p>麻烦老师解答一下，谢谢老师</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<ol>
<li><p>我们语句里面是 where ftime&#x3D;’2017-5-1’ 哈，不是“4-1”</p>
</li>
<li><p>“分区表的查询性能还是要比不分区好，这样理解对吗”，其实还是要看表的索引情况。当然一定存在一个数量级N，把这N行分到10个分区表，比把这N行放到一个大表里面，效率高</p>
</li>
</ol>
<p>2019-02-20</p>
<p>千木   0</p>
<p>老师您好，你在文章里面有说通用分区规则会打开所有引擎文件导致不可用，而本地分区规则</p>
<p>应该是只打开单个引擎文件，那你不建议创建太多分区的原因是什么呢？如果是本地分区规则</p>
<p>，照例说是不会影响的吧，叨扰了</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>“本地分区规则应该是只打开单个引擎文件”，并不是哈，我在文章末尾说了，也会打开所有文</p>
<p>件的，只是说本地分区规则有优化，比如如果文件数过多，就会淘汰之前打开的文件句柄（暂</p>
<p>时关掉）。所以分区太多，还是会有影响的</p>
<p>2019-02-20</p>
<p>郭江伟   0</p>
<p>此时主键包含自增列+分区键，原因为对innodb来说分区等于单独的表，自增字段每个分区可以</p>
<p>插入相同的值，如果主键只有自增列无法完全保证唯一性。测试表如下：</p>
<p>mysql&gt; show create table t\G</p>
<p>Table: t</p>
<p>Create Table: CREATE TABLE <code>t</code> (</p>
<p><code>id</code> int(11) NOT NULL AUTO_INCREMENT,</p>
<p><code>ftime</code> datetime NOT NULL,</p>
<p><code>c</code> int(11) DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>id</code>,<code>ftime</code>),</p>
<p>KEY <code>ftime</code> (<code>ftime</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</p>
<p>&#x2F;*!50100 PARTITION BY RANGE (YEAR(ftime))</p>
<p>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE &#x3D; InnoDB,</p>
<p>PARTITION p_2018 VALUES LESS THAN (2018) ENGINE &#x3D; InnoDB,</p>
<p>PARTITION p_2019 VALUES LESS THAN (2019) ENGINE &#x3D; InnoDB,</p>
<p>PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE &#x3D; InnoDB) *&#x2F;</p>
<p>1 row in set (0.00 sec)</p>
<p>mysql&gt; insert into t values(1,’2017-4-1’,1),(1,’2018-4-1’,1);</p>
<p>Query OK, 2 rows affected (0.02 sec)</p>
<p>mysql&gt; select * from t;</p>
<p>+—-+———————+——+</p>
<p>| id | ftime | c |</p>
<p>+—-+———————+——+</p>
<p>| 1 | 2017-04-01 00:00:00 | 1 |</p>
<p>| 1 | 2018-04-01 00:00:00 | 1 |</p>
<p>+—-+———————+——+</p>
<p>2 rows in set (0.00 sec)</p>
<p>mysql&gt; insert into t values(null,’2017-5-1’,1),(null,’2018-5-1’,1);</p>
<p>Query OK, 2 rows affected (0.02 sec)</p>
<p>mysql&gt; select * from t;</p>
<p>+—-+———————+——+</p>
<p>| id | ftime | c |</p>
<p>+—-+———————+——+</p>
<p>| 1 | 2017-04-01 00:00:00 | 1 |</p>
<p>| 2 | 2017-05-01 00:00:00 | 1 |</p>
<p>| 1 | 2018-04-01 00:00:00 | 1 |</p>
<p>| 3 | 2018-05-01 00:00:00 | 1 |</p>
<p>+—-+———————+——+</p>
<p>4 rows in set (0.00 sec)</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p> </p>
<p>2019-02-24</p>
<p>wljs   0</p>
<p>老师我想问个问题 我们公司一个订单表有110个字段 想拆分成两个表 第一个表放经常查的字段</p>
<p>第二个表放不常查的 现在程序端不想改sql，数据库端来实现 当查询字段中 第一个表不存在 就</p>
<p>去关联第二个表查出数据 db能实现不</p>
<p>2019-02-20</p>
<p> 作者回复</p>
<p>用view可能可以实现部分你的需求，但是强烈不建议这么做。业务不想修改，就好好跟他们说，毕竟这样分（常查和不常查的垂直拆分）是合理的，对读写</p>
<p>性能都有明显的提升的。2019-02-20</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-误删数据后除了跑路还能怎么办</title>
    <url>/posts/3ffe231f.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>31 | 误删数据后除了跑路，还能怎么办？2019-01-23 林晓斌</p>
<p>今天我要和你讨论的是一个沉重的话题：误删数据。在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误</p>
<p>删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整</p>
<p>个集群的实例都会执行这个命令。虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数</p>
<p>据操作权限的同学，都有可能踩到误删数据这条线。今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来</p>
<p>的损失。为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p>
<ol>
<li><p>使用delete语句误删数据行；</p>
</li>
<li><p>使用drop table或者truncate table语句误删数据表；</p>
</li>
<li><p>使用drop database语句误删数据库；</p>
</li>
<li><p>使用rm命令误删整个MySQL实例。误删行</p>
</li>
</ol>
<p>在第24篇文章中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪</p>
<p>回把数据恢复回来。Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提</p>
<p>是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event</li>
</ol>
<p>即可；</p>
<ol start="2">
<li><p>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</p>
</li>
<li><p>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的</p>
</li>
</ol>
<p>位置即可。如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务：</p>
<p>现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库</p>
<p>的命令是：</p>
<p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。需要说明的是，我不建议你直接在主库上执行这些操作。恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执</p>
<p>行这些操作，然后再将确认过的临时库的数据，恢复回主库。为什么要这么做呢？这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问</p>
<p>题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数</p>
<p>据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破</p>
<p>(A)delete …</p>
<p>(B)insert …</p>
<p>(C)update …</p>
<p>(reverse C)update …</p>
<p>(reverse B)delete …</p>
<p>(reverse A)insert …</p>
<p>坏。当然，我们不止要说误删数据的事后处理办法，更重要是要做到事前预防。我有以下两个建</p>
<p>议：</p>
<ol>
<li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写</li>
</ol>
<p>where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。2. 代码上线前，必须经过SQL审计。你可能会说，设置了sql_safe_updates&#x3D;on，如果我真的要把一个小表的数据全部删掉，应该怎</p>
<p>么办呢？如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id&gt;&#x3D;0。但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，</p>
<p>你应该优先考虑使用truncate table或者drop table命令。使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate &#x2F;drop table和drop</p>
<p>database命令删除的数据，就没办法通过Flashback来恢复了。为什么呢？这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是</p>
<p>statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？误删库&#x2F;表</p>
<p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有</p>
<p>定期的全量备份，并且实时备份binlog。在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li><p>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</p>
</li>
<li><p>用备份恢复出一个临时库；</p>
</li>
<li><p>从日志备份里面，取出凌晨0点之后的日志；</p>
</li>
<li><p>把这些日志，除了误删除数据的语句外，全部应用到临时库。这个流程的示意图如下所示：</p>
</li>
</ol>
<p>图1 数据恢复流程-mysqlbinlog方法</p>
<p>关于这个过程，我需要和你说明如下几点：</p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加</li>
</ol>
<p>上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用</p>
<p>其他库日志的情况。2. 在应用日志的时候，需要跳过12点误操作的那个语句的binlog：</p>
<p>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–</p>
<p>stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日</p>
<p>志继续执行；</p>
<p>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要</p>
<p>执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后</p>
<p>按顺序执行binlog的时候，就会自动跳过误操作的语句。不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工</li>
</ol>
<p>具并不能指定只解析一个表的日志；</p>
<ol start="2">
<li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在第26篇文章中介</li>
</ol>
<p>绍的那些并行复制的方法，在这里都用不上。一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，</p>
<p>这样：</p>
<ol>
<li>在start slave之前，先通过执行</li>
</ol>
<p>change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以让临时库只同步误操</p>
<p>作的表；</p>
<ol start="2">
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。这个过程的示意图如下所示。图2 数据恢复流程-master-slave方法</li>
</ol>
<p>可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删</p>
<p>除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库</p>
<p>中。假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show</p>
<p>binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就</p>
<p>需要去binlog备份系统中找到这两个文件。把之前删掉的binlog放回备库的操作步骤，是这样的：</p>
<ol>
<li><p>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</p>
</li>
<li><p>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是</p>
</li>
</ol>
<p>“.&#x2F;master.000005”和“.&#x2F;master.000006”;</p>
<ol start="3">
<li><p>重启备库，目的是要让备库重新识别这两个日志文件；</p>
</li>
<li><p>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个</p>
</li>
</ol>
<p>方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方</p>
<p>式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除</p>
<p>之前已经做了备份。但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留</p>
<p>的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就</p>
<p>表示备份系统保留的日志时间就至少是半个月。另外，我建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿</p>
<p>出来演练。为什么这么说呢？这里的原因，主要包括两个方面：</p>
<ol>
<li>虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失</li>
</ol>
<p>降到最小，也应该不用跑路了。2. 而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过</p>
<p>去了。延迟复制备库</p>
<p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可</p>
<p>控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的</p>
<p>实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天</p>
<p>来计算的。那么，我们有什么方法可以缩短恢复数据需要的时间呢？如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑搭建延迟复制的备库。这个功</p>
<p>能是MySQL 5.6版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有</p>
<p>从库，进而导致所有从库的数据表也都一起被误删了。延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，</p>
<p>可以指定这个备库持续保持跟主库有N秒的延迟。比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误</p>
<p>操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop</p>
<p>slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也</p>
<p>就缩短了整个数据恢复需要的时间。预防误删库&#x2F;表的方法</p>
<p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你</p>
<p>一些减少误删操作风险的建议。第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p>
<p>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需</p>
<p>求的话，也可以通过开发管理系统得到支持。即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账</p>
<p>号。第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p>
<p>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后</p>
<p>再删除这张表。改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须</p>
<p>通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。rm删除数据</p>
<p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意</p>
<p>地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一</p>
<p>个新的主库，从而保证整个集群的正常工作。这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批</p>
<p>量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。小结</p>
<p>今天，我和你讨论了误删数据的几种可能，以及误删后的处理方法。但，我要强调的是，预防远比处理的意义来得大。另外，在MySQL的集群方案中，会时不时地用到备份来恢复实例，因此定期检查备份的有效性</p>
<p>也很有必要。如果你是业务开发同学，你可以用show grants命令查看账户的权限，如果权限过大，可以建议</p>
<p>DBA同学给你分配权限低一些的账号；你也可以评估业务的重要性，和DBA商量备份的周期、</p>
<p>是否有必要创建延迟复制的备库等等。数据和服务的可靠性不止是运维团队的工作，最终是各个环节一起保障的结果。今天的课后话题是，回忆下你亲身经历过的误删数据事件吧，你用了什么方法来恢复数据呢？你</p>
<p>在这个过程中得到的经验又是什么呢？你可以把你的经历和经验写在留言区，我会在下一篇文章的末尾选取有趣的评论和你一起讨论。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>我在上一篇文章给你留的问题，是关于空表的间隙的定义。一个空表就只有一个间隙。比如，在空表上执行：</p>
<p>这个查询语句加锁的范围就是next-key lock (-∞, supremum]。验证方法的话，你可以使用下面的操作序列。你可以在图4中看到显示的结果。begin;</p>
<p>select * from t where id&gt;1 for update;</p>
<p>图3 复现空表的next-key lock</p>
<p>图4 show engine innodb status 部分结果</p>
<p>评论区留言点赞板：</p>
<p>赞这些思考和反馈。@老杨同志 给出了正确的分析和SQL语句验证方法；</p>
<p>@库淘淘 指出了show engine innodb status验证结论。苍茫   3</p>
<p>有一次，我维护一张表，需要手动修改大量数据的状态，sql就很多，然后我保存到txt文件中以</p>
<p>附件的形式发给部门老大审批，部门老大审批后转发邮件给运维，然后运维这哥们用的是360</p>
<p>浏览器，他预览的sql，然后全部复制到客户端执行，但是问题也在这，360浏览器预览的时候</p>
<p>由于文本偏长，到了某一条语句只有前半部分的update语句，没有后面的条件，然后就悲剧了</p>
<p>。全表的状态都变成同一个。然后我就特别莫名其妙，还被老大批了一顿。说我写的脚本有问</p>
<p>题。这锅我可不背，我把脚本在本地备份库跑了一遍又一遍就是没有问题。然后我再去运维哥</p>
<p>们那，叫他再复制一下脚本就发现问题了。好在执行脚本前进行了表备份。扩展一下，如果你</p>
<p>用谷歌浏览器就不会出现这种问题！发现问题后，立马恢复了数据</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>  这个是血泪经验</p>
<p>拷贝文本执行，这个操作还可能存在字符集隐患。这个事情更深一层逻辑，是你做了创造性的事情，非常优秀 。而这个运维同学认为他只是一个”复制粘贴执行的人”， 这种思路下是迟早会出问题的。2019-01-24</p>
<p>linhui0705   1</p>
<p>对生产数据库操作，公司DBA提出的编写脚本方法，个人觉得还是值得分享，虽说可能大部分</p>
<p>公司也可能有这样的规范。修改生产的数据，或者添加索引优化，都要先写好四个脚本：备份脚本、执行脚本、验证脚本</p>
<p>和回滚脚本。备份脚本是对需要变更的数据备份到一张表中，固定需要操作的数据行，以便误</p>
<p>操作或业务要求进行回滚；执行脚本就是对数据变更的脚本，为防Update错数据，一般连备份</p>
<p>表进行Update操作；验证脚本是验证数据变更或影响行数是否达到预期要求效果；回滚脚本就</p>
<p>是将数据回滚到修改前的状态。虽说分四步骤写脚本可能会比较繁琐，但是这能够很大程度避免数据误操作。2019-01-23</p>
<p> 作者回复</p>
<p>  非常好的经验</p>
<p>如果能够切实执行，即使有出问题，也是可以很快恢复的</p>
<p>把这些脚本当做开发代码来维护，是一个很好的实践</p>
<p>2019-01-23</p>
<p>某、人   9</p>
<p>总结下今天的知识点:</p>
<p>我觉得DBA的最核心的工作就是保证数据的完整性</p>
<p>今天老师也讲到了先要做好预防,预防的话大概是通过这几个点：</p>
<p>1.权限控制与分配(数据库和服务器权限)</p>
<p>精选留言</p>
<p>2.制作操作规范</p>
<p>3.定期给开发进行培训</p>
<p>4.搭建延迟备库</p>
<p>5.做好sql审计,只要是对线上数据有更改操作的语句(DML和DDL)都需要进行审核</p>
<p>6.做好备份。备份的话又分为两个点.</p>
<p>(1)如果数据量比较大,用物理备份xtrabackup。定期对数据库进行全量备份,也可以做增量备份。(2)如果数据量较少,用mysqldump或者mysqldumper。再利用binlog来恢复或者搭建主从的方式</p>
<p>来恢复数据。定期备份binlog文件也是很有必要的</p>
<p>还需要定期检查备份文件是否可用,如果真的发生了误操作,需要恢复数据的时候,发生备份文件</p>
<p>不可用,那就更悲剧了</p>
<p>如果发生了数据删除的操作,又可以从以下几个点来恢复:</p>
<p>1.DML误操作语句造成数据不完整或者丢失。可以通过flashback,不过我们目前用的是美团的m</p>
<p>yflash,也是一个不错的工具，本质都差不多.都是先解析binlog event,然后在进行反转。把delete</p>
<p>反转为insert,insert反转为delete,update前后image对调。所以必须设置binlog_format&#x3D;row 和 bi</p>
<p>nlog_row_image&#x3D;full.</p>
<p>切记恢复数据的时候,应该先恢复到临时的实例,然后在恢复回主库上。2.DDL语句误操作(truncate和drop),由于DDL语句不管binlog_format是row还是statement.在binl</p>
<p>og里都只记录语句,不记录image所以恢复起来相对要麻烦得多。只能通过全量备份+应用binlog</p>
<p>的方式来恢复数据。一旦数据量比较大,那么恢复时间就特别长,</p>
<p>对业务是个考验。所以就涉及到老师在第二讲提到的问题了，全量备份的周期怎么去选择</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p> </p>
<p>2019-01-23</p>
<p>亮   2</p>
<p>CREATE TABLE <code>t</code> (</p>
<p><code>id</code> int(11) NOT NULL,</p>
<p><code>city</code> varchar(16) NOT NULL,</p>
<p><code>name</code> varchar(16) NOT NULL,</p>
<p><code>age</code> int(11) NOT NULL,</p>
<p><code>addr</code> varchar(128) DEFAULT NULL,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>city</code> (<code>city</code>)</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>老师请教您16章的问题，您提到“city、name、age 这三个字段的定义总长度是36”，这个是怎</p>
<p>么算出来的呢，varchar(16)是可以保存16个字符，占用了49个字节（utf8），所以我没想明白3</p>
<p>6是怎么来的。第二个问题是max_length_for_sort_data参数系统默认是1024，是1024个字节的意思吗？2019-01-23</p>
<p>  作者回复</p>
<ol>
<li><p>age(11)其实是4个字节哈</p>
</li>
<li><p>对，单位是字节</p>
</li>
</ol>
<p>谢谢老师，不过还是没明白，age是4个字节，city和name分别是49个字节，49+49+4&#x3D;102字节</p>
<p>，36是怎么来的呢？再次感谢</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>哦 抱歉哈，我这边验证的时候默认用的latin1，是16+16+4</p>
<p>2019-01-23</p>
<p>技术人成长   1</p>
<p>我只想说，作者功力过于深厚了！</p>
<p>2019-01-25</p>
<p>Cranliu   1</p>
<p>个人觉得，预防同样很重要，一般的dml操作，我是先ctas要操作的数据，drop&#x2F;truncate 的时候</p>
<p>先逻辑备份。2019-01-23</p>
<p> 作者回复</p>
<p>对的，备份的意识很重要。不过“drop&#x2F;truncate 的时候先逻辑备份”这么做的不多^_^ </p>
<p>主要的原因是逻辑备份可能会对系统有额外消耗。（全表扫描）</p>
<p>2019-01-23</p>
<p>511   1</p>
<p>早~</p>
<p>2019-01-23</p>
<p>Long   0</p>
<p>又到了讲故事(事故)的时候了，历史上遇到过很多次事故。全表误删除，误更新不下于8次，有</p>
<p>MySQL 的DB也有memory DB. 有一次同事比较搞笑的是，有一次一张重要的权限控制表更新</p>
<p>，由于用的是workbench 界面工具当时写了where条件，但是在选中执行行的时候where条件在</p>
<p>第二行，没选中，还在执行前的时候手动把session 级的sql_safe_updates&#x3D;0了，也没有点开那</p>
<p>个autocommit取消的按钮。然后一执行，全表更新了，导致全网只有一个用户可以正常登录。还有其他的误操作，总结历史遇到过的这类问题基本就是几类</p>
<ol>
<li>登错环境，以为是测试环境，一顿操作猛如虎，一看环境是生产，回头一看，表已经drop了</li>
</ol>
<p>……</p>
<ol start="2">
<li>sql写的有问题，逻辑错误，或者条件缺失，常见的如不带where；or关键字的逻辑没有用括</li>
</ol>
<p>号括好</p>
<ol start="3">
<li>还有一些奇葩的，比如where 字段1&#x3D;字段2写成了字段1+字段2，逻辑等于判断变成了是否为</li>
</ol>
<p>1的判断了，大概率全表更新了。错误解决大部分都是用备份恢复或者根据错误的逻辑来逻辑恢复。还有一个，最近在尝试的，就是ibd文件中有坏页，只要一读到那个坏页，就会crash，报错spa</p>
<p>ceid page no should be多少多少，尝试了copy frm, ibd，ibdata, iblogfile这些表结构，数据文件</p>
<p>，数据字典，undo redo 日志，也尝试用了undrop的工具也解析不出来。这个表比较特殊，是</p>
<p>一个特殊库，没备份，表没有索引没法通过走索引跳过那个坏页的那些行，现在的状态是，只</p>
<p>能用nysqldump恢复一部分数据。 我想通过16进制，自己慢慢找到那个脏写的数据，然后修改</p>
<p>一下文件……</p>
<p>老师有什么比较好的建议吗？或者后面会说到ibd文件的物理结构之类的吗？ 感谢</p>
<p>2019-01-28</p>
<p> 作者回复</p>
<p>感谢你的分享，都是血泪教训。。我看有几个是用的可视化工具导致的，后面还是尽量用MySQL客户端敲命令吧 </p>
<p>ibd文件坏页我之前有回答过其他同学的，看下这个</p>
<p><a href="https://weibo.com/1933424965/H3qIu0JYo?from=page_1005051933424965_profile&wvr=6&mo">https://weibo.com/1933424965/H3qIu0JYo?from=page_1005051933424965_profile&amp;wvr=6&amp;mo</a></p>
<p>d&#x3D;weibotime</p>
<p>2019-01-28</p>
<p>PengfeiWang   0</p>
<p>老师，您好，有个问题请教一下：</p>
<p>关于MySQL备份有效性的验证，你有什么好的方法可以推荐吗？目前只能通过不定期的备份恢</p>
<p>复来验证。2019-01-25</p>
<p> 作者回复</p>
<p>大家都是这么做的 </p>
<p>2019-01-25</p>
<p>AI杜嘉嘉   0</p>
<p>老师，接着上面问题。是删表，线上rename，有什么风险吗？需要注意什么？rename是不是d</p>
<p>dl操作</p>
<p>2019-01-25</p>
<p> 作者回复</p>
<p>是，不过rename的执行速度很快</p>
<p>2019-01-25</p>
<p>还一棵树   0</p>
<p>我遇到过一个线上误truncate表的，最终选择的处理过程如下：</p>
<p>1、创建一个同版本的空mysql实例，建一个名字+结构一模一样的表</p>
<p>2、discard这个表的tablespace</p>
<p>3、从之前的备份集中 innobackupex –apply-log 并记录binlog位置（用innobackupex备份的）</p>
<p>。还原后找到误操作表的.ibd文件，copy到新实例对应的位置</p>
<p>4、在之前创建的mysql实例上import tablespace</p>
<p>5、利用mysqlbinlog 处理增量数据</p>
<p>6、最后导出 再导入</p>
<p>2019-01-24</p>
<p> 作者回复</p>
<p> </p>
<p>这基本上是最快的恢复步骤了</p>
<p>2019-01-24</p>
<p>苍茫   0</p>
<p>有一次我在查询数据倒数报表给业务方，那个脚本是我写的，关联了很多表，还跨了库，一个</p>
<p>主表有一万多条纪录，关联另一张操作记录表好像是10万条数据。因为要统计多步操作步骤，</p>
<p>所以每一步的操作记录我就得按照不同的条件关联产生临时表（关联中有group 还有max（）</p>
<p>聚合函数，这个是需求导致的），一开始写好的查询很快有了结果。那天11点多的时候，我执</p>
<p>行那个脚本，发现很慢没有反应，然后我就把连接关了，重复几次操作，然后生产库就被我搞</p>
<p>挂了。后面运维的同学操作了一波才恢复过来。这次也是运维同学背的锅。后面，还把我的操</p>
<p>作给贴出来了，做通报批评。我想问下为啥会出现这种情况呢？后续我的组长对我写的sql进行了优化，主要是把联表操作需要的信息放在子查询中，然后再操</p>
<p>作记录表中加了索引，有了备份库，每次执行脚本导出数据都是在备份库中导出，就再也没有</p>
<p>发生这个问题了。2019-01-24</p>
<p> 作者回复</p>
<p>后面有一篇专门说这个，敬请期待哈</p>
<p>2019-01-24</p>
<p>xishuai   0</p>
<p>老师，麻烦问一下，5.7.21上innodb的表两列（有中文有英文）建的全文索引，最小分词1，按</p>
<p>中文可以查询，按英文有些查询不出来，您知道原因吗？2019-01-24</p>
<p> 作者回复</p>
<p>全文索引有stop words的，你看看是不是落在stop words里了</p>
<p>2019-01-24</p>
<p>catalina   0</p>
<p>老师，我们现在需要将一个库下面的所有表的数据同步到另外一个库，每个表有几百万数据吧</p>
<p>，大约十多张表。有什么好的方法吗？2019-01-24</p>
<p> 作者回复</p>
<p>原库的这几个表还会继续更新吗？ 如果会继续更新，就用搭主备的方法；</p>
<p>如果没更新了，后面有一个文章专门讲这个问题哈</p>
<p>2019-01-24</p>
<p>hua168   0</p>
<p>大神，有亲戚小公司搞DBA一年，我想问一下：</p>
<p>1.DBA一般发展方向是怎样的呀？运维和开发我了解，DBA没接触过，无法给建议，一般的升</p>
<p>级过程是怎样的？2.以后发展方向是怎样？现在都是开源、大数据时代时代，阿里又搞“去IOE”，一般oracle DBA</p>
<p>发展前景不好吧？能帮指一个大概的方向吗？谢谢~~</p>
<p>2019-01-24</p>
<p>aliang   0</p>
<p>老师好。这是第6讲评论区Tony Du的评论：</p>
<p>session A: begin; select * from t limit 1; 最先启动sessionA</p>
<p>session B: begin; select * from t limit 1; 紧接着启动sessionB</p>
<p>session C: alter table t add f int; 然后再是启动sessionC</p>
<p>session D: begin; select * from t limit 1; 最后是启动sessionD</p>
<p>他说session C会被A和B阻塞，D会被C阻塞；当A和B提交后，D是可以继续执行得到查询结果</p>
<p>的，但是C仍然被阻塞，只有D提交后C才能执行成功。我自己在5.6和5.7按他的步骤做了试验</p>
<p>，结果和他一样。然后我再做了一次试验，这次把D的begin;去掉，变成了：</p>
<p>session A: begin; select * from t limit 1; 最先启动sessionA</p>
<p>session B: begin; select * from t limit 1; 紧接着启动sessionB</p>
<p>session C: alter table t add f int; 然后再是启动sessionC</p>
<p>session D: select * from t limit 1; 最后是启动sessionD</p>
<p>结果是当A和B提交后，D和C都能执行成功了（和老师的结果一样）。我的问题是：为什么第</p>
<p>一次session D显式开启事务，和第二次不显式开启的结果不一样呢？2019-01-24</p>
<p> 作者回复</p>
<p>可否贴一下你的show variables 的结果，我这边验证（不论D有没有加begin）的效果都是你说</p>
<p>的第二次的情况哦</p>
<p>2019-02-04</p>
<p>太福   0</p>
<p>因为时间原因，前面的课程没跟上，在这里请教个最近线上mysql遇到的问题：</p>
<p>一个从库mysql5.6版本,正常情况下只有3到5个并发sql在查询，每分钟用下面的sql查看一次检</p>
<p>测到的</p>
<p>SELECT t1.* FROM information_schema.<code>PROCESSLIST</code> t1 WHERE info is not null ORDER</p>
<p>BY time desc;</p>
<p>前一次检测还是几个sql在查询，下1分钟查到2000多个sql在跑，很多堆积了几十秒的sql，状态</p>
<p>“Sending data” “Creating sort index”</p>
<p>，而这些sql在正常情况下是不到1秒就查到结果了的，且cpu使用率与io很低，看起来mysql僵</p>
<p>死的了。有两个问题：1）问题突然出现</p>
<p>2）大量sql在跑，而cpu与磁盘io反而比正常下降；这是从库，写只有主从同步，其它都是读查</p>
<p>询。配置：64G内存，bp分配40G，io使用不高</p>
<p>,业务量没大变动，也没新版本发布，大体排除业务并发加大导致的。2019-01-24</p>
<p> 作者回复</p>
<p>这个不算突然出现吧，你两次检测之间是1分钟是吧？你这样说我看不太明白，可否给一个当时的show processlist的截图；</p>
<p>你还能执行show processlist，就不能算”僵死“；</p>
<p>io的状态如果有保存，也贴一下当时的iostat的结果；</p>
<p>可以发个微博附图，然后地址发到评论区哈</p>
<p>2019-02-01</p>
<p>风二中   0</p>
<p>老师，您好。如何设置binlog 的备份时间呢，感觉RPO 时间总是不能为零，如果是informix 可</p>
<p>以只丢一个逻辑日志。对于需要保证mysql恢复 RPO 时间为零，有什么建议吗？备库延迟1小</p>
<p>时，加每小时备份一次binlog 。2019-01-23</p>
<p> 作者回复</p>
<p>嗯 对于核心业务，使用延迟复制的备份</p>
<p>RPO时间为0？有这么凶残的业务需求吗。。我能想到的就是多套延迟备份的库。比如开3个， 一个是10分钟，一个20分钟，一个30分钟（主要考虑成本）</p>
<p>RPO这么敏感的，应该有对应敏感的监控，误操作要是30分钟还不能发现，可以挑战一下，这</p>
<p>个业务是不是值得这么高的指标^_^</p>
<p>2019-01-23</p>
<p>700   0</p>
<p>老师，请教。假如我有数据库的物理备份和逻辑备份（mydumper），因为 mydumper 导出的</p>
<p>数据是按表名分开存放的，那么表误删数据的时候优先考虑逻辑备份（误删数据表的备份集）</p>
<p>+binlog 恢复比物理备份恢复会快点？基于此，我总感觉物理备份只是在要恢复整个实例时才会</p>
<p>优先考虑，而恢复整个实例的场景又是比较少的，毕竟一般大家的线上架构至少都是主从模式</p>
<p>。所以逻辑备份被物理备份更实用。这种想法算是说得通吗？2019-01-23</p>
<p> 作者回复</p>
<p>其实是要看表的大小</p>
<p>如果是一个大表，逻辑恢复还是比较慢的，毕竟用物理备份来恢复出实例，相对会快些。当然如果你已经有了一个成熟系统用逻辑恢复来实现，也不用改它，主要关注一下是否满足SL</p>
<p>A就可以了^_^</p>
<p>facebook就是主要用逻辑备份的</p>
<p>2019-01-23</p>
<p>高强   0</p>
<p>老师你好，问个带子查询的delete&#x2F;update&#x2F;insert问题，Delete from A where name in( </p>
<p>Select name from B where time&lt;’2019-01-23 11:11:12’ </p>
<p>) 这条语句删除A表记录之前是不是也会把表 B满足条件的记录也会给锁住呢?</p>
<p>我试验了一下会锁住B表记录的，有没有其他办法不让锁B表呢?</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>改成RC隔离级别试试</p>
<p>2019-01-23</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-读写分离有哪些坑</title>
    <url>/posts/5d62a522.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>28 | 读写分离有哪些坑？2019-01-16 林晓斌</p>
<p>在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架</p>
<p>构的应用场景：读写分离，以及怎么处理主备延迟导致的读写分离问题。我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这</p>
<p>张图贴过来，方便你理解。图1 读写分离基本结构</p>
<p>读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这</p>
<p>种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据</p>
<p>库进行查询。还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由</p>
<p>proxy根据请求类型和上下文决定请求的分发路由。图2 带proxy的读写分离架构</p>
<p>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。1. 客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简</p>
<p>单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库</p>
<p>迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这</p>
<p>样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于</p>
<p>业务逻辑开发。2. 带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维</p>
<p>护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy</p>
<p>也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋</p>
<p>势是往带proxy的架构方向发展的。但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端</p>
<p>执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更</p>
<p>新之前的状态。这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期</p>
<p>读”。前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能</p>
<p>100%避免的。不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。接下来，我们就来讨论怎么处理过期读问题。这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好地理解和掌握全文的</p>
<p>知识脉络。这些方案包括：</p>
<p>强制走主库方案；</p>
<p>sleep方案；</p>
<p>判断主备无延迟方案；</p>
<p>配合semi-sync方案；</p>
<p>等主库位点方案；</p>
<p>等GTID方案。强制走主库方案</p>
<p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两</p>
<p>类：</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发</li>
</ol>
<p>布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结</p>
<p>果，就必须走主库。2. 对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，</p>
<p>就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些</p>
<p>金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展</p>
<p>性。因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并</p>
<p>分析各个方案的优缺点。Sleep 方案</p>
<p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的</p>
<p>数据。这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接</p>
<p>在发起查询时先执行一条sleep语句，用户体验很不友好啊。但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript + XML，异步JavaScript</p>
<p>和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查</p>
<p>询。这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商</p>
<p>品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个</p>
<p>方案存在的问题就是不精确。这个不精确包含了两层意思：</p>
<ol>
<li><p>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</p>
</li>
<li><p>如果延迟超过1秒，还是会出现过期读。看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景</p>
</li>
</ol>
<p>下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。判断主备无延迟方案</p>
<p>要确保备库无延迟，通常有三种做法。通过前面的第25篇文章，我们知道show slave status结果里的seconds_behind_master参数的</p>
<p>值，可以用来衡量主备延迟时间的长短。所以第一种确保主备无延迟的方法是，每次从库执行查询请求前，先判断</p>
<p>seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执</p>
<p>行查询请求。seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID</p>
<p>的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。如图3所示，是一个show slave status结果的部分截图。图3 show slave status结果</p>
<p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。第二种方法，对比位点确保主备无延迟：</p>
<p>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</p>
<p>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和</p>
<p>Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。第三种方法，对比GTID集合确保主备无延迟：</p>
<p>Auto_Position&#x3D;1 ，表示这对主备关系使用了GTID协议。Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</p>
<p>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。如果这两个集合相同，也表示备库接收到的日志都已经同步完成。可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了</p>
<p>不少，但还是没有达到“精确”的程度。为什么这么说呢？我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：</p>
<ol>
<li><p>主库执行完成，写入binlog，并反馈给客户端；</p>
</li>
<li><p>binlog被从主库发送给备库，备库收到；</p>
</li>
<li><p>在备库执行binlog完成。我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之</p>
</li>
</ol>
<p>间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日</p>
<p>志的状态。如图4所示就是这样的一个状态。图4 备库还没收到trx3</p>
<p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p>
<ol>
<li><p>trx1和trx2已经传到从库，并且已经执行完成了；</p>
</li>
<li><p>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但</p>
</li>
</ol>
<p>还是查不到trx3的。严格地说，就是出现了过期读。那么，这个问题有没有办法解决呢？配合semi-sync</p>
<p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。semi-sync做了这样的设计：</p>
<ol>
<li><p>事务提交的时候，主库把binlog发给从库；</p>
</li>
<li><p>从库收到binlog以后，发回给主库一个ack，表示收到了；</p>
</li>
<li><p>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经</p>
</li>
</ol>
<p>收到了这个日志。在第25篇文章的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会</p>
<p>不会导致系统数据丢失？答案是，如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问</p>
<p>题。这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过</p>
<p>期读。但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只</p>
<p>要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情</p>
<p>况：</p>
<ol>
<li><p>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</p>
</li>
<li><p>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位</p>
</li>
</ol>
<p>点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上</p>
<p>迟迟无法响应查询请求的情况。实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实</p>
<p>并不需要等到“主备完全同步”。为什么这么说呢？我们来看一下这个时序图。图5 主备持续延迟一个事务</p>
<p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和</p>
<p>binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语</p>
<p>句直到状态4都不能被执行。但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可</p>
<p>以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li><p>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</p>
</li>
<li><p>在持续延迟的情况下，可能出现过度等待的问题。接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。等主库位点方案</p>
</li>
</ol>
<p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<p>这条命令的逻辑如下：</p>
<ol>
<li><p>它是在从库执行的；</p>
</li>
<li><p>参数file和pos指的是主库上的文件名和位置；</p>
</li>
<li><p>timeout可选，设置为正整数N表示这个函数最多等待N秒。这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的</p>
</li>
</ol>
<p>binlog位置，执行了多少事务。当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：</p>
<ol>
<li><p>如果执行期间，备库同步线程发生异常，则返回NULL；</p>
</li>
<li><p>如果等待超过N秒，就返回-1；</p>
</li>
<li><p>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使</p>
</li>
</ol>
<p>用这个逻辑：</p>
<ol>
<li><p>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</p>
</li>
<li><p>选定一个从库执行查询语句；</p>
</li>
<li><p>在从库上执行select master_pos_wait(File, Position, 1)；</p>
</li>
<li><p>如果返回值是&gt;&#x3D;0的正整数，则在这个从库执行查询语句；</p>
</li>
<li><p>否则，到主库执行查询语句。我把上面这个流程画出来。select master_pos_wait(file, pos[, timeout]);</p>
</li>
</ol>
<p>图6 master_pos_wait方案</p>
<p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回</p>
<p>一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。步骤5到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无</p>
<p>限等待，所以如果等待超时，就应该放弃，然后到主库去查。你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这</p>
<p>样。但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库</p>
<p>查询。具体怎么选择，就需要业务开发同学做好限流策略了。GTID方案</p>
<p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。MySQL中同样提供了一个类似的命令：</p>
<p> select wait_for_executed_gtid_set(gtid_set, 1);</p>
<p>这条命令的逻辑是：</p>
<ol>
<li><p>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</p>
</li>
<li><p>超时返回1。在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而</p>
</li>
</ol>
<p>MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样</p>
<p>等GTID的方案就可以减少一次查询。这时，等GTID的执行流程就变成了：</p>
<ol>
<li><p>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</p>
</li>
<li><p>选定一个从库执行查询语句；</p>
</li>
<li><p>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</p>
</li>
<li><p>如果返回值是0，则在这个从库执行查询语句；</p>
</li>
<li><p>否则，到主库执行查询语句。跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。我把这个流程图画出来。图7 wait_for_executed_gtid_set方案</p>
</li>
</ol>
<p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能</p>
<p>够让MySQL在执行事务后，返回包中带上GTID呢？你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口</p>
<p>mysql_session_track_get_first从返回包解析出GTID的值即可。在专栏的第一篇文章中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口</p>
<p>应该怎么使用。这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的</p>
<p>API(<a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%8C%E4%B8%BA%E4%BA%86%E8%AE%A9%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84GITD%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%EF%BC%8C%E6%88%91%E5%AF%B9MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)。比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对MySQL客户端代</a></p>
<p>码做了点修改，如下所示：</p>
<p>图8 显示更新事务的GTID–代码</p>
<p>这样，就可以看到语句执行完成，显示出GITD的值。图9 显示更新事务的GTID–效果</p>
<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用</p>
<p>mysql_session_track_get_first这个函数。小结</p>
<p>在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应</p>
<p>对的方案。这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用</p>
<p>场景的，你需要根据业务需求选择。即使是最后等待位点和等待GTID这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的</p>
<p>情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增</p>
<p>大，把主库打挂了呢？其实，在实际应用中，这几个方案是可以混合使用的。比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期</p>
<p>读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就</p>
<p>可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中</p>
<p>取权衡。最后 ，我给你留下一个问题吧。假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的</p>
<p>一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？你可以把你的分析和方案设计写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期给你留的问题是，在GTID模式下，如果一个新的从库接上主库，但是需要的binlog已经没</p>
<p>了，要怎么做？@某、人同学给了很详细的分析，我把他的回答略做修改贴过来。1. 如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like</p>
<p>‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行</p>
<p>reset master，再执行set global gtid_purged &#x3D;‘gtid_purged1’；最后执行start slave，就会从</p>
<p>主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成</p>
<p>主从不一致。2. 如果需要主从数据一致的话，最好还是通过重新搭建从库来做。3. 如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog</p>
<p>的从库，追上日志以后，如果有需要，再接回主库。4. 如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。评论区留言点赞板：</p>
<p>@悟空 同学级联实验，验证了seconds_behind_master的计算逻辑。@_CountingStars 问了一个好问题：MySQL是怎么快速定位binlog里面的某一个GTID位置</p>
<p>的？答案是，在binlog文件头部的Previous_gtids可以解决这个问题。@王朋飞 同学问了一个好问题，sql_slave_skip_counter跳过的是一个event，由于MySQL总</p>
<p>不能执行一半的事务，所以既然跳过了一个event，就会跳到这个事务的末尾，因此set global</p>
<p>sql_slave_skip_counter&#x3D;1;start slave是可以跳过整个事务的。有铭   6</p>
<p>这专栏真的是干货满满，每看一篇我都有“我发现我真的不会使用MySQL”和“我原来把MySQL</p>
<p>用错了”的挫败感</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>这样我觉得你和我的时间都值了 </p>
<p>把你更新了认识的点发到评论区，这样会印象更深哈 </p>
<p>2019-01-16</p>
<p>某、人   3</p>
<p>老师我先请教两个问题(估计大多数同学都有这个疑惑) :</p>
<p>1.现在的中间件可以说是乱花渐欲迷人眼,请问老师哪一款中间件适合大多数不分库分表,只是做</p>
<p>读写分离业务的proxy,能推荐一款嘛?毕竟大多数公司都没有专门做中间件开发的团队</p>
<p>2.如果是业务上进行了分库分表,老师能推荐一款分库分表的proxy嘛？我目前了解到的针对分库</p>
<p>分表的proxy都或多或少有些问题。不过分布式数据库是一个趋势也是一个难点。2019-01-16</p>
<p> 作者回复</p>
<p>额，这个最难回答了</p>
<p>精选留言</p>
<p>说实话因为我原来团队是团队自己做的proxy（没有开源），所以我对其他proxy用得并不多，</p>
<p>实在不敢随便指一个。如果我说个比较熟悉的话，可能MariaDB MaxScale还不错</p>
<p>2019-01-17</p>
<p>曾剑   2</p>
<p>老师写的每一篇文章都能让我获益良多。每一篇都值得看好几遍。今天的问题，大表做DDL的时候可能会出现主从延迟，导致等 GTID 的方案可能会导致这部分</p>
<p>流量全打到主库，或者全部超时。如果这部分流量太大的话，我会选择上一篇文章介绍的两种方法：</p>
<p>1.在各个从库先SET sql_log_bin &#x3D; OFF，然后做DDL，所有从库及备主全做完之后，做主从切</p>
<p>换，最后在原来的主库用同样的方式做DDL。2.从库上执行DDL；将从库上执行DDL产生的GTID在主库上利用生成一个空事务GTID的方式将</p>
<p>这个GTID在主库上生成出来。各个从库做完之后再主从切换，然后再在原来的主库上同样做一次。需要注意的是如果有MM架构的情况下，承担写职责的主库上的slave需要先停掉。2019-01-16</p>
<p> 作者回复</p>
<p>  表示这两篇文章你都get到了</p>
<p>2019-01-16</p>
<p>二马   2</p>
<p>最近做性能测试时发现当并发用户达到一定量(比如500)，部分用户连接不上，能否介绍下MyS</p>
<p>QL连接相关问题，谢谢！</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>修改max_connections参数</p>
<p>2019-01-16</p>
<p>IceGeek17   1</p>
<p>老师，能不能分析下，如果去实现一个做读写分离的proxy，有哪些重要的点要考虑，比如：连</p>
<p>接管理、流量分配管理、proxy自己的高可用，等等。因为老师原来的团队自己开发过proxy，肯定有相关的经验，也趟过很多坑，能不能从如何实现</p>
<p>一个proxy需要考虑哪些关键点，在架构上做一个分析和梳理</p>
<p>2019-01-29</p>
<p> 作者回复</p>
<p>额，这个问题有点大… 你提一个具体问题我们来讨论吧</p>
<p>2019-01-31</p>
<p>猪哥哥   1</p>
<p>老师, 你真棒, 我公司的生产环境解决过期读使用的就是强制走主库方案, 看了这篇文章, 困惑了</p>
<p>很久的问题迎刃而解！很感谢!</p>
<p>2019-01-17</p>
<p>易翔   1</p>
<p>为老师一句你的时间和我的时间都值了。点赞</p>
<p>2019-01-16</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>关于主库大表的DDL操作，我看了问题答案，有两种方案。第一种是读写请求转到主库，在主</p>
<p>库上做DDL。第二种是从库上做DDL，完成后进行主从切换。关于第二种，有一个疑惑：</p>
<p>从库上做DDL，读写请求走主库，等到从库完成后，从库必须要同步DDL期间，主库完成的事</p>
<p>务后才能进行主从切换。而如果DDL操作是删除一列，那么在同步过程中会出错呀？（比如抛</p>
<p>出这一列不存在的错误）。2019-01-21</p>
<p> 作者回复</p>
<p>你说得对，这种方案下能支持的DDL只有以下几种：</p>
<p>创建&amp;#47;删除索引、新增最后一列、删除最后一列</p>
<p>其中DBA会认为“合理”的DDL需求就是： “创建&amp;#47;删除索引、新增最后一列”</p>
<p>新春快乐~</p>
<p>2019-02-04</p>
<p>black_mirror   0</p>
<p>林老师 您好</p>
<p>1.mysql_session_track_get_fitst这个函数，从github下载mysql源码后怎么尝试简单编译，如图</p>
<p>8？2. mysql_session_track_get_fitst这个函数貌似不支持python语言，我想模拟文中等gtid方法，</p>
<p>不会java怎么办？2019-01-21</p>
<p>black_mirror   0</p>
<p>林老师 您好</p>
<p>请问mysql_session_track_get_fitst这个函数查询了官方资料都需要可以修改源码</p>
<p>1.在不懂c++情况下，github上下载源码后怎么尝试简单编译使用，如图8代码</p>
<ol start="2">
<li>mysql_session_track_get_fitst函数貌似没有python语言api，不会java，想在代码层面模拟整</li>
</ol>
<p>个过程，还有木有解决方法？2019-01-21</p>
<p> 作者回复</p>
<p>不知道python是不是有方法可以把c代码作为扩展模块 </p>
<p>2019-01-21</p>
<p>辣椒   0</p>
<p>辣椒   0</p>
<p>老师，mysql_session_track_get_first是c的，有没有java的？2019-01-18</p>
<p> 作者回复</p>
<p>额，这个我还真不知道 ，抱歉哈。2019-01-18</p>
<p>信信   0</p>
<p>老师您好，文中判断主备无延迟方案的第二种和第三种方法，都是对比了主从执行完的日志是</p>
<p>否相同。因为不会出现图4下方说的：“从库认为已经没有同步延迟，但还是查不到 trx3 的。”因</p>
<p>为如果从库未执行trx3的话，第二，第三种方法都是不通过的。2019-01-18</p>
<p> 作者回复</p>
<p>不会哦</p>
<p>如果trx3还没传到备库，备库是会认为已经同步完成了</p>
<p>2019-01-18</p>
<p>Max   0</p>
<p>我一般是先是在从库上设置 set_log_bin&#x3D;off，然后执行ddl,语句。然后完成以后，主从做一下切换。然后在主库上在执行一下set_log_bin&#x3D;off,执行ddl语句。然后在做一下主从切换。个人对pt-online-scheman-change不是很推荐使用，它的原理基本是创建触发器，然后创建和</p>
<p>旧表一样结构的数据表，</p>
<p>把旧表的数据复制过去。最后删除旧表。以前做个一个测试，如果旧表一直在被select,删除过</p>
<p>程会一直会等待。所以个人不是很建议。万一不小心变成从删库到路步，那就得不偿失了。老师，有个问题想请教一下，一主多从可以多到什么地步，以前我们CTO解决的方案就是加机</p>
<p>器，一主十三从。当时我是反对的，其实个人建议还是从SQL，业务上面去优化。而不是一味的加机器。如果加</p>
<p>机器解决的话，还要DBA做什么呢？2019-01-17</p>
<p> 作者回复</p>
<p>前面的分析很好哈</p>
<p>然后一主13从有点多了，否则主库生成binlog太快的话，主库的网卡会被打爆。要这么多的话</p>
<p>，得做级联。DBA解决不能靠加机器解决的事情^_^ 而且如果通过优化，可以把13变成3，那也是DBA的价值</p>
<p>2019-01-17</p>
<p>coderfocus   0</p>
<p>一步一步 循序渐渐 讲的太棒了 感谢老师</p>
<p>2019-01-17</p>
<p>ThinkingQuest   0</p>
<p>楼上有人提到8小时自动断开连接的问题。 </p>
<p>mysql中有wait_timeout和interactive_timeout两个参数。 </p>
<p>这俩参数挺容易混淆的，往上博客文章说的很多，但是不敢相信他们。官方的解释在这里：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_interactive_time">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_interactive_time</a></p>
<p>out</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_wait_timeout">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_wait_timeout</a></p>
<p>只说用这两个参数中的哪个，取决于客户端调用mysql_real_connect()的时候传递的options中</p>
<p>是否使用了CLIENT_INTERACTIVE选项。但是很多做java开发的同学，想必并不知道JDBC的connector用的是哪一个。 </p>
<p>我倾向于认为是interactive_timeout。 mysql client cli大概是wait_timeout吧。其实做一个实验就可以知道结果。 但是不阅读mysql代码，大概不能理解mysql为什么设计这么</p>
<p>两个timeout，是出于什么考虑的。2019-01-17</p>
<p> 作者回复</p>
<p>JDBC的connector我也没研究过，不过我认为应该是非interactive模式。需要这两个的原因，还是因为有不同的使用模式，给MySQL客户端和一些其他的可视化工具客</p>
<p>户端使用。2019-01-17</p>
<p>不停   0</p>
<p>高手，你这现在在哪里上班了，有兴趣来我们公司耍耍么？2019-01-16</p>
<p>万勇   0</p>
<p>老师，请教下。1.对大表做ddl，是可以采用先在备库上set global log_bin&#x3D;off，先做完ddl，然后切换主备库。为了保证数据一致性，在切主备的时候，数据库会有个不可用的时间段，对业务会造成影响。现在的架构方式，中间层还有proxy，意味着proxy也需要修改主备配置，做reload。这样做的话</p>
<p>，感觉成本太高，在真正的生产环境中，这种方法适用吗？2.目前我们常采用的是对几百万以上的表用pt-online-schema-change，这种方式会产生大量的b</p>
<p>inlog，业务高峰期不能做，会引起主备延迟。在生产业务中，我觉得等主库节点或者等gtid这</p>
<p>种方案挺不错，至少能保证业务，但也会增加主库的压力。3.5.7版本出的group_replication多写模式性能不知道如何？架构变动太大，还不敢上。2019-01-16</p>
<p> 作者回复</p>
<ol>
<li>是这样的，我们说的是，如果非紧急情况下，还是尽量用gh-ost，在“紧急”的情况下，才这么</li>
</ol>
<p>做；确实是要绕过proxy的，也就是说，这事儿是要负责运维的同学做；</p>
<ol start="2">
<li>pt工具是有这个问题，试一下gh-ost哈；group_replication多写模式国内我还没有听到国内有</li>
</ol>
<p>公司在生产上大规模用的，如果你有使用经验，分享一下哈</p>
<p>2019-01-16</p>
<p>永恒记忆   0</p>
<p>老师好，有几个问题想请教下，</p>
<p>1.如果不想有过期读，用等GTID的方案，那么每次查询都要有等GTID的相关操作，增加的这部</p>
<p>分对性能有多少影响；</p>
<p>2.我们用的读写分离proxy不支持等GTID，那是不是自己要在客户端实现这部分逻辑，等于读写</p>
<p>分离的架构既用了proxy，又在客户端做了相关策略，感觉这方案更适合有能力自研proxy的公</p>
<p>司啊；</p>
<p>3.感觉目前大多数生产环境还是用的读主库这种方式避免过期读，如果只能用这种方案的话该</p>
<p>怎么扩展mysql架构来避免主库压力太大呢。我们是项目上线很久然后加的读写分离，好多service层代码写的不好，可以读从库的sql被写到</p>
<p>了事务中，这样会被proxy转到主库上读，所以导致主库负担了好多读的sql，感觉读写分离不</p>
<p>仅对mysql这块要掌握，整体的代码结构上也要有所调整吧。2019-01-16</p>
<p> 作者回复</p>
<ol>
<li><p>这个等待时间其实就基本上是主备延迟的时间</p>
</li>
<li><p>用了proxy这事情就得proxy做了，就不要客户端做了。没有gtid，可以用倒数第二种方法呀：</p>
</li>
</ol>
<p>）</p>
<ol start="3">
<li>是的，其实“走主库”这种做法还挺多的。我之前看到有的公司的做法，就是直接拆库了。等</li>
</ol>
<p>于一套“一主多从”拆成多套。2019-01-16</p>
<p>HuaMax   0</p>
<p>课后题。对大表做ddl是一个大事务，等待从库执行，基本就会超时，最后都返回到主库执行，</p>
<p>这样的话不如跳过等待从库这一步，但是像老师文中提到需要做好限流。从另一个角度，对于</p>
<p>主库的ddl操作，从业务场景去考虑，一般随后到来的查询不会被这个ddl影响，而是对新的业务</p>
<p>变更有影响，这样的话，也可以跳过等待从库这一步，直接让从库执行即可。不知道理解是否</p>
<p>正确？2019-01-16</p>
<p> 作者回复</p>
<p>核心是要处理延迟问题，比如怎么操作可以不会产生延迟</p>
<p>2019-01-16</p>
<ul>
<li>晓 *   0</li>
</ul>
<p>老师好，如果用MGR或InnoDB cluster方案做读写分离的话可以替代文中提到的方案吗？这两</p>
<p>个方案建议在生产中大量使用吗？2019-01-16</p>
<p> 作者回复</p>
<p>MGR开始有国内公司在使用了</p>
<p>InnoDB cluster也可以的，但是一般就是平时一写多读，只在主备切换的时候，短暂允许多写</p>
<p>2019-01-16</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-都说InnoDB好那还要不要使用Memory引擎</title>
    <url>/posts/f45d456.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>38 | 都说InnoDB好，那还要不要使用Memory引擎？2019-02-08 林晓斌</p>
<p>我在上一篇文章末尾留给你的问题是：两个group by 语句都用了order by null，为什么使用内存</p>
<p>临时表得到的语句结果里，0这个值在最后一行；而使用磁盘临时表得到的结果里，0这个值在</p>
<p>第一行？今天我们就来看看，出现这个问题的原因吧。内存表的数据组织结构</p>
<p>为了便于分析，我来把这个问题简化一下，假设有以下的两张表t1 和 t2，其中表t1使用Memory</p>
<p>引擎， 表t2使用InnoDB引擎。然后，我分别执行select * from t1和select * from t2。create table t1(id int primary key, c int) engine&#x3D;Memory;</p>
<p>create table t2(id int primary key, c int) engine&#x3D;innodb;</p>
<p>insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</p>
<p>insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);</p>
<p>图1 两个查询结果-0的位置</p>
<p>可以看到，内存表t1的返回结果里面0在最后一行，而InnoDB表t2的返回结果里0在第一行。出现这个区别的原因，要从这两个引擎的主键索引的组织方式说起。表t2用的是InnoDB引擎，它的主键索引id的组织方式，你已经很熟悉了：InnoDB表的数据就放</p>
<p>在主键索引树上，主键索引是B+树。所以表t2的数据组织方式如下图所示：</p>
<p>图2 表t2的数据组织</p>
<p>主键索引上的值是有序存储的。在执行select *的时候，就会按照叶子节点从左到右扫描，所以</p>
<p>得到的结果里，0就出现在第一行。与InnoDB引擎不同，Memory引擎的数据和索引是分开的。我们来看一下表t1中的数据内容。图3 表t1 的数据组织</p>
<p>可以看到，内存表的数据部分以数组的方式单独存放，而主键id索引里，存的是每个数据的位</p>
<p>置。主键id是hash索引，可以看到索引上的key并不是有序的。在内存表t1中，当我执行select *的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0</p>
<p>就是最后一个被读到，并放入结果集的数据。可见，InnoDB和Memory引擎的数据组织方式是不同的：</p>
<p>InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为索</p>
<p>引组织表（Index Organizied Table）。而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之</p>
<p>为堆组织表（Heap Organizied Table）。从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li><p>InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</p>
</li>
<li><p>当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在</p>
</li>
</ol>
<p>固定的位置写入新值，而内存表找到空位就可以插入新值；</p>
<ol start="3">
<li><p>数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；</p>
</li>
<li><p>InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索</p>
</li>
</ol>
<p>引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。5. InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并</p>
<p>且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表</p>
<p>的每行数据长度相同。由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据</p>
<p>复用。比如，如果要在表t1中执行：</p>
<p>就会看到返回结果里，id&#x3D;10这一行出现在id&#x3D;4之后，也就是原来id&#x3D;5这行数据的位置。需要指出的是，表t1的这个主键索引是哈希索引，因此如果执行范围查询，比如</p>
<p>是用不上主键索引的，需要走全表扫描。你可以借此再回顾下第4篇文章的内容。那如果要让内</p>
<p>存表支持范围扫描，应该怎么办呢 ？hash索引和B-Tree索引</p>
<p>实际上，内存表也是支B-Tree索引的。在id列上创建一个B-Tree索引，SQL语句可以这么写：</p>
<p>这时，表t1的数据组织形式就变成了这样：</p>
<p>delete from t1 where id&#x3D;5;</p>
<p>insert into t1 values(10,10);</p>
<p>select * from t1;</p>
<p>select * from t1 where id&lt;5;</p>
<p>alter table t1 add index a_btree_index using btree (id);</p>
<p>图4 表t1的数据组织–增加B-Tree索引</p>
<p>新增的这个B-Tree索引你看着就眼熟了，这跟InnoDB的b+树索引组织形式类似。作为对比，你可以看一下这下面这两个语句的输出：</p>
<p>图5 使用B-Tree和hash索引查询返回结果对比</p>
<p>可以看到，执行select * from t1 where id&lt;5的时候，优化器会选择B-Tree索引，所以返回结果是</p>
<p>0到4。 使用force index强行使用主键id这个索引，id&#x3D;0这一行就在结果集的最末尾了。其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是Memory引擎支持</p>
<p>hash索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是</p>
<p>比磁盘快。但是，接下来我要跟你说明，为什么我不建议你在生产环境上使用内存表。这里的原因主要包括</p>
<p>两个方面：</p>
<ol>
<li><p>锁粒度问题；</p>
</li>
<li><p>数据持久化问题。内存表的锁</p>
</li>
</ol>
<p>我们先来说说内存表的锁粒度问题。内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读</p>
<p>写操作。需要注意的是，这里的表锁跟之前我们介绍过的MDL锁不同，但都是表级的锁。接下来，我通</p>
<p>过下面这个场景，跟你模拟一下内存表的表级锁。图6 内存表的表锁–复现步骤</p>
<p>在这个执行序列里，session A的update语句要执行50秒，在这个语句执行期间session B的查询</p>
<p>会进入锁等待状态。session C的show processlist 结果输出如下：</p>
<p>图7 内存表的表锁–结果</p>
<p>跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并</p>
<p>发事务的时候，性能也不会太好。数据持久性问题</p>
<p>接下来，我们再看看数据持久性的问题。数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表</p>
<p>都会被清空。你可能会说，如果数据库异常重启，内存表被清空也就清空了，不会有什么问题啊。但是，在高</p>
<p>可用架构下，内存表的这个特点简直可以当做bug来看待了。为什么这么说呢？我们先看看M-S架构下，使用内存表存在的问题。图8 M-S基本架构</p>
<p>我们来看一下下面这个时序：</p>
<ol>
<li><p>业务正常访问主库；</p>
</li>
<li><p>备库硬件升级，备库重启，内存表t1内容被清空；</p>
</li>
<li><p>备库重启后，客户端发送一条update语句，修改表t1的数据行，这时备库应用线程就会报</p>
</li>
</ol>
<p>错“找不到要更新的行”。这样就会导致主备同步停止。当然，如果这时候发生主备切换的话，客户端会看到，表t1的数</p>
<p>据“丢失”了。在图8中这种有proxy的架构里，大家默认主备切换的逻辑是由数据库系统自己维护的。这样对客</p>
<p>户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。你可能说这还好啊，毕竟主备发生切换，连接会断开，业务端能够感知到异常。但是，接下来内存表的这个特性就会让使用现象显得更“诡异”了。由于MySQL知道重启之后，内</p>
<p>存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL在实现上做了这样一</p>
<p>件事儿：在数据库重启之后，往binlog里面写入一行DELETE FROM t1。如果你使用是如图9所示的双M结构的话：</p>
<p>图9 双M结构</p>
<p>在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。基于上面的分析，你可以看到，内存表并不适合在生产环境上作为普通数据表使用。有同学会说，但是内存表执行速度快呀。这个问题，其实你可以这么分析：</p>
<ol>
<li>如果你的表更新量大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比</li>
</ol>
<p>内存表好；</p>
<ol start="2">
<li>能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读QPS很高并且数据量不大</li>
</ol>
<p>的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的。因此，使用</p>
<p>InnoDB表的读性能也不会差。所以，我建议你把普通内存表都用InnoDB表来代替。但是，有一个场景却是例外的。这个场景就是，我们在第35和36篇说到的用户临时表。在数据量可控，不会耗费过多内存的情</p>
<p>况下，你可以考虑使用内存表。内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p>
<ol>
<li><p>临时表不会被其他线程访问，没有并发性的问题；</p>
</li>
<li><p>临时表重启后也是需要删除的，清空数据这个问题不存在；</p>
</li>
<li><p>备库的临时表也不会影响主库的用户线程。现在，我们回过头再看一下第35篇join语句优化的例子，当时我建议的是创建一个InnoDB临时</p>
</li>
</ol>
<p>表，使用的语句序列是：</p>
<p>了解了内存表的特性，你就知道了， 其实这里使用内存临时表的效果更好，原因有三个：</p>
<ol>
<li><p>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</p>
</li>
<li><p>索引b使用hash索引，查找的速度比B-Tree索引快；</p>
</li>
<li><p>临时表数据只有2000行，占用的内存有限。因此，你可以对第35篇文章的语句序列做一个改写，将临时表t1改成内存临时表，并且在字段b</p>
</li>
</ol>
<p>上创建一个hash索引。create temporary table temp_t(id int primary key, a int, b int, index(b))engine&#x3D;innodb;</p>
<p>insert into temp_t select * from t2 where b&gt;&#x3D;1 and b&lt;&#x3D;2000;</p>
<p>select * from t1 join temp_t on (t1.b&#x3D;temp_t.b);</p>
<p>create temporary table temp_t(id int primary key, a int, b int, index (b))engine&#x3D;memory;</p>
<p>insert into temp_t select * from t2 where b&gt;&#x3D;1 and b&lt;&#x3D;2000;</p>
<p>select * from t1 join temp_t on (t1.b&#x3D;temp_t.b);</p>
<p>图10 使用内存临时表的执行效果</p>
<p>可以看到，不论是导入数据的时间，还是执行join的时间，使用内存临时表的速度都比使用</p>
<p>InnoDB临时表要更快一些。小结</p>
<p>今天这篇文章，我从“要不要使用内存表”这个问题展开，和你介绍了Memory引擎的几个特性。可以看到，由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个</p>
<p>备库是双M架构，还可能导致主库的内存表数据被删掉。因此，在生产上，我不建议你使用普通内存表。如果你是DBA，可以在建表的审核系统中增加这类规则，要求业务改用InnoDB表。我们在文中</p>
<p>也分析了，其实InnoDB表性能还不错，而且数据安全也有保障。而内存表由于不支持行锁，更</p>
<p>新语句会阻塞查询，性能也未必就如想象中那么好。基于内存表的特性，我们还分析了它的一个适用场景，就是内存临时表。内存表支持hash索</p>
<p>引，这个特性利用起来，对复杂查询的加速效果还是很不错的。最后，我给你留一个问题吧。假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内</p>
<p>存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止</p>
<p>呢？你可以把你的思考和分析写在评论区，我会在下一篇文章的末尾跟你讨论这个问题。感谢你的收</p>
<p>听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>今天文章的正文内容，已经回答了我们上期的问题，这里就不再赘述了。评论区留言点赞板：</p>
<p>Long   2</p>
<p>老师新年好 :-)</p>
<p>刚好遇到一个问题。 </p>
<p>本来准备更新到，一个查询是怎么运行的里面的，看到这篇更新文章，就写在这吧，希望老师</p>
<p>帮忙解答。关于这个系统memory引擎表：information_schema.tables</p>
<p>相关信息如下</p>
<p>（1）Verison: MySQL 5.6.26</p>
<p>（2）数据量table_schema &#x3D; abc的有接近4W的表，整个实例有接近10W的表。（默认innodb</p>
<p>引擎）</p>
<p>（3）mysql.user和mysql.db的数据量都是100-200的行数，MyISAM引擎。@老杨同志、@poppy、@长杰 这三位同学给出了正确答案，春节期间还持续保持跟进学习，</p>
<p>给你们点赞。精选留言</p>
<p>（4）默认事务隔离级别RC</p>
<p>在运行查询语句1的时候：select * from information_schema.tables where table_schema &#x3D; ‘abc</p>
<p>‘;</p>
<p>状态一直是check permission，opening tables，其他线程需要打开的表在opend tables里面被</p>
<p>刷掉的，会显示在opening tables，可能需要小几秒后基本恢复正常。但是如果在运行查询语句2：select count(1) from information_schema.tables where table_sche</p>
<p>ma &#x3D; ‘abc’; 这个时候语句2本身在profiling看长期处于check permission状态，其他线程就会出</p>
<p>现阻塞现象，大部分卡在了opening tables，小部分closing tables。我测试下了，当个表查询的</p>
<p>时候check permission大概也就是0.0005s左右的时间，4W个表理论良好状态应该是几十秒的</p>
<p>事情。但是语句1可能需要5-10分钟，语句2需要5分钟。3个问题，请老师抽空看下：</p>
<p>（1）information_schema.tables的组成方式，是我每次查询的时候从数据字典以及data目录下</p>
<p>的文件中实时去读的吗？（2）语句1和语句2在运行的时候的过程分别是怎样的，特别是语句2。（3）语句2为什么会出现大量阻塞其他事务，其他事务都卡在opening tables的状态。PS: 最后根据audit log分析来看，语句实际上是MySQL的一个客户端Toad发起的，当使用Toad</p>
<p>的object explorer的界面来查询表，或者设置connection的时候指定的的default schema是大域</p>
<p>的时候就会run这个语句：（table_schema改成了abc，其他都是原样）</p>
<p>SELECT COUNT(1) FROM information_schema.tables WHERE table_schema &#x3D; ‘abc’ AND ta</p>
<p>ble_type !&#x3D; ‘VIEW’;</p>
<p>再次感谢！</p>
<p>2019-02-08</p>
<p>放   1</p>
<p>老师新年快乐！过年都不忘给我们传授知识！</p>
<p>2019-02-08</p>
<p> 作者回复</p>
<p>新年快乐 </p>
<p>2019-02-08</p>
<p>于家鹏   1</p>
<p>新年好！</p>
<p>课后作业：在备库配置跳过该内存表的主从同步。有一个问题一直困扰着我：SSD以及云主机的广泛运用，像Innodb这种使用WAL技术似乎并不</p>
<p>能发挥最大性能（我的理解：基于SSD的WAL更多的只是起到队列一样削峰填谷的作用）。对</p>
<p>于一些数据量不是特别大，但读写频繁的应用（比如点赞、积分），有没有更好的引擎推荐。2019-02-08</p>
<p> 作者回复</p>
<p>即使是SSD，顺序写也比随机写快些的。 不过确实没有机械盘那么明显。2019-02-08</p>
<p>长杰   0</p>
<p>内存表一般数据量不大，并且更新不频繁，可以写一个定时任务，定期检测内存表的数据，如</p>
<p>果数据不空，就将它持久化到一个innodb同结构的表中，如果为空，就反向将数据写到内存表</p>
<p>中，这些操作可设置为不写入binlog。2019-02-09</p>
<p>往事随风，顺其自然   0</p>
<p>为什么memory 引擎中数据按照数组单独存储，0索引对应的数据怎么放到数组的最后</p>
<p>2019-02-09</p>
<p> 作者回复</p>
<p>这就是堆组织表的数据存放方式</p>
<p>2019-02-09</p>
<p>HuaMax   0</p>
<p>课后题。是不是可以加上创建表的操作，并且是innodb 类型的？2019-02-09</p>
<p>老杨同志   0</p>
<p>安装之前学的知识，把主库delete语句的gtid，设置到从库中，就可以跳过这条语句了吧。但是主备不一致是不是要也处理一下，将主库的内存表数据备份一下。然后delete数据，重新</p>
<p>插入。等备件执行者两个语句后，主备应该都有数据了</p>
<p>2019-02-08</p>
<p> 作者回复</p>
<p>题目里说的是 “备库重启”哈</p>
<p>2019-02-09</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/posts/28769.html</url>
    <content><![CDATA[<p>红黑树是特殊的二叉查找树</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 （这里叶子节点，是指为空的叶子节点！）</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注：确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        &#125;

    &#125;

    ...
&#125;

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        &#125;

    &#125;

    ...
&#125;

/* 
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                              px
 *     /                               /
 *    x                               y                
 *   /  \      --(左旋)-.           / \                #
 *  lx   y                          x  ry     
 *     /   \                       /  \
 *    ly   ry                     lx  ly  
 *
 *
 */
private void leftRotate(RBTNode&lt;T&gt; x) &#123;
    // 设置x的右孩子为y
    RBTNode&lt;T&gt; y = x.right;

    // 将 “y的左孩子” 设为 “x的右孩子”；
    // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
    x.right = y.left;
    if (y.left != null)
        y.left.parent = x;

    // 将 “x的父亲” 设为 “y的父亲”
    y.parent = x.parent;

    if (x.parent == null) &#123;
        this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
    &#125; else &#123;
        if (x.parent.left == x)
            x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        else
            x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
    &#125;
    
    // 将 “x” 设为 “y的左孩子”
    y.left = x;
    // 将 “x的父节点” 设为 “y”
    x.parent = y;
&#125;

/* 
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           /                                /
 *          y                                x                  
 *         /  \      --(右旋)-.            /  \                     #
 *        x   ry                           lx   y  
 *       / \                                   / \                   #
 *      lx  rx                                rx  ry
 * 
 */
private void rightRotate(RBTNode&lt;T&gt; y) &#123;
    // 设置x是当前节点的左孩子。
    RBTNode&lt;T&gt; x = y.left;

    // 将 “x的右孩子” 设为 “y的左孩子”；
    // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
    y.left = x.right;
    if (x.right != null)
        x.right.parent = y;

    // 将 “y的父亲” 设为 “x的父亲”
    x.parent = y.parent;

    if (y.parent == null) &#123;
        this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
    &#125; else &#123;
        if (y == y.parent.right)
            y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
        else
            y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
    &#125;

    // 将 “y” 设为 “x的右孩子”
    x.right = y;

    // 将 “y的父节点” 设为 “x”
    y.parent = x;
&#125;

/* 
 * 将结点插入到红黑树中
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的node
 */
private void insert(RBTNode&lt;T&gt; node) &#123;
    int cmp;
    RBTNode&lt;T&gt; y = null;
    RBTNode&lt;T&gt; x = this.mRoot;

    // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
    while (x != null) &#123;
        y = x;
        cmp = node.key.compareTo(x.key);
        if (cmp &lt; 0)
            x = x.left;
        else
            x = x.right;
    &#125;

    node.parent = y;
    if (y!=null) &#123;
        cmp = node.key.compareTo(y.key);
        if (cmp &lt; 0)
            y.left = node;
        else
            y.right = node;
    &#125; else &#123;
        this.mRoot = node;
    &#125;

    // 2. 设置节点的颜色为红色
    node.color = RED;

    // 3. 将它重新修正为一颗二叉查找树
    insertFixUp(node);
&#125;

/* 
 * 新建结点(key)，并将其插入到红黑树中
 *
 * 参数说明：
 *     key 插入结点的键值
 */
public void insert(T key) &#123;
    RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

    // 如果新建结点失败，则返回。
    if (node != null)
        insert(node);
&#125;


/*
 * 红黑树插入修正函数
 *
 * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 插入的结点        // 对应《算法导论》中的z
 */
private void insertFixUp(RBTNode&lt;T&gt; node) &#123;
    RBTNode&lt;T&gt; parent, gparent;

    // 若“父节点存在，并且父节点的颜色是红色”
    while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) &#123;
        gparent = parentOf(parent);

        //若“父节点”是“祖父节点的左孩子”
        if (parent == gparent.left) &#123;
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.right;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            &#125;

            // Case 2条件：叔叔是黑色，且当前节点是右孩子
            if (parent.right == node) &#123;
                RBTNode&lt;T&gt; tmp;
                leftRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            &#125;

            // Case 3条件：叔叔是黑色，且当前节点是左孩子。
            setBlack(parent);
            setRed(gparent);
            rightRotate(gparent);
        &#125; else &#123;    //若“z的父节点”是“z的祖父节点的右孩子”
            // Case 1条件：叔叔节点是红色
            RBTNode&lt;T&gt; uncle = gparent.left;
            if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;
                setBlack(uncle);
                setBlack(parent);
                setRed(gparent);
                node = gparent;
                continue;
            &#125;

            // Case 2条件：叔叔是黑色，且当前节点是左孩子
            if (parent.left == node) &#123;
                RBTNode&lt;T&gt; tmp;
                rightRotate(parent);
                tmp = parent;
                parent = node;
                node = tmp;
            &#125;

            // Case 3条件：叔叔是黑色，且当前节点是右孩子。
            setBlack(parent);
            setRed(gparent);
            leftRotate(gparent);
        &#125;
    &#125;

    // 将根节点设为黑色
    setBlack(this.mRoot);
&#125;


/* 
 * 删除结点(node)，并返回被删除的结点
 *
 * 参数说明：
 *     node 删除的结点
 */
private void remove(RBTNode&lt;T&gt; node) &#123;
    RBTNode&lt;T&gt; child, parent;
    boolean color;

    // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
    if ( (node.left!=null) &amp;&amp; (node.right!=null) ) &#123;
        // 被删节点的后继节点。(称为&quot;取代节点&quot;)
        // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
        RBTNode&lt;T&gt; replace = node;

        // 获取后继节点
        replace = replace.right;
        while (replace.left != null)
            replace = replace.left;

        // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
        if (parentOf(node)!=null) &#123;
            if (parentOf(node).left == node)
                parentOf(node).left = replace;
            else
                parentOf(node).right = replace;
        &#125; else &#123;
            // &quot;node节点&quot;是根节点，更新根节点。
            this.mRoot = replace;
        &#125;

        // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
        // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
        child = replace.right;
        parent = parentOf(replace);
        // 保存&quot;取代节点&quot;的颜色
        color = colorOf(replace);

        // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
        if (parent == node) &#123;
            parent = replace;
        &#125; else &#123;
            // child不为空
            if (child!=null)
                setParent(child, parent);
            parent.left = child;

            replace.right = node.right;
            setParent(node.right, replace);
        &#125;

        replace.parent = node.parent;
        replace.color = node.color;
        replace.left = node.left;
        node.left.parent = replace;

        if (color == BLACK)
            removeFixUp(child, parent);

        node = null;
        return ;
    &#125;

    if (node.left !=null) &#123;
        child = node.left;
    &#125; else &#123;
        child = node.right;
    &#125;

    parent = node.parent;
    // 保存&quot;取代节点&quot;的颜色
    color = node.color;

    if (child!=null)
        child.parent = parent;

    // &quot;node节点&quot;不是根节点
    if (parent!=null) &#123;
        if (parent.left == node)
            parent.left = child;
        else
            parent.right = child;
    &#125; else &#123;
        this.mRoot = child;
    &#125;

    if (color == BLACK)
        removeFixUp(child, parent);
    node = null;
&#125;

/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 红黑树的根结点
 *     z 删除的结点
 */
public void remove(T key) &#123;
    RBTNode&lt;T&gt; node; 

    if ((node = search(mRoot, key)) != null)
        remove(node);
&#125;



/*
 * 红黑树删除修正函数
 *
 * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
 * 目的是将它重新塑造成一颗红黑树。
 *
 * 参数说明：
 *     node 待修正的节点
 */
private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;
    RBTNode&lt;T&gt; other;

    while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) &#123;
        if (parent.left == node) &#123;
            other = parent.right;
            if (isRed(other)) &#123;
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                leftRotate(parent);
                other = parent.right;
            &#125;

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) &#123;
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            &#125; else &#123;

                if (other.right==null || isBlack(other.right)) &#123;
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.left);
                    setRed(other);
                    rightRotate(other);
                    other = parent.right;
                &#125;
                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.right);
                leftRotate(parent);
                node = this.mRoot;
                break;
            &#125;
        &#125; else &#123;

            other = parent.left;
            if (isRed(other)) &#123;
                // Case 1: x的兄弟w是红色的  
                setBlack(other);
                setRed(parent);
                rightRotate(parent);
                other = parent.left;
            &#125;

            if ((other.left==null || isBlack(other.left)) &amp;&amp;
                (other.right==null || isBlack(other.right))) &#123;
                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                setRed(other);
                node = parent;
                parent = parentOf(node);
            &#125; else &#123;

                if (other.left==null || isBlack(other.left)) &#123;
                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                    setBlack(other.right);
                    setRed(other);
                    leftRotate(other);
                    other = parent.left;
                &#125;

                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                setColor(other, colorOf(parent));
                setBlack(parent);
                setBlack(other.left);
                rightRotate(parent);
                node = this.mRoot;
                break;
            &#125;
        &#125;
    &#125;

    if (node!=null)
        setBlack(node);
&#125;
</code></pre>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>/**
 * Java 语言: 红黑树
 *
 * @author skywang
 * @date 2013/11/07
 */

public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;

    private RBTNode&lt;T&gt; mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode&lt;T&gt; left;    // 左孩子
        RBTNode&lt;T&gt; right;    // 右孩子
        RBTNode&lt;T&gt; parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        &#125;

        public T getKey() &#123;
            return key;
        &#125;

        public String toString() &#123;
            return &quot;&quot;+key+(this.color==RED?&quot;(R)&quot;:&quot;B&quot;);
        &#125;
    &#125;

    public RBTree() &#123;
        mRoot=null;
    &#125;

    private RBTNode&lt;T&gt; parentOf(RBTNode&lt;T&gt; node) &#123;
        return node!=null ? node.parent : null;
    &#125;
    private boolean colorOf(RBTNode&lt;T&gt; node) &#123;
        return node!=null ? node.color : BLACK;
    &#125;
    private boolean isRed(RBTNode&lt;T&gt; node) &#123;
        return ((node!=null)&amp;&amp;(node.color==RED)) ? true : false;
    &#125;
    private boolean isBlack(RBTNode&lt;T&gt; node) &#123;
        return !isRed(node);
    &#125;
    private void setBlack(RBTNode&lt;T&gt; node) &#123;
        if (node!=null)
            node.color = BLACK;
    &#125;
    private void setRed(RBTNode&lt;T&gt; node) &#123;
        if (node!=null)
            node.color = RED;
    &#125;
    private void setParent(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;
        if (node!=null)
            node.parent = parent;
    &#125;
    private void setColor(RBTNode&lt;T&gt; node, boolean color) &#123;
        if (node!=null)
            node.color = color;
    &#125;

    /*
     * 前序遍历&quot;红黑树&quot;
     */
    private void preOrder(RBTNode&lt;T&gt; tree) &#123;
        if(tree != null) &#123;
            System.out.print(tree.key+&quot; &quot;);
            preOrder(tree.left);
            preOrder(tree.right);
        &#125;
    &#125;

    public void preOrder() &#123;
        preOrder(mRoot);
    &#125;

    /*
     * 中序遍历&quot;红黑树&quot;
     */
    private void inOrder(RBTNode&lt;T&gt; tree) &#123;
        if(tree != null) &#123;
            inOrder(tree.left);
            System.out.print(tree.key+&quot; &quot;);
            inOrder(tree.right);
        &#125;
    &#125;

    public void inOrder() &#123;
        inOrder(mRoot);
    &#125;


    /*
     * 后序遍历&quot;红黑树&quot;
     */
    private void postOrder(RBTNode&lt;T&gt; tree) &#123;
        if(tree != null)
        &#123;
            postOrder(tree.left);
            postOrder(tree.right);
            System.out.print(tree.key+&quot; &quot;);
        &#125;
    &#125;

    public void postOrder() &#123;
        postOrder(mRoot);
    &#125;


    /*
     * (递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; search(RBTNode&lt;T&gt; x, T key) &#123;
        if (x==null)
            return x;

        int cmp = key.compareTo(x.key);
        if (cmp &lt; 0)
            return search(x.left, key);
        else if (cmp &gt; 0)
            return search(x.right, key);
        else
            return x;
    &#125;

    public RBTNode&lt;T&gt; search(T key) &#123;
        return search(mRoot, key);
    &#125;

    /*
     * (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点
     */
    private RBTNode&lt;T&gt; iterativeSearch(RBTNode&lt;T&gt; x, T key) &#123;
        while (x!=null) &#123;
            int cmp = key.compareTo(x.key);

            if (cmp &lt; 0) 
                x = x.left;
            else if (cmp &gt; 0) 
                x = x.right;
            else
                return x;
        &#125;

        return x;
    &#125;

    public RBTNode&lt;T&gt; iterativeSearch(T key) &#123;
        return iterativeSearch(mRoot, key);
    &#125;

    /* 
     * 查找最小结点：返回tree为根结点的红黑树的最小结点。
     */
    private RBTNode&lt;T&gt; minimum(RBTNode&lt;T&gt; tree) &#123;
        if (tree == null)
            return null;

        while(tree.left != null)
            tree = tree.left;
        return tree;
    &#125;

    public T minimum() &#123;
        RBTNode&lt;T&gt; p = minimum(mRoot);
        if (p != null)
            return p.key;

        return null;
    &#125;
     
    /* 
     * 查找最大结点：返回tree为根结点的红黑树的最大结点。
     */
    private RBTNode&lt;T&gt; maximum(RBTNode&lt;T&gt; tree) &#123;
        if (tree == null)
            return null;

        while(tree.right != null)
            tree = tree.right;
        return tree;
    &#125;

    public T maximum() &#123;
        RBTNode&lt;T&gt; p = maximum(mRoot);
        if (p != null)
            return p.key;

        return null;
    &#125;

    /* 
     * 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。
     */
    public RBTNode&lt;T&gt; successor(RBTNode&lt;T&gt; x) &#123;
        // 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。
        if (x.right != null)
            return minimum(x.right);

        // 如果x没有右孩子。则x有以下两种可能：
        // (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。
        // (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.right)) &#123;
            x = y;
            y = y.parent;
        &#125;

        return y;
    &#125;
     
    /* 
     * 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。
     */
    public RBTNode&lt;T&gt; predecessor(RBTNode&lt;T&gt; x) &#123;
        // 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。
        if (x.left != null)
            return maximum(x.left);

        // 如果x没有左孩子。则x有以下两种可能：
        // (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。
        // (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。
        RBTNode&lt;T&gt; y = x.parent;
        while ((y!=null) &amp;&amp; (x==y.left)) &#123;
            x = y;
            y = y.parent;
        &#125;

        return y;
    &#125;

    /* 
     * 对红黑树的节点(x)进行左旋转
     *
     * 左旋示意图(对节点x进行左旋)：
     *      px                              px
     *     /                               /
     *    x                               y                
     *   /  \      --(左旋)-.           / \                #
     *  lx   y                          x  ry     
     *     /   \                       /  \
     *    ly   ry                     lx  ly  
     *
     *
     */
    private void leftRotate(RBTNode&lt;T&gt; x) &#123;
        // 设置x的右孩子为y
        RBTNode&lt;T&gt; y = x.right;

        // 将 “y的左孩子” 设为 “x的右孩子”；
        // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”
        x.right = y.left;
        if (y.left != null)
            y.left.parent = x;

        // 将 “x的父亲” 设为 “y的父亲”
        y.parent = x.parent;

        if (x.parent == null) &#123;
            this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点
        &#125; else &#123;
            if (x.parent.left == x)
                x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
            else
                x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
        &#125;
        
        // 将 “x” 设为 “y的左孩子”
        y.left = x;
        // 将 “x的父节点” 设为 “y”
        x.parent = y;
    &#125;

    /* 
     * 对红黑树的节点(y)进行右旋转
     *
     * 右旋示意图(对节点y进行左旋)：
     *            py                               py
     *           /                                /
     *          y                                x                  
     *         /  \      --(右旋)-.            /  \                     #
     *        x   ry                           lx   y  
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     * 
     */
    private void rightRotate(RBTNode&lt;T&gt; y) &#123;
        // 设置x是当前节点的左孩子。
        RBTNode&lt;T&gt; x = y.left;

        // 将 “x的右孩子” 设为 “y的左孩子”；
        // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”
        y.left = x.right;
        if (x.right != null)
            x.right.parent = y;

        // 将 “y的父亲” 设为 “x的父亲”
        x.parent = y.parent;

        if (y.parent == null) &#123;
            this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点
        &#125; else &#123;
            if (y == y.parent.right)
                y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”
            else
                y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”
        &#125;

        // 将 “y” 设为 “x的右孩子”
        x.right = y;

        // 将 “y的父节点” 设为 “x”
        y.parent = x;
    &#125;

    /*
     * 红黑树插入修正函数
     *
     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的z
     */
    private void insertFixUp(RBTNode&lt;T&gt; node) &#123;
        RBTNode&lt;T&gt; parent, gparent;

        // 若“父节点存在，并且父节点的颜色是红色”
        while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) &#123;
            gparent = parentOf(parent);

            //若“父节点”是“祖父节点的左孩子”
            if (parent == gparent.left) &#123;
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.right;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                &#125;

                // Case 2条件：叔叔是黑色，且当前节点是右孩子
                if (parent.right == node) &#123;
                    RBTNode&lt;T&gt; tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                &#125;

                // Case 3条件：叔叔是黑色，且当前节点是左孩子。
                setBlack(parent);
                setRed(gparent);
                rightRotate(gparent);
            &#125; else &#123;    //若“z的父节点”是“z的祖父节点的右孩子”
                // Case 1条件：叔叔节点是红色
                RBTNode&lt;T&gt; uncle = gparent.left;
                if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;
                    setBlack(uncle);
                    setBlack(parent);
                    setRed(gparent);
                    node = gparent;
                    continue;
                &#125;

                // Case 2条件：叔叔是黑色，且当前节点是左孩子
                if (parent.left == node) &#123;
                    RBTNode&lt;T&gt; tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                &#125;

                // Case 3条件：叔叔是黑色，且当前节点是右孩子。
                setBlack(parent);
                setRed(gparent);
                leftRotate(gparent);
            &#125;
        &#125;

        // 将根节点设为黑色
        setBlack(this.mRoot);
    &#125;

    /* 
     * 将结点插入到红黑树中
     *
     * 参数说明：
     *     node 插入的结点        // 对应《算法导论》中的node
     */
    private void insert(RBTNode&lt;T&gt; node) &#123;
        int cmp;
        RBTNode&lt;T&gt; y = null;
        RBTNode&lt;T&gt; x = this.mRoot;

        // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。
        while (x != null) &#123;
            y = x;
            cmp = node.key.compareTo(x.key);
            if (cmp &lt; 0)
                x = x.left;
            else
                x = x.right;
        &#125;

        node.parent = y;
        if (y!=null) &#123;
            cmp = node.key.compareTo(y.key);
            if (cmp &lt; 0)
                y.left = node;
            else
                y.right = node;
        &#125; else &#123;
            this.mRoot = node;
        &#125;

        // 2. 设置节点的颜色为红色
        node.color = RED;

        // 3. 将它重新修正为一颗二叉查找树
        insertFixUp(node);
    &#125;

    /* 
     * 新建结点(key)，并将其插入到红黑树中
     *
     * 参数说明：
     *     key 插入结点的键值
     */
    public void insert(T key) &#123;
        RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);

        // 如果新建结点失败，则返回。
        if (node != null)
            insert(node);
    &#125;


    /*
     * 红黑树删除修正函数
     *
     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；
     * 目的是将它重新塑造成一颗红黑树。
     *
     * 参数说明：
     *     node 待修正的节点
     */
    private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;
        RBTNode&lt;T&gt; other;

        while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) &#123;
            if (parent.left == node) &#123;
                other = parent.right;
                if (isRed(other)) &#123;
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                &#125;

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) &#123;
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                &#125; else &#123;

                    if (other.right==null || isBlack(other.right)) &#123;
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.left);
                        setRed(other);
                        rightRotate(other);
                        other = parent.right;
                    &#125;
                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.right);
                    leftRotate(parent);
                    node = this.mRoot;
                    break;
                &#125;
            &#125; else &#123;

                other = parent.left;
                if (isRed(other)) &#123;
                    // Case 1: x的兄弟w是红色的  
                    setBlack(other);
                    setRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                &#125;

                if ((other.left==null || isBlack(other.left)) &amp;&amp;
                    (other.right==null || isBlack(other.right))) &#123;
                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  
                    setRed(other);
                    node = parent;
                    parent = parentOf(node);
                &#125; else &#123;

                    if (other.left==null || isBlack(other.left)) &#123;
                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  
                        setBlack(other.right);
                        setRed(other);
                        leftRotate(other);
                        other = parent.left;
                    &#125;

                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。
                    setColor(other, colorOf(parent));
                    setBlack(parent);
                    setBlack(other.left);
                    rightRotate(parent);
                    node = this.mRoot;
                    break;
                &#125;
            &#125;
        &#125;

        if (node!=null)
            setBlack(node);
    &#125;

    /* 
     * 删除结点(node)，并返回被删除的结点
     *
     * 参数说明：
     *     node 删除的结点
     */
    private void remove(RBTNode&lt;T&gt; node) &#123;
        RBTNode&lt;T&gt; child, parent;
        boolean color;

        // 被删除节点的&quot;左右孩子都不为空&quot;的情况。
        if ( (node.left!=null) &amp;&amp; (node.right!=null) ) &#123;
            // 被删节点的后继节点。(称为&quot;取代节点&quot;)
            // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。
            RBTNode&lt;T&gt; replace = node;

            // 获取后继节点
            replace = replace.right;
            while (replace.left != null)
                replace = replace.left;

            // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)
            if (parentOf(node)!=null) &#123;
                if (parentOf(node).left == node)
                    parentOf(node).left = replace;
                else
                    parentOf(node).right = replace;
            &#125; else &#123;
                // &quot;node节点&quot;是根节点，更新根节点。
                this.mRoot = replace;
            &#125;

            // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。
            // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。
            child = replace.right;
            parent = parentOf(replace);
            // 保存&quot;取代节点&quot;的颜色
            color = colorOf(replace);

            // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;
            if (parent == node) &#123;
                parent = replace;
            &#125; else &#123;
                // child不为空
                if (child!=null)
                    setParent(child, parent);
                parent.left = child;

                replace.right = node.right;
                setParent(node.right, replace);
            &#125;

            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;

            if (color == BLACK)
                removeFixUp(child, parent);

            node = null;
            return ;
        &#125;

        if (node.left !=null) &#123;
            child = node.left;
        &#125; else &#123;
            child = node.right;
        &#125;

        parent = node.parent;
        // 保存&quot;取代节点&quot;的颜色
        color = node.color;

        if (child!=null)
            child.parent = parent;

        // &quot;node节点&quot;不是根节点
        if (parent!=null) &#123;
            if (parent.left == node)
                parent.left = child;
            else
                parent.right = child;
        &#125; else &#123;
            this.mRoot = child;
        &#125;

        if (color == BLACK)
            removeFixUp(child, parent);
        node = null;
    &#125;

    /* 
     * 删除结点(z)，并返回被删除的结点
     *
     * 参数说明：
     *     tree 红黑树的根结点
     *     z 删除的结点
     */
    public void remove(T key) &#123;
        RBTNode&lt;T&gt; node; 

        if ((node = search(mRoot, key)) != null)
            remove(node);
    &#125;

    /*
     * 销毁红黑树
     */
    private void destroy(RBTNode&lt;T&gt; tree) &#123;
        if (tree==null)
            return ;

        if (tree.left != null)
            destroy(tree.left);
        if (tree.right != null)
            destroy(tree.right);

        tree=null;
    &#125;

    public void clear() &#123;
        destroy(mRoot);
        mRoot = null;
    &#125;

    /*
     * 打印&quot;红黑树&quot;
     *
     * key        -- 节点的键值 
     * direction  --  0，表示该节点是根节点;
     *               -1，表示该节点是它的父结点的左孩子;
     *                1，表示该节点是它的父结点的右孩子。
     */
    private void print(RBTNode&lt;T&gt; tree, T key, int direction) &#123;

        if(tree != null) &#123;

            if(direction==0)    // tree是根节点
                System.out.printf(&quot;%2d(B) is root\n&quot;, tree.key);
            else                // tree是分支节点
                System.out.printf(&quot;%2d(%s) is %2d&#39;s %6s child\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction==1?&quot;right&quot; : &quot;left&quot;);

            print(tree.left, tree.key, -1);
            print(tree.right,tree.key,  1);
        &#125;
    &#125;

    public void print() &#123;
        if (mRoot != null)
            print(mRoot, mRoot.key, 0);
    &#125;
&#125;

/**
 * Java 语言: 二叉查找树
 *
 * @author skywang
 * @date 2013/11/07
 */
public class RBTreeTest &#123;

    private static final int a[] = &#123;10, 40, 30, 60, 90, 70, 20, 50, 80&#125;;
    private static final boolean mDebugInsert = false;    // &quot;插入&quot;动作的检测开关(false，关闭；true，打开)
    private static final boolean mDebugDelete = false;    // &quot;删除&quot;动作的检测开关(false，关闭；true，打开)

    public static void main(String[] args) &#123;
        int i, ilen = a.length;
        RBTree&lt;Integer&gt; tree=new RBTree&lt;Integer&gt;();

        System.out.printf(&quot;== 原始数据: &quot;);
        for(i=0; i&lt;ilen; i++)
            System.out.printf(&quot;%d &quot;, a[i]);
        System.out.printf(&quot;\n&quot;);

        for(i=0; i&lt;ilen; i++) &#123;
            tree.insert(a[i]);
            // 设置mDebugInsert=true,测试&quot;添加函数&quot;
            if (mDebugInsert) &#123;
                System.out.printf(&quot;== 添加节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            &#125;
        &#125;

        System.out.printf(&quot;== 前序遍历: &quot;);
        tree.preOrder();

        System.out.printf(&quot;\n== 中序遍历: &quot;);
        tree.inOrder();

        System.out.printf(&quot;\n== 后序遍历: &quot;);
        tree.postOrder();
        System.out.printf(&quot;\n&quot;);

        System.out.printf(&quot;== 最小值: %s\n&quot;, tree.minimum());
        System.out.printf(&quot;== 最大值: %s\n&quot;, tree.maximum());
        System.out.printf(&quot;== 树的详细信息: \n&quot;);
        tree.print();
        System.out.printf(&quot;\n&quot;);

        // 设置mDebugDelete=true,测试&quot;删除函数&quot;
        if (mDebugDelete) &#123;
            for(i=0; i&lt;ilen; i++)
            &#123;
                tree.remove(a[i]);

                System.out.printf(&quot;== 删除节点: %d\n&quot;, a[i]);
                System.out.printf(&quot;== 树的详细信息: \n&quot;);
                tree.print();
                System.out.printf(&quot;\n&quot;);
            &#125;
        &#125;

        // 销毁二叉树
        tree.clear();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>data</category>
      </categories>
  </entry>
  <entry>
    <title>mysql-MySQL有哪些“饮鸩止渴”提高性能的方法</title>
    <url>/posts/84d0671b.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>22 | MySQL有哪些“饮鸩止渴”提高性能的方法？2019-01-02 林晓斌</p>
<p>不知道你在实际运维过程中有没有碰到这样的情景：业务高峰期，生产环境的MySQL压力太</p>
<p>大，没法正常响应，需要短期内、临时性地提升一些性能。我以前做业务护航的时候，就偶尔会碰上这种场景。用户的开发负责人说，不管你用什么方案，</p>
<p>让业务先跑起来再说。但，如果是无损方案的话，肯定不需要等到这个时候才上场。今天我们就来聊聊这些临时方案，</p>
<p>并着重说一说它们可能存在的风险。短连接风暴</p>
<p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。我在第1篇文章《基础架构：一条SQL查询语句是如何执行的？》中说过，MySQL建立连接的过</p>
<p>程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的</p>
<p>数据读写权限。在数据库压力比较小的时候，这些额外的成本并不明显。但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。max_connections参数，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统</p>
<p>就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来</p>
<p>说，从业务角度看就是数据库不可用。在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有</p>
<p>新建连接的话，就可能会超过max_connections的限制。碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险</p>
<p>的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更</p>
<p>多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑</p>
<p>上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。那么这种情况下，你还有没有别的建议呢？我这里还有两种方法，但要注意，这些方法都是有损</p>
<p>的。第一种方法：先处理掉那些占着连接但是不工作的线程。max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需</p>
<p>要保持的连接，我们可以通过kill connection主动踢掉。这个行为跟事先设置wait_timeout的效果</p>
<p>是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被</p>
<p>MySQL直接断开连接。但是需要注意，在show processlist的结果里，踢掉显示为sleep的线程，可能是有损的。我们来</p>
<p>看下面这个例子。图1 sleep线程的两种状态</p>
<p>在上面这个例子里，如果断开session A的连接，因为这时候session A还没有提交，所以MySQL</p>
<p>只能按照回滚事务来处理；而断开session B的连接，就没什么大影响。所以，如果按照优先级</p>
<p>来说，你应该优先断开像session B这样的事务外空闲的连接。但是，怎么判断哪些是事务外空闲的呢？session C在T时刻之后的30秒执行show processlist，</p>
<p>看到的结果是这样的。图2 sleep线程的两种状态，show processlist结果</p>
<p>图中id&#x3D;4和id&#x3D;5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查</p>
<p>information_schema库的innodb_trx表。图3 从information_schema.innodb_trx查询事务状态</p>
<p>这个结果里，trx_mysql_thread_id&#x3D;4，表示id&#x3D;4的线程还处在事务中。因此，如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断</p>
<p>开事务内空闲太久的连接。从服务端断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接</p>
<p>被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会</p>
<p>收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是</p>
<p>直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。你可能觉得这是一个冷笑话，但实际上我碰到过不下10次。所以，如果你是一个支持业务的DBA，不要假设所有的应用代码都会被正确地处理。即使只是</p>
<p>一个断开连接的操作，也要确保通知到业务开发团队。第二种方法：减少连接过程的消耗。有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打</p>
<p>挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables参数启动。这样，整个MySQL会</p>
<p>跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。但是，这种方法特别符合我们标题里说的“饮鸩止渴”，风险极高，是我特别不建议使用的方案。尤其你的库外网可访问的话，就更不能这么做了。在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参</p>
<p>数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL官方对skip-grant-tables这</p>
<p>个参数的安全问题也很重视。除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句</p>
<p>导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是</p>
<p>由QPS（每秒查询数）突增导致的。而关于更新语句导致的性能问题，我会在下一篇文章和你展</p>
<p>开说明。慢查询性能问题</p>
<p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li><p>索引没有设计好；</p>
</li>
<li><p>SQL语句没写好；</p>
</li>
<li><p>MySQL选错了索引。接下来，我们就具体分析一下这三种可能，以及对应的解决方案。导致慢查询的第一种可能是，索引没有设计好。这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL</p>
</li>
</ol>
<p>了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter</p>
<p>table 语句。比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的</p>
<p>大致流程是这样的：</p>
<ol>
<li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索</li>
</ol>
<p>引；</p>
<ol start="2">
<li><p>执行主备切换；</p>
</li>
<li><p>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上</p>
</li>
</ol>
<p>索引。这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳</p>
<p>妥。但是在需要紧急处理时，上面这个方案的效率是最高的。导致慢查询的第二种可能是，语句没写好。比如，我们犯了在第18篇文章《为什么这些SQL语句逻辑相同，性能却差异巨大？》中提到的</p>
<p>那些错误，导致语句没有使用上索引。这时，我们可以通过改写SQL语句来处理。MySQL 5.7提供了query_rewrite功能，可以把输入的</p>
<p>一种语句改写成另外一种模式。比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，你可以通过下面的方式，增加</p>
<p>一个语句改写规则。这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我</p>
<p>们说的“查询重写”。你可以用图4中的方法来确认改写规则是否生效。图4 查询重写效果</p>
<p>mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (“select * from t where id + 1 &#x3D; ?”, “select * from t where id &#x3D; ? - 1”, “db1”);</p>
<p>call query_rewrite.flush_rewrite_rules();</p>
<p>导致慢查询的第三种可能，就是碰上了我们在第10篇文章《MySQL为什么有时候会选错索</p>
<p>引？》中提到的情况，MySQL选错了索引。这时候，应急方案就是给这个语句加上force index。同样地，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。上面我和你讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索</p>
<p>引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程，</p>
<p>我们就可以预先发现问题。1. 上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，</p>
<p>确保每个语句都会被记录入慢查询日志；</p>
<ol start="2">
<li><p>在测试表里插入模拟线上的数据，做一遍回归测试；</p>
</li>
<li><p>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我</p>
</li>
</ol>
<p>们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果</p>
<p>还有不明白的，欢迎给我留言，我们一起讨论）。不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的</p>
<p>表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结</p>
<p>果。比如，你可以使用开源工具pt-query-digest(<a href="https://www.percona.com/doc/percona-">https://www.percona.com/doc/percona-</a></p>
<p>toolkit&#x2F;3.0&#x2F;pt-query-digest.html)。QPS突增问题</p>
<p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致</p>
<p>MySQL压力过大，影响服务。我之前碰到过一类情况，是由一个新功能的bug导致的。当然，最理想的情况是让业务把这个功</p>
<p>能下掉，服务自然就会恢复。而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。我这里再</p>
<p>和你展开说明一下。1. 一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个</p>
<p>加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就</p>
<p>可以从数据库端直接把白名单去掉。2. 如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开</p>
<p>现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。3. 如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这</p>
<p>时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返</p>
<p>回。当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p>
<ol>
<li><p>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</p>
</li>
<li><p>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结</p>
</li>
</ol>
<p>果返回的话，可能会导致后面的业务逻辑一起失败。所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低</p>
<p>的一个方案。同时你会发现，其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分</p>
<p>离。由此可见，更多的准备，往往意味着更稳定的系统。小结</p>
<p>今天这篇文章，我以业务高峰期的性能问题为背景，和你介绍了一些紧急处理的手段。这些处理手段中，既包括了粗暴地拒绝连接和断开连接，也有通过重写语句来绕过一些坑的方</p>
<p>法；既有临时的高危方案，也有未雨绸缪的、相对安全的预案。在实际开发中，我们也要尽量避免一些低效的方法，比如避免大量地使用短连接。同时，如果你</p>
<p>做业务开发的话，要知道，连接异常断开是常有的事，你的代码里要有正确地重连并重试的机</p>
<p>制。DBA虽然可以通过语句重写来暂时处理问题，但是这本身是一个风险高的操作，做好SQL审计</p>
<p>可以减少需要这类操作的机会。其实，你可以看得出来，在这篇文章中我提到的解决方法主要集中在server层。在下一篇文章</p>
<p>中，我会继续和你讨论一些跟InnoDB有关的处理方法。最后，又到了我们的思考题时间了。今天，我留给你的课后问题是，你是否碰到过，在业务高峰期需要临时救火的场景？你又是怎么</p>
<p>处理的呢？你可以把你的经历和经验写在留言区，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享</p>
<p>和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>前两期我给你留的问题是，下面这个图的执行序列中，为什么session B的insert语句会被堵住。我们用上一篇的加锁规则来分析一下，看看session A的select语句加了哪些锁：</p>
<ol>
<li>由于是order by c desc，第一个要定位的是索引c上“最右边的”c&#x3D;20的行，所以会加上间隙锁</li>
</ol>
<p>(20,25)和next-key lock (15,20]。2. 在索引c上向左遍历，要扫描到c&#x3D;10才停下来，所以next-key lock会加到(5,10]，这正是阻塞</p>
<p>session B的insert语句的原因。3. 在扫描过程中，c&#x3D;20、c&#x3D;15、c&#x3D;10这三行都存在值，由于是select *，所以会在主键id上加</p>
<p>三个行锁。因此，session A 的select语句锁的范围就是：</p>
<ol>
<li><p>索引c上 (5, 25)；</p>
</li>
<li><p>主键索引上id&#x3D;15、20两个行锁。这里，我再啰嗦下，你会发现我在文章中，每次加锁都会说明是加在“哪个索引上”的。因为，锁</p>
</li>
</ol>
<p>就是加在索引上的，这是InnoDB的一个基础设定，需要你在分析问题的时候要一直记得。评论区留言点赞板：</p>
<p>@HuaMax 给出了正确的解释。@Justin 同学提了个好问题，&lt;&#x3D;到底是间隙锁还是行锁？其实，这个问题，你要跟“执行过</p>
<p>程”配合起来分析。在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断</p>
<p>的规则；找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。@信信 提了一个不错的问题，要知道最终的加锁是根据实际执行情况来的。所以，如果一个</p>
<p>select * from … for update 语句，优化器决定使用全表扫描，那么就会把主键索引上next-key</p>
<p>lock全加上。最后，我要为元旦期间还坚持学习的同学们，点个赞 ^_^</p>
<p>某、人   4</p>
<p>最近才发生了个案列:</p>
<p>由于一个delete大事务导致磁盘空间满了,数据库hang住,连接不上,所以无法kill掉该大事务</p>
<p>当时的观察到的现象是:</p>
<p>binlog有一个文件已经达到50多G</p>
<p>lsof | grep delete 该tmp文件100多G</p>
<p>redo log还是只有4个组,每个文件1G</p>
<p>undo log大概有100来G</p>
<p>由于数据库连不上,只有把连接切到从库,kill掉主库的进程。过了几分钟,binlog文件才缩小为原来</p>
<p>的大小。把主库启起来,但是recovery非常慢。后面kill掉,又以innodb_force_recovery&#x3D;3恢复,rec</p>
<p>overy也是半天没反应。由于这个库也不是重要的库,就把新的主库的备份文件重做了之前的主</p>
<p>库,以从库启起来</p>
<p>@nero 同学的问题，提示我需要提醒大家注意，“有行”才会加行锁。如果查询条件没有命中</p>
<p>行，那就加next-key lock。当然，等值判断的时候，需要加上优化2（即：索引上的等值查</p>
<p>询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。）。@小李子、@发条橙子同学，都提了很好的问题，这期高质量评论很多，你也都可以去看看。精选留言</p>
<p>通过最近的学习+测试分析了下,为什么binlog达到了50多G。tmp文件100多G.</p>
<p>由于binlog_cache不够用,把binlog写进了tmp文件中,binlog文件50多G,说明事务已经执行完成,</p>
<p>是binlog在fsync阶段,把空间占满了。fsync并不是一个move而是相当于copy。要等binlog完全</p>
<p>落盘以后,才会删除之前的tmp文件。redo log由于是循环写,而且在事务执行过程中,就会把redo l</p>
<p>og分为mtx落地到磁盘上。所以没有一次性暴增,还是以1G的大小持续写.</p>
<p>我也是后续做测试,观察在事务进行中,redo log文件一直都有变化。binlog没有变化</p>
<p>binlog是在事务执行完以后,才一次性fsync到磁盘</p>
<p>但是为什么recovery&#x3D;3的情况下,还比较耗时。我估计是之前脏页较多,而redo log又全部被覆盖</p>
<p>掉,</p>
<p>需要先通过binlog来恢复redo log,然后再通过redo log来恢复数据页。请问老师有没有更好的办法来处理这种hang住的情况?</p>
<p>如果在操作系统层面kill掉执行的线程,就好了。昨天提到的问题3,我也没有测试出来Sending to client这个状态.是之前别人问到的,我也挺懵</p>
<p>2019-01-03</p>
<p> 作者回复</p>
<p>先说明下，binlog是没有“恢复redolog”的能力的哈。其它部分分析得很好  </p>
<p>Binlog 这么大，说明是大事务，崩溃恢复的时候要处理的redolog 很多，估计耗时间耗在这。这种磁盘空间满的情况，以前我的处理方法是把最老的binlog移动到别的盘（如果确定日志已</p>
<p>经备份到备份系统了就删掉），目的是腾出空间让这个事务执行完成。后面可以考虑这种方案，强制重启还是有点伤的，不过核心还是做好监控，不让出现磁盘100%</p>
<p>写满的情况</p>
<p>2019-01-03</p>
<p>Long   9</p>
<p>不是专业DBA，遇到过几次数据库问题，有的能解决，有的好像除了重启或者干等着没啥好办</p>
<p>法。MySQL5.6版本遇到的部分问题：</p>
<ol>
<li>几个线程处于killed状态一直kill不掉（1天），然后备份的时候MySQL backup flush all tables</li>
</ol>
<p>with read lock的时候被阻塞，后面的线程只能等待flush table, kill backup以后也没有办法kill那</p>
<p>几个killed状态的语句（processlist显示的killed状态的语句的就是show columns, show create t</p>
<p>able这样的），后面没办法，重启了server。（看到老师后面第25讲有关于kill的解释，非常期</p>
<p>待新知识）</p>
<ol start="2">
<li>一个非常大（大几百万行）的表truncate，结果后面所有的线程都阻塞了，类似于下面这个M</li>
</ol>
<p>ySQL bug的场景，结果就是等这个truncate结束。没有继续干预。<a href="https://bugs.mysql.com/bug.php?id=80060">https://bugs.mysql.com/bug.php?id=80060</a></p>
<ol start="3">
<li>某个新功能上线以后，一个记录操作人员操作页面操作时间KPI的功能，由于sql性能不好，</li>
</ol>
<p>在业务上线跑了3天后数据量增多到临界值，突然影响了整个系统性能。数据库发现是大量的s</p>
<p>ql执行状态是converting heap to MyISAM，sql写法类似 select (select * from table) where id(有</p>
<p>索引)&#x3D; xxxx order by yyyy</p>
<p>DBA以及他们团队要求重启。但是分析了几分钟后提供了几个意见给”DBA”，并解释重启解决</p>
<p>不了问题：首先这个问题重启是解决不了，因为每次这个sql查询全表，查询分配的临时表空间</p>
<p>不足了，需要把结果集转到磁盘上，重启了sql动作没变，参数没变所以重启解决不了问题。页面查询也没法屏蔽，页面查询也无法过滤条件，</p>
<p>（1）和研发确认后，表数据删除不影响功能，只影响客户的KPI报表，先备份表，然后删除，</p>
<p>后面等功能修复了再补回去。（2）调整max_heap_table_size，tmp_table_size，扩大几倍</p>
<p>（3）给这个sql的唯一的一个order by字段加个索引。同时催促研发提供hotfix。最终选择了最简单有效的（1）问题解决，研发迅速后面也发了hotfix</p>
<p>解决了。4. 某个消费高峰时间段，高频查询被触发，一天几十万次执行，由于存量数据越来越多，查询</p>
<p>性能越来越慢，主要是索引没有很好规划，导致CPU资源使用飙升，后面的sql执行越来越慢。最后尝试了给2个字段添加单独的索引，解决了50%的问题，看到执行计划，extra里面，索引</p>
<p>合并使用了intersect，性能还是慢，然后立马drop原先的2个单独索引，创建两个字段的联合索</p>
<p>引，问题解决了。5. 死锁回滚，导致的MySQL hang住了，当时刚入门，只能简单复现死锁，没有保留所有的日</p>
<p>志，现在想查也查不了了。。。感觉大部分都是慢sql和高频事务导致的。（当然后面的慢sql监控分析，项目上就很重视了。。）</p>
<p>今天看了这期专栏，发现5.7的这个功能，query_rewrite，受教了。等我们升到5.7以后，可以实</p>
<p>际操练下。上面的问题3，也可以用这个功能了（因为是新业务，新表，特殊sql，完全可以起</p>
<p>到hotfix的作用）。请老师帮忙看下上面几次故障是否有更好，更专业的解决方案。多谢</p>
<p>2019-01-02</p>
<p> 作者回复</p>
<ol>
<li>Kill 掉备份线程在当时是最好的办法了。不过我之前确实也没碰到过show create table 不能kil</li>
</ol>
<p>l的情况，我看下代码，如果能复现出来加入那篇文章中</p>
<ol start="2">
<li>嗯，80060这个问题是因为要truncate，所以要回收脏页导致慢，不过这个问题在5.5.23就优</li>
</ol>
<p>化掉了哦，看你使用的是5.6，可能是别的原因。truncate如果不是被锁，而是已经在执行了，</p>
<p>确实还是别做别的事情，等结束最好；</p>
<ol start="3">
<li>这个语句是因为子查询要用临时表，跟order by 无关的（你看到的阶段还没开始order by 操</li>
</ol>
<p>作）。这个语句的临时表都能多到把磁盘打满，增加tmp_table_size是没用的。就是说这三个方法里面2和3其实都无效。你们当时的选择很精准呀。而且前面提出“重启无效”的这个人值得团队内大力表扬（是不是就是你 ）</p>
<p>另外这个语句，看着像有机会优化的样子，核心方向是去掉临时表</p>
<p>4.可以只删掉其中一个独立索引，再加一个联合索引，就是变成(a,b)和(b)这两种索引，也就是</p>
<p>把(a)改成(a,b)，这样是加法，相对比较安全。删除索引是一个要很小心的操作，少删一个多一</p>
<p>份安全，之后再通过观察索引b的使用情况，确定没必要再删。interset确实一般都比较慢。5. 正常回滚很快的，是不是大事务回滚？这种还是得从消除大事务入手</p>
<p>2019-01-02</p>
<p>某、人   4</p>
<p>老师,我有几个问题:</p>
<p>1.如果把order by去掉或者order by c asc,往右扫描,为什么没有加[25,30)next-key lock?</p>
<p>2.执行session A,为什么slow log里的Rows_examined为2?按照答案来讲不应该是为3嘛</p>
<p>3.thread states里sending data包括sending data to the client,</p>
<p>另外还有一种state是Sending to client(5.7.8之前叫Writing to net)是writing a packet to the client.</p>
<p>请问针对发送数据给客户端,这两种状态有什么区别？2019-01-02</p>
<p> 作者回复</p>
<ol>
<li><p>Next-key lock是前开后闭区间呀，有扫描到25，所以(20,25]</p>
</li>
<li><p>Rows_examined 是server层统计的，这个不满足的值没返回给server</p>
</li>
<li><p>你show processlist 结果发我看下，代码中没搜到 </p>
</li>
</ol>
<p>2019-01-02</p>
<p>Tony Du   4</p>
<p>对于上期问题的解答，有一点不是特别理解，</p>
<p>因为order by desc，在索引c上向左遍历，对于（15， 25）这段区间没有问题，</p>
<p>然后，扫描到c&#x3D;10才停下来，理论上把（10，15]这个区间锁上就应该是完备的了呀。（5，10]</p>
<p>这段区间是否锁上对结果应该没有影响呀，为什么会需要（5，10] 这段的next-key lock ?</p>
<p>2019-01-02</p>
<p> 作者回复</p>
<p>就是这么实现的 </p>
<p>C&#x3D;10还是要锁的，如果不锁可能被删除</p>
<p>2019-01-02</p>
<p>Tony Du   2</p>
<p>对于上期问题的解答，有一点不是特别理解，</p>
<p>因为order by desc，在索引c上向左遍历，对于（15， 25）这段区间没有问题，</p>
<p>然后，扫描到c&#x3D;10才停下来，理论上把（10，15]这个区间锁上就应该是完备的了呀。（5，10]</p>
<p>这段区间是否锁上对结果应该没有影响呀，为什么会需要（5，10] 这段的next-key lock ?</p>
<p>2019-01-02</p>
<p>  作者回复</p>
<p>就是这么实现的 </p>
<p>C&#x3D;10还是要锁的，如果不锁可能被删除</p>
<p>我的回复：</p>
<p>所以，如果把sql改成</p>
<p>select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c asc lock in share mode;</p>
<p>那锁的范围就应该是索引c上（10，25）了吧。同样查询条件，不同的order顺序，锁的范围不一样，稍微感觉有一点奇怪…</p>
<p>2019-01-03</p>
<p> 作者回复</p>
<p>嗯，因为执行索引遍历的顺序不一样，其实锁范围不一样也算合理啦 </p>
<p>2019-01-03</p>
<p>Long   1</p>
<p>老师好，看到有的同学在讨论锁的释放问题。之前分析过一个锁表异常，很多用workbench或者类似客户端的同学可能会遇到，</p>
<p>复现方式：</p>
<p>Step 1：显示的打开一个事务，或者把autocommit&#x3D;0，或者mysql workbench中把自动提交的</p>
<p>置灰按钮打开以后</p>
<p>Step 2: 执行一个sql（比如，update或者delete之类的），然后sql还没有返回执行结果的中途点</p>
<p>击workbench 自带的那个stop的红色的按钮。这个时候很多人可能就不再做其他操作，大多会认为执行已经结束了。但是实际上，锁还在继</p>
<p>续锁着的并不会释放。系统日志记录：</p>
<p>（1）processlist的状态是sleep，info为null</p>
<p>（2）innodb_trx的状态是running，trx_query为null</p>
<p>（3）performance_schema.events_statements_current表中的，</p>
<p>sql_text，digest_text：是有正确的sql的。—这个5.6以后就有了，如果ps打开的话，应该是可</p>
<p>以看到的。message_text ：Query execution was interrupted</p>
<p>（4）inoodb_locks，lock_waits，以及show engine innodb status，只有出现锁等待的时候才</p>
<p>会记录，如果只有一个事务的记录行锁，或者表锁，是不会记录的。（不知道是否有参考控制</p>
<p>，还是默认的）</p>
<p>（5）关于行锁记录数的问题，从测试的结果看，inoodb_trx的locked rows，当我点停止的时候</p>
<p>，锁定行数保持不变了，当我继续点击执行的时候，锁定记录行数会在之前的记录上向上累加</p>
<p>，并不是从0开始。然后查了audit log以后发现，客户端（mysqlworkbench）送给server端的是KILL QUERY threa</p>
<p>d_id，而不是Kill thread_id，</p>
<p>所以MySQL只是终止了事务中的statement执行，但是并不会释放锁，因为目前的琐的获取和</p>
<p>释放都是基于事务结束的（提交或者回滚）。这里面关于kill query&#x2F; thread_id的区别解释</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/kill.html">https://dev.mysql.com/doc/refman/5.6/en/kill.html</a></p>
<p>解决方法：</p>
<p>自己解决：kill 对应的thread_id，或者关闭执行窗口（这个时候会送个quit给server端）。别人解决：有super权限的人kill thread_id。关于kill的那个文章，其实对所有DDL，DML的操作释放过程，还没有全部搞清楚，期待老师的</p>
<p>第25讲。2019-01-02</p>
<p> 作者回复</p>
<p>总结的非常好，而且现象很全面。核心的一个点是：kill query 只是终止当前执行语句，并不会让事务回滚  </p>
<p>2019-01-03</p>
<p>曾剑   1</p>
<p>老师，关于上期遗留问题的解答，我有一点疑惑：</p>
<p>解答中的1中，第一个要定位的是索引 c 上“最右边的”c&#x3D;20 的行，为啥只会加上间隙锁（20,25</p>
<p>）和next-key lock(15,20]呢，为啥不是两个next-key lock(15,20]和(20,25]呢？25上的行锁难道</p>
<p>是退化的？老师上一篇文章中说到加锁的基本原则中第一点是加锁的基本单位是next-key lock</p>
<p>，而退化都是基于索引上的等值查询才会发生呀？盼老师指点迷津。2019-01-02</p>
<p> 作者回复</p>
<p>就是优化2，找第一个值的时候是等值查询</p>
<p>2019-01-02</p>
<p>Invictus_CD     0</p>
<p>老师好，这个课后题c≥15加锁和上一课的例子4的c≥10解释的不太一样啊。例子4的直接在10上</p>
<p>面加的间隙锁啊，这个为啥要在5上面加呢？2019-02-08</p>
<p> 作者回复</p>
<p>上一篇的案例4，session A的select语句没有order by c desc</p>
<p>区别就是在 “order by c desc”上</p>
<p>看一下30篇哈</p>
<p>2019-02-09</p>
<p>刘昆   0</p>
<p>老师你好，上期问题里面我遇到一下问题：</p>
<p>insert into t values(6,5,6) &#x3D;&gt; block</p>
<p>insert into t values(4,5,6) &#x3D;&gt; no block</p>
<p>insert into t values(6,4,6) &#x3D;&gt; no block</p>
<p>insert into t values(7,5,6) &#x3D;&gt; block</p>
<p>insert into t values(7,4,6) &#x3D;&gt; no block</p>
<p>根据你的解答，c 上面的 next-key lock 在 (5, 10]，那么上面的情况应该都不会阻塞还对呀？Server version: 5.7.24-log MySQL Community Server (GPL)</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>是这样的，我们只是简写成(5,10],</p>
<p>这个是索引c上的next-key lock，</p>
<p>所以这个范围的左边界是 (c&#x3D;5,id&#x3D;5), 右边界是(c&#x3D;10,id&#x3D;10)</p>
<p>你举例里面，</p>
<p>insert into t values(6,5,6) 是（c&#x3D;5, id&#x3D;6);</p>
<p>insert into t values(7,5,6) 是（c&#x3D;5, id&#x3D;7);</p>
<p>这两个都落在上面的next-key lock的区间，所以是会被锁住的哦</p>
<p>好问题， 新年快乐</p>
<p>2019-02-03</p>
<p>Moby   0</p>
<p>谢谢谢谢谢谢老师的回答！“作者回复</p>
<p>这没问题呀</p>
<p>begin; select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode;</p>
<p>锁的范围是这样的：</p>
<p>索引c上，next-key lock: (5，10],(10,15],(15,20];</p>
<p>索引id上，行锁: id&#x3D;15和id&#x3D;20”</p>
<p>不过在文末（二十二：MySQL有哪些”饮鸩止渴“提高性能的方法）上写的是“</p>
<p>因此，session A 的 select 语句锁的范围就是：1.索引c上(5,25); 2. 主键索引上id&#x3D;10、15、20</p>
<p>三个行锁”（写错了吧？）</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>嗯嗯，你说的对，我这里弄错了，应该是“主键索引上id&#x3D;15、20两个行锁”</p>
<p>勘误啦 多谢</p>
<p>2019-01-23</p>
<p>Moby   0</p>
<p>丁奇老师好，不好意思，学渣看得比较慢。关于前两期的问题，我有一点没搞懂。就是你说的</p>
<p>：”session A 在 select 语句锁的范围是 1…. ; 2.在主键索引上id&#x3D;10、15、20三个行锁”，经我测</p>
<p>试(MySQL版本：5.7.17-log; 隔离级别：可重复读)：“session </p>
<p>A: begin; select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode;”、”sessi</p>
<p>on B: update t set c&#x3D;1010 where id&#x3D;10; Query ok”、”session C: update t set c&#x3D;1515 where id&#x3D;</p>
<p>15;block…“。即：为什么id&#x3D;10这一行可以更新数据？而id&#x3D;15、20这两行更新数据就被阻塞？2019-01-21</p>
<p> 作者回复</p>
<p>这没问题呀</p>
<p>begin; select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode;</p>
<p>锁的范围是这样的：</p>
<p>索引c上，next-key lock: (5，10],(10,15],(15,20];</p>
<p>索引id上，行锁: id&#x3D;15和id&#x3D;20</p>
<p>2019-01-21</p>
<p>unlock   0</p>
<p>老师，对于这句话“锁就是加在索引上的”，如果一个表没有主键、没有索引，还会加锁吗。如果会加，加到哪</p>
<p>2019-01-18</p>
<p> 作者回复</p>
<p>InnoDB可不存在“没有索引的表”哦</p>
<p>没有主键，系统会给创建一个的（隐藏的</p>
<p>2019-01-18</p>
<p>往事随风，顺其自然   0</p>
<p>为什么我的电脑上没有慢查询的日志文件，mysql5.7</p>
<p>ysql&gt; show VARIABLES like ‘%slow%’;</p>
<p>+—————————+————————–+</p>
<p>| Variable_name | Value |</p>
<p>+—————————+————————–+</p>
<p>| log_slow_admin_statements | OFF |</p>
<p>| log_slow_slave_statements | OFF |</p>
<p>| slow_launch_time | 2 |</p>
<p>| slow_query_log | ON |</p>
<p>| slow_query_log_file | DESKTOP-76FNKS3-slow.log |</p>
<p>+—————————+————————–+</p>
<p>DESKTOP-76FNKS3-slow.log 这个文件再本地磁盘找不到</p>
<p>2019-01-04</p>
<p> 作者回复</p>
<p>Show variables like “output”</p>
<p>2019-01-04</p>
<p>往事随风，顺其自然   0</p>
<p>mysql5.7为什么不存在下面的数据库和表 </p>
<p>mysql&gt; use query_rewrite;</p>
<p>ERROR 1049 (42000): Unknown database ‘query_rewrite’</p>
<p>mysql&gt;</p>
<p>2019-01-04</p>
<p> 作者回复</p>
<p>搜一下用法吧 </p>
<p>2019-01-04</p>
<p>堕落天使   0</p>
<p>老师，您好：</p>
<p>我引用一下 Ryoma 的留言，如下：</p>
<p>Ryoma</p>
<p>我之前的描述有点问题，其实想问的是：为什么加了 order by c desc，第一个定位c&#x3D;20 的行，</p>
<p>会加上间隙锁 (20,25) 和 next-key lock (15,20]？如果没有order by c desc，第一次命中c&#x3D;15时，只会加上next-key lock(10.15]；</p>
<p>而有了order by c desc，我的理解是第一次命中c&#x3D;20只需要加上next-key lock (15,20]</p>
<p>当然最后(20,25)还是加上了锁，老师的结论是对的，我也测试过了，但是我不知道如何解释。唯一能想到的解释是order by c desc 并不会改变优化2这个原则：即等值查询时，会向右遍历</p>
<p>且最后一个值不满足等值条件；同时order by c desc 带来一个类似于优化2的向左遍历原则。进而导致最后的锁范围是(5,25)；而没有order by c desc的范围是(10,25]。2019-01-03</p>
<p>  作者回复</p>
<p>因为执行c&#x3D;20的时候，由于要order by c desc, 就要先找到“最右边第一个c&#x3D;20的行”，</p>
<p>这个怎么找呢，只能向右找到25，才能知道它左边那个20是“最右的20”</p>
<p>我的问题是：</p>
<ol>
<li>按照老师您说的，先找c&#x3D;20，由于是order by c desc，所以要找最右边的20，即找到25。那</li>
</ol>
<p>如果c是唯一索引呢？是不是就不会找到25了（是否会加 (20,25) 的gap lock）？我把语句改造</p>
<p>了一下，“select * from t_20 where id &gt;&#x3D; 15 and id&lt;&#x3D;20 ORDER BY id desc lock in share mode</p>
<p>;”。发现当 session A 执行完这行语句不提交的时候，session B 执行 “insert into t_20 values(2</p>
<p>4,24,24);” 是阻塞的。也就是说也加了(20,25)的间隙锁。这又是为什么呢？2. 间隙锁本身不冲突，但和插入语句冲突。那么delete语句呢?</p>
<p>我做了个如下实验（以下语句按时间顺序排序）：</p>
<p>session A</p>
<p>begin;</p>
<p>select * from t_20 where c&#x3D;10 lock in share mode;</p>
<p>session B</p>
<p>delete from t_20 where c&#x3D;15;</p>
<p>insert into t_20 values(16,16,16); </p>
<p>(blocked)</p>
<p>session B 中第一条delete语句执行正常，第二条insert语句被阻塞。我的分析是：session A在索引c上的锁是：(5,10] (10,15)；当session B把(15,15,15)这条记录删</p>
<p>了之后，(10,15)的间隙就不存在了，所以此时session A在索引c上的锁变为：(5,10] (10,20)。这时再在session B中插入(16,16,16)就被阻塞了。这个分析正确吗？2019-01-04</p>
<p> 作者回复</p>
<p>对，我在第30篇会说到这个问题哈</p>
<p>2019-01-10</p>
<p>不二   0</p>
<p>老师，曾剑同学的问题</p>
<p>关于上期遗留问题的解答，我有一点疑惑：</p>
<p>解答中的1中，第一个要定位的是索引 c 上“最右边的”c&#x3D;20 的行，为啥只会加上间隙锁（20,25</p>
<p>）和next-key lock(15,20]呢，为啥不是两个next-key lock(15,20]和(20,25]呢？25上的行锁难道</p>
<p>是退化的？老师上一篇文章中说到加锁的基本原则中第一点是加锁的基本单位是next-key lock</p>
<p>，而退化都是基于索引上的等值查询才会发生呀？盼老师指点迷津。您给回答是定位到c&#x3D;20的时候，是等值查询，所以加的是(20,25)的间隙锁，25的行锁退化了，</p>
<p>那么在上一期中的案例五：唯一索引范围锁 bug，那id&lt;&#x3D;15,不也是先定位到id&#x3D;15，然后向右扫</p>
<p>描，那应该也是等值查询，那么应该加的是（15，20）间隙锁，那为啥你说的加的是（15，20]</p>
<p>,为啥这个id&#x3D;20的行锁也加上了呢，为啥同样是范围查询，一个行锁退化了，一个没有退化呢</p>
<p>，求老师指点迷津</p>
<p>2019-01-04</p>
<p> 作者回复</p>
<ol>
<li><p>第一次就是找c&#x3D;20,这个就是一次等值查找</p>
</li>
<li><p>案例5那个，等值查的是id&#x3D;10,然后向右遍历。这两个，一个是有order by desc,索引的扫描方</p>
</li>
</ol>
<p>向不一样，“找第一个”的值也是不一样的</p>
<p>2019-01-04</p>
<p>张永志   0</p>
<p>说一个锁全库(schema)的案例，数据库晚间定时任务执行CTAS操作，由于需要执行十几分钟</p>
<p>，导致严重会话阻塞，全库所有表上的增删改查全被阻塞。后改为先建表再插数解决。2019-01-04</p>
<p> 作者回复</p>
<p>嗯嗯。看来你也是趟过好多坑啦，</p>
<p>CTAS不是好用法 </p>
<p>2019-01-04</p>
<p>张永志   0</p>
<p>我是从Oracle转到MySQL来的，先接触的Oracle再看MySQL就经常喜欢拿两者对比，包括表数</p>
<p>据存储结构，二级索引的异同，redo，binlog，锁机制，以及默认隔离级别。研究锁后，根据自己的理解得出一个结论，MySQL默认隔离级别选为RR也是无奈之举！</p>
<p>因为当时binlog还是语句格式，为了保证binlog事务顺序正确就得有gap和next key锁。而对开发人员来说，他们未必清楚事务隔离级别，且大多数开发都是从Oracle转向MySQL的，</p>
<p>故果断将隔离级别全部调整为RC。2019-01-04</p>
<p> 作者回复</p>
<p>是的，以前有很多oracle专家，然后大家就觉得RC够用。不过他们不是“以为够用”，他们是真的分析过业务场景，分析业务的用法，确认够用。这种是</p>
<p>很好的实践</p>
<p>2019-01-04</p>
<p>张永志   0</p>
<p>分享一个主从切换时遇到的问题，主从切换前主库要改为只读，设置只读后，show master sta</p>
<p>tus发现binlog一直在变化，当时应用没断开。主库并不是其他库的从库，怎么搞的呢？检查业务用户权限发现拥有super权限，查看授权语句原来是grant all on <em>.</em> to user，这里要说</p>
<p>的是*.* 权限就太大了，而且这个也很容易被误解，需要特别注意。2019-01-04</p>
<p> 作者回复</p>
<p>对的，readonly对super无效；</p>
<p>一方面是尽量不要给业务super</p>
<p>一方面你做完readonly还会去确认binlog有没有变，这个意识很好哦</p>
<p>2019-01-04</p>
<p>张永志   0</p>
<p>小系统，昨天一直报CPU使用率高，报警阈值设定为CPU平均使用率0.8。登录看进程都在执行同一条SQL，活动会话有40个，主机逻辑CPU只有4个，这负载能不高吗</p>
<p>？检查SQL，表很小不到两万行，创建一个复合索引后，负载立刻就消失不见啦 </p>
<p>2019-01-04</p>
<p> 作者回复</p>
<p>   立竿见影</p>
<p>2019-01-04</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-“order by”是怎么工作的(1)</title>
    <url>/posts/5d094abf.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>16 | “order by”是怎么工作的？2018-12-19 林晓斌</p>
<p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们</p>
<p>前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回</p>
<p>前1000个人的姓名、年龄。假设这个表的部分定义是这样的：</p>
<p>这时，你的SQL语句可以这么写：</p>
<p>CREATE TABLE t̀  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;city  ̀varchar(16) NOT NULL,</p>
<p>  &#96;name  ̀varchar(16) NOT NULL,</p>
<p>  &#96;age  ̀int(11) NOT NULL,</p>
<p>  &#96;addr̀  varchar(128) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  KEY &#96;city  ̀(̀ city )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>select city,name,age from t where city&#x3D;’杭州’ order by name limit 1000  ;</p>
<p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么</p>
<p>执行的，以及有什么参数会影响执行的行为。全字段排序</p>
<p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索</p>
<p>引。在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。图1 使用explain命令查看语句的执行情况</p>
<p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于</p>
<p>排序，称为sort_buffer。为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。图2 city字段的索引示意图</p>
<p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li><p>初始化sort_buffer，确定放入name、city、age这三个字段；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name做快速排序；</p>
</li>
<li><p>按照排序结果取前1000行返回给客户端。我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还</p>
</li>
</ol>
<p>会用到这个排序。图3 全字段排序</p>
<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所</p>
<p>需的内存和参数sort_buffer_size。sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量</p>
<p>小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不</p>
<p>利用磁盘临时文件辅助排序。你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中</p>
<p>看到是否使用了临时文件。&#x2F;* 打开optimizer_trace，只对本线程有效 *&#x2F;</p>
<p>SET optimizer_trace&#x3D;’enabled&#x3D;on’; </p>
<p>&#x2F;* @a保存Innodb_rows_read的初始值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 执行语句 *&#x2F;</p>
<p>select city, name,age from t where city&#x3D;’杭州’ order by name limit 1000; </p>
<p>&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</p>
<p>SELECT * FROM ìnformation_schema .̀&#96;OPTIMIZER_TRACE \̀G</p>
<p>&#x2F;* @b保存Innodb_rows_read的当前值 *&#x2F;</p>
<p>select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name &#x3D; ‘Innodb_rows_read’;</p>
<p>&#x2F;* 计算Innodb_rows_read差值 *&#x2F;</p>
<p>select @b-@a;</p>
<p>图4 全排序的OPTIMIZER_TRACE部分结果</p>
<p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个</p>
<p>文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理</p>
<p>解，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把</p>
<p>这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序</p>
<p>可以直接在内存中完成。否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越</p>
<p>多，number_of_tmp_files的值就越大。接下来，我再和你解释一下图4中其他两个值的意思。我们的示例表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示</p>
<p>参与排序的行数是4000行。sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使</p>
<p>name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000</p>
<p>行。这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成</p>
<p>MyISAM。否则，select @b-@a的结果会显示为4001。这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而</p>
<p>internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数</p>
<p>据从临时表取出来的时候，会让Innodb_rows_read的值加1。rowid排序</p>
<p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件</p>
<p>中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面</p>
<p>要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能</p>
<p>会很差。所以如果单行很大，这个方法效率不够好。那么，如果MySQL认为排序的单行长度太大会怎么做呢？接下来，我来修改一个参数，让MySQL采用另外一种算法。max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意</p>
<p>思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我</p>
<p>们再来看看计算过程有什么改变。新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如</p>
<p>下所示的样子：</p>
<ol>
<li><p>初始化sort_buffer，确定放入两个字段，即name和id；</p>
</li>
<li><p>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</p>
</li>
<li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</p>
</li>
<li><p>从索引city取下一个记录的主键id；</p>
</li>
<li><p>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</p>
</li>
<li><p>对sort_buffer中的数据按照字段name进行排序；</p>
</li>
<li><p>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回</p>
</li>
</ol>
<p>给客户端。这个执行流程的示意图如下，我把它称为rowid排序。SET max_length_for_sort_data &#x3D; 16;</p>
<p>图5 rowid排序</p>
<p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中</p>
<p>依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存</p>
<p>存储结果，是直接返回给客户端的。根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？现在，我们就来看看结果有什么不同。首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-</p>
<p>@a这个语句的值变成5000了。因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因</p>
<p>此会多读1000行。图6 rowid排序的OPTIMIZER_TRACE部分输出</p>
<p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一</p>
<p>行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。全字段排序 VS rowid排序</p>
<p>我们来分析一下，从这两个执行流程里，还能得出什么结论。如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过</p>
<p>程中一次可以排序更多行，但是需要再回到原表去取数据。如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这</p>
<p>样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。这也就体现了MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的</p>
<p>order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句</p>
<p>的执行时间也会变得更短。其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看</p>
<p>到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无</p>
<p>序的。你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，</p>
<p>是不是就可以不用再排序了呢？确实是这样的。所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<p>作为与city索引的对比，我们来看看这个索引的示意图。图7 city和name联合索引示意图</p>
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外</p>
<p>确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是</p>
<p>有序的。这样整个查询过程的流程就变成了：</p>
<ol>
<li><p>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</p>
</li>
<li><p>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返</p>
</li>
</ol>
<p>回；</p>
<ol start="3">
<li>从索引(city,name)取下一个记录主键id；</li>
</ol>
<p>alter table t add index city_user(city, name);</p>
<ol start="4">
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图8 引入(city,name)联合索引后，查询语句的执行计划</li>
</ol>
<p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一</p>
<p>下。图9 引入(city,name)联合索引后，查询语句的执行计划</p>
<p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)</p>
<p>这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前</p>
<p>1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。既然说到这里了，我们再往前讨论，这个语句的执行流程有没有可能进一步简化呢？不知道</p>
<p>你还记不记得，我在第5篇文章《 深入浅出索引（下）》中，和你介绍的覆盖索引。这里我们可以再稍微复习一下。覆盖索引是指，索引上的信息足够满足查询请求，不需要再</p>
<p>回到主键索引上去取数据。按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也</p>
<p>就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age</li>
</ol>
<p>这三个字段的值，作为结果集的一部分直接返回；</p>
<ol start="2">
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接</li>
</ol>
<p>返回；</p>
<ol start="3">
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。图10 引入(city,name,age)联合索引后，查询语句的执行流程</li>
</ol>
<p>然后，我们再来看看explain的结果。alter table t add index city_user_age(city, name, age);</p>
<p>图11 引入(city,name,age)联合索引后，查询语句的执行计划</p>
<p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索</p>
<p>引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。小结</p>
<p>今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻</p>
<p>辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能</p>
<p>做到下笔如有神，不犯低级错误。最后，我给你留下一个思考题吧。假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市</p>
<p>中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p>
<p>那么，这个语句执行的时候会有排序过程吗，为什么？如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你</p>
<p>的实现方法又会是什么呢？你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的</p>
<p>收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会</p>
<p>真的去执行一次修改吗？还是看到值相同就直接返回呢？这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我</p>
<p>们可以用一个锁实验来确认。mysql&gt; select * from t where city in (‘杭州’,”苏州”) order by name limit 100;</p>
<p>假设，当前表t里的值是(1,2)。图12 锁验证方式</p>
<p>session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新，</p>
<p>直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。假设当前表里的值是(1,2)。图13 可见性验证方式</p>
<p>session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语</p>
<p>句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章《事务到底是隔</p>
<p>离的还是不隔离的？》中的相关内容）</p>
<p>所以，我们上期思考题的答案应该是选项3，即：InnoDB认真执行了“把这个值修改成(1,2)”这个</p>
<p>操作，该加锁的加锁，该更新的更新。然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不</p>
<p>就不用浪费InnoDB操作，多去更新一次了？其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的</p>
<p>(id&#x3D;1), 而要写的是(a&#x3D;3)，只从这两个信息是看不出来“不需要修改”的。作为验证，你可以看一下下面这个例子。图14 可见性验证方式–对照</p>
<p>补充说明：</p>
<p>上面我们的验证结果都是在binlog_format&#x3D;statement格式下进行的。@didiren 补充了一个case， 如果是binlog_format&#x3D;row 并且binlog_row_image&#x3D;FULL的时候，由</p>
<p>于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id&#x3D;1，</p>
<p>结果就是“返回 (1,2)”。同理，如果是binlog_row_image&#x3D;NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里，</p>
<p>结果还是“返回 (1,2)”。对应的代码如图15所示。这是MySQL 5.6版本引入的，在此之前我没有看过。所以，特此说明。图15 binlog_row_image&#x3D;FULL读字段逻辑</p>
<p>类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字</p>
<p>段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样</p>
<p>通过判断，就会发现不需要修改。这两个点我会在后面讲更新性能的文章中再展开。评论区留言点赞板：</p>
<p>某、人   20</p>
<p>回答下@发条橙子同学的问题:</p>
<p>问题一：</p>
<p>1)无条件查询如果只有order by create_time,即便create_time上有索引,也不会使用到。因为优化器认为走二级索引再去回表成本比全表扫描排序更高。所以选择走全表扫描,然后根据老师讲的两种方式选择一种来排序</p>
<p>2)无条件查询但是是order by create_time limit m.如果m值较小,是可以走索引的.</p>
<p>因为优化器认为根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比</p>
<p>@Gavin 、@melon、@阿建 等同学提到了锁验证法；</p>
<p>@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的：</p>
<p>第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下</p>
<p>的策略。你可以把binlog_format 改成statement再验证下。精选留言</p>
<p>全表扫描小,则选择走二级索引。即便没有二级索引,mysql针对order by limit也做了优化,采用堆排序。这部分老师明天会讲</p>
<p>问题二:</p>
<p>如果是group by a,a上不能使用索引的情况,是走rowid排序。如果是group by limit,不能使用索引的情况,是走堆排序</p>
<p>如果是只有group by a,a上有索引的情况,又根据选取值不同,索引的扫描方式又有不同</p>
<p>select * from t group by a –走的是索引全扫描,至于这里为什么选择走索引全扫描,还需要老师解</p>
<p>惑下</p>
<p>select a from t group by a –走的是索引松散扫描,也就说只需要扫描每组的第一行数据即可,不</p>
<p>用扫描每一行的值</p>
<p>问题三:</p>
<p>bigint和int加数字都不影响能存储的值。bigint(1)和bigint(19)都能存储2^64-1范围内的值,int是2^32-1。只是有些前端会根据括号里来截</p>
<p>取显示而已。建议不加varchar()就必须带,因为varchar()括号里的数字代表能存多少字符。假设</p>
<p>varchar(2),就只能存两个字符,不管是中文还是英文。目前来看varchar()这个值可以设得稍稍大</p>
<p>点,因为内存是按照实际的大小来分配内存空间的,不是按照值来预分配的。老师我有几个问题:</p>
<p>1.我还是想在确认之前问的问题。一个长连接,一条sql申请了sort_buffer_size等一系列的会话级</p>
<p>别的内存,sql成功执行完,该连接变为sleep状态。这些内存只是内容会被情况,但是占用的内存空</p>
<p>间不会释放?</p>
<p>2.假设要给a值加1,执行器先找引擎取a&#x3D;1的行,然后执行器给a+1,在调用接口写入a+1了数据。那么加锁不应该是在执行器第一次去取数据时，引擎层就加该加的锁？为什么要等到第二次调</p>
<p>用写入数据时,才加锁。第一次和第二次之间,难道不会被其他事务修改吗？如果没有锁保证</p>
<p>3.始终没太明白堆排序是采用的什么算法使得只需要对limit的数据进行排序就可以,而不是排序</p>
<p>所有的数据在取前m条。–不过这里期待明天的文章</p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>发条橙子同学的问题：</p>
<p>问题1:你回答得比我回复的答案还好！  </p>
<p>问题2:这个后面我们展开哈，要配图才能说得清 </p>
<p>问题3:回答得也很好，需要注意的是255这个边界。小于255都需要一个字节记录长度，超过25</p>
<p>5就需要两个字节</p>
<p>你的问题：#好问题_#</p>
<ol>
<li><p>排序相关的内存在排序后就free掉还给系统了</p>
</li>
<li><p>读的时候加了写锁的</p>
</li>
<li><p>堆排序要读所有行的，只读一次，我估计你已经理解对了 </p>
</li>
</ol>
<p>2018-12-20</p>
<p>didiren   6</p>
<p>刚才又测了一下，在binlog-row-image&#x3D;full的情况下，第二次update是不写redolog的，说明upd</p>
<p>ate并没有发生</p>
<p>这样我就理解了，当full时，mysql需要读到在更新时读到a值，所以会判断a值不变，不需要更</p>
<p>新，与你给出的update t set a&#x3D;3 where id&#x3D;1 and a&#x3D;3原理相同，但binlog-row-image会影响查询</p>
<p>结果还是会让人吃一惊</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>是的。这个我也盲点了。但是细想MySQL 选择这个策略又是合理的。我需要再更新一下专栏内容</p>
<p>2018-12-19</p>
<p>null   2</p>
<p>re: 问题3:回答得也很好，需要注意的是255这个边界。小于255都需要一个字节记录长度，超过</p>
<p>255就需要两个字节</p>
<p>11 月过数据库设计方案，总监现场抛了一个问题，就是关于 varchar 255 的。现在回看，木有</p>
<p>人回答到点上，都说是历史原因。下回再问，就可以分享这一点了。  (˵¯̴ ͒  ¯̴ ͒ ˵) ”哇哈哈～</p>
<p>2018-12-21</p>
<p> 作者回复</p>
<p>最怕的回答“历史原因”、“大家都这么做的所以…”、“别人要求的”  </p>
<p>2018-12-21</p>
<p>老杨同志   11</p>
<ol>
<li></li>
</ol>
<p>mysql&gt; select * from t where city in (‘杭州’,” 苏州 “) order by name limit 100;</p>
<p>需要排序</p>
<p>原因是索引顺序城市、名称 与 单独按name排序的顺序不一致。2）如果不想mysql排序</p>
<p>方案a</p>
<p>可以执行两条语句</p>
<p>select * from t where city &#x3D; ‘杭州’ limit 100;</p>
<p>select * from t where city &#x3D; ‘苏州’ limit 100;</p>
<p>然后把200条记录在java中排序。方案b</p>
<p>分别取前100，然后在数据端对200条数据进行排序。可以sort buffer就可以完成排序了。少了一次应用程序与数据库的网络交互</p>
<p>select * from (</p>
<p>select * from t where city &#x3D; ‘杭州’ limit 100</p>
<p>union all</p>
<p>select * from t where city &#x3D; ‘苏州’ limit 100</p>
<p>) as tt order by name limit 100</p>
<p>3）对分页的优化。没有特别好的办法。如果业务允许不提供排序功能，不提供查询最后一页，只能一页一页的翻</p>
<p>，基本上前几页的数据已经满足客户需求。为了意义不大的功能优化，可能会得不偿失。如果一定要优化可以 select id from t where city in (‘杭州’,” 苏州 “) order by name limit 10000,10</p>
<p>0</p>
<p>因为有city\name索引，上面的语句走覆盖索引就可以完成，不用回表。最后使用 select * from t where id in (); 取得结果</p>
<p>对于这个优化方法，我不好确定的是临界点，前几页直接查询就可以，最后几页使用这个优化</p>
<p>方法。但是中间的页码应该怎么选择不太清楚</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>从业务上砍掉功能，这个意识很好   </p>
<p>2018-12-19</p>
<p>波波   6</p>
<p>笔记:</p>
<p>1.MySQL会为每个线程分配一个内存（sort_buffer）用于排序该内存大小为sort_buffer_size</p>
<p>1&gt;如果排序的数据量小于sort_buffer_size，排序将会在内存中完成</p>
<p>2&gt;如果排序数据量很大，内存中无法存下这么多数据，则会使用磁盘临时文件来辅助排序，也</p>
<p>称外部排序</p>
<p>3&gt;在使用外部排序时，MySQL会分成好几份单独的临时文件用来存放排序后的数据，然后在将</p>
<p>这些文件合并成一个大文件</p>
<p>2.mysql会通过遍历索引将满足条件的数据读取到sort_buffer，并且按照排序字段进行快速排序</p>
<p>1&gt;如果查询的字段不包含在辅助索引中，需要按照辅助索引记录的主键返回聚集索引取出所需</p>
<p>字段</p>
<p>2&gt;该方式会造成随机IO，在MySQL5.6提供了MRR的机制，会将辅助索引匹配记录的主键取出</p>
<p>来在内存中进行排序，然后在回表</p>
<p>3&gt;按照情况建立联合索引来避免排序所带来的性能损耗，允许的情况下也可以建立覆盖索引来</p>
<p>避免回表</p>
<p>全字段排序</p>
<p>1.通过索引将所需的字段全部读取到sort_buffer中</p>
<p>2.按照排序字段进行排序</p>
<p>3.将结果集返回给客户端</p>
<p>缺点：</p>
<p>1.造成sort_buffer中存放不下很多数据，因为除了排序字段还存放其他字段，对sort_buffer的利</p>
<p>用效率不高</p>
<p>2.当所需排序数据量很大时，会有很多的临时文件，排序性能也会很差</p>
<p>优点：MySQL认为内存足够大时会优先选择全字段排序，因为这种方式比rowid 排序避免了一</p>
<p>次回表操作</p>
<p>rowid排序</p>
<p>1.通过控制排序的行数据的长度来让sort_buffer中尽可能多的存放数据，max_length_for_sort_</p>
<p>data</p>
<p>2.只将需要排序的字段和主键读取到sort_buffer中，并按照排序字段进行排序</p>
<p>3.按照排序后的顺序，取id进行回表取出想要获取的数据</p>
<p>4.将结果集返回给客户端</p>
<p>优点：更好的利用内存的sort_buffer进行排序操作，尽量减少对磁盘的访问</p>
<p>缺点：回表的操作是随机IO，会造成大量的随机读，不一定就比全字段排序减少对磁盘的访问</p>
<p>3.按照排序的结果返回客户所取行数</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>  </p>
<p>2018-12-21</p>
<p>峰   3</p>
<p>由于city有两个值，相当于匹配到了索引树的两段区域，虽然各自都是按name排序，但整体需</p>
<p>要做一次归并，当然只是limit100，所以够数就行。再然后如果需要不做排序，业务端就按city</p>
<p>不同的取值查询两次，每次都limit100，然后业务端做归并处理喽。再然后要做分页的话，好吧</p>
<p>，我的思路是先整出一张临时的结果表，create table as select rownumber,* from t where city&#x3D;</p>
<p>x order by name(写的不对哈，只是表达意思，rownumber为行数,并为主键)然后直接从这张表</p>
<p>中按rownumber进行分页查询就好。2018-12-19</p>
<p> 作者回复</p>
<p>分页这个再考虑考虑哈 </p>
<p>2018-12-19</p>
<p>赵海亮   2</p>
<p>老师你好，全字段排序那一节，我做了实验，我的排序缓存大小是1M， examined rows 是771</p>
<p>5892，查询的三个字段都有数据，那么如果这些数据都放到缓存应该需要（4+8+11）*771589</p>
<p>2等于160M，但是我看了都没有用到临时表，这是为什么？CREATE TABLE <code>phone_call_logs</code> (</p>
<p><code>id</code> int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT ‘主键ID’,</p>
<p><code>city_id</code> int(11) NOT NULL DEFAULT ‘11’,</p>
<p><code>call_sender</code> varchar(40) DEFAULT NULL COMMENT ‘电话主叫号码’,</p>
<p><code>phone_id</code> bigint(20) NOT NULL DEFAULT ‘0’ COMMENT ‘手机id’,</p>
<p>PRIMARY KEY (<code>id</code>),</p>
<p>KEY <code>idx_city</code> (<code>city_id</code>)</p>
<p>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;64551193;</p>
<p>—————-sort_buffer_size&#x3D;1M—————————-</p>
<p>root:(none)&gt; show variables like ‘sort_buffer_size’;</p>
<p>+——————+———+</p>
<p>| Variable_name | Value |</p>
<p>+——————+———+</p>
<p>| sort_buffer_size | 1048576 |</p>
<p>+——————+———+</p>
<p>1 row in set (0.00 sec)</p>
<p>—————查询sql———————</p>
<p>select city_id,phone_id,call_sender from phone_call_logs where city_id&#x3D;11 order by phone_id d</p>
<p>esc limit 1000;</p>
<p>———————–执行计划结果———————————————</p>
<p>“filesort_priority_queue_optimization”: {</p>
<p>“limit”: 1000,</p>
<p>“rows_estimate”: 146364461,</p>
<p>“row_size”: 146,</p>
<p>“memory_available”: 1048576,</p>
<p>“chosen”: true</p>
<p>},</p>
<p>“filesort_execution”: [</p>
<p>],</p>
<p>“filesort_summary”: {</p>
<p>“rows”: 1001,</p>
<p>“examined_rows”: 7715892,</p>
<p>“number_of_tmp_files”: 0,</p>
<p>“sort_buffer_size”: 154160,</p>
<p>“sort_mode”: “&lt;sort_key, additional_fields&gt;”</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>好问题，明天见  </p>
<p>（明天的一篇也是跟排序有关的哦）</p>
<p>2018-12-20</p>
<p>didiren   2</p>
<p>感谢！针对我之前提出的疑问，我又详细的做了实验，发现一个新的问题，我感觉是个bug，</p>
<p>希望解答</p>
<h1 id="SessionA"><a href="#SessionA" class="headerlink" title="SessionA"></a>SessionA</h1><p>mysql&gt; show variables like ‘%binlog_row_image%’;</p>
<p>| Variable_name | Value |</p>
<p>| binlog_row_image | FULL |</p>
<p>mysql&gt; create table t (id int not null primary key auto_increment,</p>
<p>-&gt; a int default null)</p>
<p>-&gt; engine&#x3D;innodb;</p>
<p>mysql&gt; insert into t values(1,2);</p>
<p>mysql&gt; set tx_isolation &#x3D; ‘repeatable-read’;</p>
<p>mysql&gt; begin;</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>此时在另一个SessionB执行update t set a&#x3D;3 where id &#x3D; 1;成功更新一条记录。通过show engin</p>
<p>e innodb status看，Log sequence number 2573458</p>
<p>然后在SessionA继续。。mysql&gt; update t set a&#x3D;3 where id &#x3D; 1;</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>Log sequence number 2573467</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>这里与你给出的答案里的实验结果不同</p>
<p>可以看到redolog是记录了第二次的update的，但是select却没有看到更新后的值，于是我又换</p>
<p>了一个平时测试用的实例，同样的步骤却得到了与你的答案相同的结果</p>
<p>然后我对比了2个实例的参数，发现当binlog-row-image&#x3D;minimal时第二次查询结果a&#x3D;3，当binl</p>
<p>og-row-image&#x3D;full时第二次查询结果a&#x3D;2，而且不论哪个参数，redolog都会因为SessionA的up</p>
<p>date增长，说明redolog都做了记录，update是发生了的，但是binlog-row-image参数会影响查</p>
<p>询结果，难以理解，我用的mysql版本是官方的5.7.13</p>
<p>下面是binlog-row-image &#x3D; minimal的实验结果</p>
<p>mysql&gt; set binlog_row_image&#x3D;MINIMAL;</p>
<p>mysql&gt; drop table t;</p>
<p>mysql&gt; create table t (id int not null primary key auto_increment,</p>
<p>-&gt; a int default null)</p>
<p>-&gt; engine&#x3D;innodb;</p>
<p>insert into t values(1,2);</p>
<p>mysql&gt; insert into t values(1,2);</p>
<p>mysql&gt; set tx_isolation &#x3D; ‘repeatable-read’;</p>
<p>mysql&gt; begin;</p>
<p>mysql&gt; select * from t where id &#x3D; 1;</p>
<p>| id | a |</p>
<p>| 1 | 2 |</p>
<p>此时在另一个SessionB执行update t set a&#x3D;3 where id &#x3D; 1;成功更新一条记录。mysql&gt; update t set a&#x3D;3 where id &#x3D; 1;</p>
<p>Rows matched: 1 Changed: 0 Warnings: 0</p>
<p>mysql&gt; select * from t where id &#x3D; 1; </p>
<p>| id | a |</p>
<p>| 1 | 3 |</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>！！！</p>
<p>你说的对</p>
<p>我验证的是statement格式。MySQL 看来选了不错吧路径。这个我之前真不知道 </p>
<p>多谢</p>
<p>2018-12-19</p>
<p>cyberbit   2</p>
<p>1.不会有排序，这种情况属于《高性能mysql》里提到的“in技法”，符合索引的最左原则，是2个</p>
<p>等值查询，可以用到右边的索引列。2.分页查询，可以用延迟关联来优化：</p>
<p>select * from t join </p>
<p>(select id from t where city in(‘杭州’,’苏州’) order by name limit 10000,100) t_id</p>
<p>on t.id&#x3D;t_id.id;</p>
<p>2018-12-19</p>
<p>尘封   2</p>
<p>请问，第7步中遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 ag</p>
<p>e 三个字段返回给客户端：这里会把id再进行排序吗？转随机io为顺序io？2018-12-19</p>
<p> 作者回复</p>
<p>要是排序就结果不符合order by 的语义逻辑了…</p>
<p>2018-12-19</p>
<p>进击的菜鸡   1</p>
<p>关于上期问题里的最后一个例子不太明白，还请老师指点一下。按说在更新操作的时候应该是</p>
<p>当前读，那么应该能读到id&#x3D;1 and a &#x3D; 3的记录并修改。那么为什么再select还会查到a &#x3D; 2。难</p>
<p>道是即便update但是where条件也是快照读？但是如果这样那么幻读的问题不就不会存在了吗</p>
<p>？（B insert了一条记录，此时A范围update后再select会把B insert的语句查出来）</p>
<p>2019-02-02</p>
<p> 作者回复</p>
<p>你是说图14这里对吧， </p>
<p>这里update语句自己是当前读，但是它没有更新数据；</p>
<p>所以之后的查询还是看不到(1,3)这个版本。好问题 </p>
<p>2019-02-02</p>
<p>发条橙子 。   1</p>
<p>老师 ， 接前面 create_time的回答 。 语句确实是 select * from t order by create_time desc ;</p>
<p>老师是指 优化器会根据 order by create_time 来选择使用 create_time 索引么 </p>
<p>我之前误以为优化器是根据 where 后面的字段条件来选择索引 ，所以上面那条语句没有where </p>
<p>的时候我就想当然地以为不会走索引 。 看来是自己跳进了一个大坑里面  </p>
<p>另 ： 我之前在本地建了张表加了20w数据 ，用explain 查了一次 ，发现走的是全表没有走索引</p>
<p>， 老师说会走索引。我想了一下， 可能是统计的数据有误的缘故，用 analyze table重新统计 </p>
<p>，再次查询果然走了索引 。 </p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>嗯 where和 order都会共同影响哦，今天这篇你要再看看最后加了联合索引以后，语句的执行逻</p>
<p>辑</p>
<p>Analyze table 立功啦 </p>
<p>2018-12-20</p>
<p>发条橙子 。   1</p>
<p>正好有个 order by 使用场景 ， 有个页面，需要按数据插入时间倒序来查看一张记录表的信息 </p>
<p>，因为除了分页的参数 ， 没有其他 where 的条件 ，所以除了主键外没有其他索引 。 </p>
<p>这时候 DBA 让我给 create_time 创建索引， 说是按照顺序排列 ，查询会增快 。这篇文章看完</p>
<p>后 ， 让我感觉实际上创建 create_time 索引是没用的 。 </p>
<p>因为查询本身并没有用到 create_time 索引 ，实际上查询的步骤是 ：</p>
<ol>
<li><p>初始化 sort_buffer 内存</p>
</li>
<li><p>因为没索引 ， 所以扫出全表的数据到 sort_buffer 中</p>
</li>
<li><p>如果内存够则直接内存按时间排序 </p>
</li>
<li><p>如果内存不够则按数据量分成不同文件分别按时间排序后整合</p>
</li>
<li><p>根据数量分页查询数量 回聚集索引中用 ID 查询数据</p>
</li>
<li><p>返回</p>
</li>
</ol>
<p>所以我分析create_time索引应该不需要创建。反而增加了维护成本</p>
<p>问题一 ：这种无条件查列表页除了全表扫还有其他建立索引的办法么</p>
<p>问题二 : 如果加入 group by ， 数据该如何走</p>
<p>问题三 ：老师之后的文章会有讲解 bigInt(20) 、 tinyint(2) 、varchar(32) 这种后面带数字与不带</p>
<p>数字有何区别的文章么 。 每次建字段都会考虑长度 ，但实际却不知道他有何作用 </p>
<p>2018-12-20</p>
<p> 作者回复</p>
<p>你说的这样场景，加上create_time索引的话，是可以加速的呀，</p>
<p>语句是这样吗？select * from t order by create_time desk limit 100? 如果是这样，创建索引有用</p>
<p>的。问题二后面会有文章会说哈</p>
<p>问题三 嗯，这个也会安排文章说到</p>
<p>2018-12-20</p>
<p>明亮   1</p>
<p>需要排序，可以将原来的索引中name字段放前面，city字段放后面，来建索引就可以了</p>
<p>2018-12-19</p>
<p> 作者回复</p>
<p>这样不太好哈，变成全索引扫描了</p>
<p>2018-12-19</p>
<p>进击的菜鸡   0</p>
<p>图14那个疑问明白了，是因为where条件中存在update的值InnoDB认为值一致所以没有修改，</p>
<p>从而导致A的一致性视图中看不到B的修改。这篇又看了一遍，还有个疑问，想请老师解答一下。1.asc和desc会影响使用索引排序吗？2.如果采用rowid也无法放入排序字段还是会转用磁盘排序吧。2019-02-06</p>
<p> 作者回复</p>
<p>新年快乐</p>
<ol>
<li><p>不影响</p>
</li>
<li><p>再小也用rowid ，对，会转成磁盘排序</p>
</li>
</ol>
<p>2019-02-06</p>
<p>frogman   0</p>
<p>你好，不知道可否讲一下 Group By 怎样运用索引来优化呢？文档说只有 MIN 和 MAX 的情况</p>
<p>下索引才能提高效率，但是我认为 COUNT 应该也行吧。如 select name count(*) from table w</p>
<p>here name&#x3D;$name group by address; 如果建立 id 和 name 的联合索引，效率会提高吗。2019-02-03</p>
<p> 作者回复</p>
<p>你的理解对的。我们后面有一篇会讲到group by</p>
<p>2019-02-03</p>
<p>Crayon   0</p>
<p>老师，您好，我想问一下对于评论区中的无条件排序问题，知道了走索引和不走索引的两种情</p>
<p>况。在我的测试中，无条件多字段排序，即使加了LIMIT，也会走全表扫描，这是为什么呢。排序的</p>
<p>字段们都加了普通索引</p>
<p>2019-01-30</p>
<p> 作者回复</p>
<p>试下，是不是其实你不加limit反而会用索引</p>
<p>2019-01-30</p>
<p>过去、今日   0</p>
<p>老师，您好！大概是这样子的，app表的数据量是10w，api_form的数据量大概50w以后还是增</p>
<p>加，app表的索引为app_key,api_form索引为app_key、modified。但是从执行计划上看Extra的</p>
<p>值为Using where Using fileSort</p>
<p>select * from app t1,api_form t2 where t1.app_key&#x3D;t2.app_key and t2.status&#x3D;1 order by t2.modi</p>
<p>fied</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<p>api_form索引为app_key、modified </p>
<p>是联合索引吗，如果是可以force一下这个索引</p>
<p>你还是两个表（脱敏后）发一下表结构，还有这个语句explain的结果</p>
<p>2019-01-28</p>
<p>过去、今日   0</p>
<p>老师有个问题</p>
<p>select * from a t1,b t2 where t1.id &#x3D; t2.id order by t1.created </p>
<p>即时a表和b表都创建了索引，但是通过执行计划看都是using filesort</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<p>贴一下你这两个表的表结构，和explain的结果。这个语句要没有filesort的话，需要t1当驱动表，并且t1 有（id, created）联合索引</p>
<p>2019-01-27</p>
<p>Wesley   0</p>
<p>表T有id name city age 三列，对name，city两列做联合索引。执行explain select name，city from T where name like ‘%’ and city &#x3D;‘BJ’ order by name limit 10</p>
<p>；rows的值永远都和limit的值一样。虽然rows是预估的值，但是也不会每次和要limit的值一样</p>
<p>吧</p>
<p>2019-01-23</p>
<p> 作者回复</p>
<p>给一下你的复现步骤哈，不太可能“永远一样的”</p>
<p>2019-01-23</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-备库为什么会延迟好几个小时</title>
    <url>/posts/8e19404c.html</url>
    <content><![CDATA[<h1 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h1><p>26 | 备库为什么会延迟好几个小时？2019-01-11 林晓斌</p>
<p>在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是</p>
<p>偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都</p>
<p>能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级</p>
<p>别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。这就涉及到今天我要给你介绍的话题：备库并行复制能力。为了便于你理解，我们再一起看一下第24篇文章《MySQL是怎么保证主备一致的？》的主备流</p>
<p>程图。图1 主备流程图</p>
<p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主</p>
<p>库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表</p>
<p>并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都</p>
<p>在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性</p>
<p>能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的</p>
<p>话，就会导致备库应用日志不够快，造成主备延迟。在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重</p>
<p>的主备延迟问题。从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说</p>
<p>MySQL多线程复制的演进过程。其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线</p>
<p>程，也就是都符合下面的这个模型：</p>
<p>图2 多线程模型</p>
<p>图2中，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日</p>
<p>志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数</p>
<p>slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的</p>
<p>情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个</p>
<p>事务分给worker_1，第二个事务发给worker_2呢？其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU</p>
<p>的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的</p>
<p>是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不</p>
<p>一致的问题。接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker</p>
<p>来执行呢？答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分</p>
<p>到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个</p>
<p>查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。2. 同一个事务不能被拆开，必须放到同一个worker中。各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策</li>
</ol>
<p>略。MySQL 5.5版本的并行复制策略</p>
<p>官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了</p>
<p>严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解</p>
<p>MySQL官方版本并行复制策略的迭代。按表分发策略</p>
<p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在</p>
<p>表里的，所以按表分发，可以保证两个worker不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规</p>
<p>则。图3 按表并行复制程模型</p>
<p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事</p>
<p>务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这</p>
<p>个表。在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这</p>
<p>个表会被从hash表中去掉。图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，</p>
<p>有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数</p>
<p>据。假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表</p>
<p>t1和t3。现在我们用事务T的分配流程，来看一下分配规则。1. 由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事</p>
<p>务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。2. 按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲</p>
<p>突。3. 事务T跟多于一个worker冲突，coordinator线程就进入等待。4. 每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务</p>
<p>先执行完成，就会从hash_table_2中把db1.t3这一项去掉。5. 这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给</p>
<p>worker_1。6. coordinator继续读下一个中转日志，继续分配事务。也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p>
<ol>
<li><p>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</p>
</li>
<li><p>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关</p>
</li>
</ol>
<p>系的worker只剩下1个；</p>
<ol start="3">
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的</li>
</ol>
<p>worker。这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如</p>
<p>所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单</p>
<p>线程复制了。按行分发策略</p>
<p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果</p>
<p>两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须</p>
<p>是row。这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改</p>
<p>同一行”。按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按</p>
<p>行分发，这时候的key，就必须是“库名+表名+唯一键的值”。但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，</p>
<p>还有唯一索引a：</p>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<p>图4 唯一键冲突示例</p>
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能</p>
<p>session B的语句先执行。这时候id&#x3D;1的行的a的值还是1，就会报唯一键冲突。因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字</p>
<p>+a的值”。比如，在上面这个例子中，我要在表t1上执行update t1 set a&#x3D;1 where id&#x3D;2语句，在binlog里面</p>
<p>记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p>
<ol>
<li>key&#x3D;hash_func(db1+t1+“PRIMARY”+2), value&#x3D;2; 这里value&#x3D;2是因为修改前后的行id值不</li>
</ol>
<p>变，出现了两次。2. key&#x3D;hash_func(db1+t1+“a”+2), value&#x3D;1，表示会影响到这个表a&#x3D;2的行。3. key&#x3D;hash_func(db1+t1+“a”+1), value&#x3D;1，表示会影响到这个表a&#x3D;1的行。可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的</p>
<p>计算资源。你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必</li>
</ol>
<p>CREATE TABLE t̀1  ̀(</p>
<p>  ìd  ̀int(11) NOT NULL,</p>
<p>  &#96;a  ̀int(11) DEFAULT NULL,</p>
<p>  &#96;b  ̀int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (̀ id )̀,</p>
<p>  UNIQUE KEY &#96;a  ̀(̀ a )̀</p>
<p>) ENGINE&#x3D;InnoDB;</p>
<p>insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);</p>
<p>须是row；</p>
<ol start="2">
<li><p>表必须有主键；</p>
</li>
<li><p>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准</p>
</li>
</ol>
<p>确。但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所</p>
<p>以这两个并行复制策略在应用上也没有碰到什么麻烦。对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很</p>
<p>多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。2. 耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如</li>
</ol>
<p>果单个事务更新的行数超过10万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样</p>
<p>的：</p>
<ol>
<li><p>coordinator暂时先hold住这个事务；</p>
</li>
<li><p>等待所有worker都执行完成，变成空队列；</p>
</li>
<li><p>coordinator直接执行这个事务；</p>
</li>
<li><p>恢复并行模式。读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其</p>
</li>
</ol>
<p>实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。MySQL 5.6版本的并行复制策略</p>
<p>官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分</p>
<p>发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使</p>
<p>用这个策略的效果会很好。相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构</li>
</ol>
<p>造100万个项这种情况。2. 不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的</p>
<p>热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。MariaDB的并行复制策略</p>
<p>在第23篇文章中，我给你介绍了redo log组提交(group commit)优化， 而MariaDB的并行复制策</p>
<p>略利用的就是这个特性：</p>
<ol>
<li><p>能够在同一组里提交的事务，一定不会修改同一行；</p>
</li>
<li><p>主库上可以并行执行的事务，备库上也一定是可以并行执行的。在实现上，MariaDB是这么做的：</p>
</li>
<li><p>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</p>
</li>
<li><p>commit_id直接写到binlog里面；</p>
</li>
<li><p>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</p>
</li>
<li><p>这一组全部执行完成后，coordinator再去取下一批。当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到</p>
</li>
</ol>
<p>worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组</p>
<p>事务在commit的时候，下一组事务是同时处于“执行中”状态的。如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时</p>
<p>候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进</p>
<p>入commit状态。图5 主库并行事务</p>
<p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。图6 MariaDB 并行复制，备库并行效果</p>
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，</p>
<p>这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时</p>
<p>候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有</p>
<p>一个worker线程在工作，是对资源的浪费。不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很</p>
<p>优雅。MySQL 5.7的并行复制策略</p>
<p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-</p>
<p>parallel-type来控制并行复制策略：</p>
<ol>
<li><p>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</p>
</li>
<li><p>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策</p>
</li>
</ol>
<p>略，针对并行度做了优化。这个优化的思路也很有趣儿。你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？答案是，不能。因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同</p>
<p>的worker，就会出现备库跟主库不一致的情况。而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于</p>
<p>commit状态，表示已经通过了锁冲突的检验了。这时候，你可以再回顾一下两阶段提交，我把前面第23篇文章中介绍过的两阶段提交过程图贴</p>
<p>过来。图7 两阶段提交细化过程图</p>
<p>其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突</p>
<p>的检验了。因此，MySQL 5.7并行复制策略的思想是：</p>
<ol>
<li><p>同时处于prepare状态的事务，在备库执行时是可以并行的；</p>
</li>
<li><p>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p>
</li>
<li><p>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</p>
</li>
<li><p>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL</p>
</li>
</ol>
<p>5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了</p>
<p>备库复制的并行度。也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL</p>
<p>5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。MySQL 5.7.22的并行复制策略</p>
<p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于</p>
<p>WRITESET的并行复制。相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策</p>
<p>略。这个参数的可选值有以下三种。1. COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可</p>
<p>以并行的策略。2. WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合</p>
<p>writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并</p>
<p>行。3. WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程</p>
<p>先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了</p>
<p>有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增</p>
<p>加一个hash值。你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不</p>
<p>过，MySQL官方的这个实现还是有很大的优势：</p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析</li>
</ol>
<p>binlog内容（event里的行数据），节省了很多计算量；</p>
<ol start="2">
<li><p>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</p>
</li>
<li><p>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化</p>
</li>
</ol>
<p>为单线程模型。小结</p>
<p>在今天这篇文章中，我和你介绍了MySQL的各种多线程复制策略。为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大</p>
<p>的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值</p>
<p>越来越大。在介绍完每个并行复制策略后，我还和你分享了不同策略的优缺点：</p>
<p>如果你是DBA，就需要根据不同的业务场景，选择不同的策略；</p>
<p>如果是你业务开发人员，也希望你能从中获取灵感用到平时的开发工作中。从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。官方MySQL5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上</p>
<p>兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。最后，我给你留下一个思考题吧。假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主</p>
<p>库搭建一个相同版本的备库。这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-</p>
<p>tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择</p>
<p>哪一个呢？你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？你可以把你的答案和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也</p>
<p>欢迎你把这篇文章分享给更多的朋友一起阅读。上期问题时间</p>
<p>上期的问题是，什么情况下，备库的主备延迟会表现为一个45度的线段？评论区有不少同学的</p>
<p>回复都说到了重点：备库的同步在这段时间完全被堵住了。产生这种现象典型的场景主要包括两种：</p>
<p>一种是大事务（包括大表DDL、一个事务操作很多行）；</p>
<p>还有一种情况比较隐蔽，就是备库起了一个长事务，比如</p>
<p>然后就不动了。这时候主库对表t做了一个加字段操作，即使这个表很小，这个DDL在备库应用的时候也会被堵</p>
<p>住，也不能看到这个现象。评论区还有同学说是不是主库多线程、从库单线程，备库跟不上主库的更新节奏导致的？今天这</p>
<p>篇文章，我们刚好讲的是并行复制。所以，你知道了，这种情况会导致主备延迟，但不会表现为</p>
<p>这种标准的呈45度的直线。评论区留言点赞板：</p>
<p>begin; </p>
<p>select * from t limit 1;</p>
<p>@易翔 、 @万勇、@老杨同志 等同学的回复都提到了我们上面说的场景；</p>
<p>@Max 同学提了一个很不错的问题。主备关系里面，备库主动连接，之后的binlog发送是主库</p>
<p>主动推送的。之所以这么设计也是为了效率和实时性考虑，毕竟靠备库轮询，会有时间差。老杨同志   5</p>
<p>尝试回答 慧鑫coming 的问题。老师图片的步骤有下面5步</p>
<p>1 redo log prepare write</p>
<p>2 binlog write</p>
<p>3 redo log prepare fsync</p>
<p>4 binlog fsync</p>
<p>5 redo log commit write</p>
<p>1)如果更新通一条记录是有锁的，只能一个事务执行，其他事务等待锁。2)第4步的时候会因为下面两个参数，等其他没有锁冲突的事务，一起刷盘，此时一起执行的事</p>
<p>务拥有相同的commit_id</p>
<p>binlog_group_commit_sync_delay</p>
<p>binlog_group_commit_sync_no_delay_count</p>
<p>3)执行步骤5后，释放锁，等待锁的事务开始执行。所以对同一行更新的事务，不可能拥有相同的commit_id</p>
<p>2019-01-11</p>
<p> 作者回复</p>
<p>精选留言</p>
<p> ，你比我回复得详细，顶起</p>
<p>2019-01-11</p>
<p>长杰   2</p>
<p>举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker </p>
<p>的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会</p>
<p>看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。老师这块不太明白，备库有查询会看到更新了一半的结果，t1的worker执行完了更新会commit</p>
<p>吗？如果不commit，备库查询应该看不到吧？如果commit，就破坏了事物的原子性，肯定是</p>
<p>有问题的。2019-01-11</p>
<p> 作者回复</p>
<p>应该是说，它迟早要commit，但是两个worker是两个线程，没办法约好“同时提交”，这样就有</p>
<p>可能出现一个先提交一个后提交。这两个提交之间的时间差，就能被用户看到“一半事务”，好问题</p>
<p>2019-01-11</p>
<p>jike   1</p>
<p>老师您好，开启并行复制后，事务是按照组来提交的，从库也是根据commit_id来回放，如果</p>
<p>从库也开启binlog的话，那是不是存在主从的binlog event写入顺序不一致的情况呢？2019-01-15</p>
<p> 作者回复</p>
<p>是有可能binlog event写入顺序不同的，好问题</p>
<p>2019-01-15</p>
<p>HuaMax   7</p>
<p>课后题。关键点在于主库单线程，针对三种不同的策略，COMMIT_ORDER：没有同时到达re</p>
<p>do log的prepare 状态的事务，备库退化为单线程；WRITESET：通过对比更新的事务是否存在</p>
<p>冲突的行，可以并发执行；WRITE_SESSION：在WRITESET的基础上增加了线程的约束，则</p>
<p>退化为单线程。综上，应选择WRITESET策略</p>
<p>2019-01-12</p>
<p> 作者回复</p>
<p>准确 </p>
<p>2019-01-12</p>
<p>慧鑫coming   2</p>
<p>老师，有个问题，mariadb的并行策略，当同一组中有3个事务，它们都对同一行同一字段值进</p>
<p>行更改，而它们的commit_id相同，可以在从库并行执行，那么3者的先后顺序是怎么保证不影</p>
<p>响该行该字段的最终结果与主库一致？2019-01-11</p>
<p> 作者回复</p>
<p>好问题</p>
<p>不过这个是不可能的哈，对同一行的修改，第一个拿到行锁的事务还没提交前，另外两个会被</p>
<p>行锁堵住的，这两个进入不了commit状态。所以这三个的commit_id不会相同的 </p>
<p>2019-01-11</p>
<p>IceGeek17   1</p>
<p>好文，总结对比不同的并行策略，讲的深入浅出，看完豁然开朗。有看源代码的冲动。2019-01-24</p>
<p> 作者回复</p>
<p>看完分享你的心得哈  </p>
<p>2019-01-24</p>
<p>每天晒白牙   1</p>
<p>我是做java的，看老师的这个专栏，确实挺吃力的，老师专栏的干货太多了，下面的留言也是</p>
<p>相当有水平，质量都很高，互动也好，应该是好多DBA吧，做java的我，看的头大</p>
<p>2019-01-13</p>
<p> 作者回复</p>
<p>这几篇偏深，但确实是大家在使用的时候需要了解的，</p>
<p>到30篇后面的文章会偏应用哈</p>
<p>2019-01-13</p>
<p>某、人   1</p>
<p>总结下多线程复制的流程,有不对之处请老师指出:</p>
<p>双1,配置为logical_clock,假设有三个事务并发执行也已经执行完成(都处于prepare阶段)</p>
<p>1.三个事务把redo log从redo log buffer写到fs page cache中</p>
<p>2.把binlog_cache flush到binlog文件中,最先进入flush队列的为leader,</p>
<p>其它两个事务为follower.把组员编号以及组的编号写进binlog文件中(三个事务为同一组).</p>
<p>3.三个事务的redo log做fsync,binlog做fsync.</p>
<p>4.dump线程从binlog文件里把binlog event发送给从库</p>
<p>5.I&#x2F;O线程接收到binlog event,写到relay log中</p>
<p>6.sql thread读取relay log,判断出这三个事务是处于同一个组,</p>
<p>则把这三个事务的event打包发送给三个空闲的worker线程(如果有)并执行。配置为writeset的多线程复制流程:</p>
<p>1.三个事务把redo log从redo log buffer写到fs page cache中</p>
<p>2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset),</p>
<p>保存到hash表中</p>
<p>判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.</p>
<p>并把把组员编号以及组的编号写进binlog文件中</p>
<p>(不过一个组的事务个数也不是无限大,由参数binlog_transaction_dependency_history_size决定</p>
<p>组内最多事务数)</p>
<p>3.然后做redo log和binlog的fsync</p>
<p>4.dump线程从binlog文件里把binlog event发送给从库</p>
<p>5.I&#x2F;O线程接收到binlog event,写到relay log中</p>
<p>6.sql thread读取relay log,如果是同一个组的事务,则把事务分配到不同的worker线程去应用relay</p>
<p>log.</p>
<p>不同组的事务,需要等到上一个组的事务全部执行完成,才能分配worker线程应用relay log.</p>
<p>老师我有几个问题想请教下:</p>
<p>1.在备库是单线程下,second_behind_master是通过计算T3-T1得到,</p>
<p>在多线程的情况下,是怎么计算出second_behind_master的值？用的是哪一个事务的时间戳?</p>
<p>2.多线程复制下,如果从库宕机了,是不是从库有一个记录表记录那些事务已经应用完成,</p>
<p>恢复的时候,只需要恢复未应用的事务.</p>
<p>3.binlog延迟sync的两个参数,是延迟已经flush未sync时间。意思是让事务组占用flush时间更长,</p>
<p>之后的事务有更多的时间,从binlog cache进入到flush队列,使得组员变多,起到从库并发的目的</p>
<p>因为我理解的是加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flus</p>
<p>h,</p>
<p>未sync,则后面的事务必须等待。不知道理解得对不</p>
<p>2019-01-13</p>
<p> 作者回复</p>
<p>上面的描述部分，writeset的多线程复制流程里面，这段需要修改下：</p>
<p>『2.把binlog_cache flush到binlog文件中,根据表名、主键和唯一键(如果有)生成hash值(writeset</p>
<p>),保存到hash表中</p>
<p>【判断这三个事务的writeset是否有冲突,如果没有冲突,则视为同组,如果有冲突,则视为不同组.</p>
<p>并把把组员编号以及组的编号写进binlog文件中】』</p>
<p>上面中括号这段要去掉，</p>
<p>判断writeset之间是否可以并行这个逻辑，是在备库的coordinator线程做的。—-</p>
<ol>
<li><p>在多线程并发的时候，Seconds_behind_master很不准，后面会介绍别的判断方法；</p>
</li>
<li><p>是的,备库有记录，就是show slave status 里面的Relay_Log_File 和 Relay_Log_Pos 这两个</p>
</li>
</ol>
<p>值表示的，好问题</p>
<ol start="3">
<li>”加入到组是在binlog cache flush到binlog文件之前做的,如果此时有事务正在flush,未sync,则</li>
</ol>
<p>后面的事务必须等待“ 这句话是对的，但是我没看出这个跟前面提的两个延迟参数作用的关系^</p>
<p>_^</p>
<p>2019-01-13</p>
<p>观弈道人   1</p>
<p>丁老师你好，问个题外问题，mysql已经通过gap锁解决了在rr级别下的幻读问题，那么serializa</p>
<p>ble隔离级别目前还有什么用途，一般文章上说的，serializable 主要是为了解决幻读，谢谢回答</p>
<p>。2019-01-12</p>
<p> 作者回复</p>
<p>serializable隔离级别确实用得很少（我没有见过在生产上使用的哈）</p>
<p>2019-01-12</p>
<p>J!   0</p>
<p>同时处于 prepare 状态的事务，在备库执行时是可以并行.复制的，是这个prepare 就可以生成</p>
<p>了改组的commited Id吗</p>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/77083">https://time.geekbang.org/column/article/77083</a></p>
<p>2019-02-01</p>
<p> 作者回复</p>
<p>进入prepare 的时候就给这个事务分配 commitid，这个commitid就是当前系统最大的一个com</p>
<p>mitid</p>
<p>2019-02-02</p>
<p>J!   0</p>
<p>5.7 版本的基于组提交的并行复制。last_commitid 是在什么时候生成的？2019-02-01</p>
<p> 作者回复</p>
<p>事务提交的时候</p>
<p>2019-02-02</p>
<p>alias cd&#x3D;rm -rf   0</p>
<p>老师您好：</p>
<p>思考题答案的猜测：建议采用 WRITESET。WRITESET_SESSION：因为主库是单线程插入，如果采用WRITESET_SESSION，那么会退</p>
<p>化成单线程主从复制。COMMIT_ORDER：因为是追历史数据，所以会退化成单线程。2019-02-01</p>
<p> 作者回复</p>
<p>对的， </p>
<p>2019-02-02</p>
<p>时隐时现   0</p>
<p>Furthermore, given that changes are propagated and applied in row-based format, this means t</p>
<p>hat they are received in an optimized and compact format, and likely reducing the number of IO </p>
<p>operations required when compared to the originating member.</p>
<p>这个是官档上对MGR的一段解读，我的疑问是：</p>
<p>为何row-base replication在从库回放时会节省大量IO？候选答案：</p>
<p>1、省去了sql解析，直接调用do_command</p>
<p>2、？？可是row复制有其他可能存在的劣势，比如单个大dml会被解析成多个dml_event进行重放，万</p>
<p>一该表没有主键或唯一索引，只能采用二级索引或者全表扫描(开启hash_scan也可以)，所以，</p>
<p>官档上直接说会减少大量IO是不是有点太武断了</p>
<p>2019-01-31</p>
<p> 作者回复</p>
<p>这个描述应该是主要考虑在有主键的时候，可以通过row里面的信息取出主键直接定位记录。你说的这些其实劣势确实也是存在的  </p>
<p>2019-01-31</p>
<p>牛牛   0</p>
<p>老师、请教两个问题～</p>
<ol>
<li>我在job里按主键删除线上表数据的时候、造成了主从延迟、delete from table where id in…</li>
</ol>
<p>id是主键、每次delete 300条、sleep 500ms、这种延迟可能是什么造成的呢？300条应该不算大</p>
<p>事务？还是说快速的数据删除导致了索引重建？2. 如果一个表快速往里写数据、每次300条、sleep 1s、这个库上的读取会慢吗？多谢老师 ～</p>
<p>2019-01-27</p>
<p> 作者回复</p>
<ol>
<li>delete 300条 ， sleep 500ms已经是很克制的操作了，单线程吗？如果还是单线程，那延迟</li>
</ol>
<p>应该不是这个操作导致的</p>
<ol start="2">
<li>这都是很小的压力，不会读取慢才对</li>
</ol>
<p>2019-02-01</p>
<p>Leon    0</p>
<p>老师，semisync啥时候讲下，昨天面试被问到一脸懵逼</p>
<p>2019-01-22</p>
<p> 作者回复</p>
<p>semi-sync在第28篇会提到，但是也不是大篇幅介绍</p>
<p>后面可能也不会大篇幅专门介绍了，你说下你的问题哈。2019-01-22</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>关于COMMIT_ORDER的并行复制方案，从库根据 commit_id来判断“处于prepare和commit状</p>
<p>态的事务”。这里我有个很大的疑惑：commit_id是什么时候加入到binlog的，又是在什么时候递</p>
<p>增的？？（</p>
<p>对于我这个问题的进一步解释：</p>
<p>既然commit_id是要被写入到binlog的，那么commit_id毫无疑问就是在write binlog阶段写入的</p>
<p>。我们知道redolog是组提交的，如果只是按照redolog的组提交方式生成commit_id，那么这个co</p>
<p>mmit_id包含的并行事务数量并不够多！因为在binlog write阶段，又有事务进入到redolog prepa</p>
<p>re阶段，他们之间的commit_id是不一样的，但是他们是可以并行的。所以commit_id什么时候递增？这个是非常关键的，我也很疑惑，commit_id到底是根据什么条</p>
<p>件递增的？？）</p>
<p>2019-01-17</p>
<p> 作者回复</p>
<p>可以这么理解，每个事务都有两个数字表示它在执行提交阶段的时间范围, 构成区间(c1, c2).</p>
<p>如果两个事务的区间有交集，就是可以并行的。这里c1是事务启动的时候，当前系统里最大的commit_id；</p>
<p>一个事务提交的时候，commit_id+1.</p>
<p>2019-01-17</p>
<p>Mr.Strive.Z.H.L   0</p>
<p>老师您好：</p>
<p>今天的内容中写到：“外键约束”会导致并行复制退化为单线程。这个地方我就突然联想到，在业务中，类似于“外键”这种关系是一定存在的。但是一般在设计</p>
<p>表的时候，比如：表A的某个唯一键是表B的外键。并不会真正”显示”的在数据库表中创建外键</p>
<p>关系。（查询的时候，查询出A的这个唯一键，然后再根据这个唯一键查询表B的数据，并不会</p>
<p>有真正的外键关系，一次性查出所有关联数据）</p>
<p>这是为什么呢？2019-01-17</p>
<p> 作者回复</p>
<p>我也建议尽量少使用外键，我自己理解的几个原因吧</p>
<ol>
<li><p>这个关系应该维护在开发系统的逻辑中，放在数据库里面，比较隐蔽，容易忘记</p>
</li>
<li><p>外键约束可能会导致有些更新失败</p>
</li>
<li><p>外键约束（尤其是级联更新）容易出现非预期的结果</p>
</li>
</ol>
<p>2019-01-17</p>
<p>亢星东   0</p>
<p>老师好，如何将大事务拆成小事务</p>
<p>2019-01-16</p>
<p> 作者回复</p>
<p>这个是要结合业务的，比如要删除100万行，改成100个事务，每个事务删除1万行，这样的</p>
<p>2019-01-16</p>
<p>道   0</p>
<p>老师，这段不太理解：“举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新</p>
<p>语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，</p>
<p>备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。”备库</p>
<p>上的查询属于另外一个事务，按照可重复读隔离级别，这个查询不应该看到另外一个事务“更新</p>
<p>了一半的结果”啊。即便是这两条更新语句被分到不同 worker ，也应该保证事务的原子性啊，</p>
<p>难道是技术上有困难吗？2019-01-16</p>
<p> 作者回复</p>
<p>因为这两个worker没办法“约好一起提交”，这个是属于两个线程了</p>
<p>2019-01-16</p>
<p>crazyone   0</p>
<p>“不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁</p>
<p>冲突的检验了。”这句话不怎么理解。事务获取锁是在执行到对应的语句才做检查的，redo log</p>
<p>在事务当中，应该也是一条条操作语句写的吧？难道写完了，才会进入到prepare阶段？这个pr</p>
<p>epare阶段是指事务已经完全扫描执行完所有事务操作，准备写入到redo log文件的阶段?</p>
<p>2019-01-15</p>
<p> 作者回复</p>
<p>就是两阶段提交里的，写redo 的第一阶段</p>
<p>2019-01-16</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
