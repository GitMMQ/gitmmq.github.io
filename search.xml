<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tensorflow使用指南</title>
      <link href="/posts/676b1804.html"/>
      <url>/posts/676b1804.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以安装Anaconda<br>通过Anaconda Prompts进入conda 命令行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="更换为国内源"><a href="#更换为国内源" class="headerlink" title="更换为国内源"></a>更换为国内源</h2><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><p>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</a></p><h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><p>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/main/">https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/free/">https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/">https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/">https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/">https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/">https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</a></p><h3 id="搜索时显示通道地址"><a href="#搜索时显示通道地址" class="headerlink" title="搜索时显示通道地址"></a>搜索时显示通道地址</h3><p>conda config –set show_channel_urls yes</p><h3 id="还原原始通道"><a href="#还原原始通道" class="headerlink" title="还原原始通道"></a>还原原始通道</h3><p>conda config –remove-key channels</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch使用指南</title>
      <link href="/posts/936ee6a2.html"/>
      <url>/posts/936ee6a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装构建"><a href="#安装构建" class="headerlink" title="安装构建"></a>安装构建</h1><p><a href="https://www.tensorflow.org/install/source_windows">https://www.tensorflow.org/install/source_windows</a></p><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p><a href="https://www.tensorflow.org/learn#prepare-data">https://www.tensorflow.org/learn#prepare-data</a></p><h1 id="调试模型"><a href="#调试模型" class="headerlink" title="调试模型"></a>调试模型</h1><p><a href="https://www.tensorflow.org/learn#build-models">https://www.tensorflow.org/learn#build-models</a></p><h1 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h1><p><a href="https://www.tensorflow.org/learn#deploy-models">https://www.tensorflow.org/learn#deploy-models</a></p><h1 id="生产应用"><a href="#生产应用" class="headerlink" title="生产应用"></a>生产应用</h1><p><a href="https://www.tensorflow.org/learn#implement-mlops">https://www.tensorflow.org/learn#implement-mlops</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>conda使用指南</title>
      <link href="/posts/1d208056.html"/>
      <url>/posts/1d208056.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以安装Anaconda<br>通过Anaconda Prompts进入conda 命令行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="更换为国内源"><a href="#更换为国内源" class="headerlink" title="更换为国内源"></a>更换为国内源</h2><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><p>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –add channels <a href="http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/">http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</a></p><h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><p>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/main/">https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/free/">https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/">https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/">https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/">https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</a><br>conda config –add channels <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/">https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</a><br>conda config –set show_channel_urls yes<br>conda config –remove-key channels</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>1.验证conda是否被安装：conda –version(查看conda版本的一个命令)<br>2.更新conda至最新的版本:conda update conda<br>3.conda –help:查看conda帮助信息<br>4.conda list:查看当前环境中已安装的包信息<br>5.conda search –full-name 包名  精确查找可供安装的包版本<br>6.conda search 包名的一部分名称  模糊查找可供安装的包版本<br>7.conda install 包名  在当前环境中安装包(当使用conda install无法进行安装时，可以使用pip install进行安装,pip install无法安装的时候，可以使用conda install 安装)<br>8.conda remove 包名   卸载当前环境中的包<br>9.conda update –all   更新所有包<br>10.conda update 包名   更新指定包</p><p>默认情况下，新创建的环境将会被保存在&#x2F;Users&#x2F;<user_name>&#x2F;anaconda3&#x2F;env目录下，其中，<user_name>为当前用户的用户名。<br>创建新的环境<br>conda create –name 新的python环境的名称<br>conda create –name 新的python环境的名称 python&#x3D;要安装的python版本<br>conda create –name 新的python环境的名称 python&#x3D;要安装的python版本 要安装的包名</user_name></user_name></p><p>切换环境<br>activate python环境名称   切换到xx环境中<br>deactivate python环境名称  退出xx环境</p><p>conda env list ：显示已创建的环境<br>conda create –name 新的虚拟环境名称 –clone 要克隆的虚拟环境名称<br>conda remove –name 虚拟环境的名称 –all</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cuda安装</title>
      <link href="/posts/bcc8f365.html"/>
      <url>/posts/bcc8f365.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="默认安装位置"><a href="#默认安装位置" class="headerlink" title="默认安装位置"></a>默认安装位置</h2><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</p><p>nvcc –version 查看安装版本（环境变量配置）</p><h2 id="cuda下载地址"><a href="#cuda下载地址" class="headerlink" title="cuda下载地址"></a>cuda下载地址</h2><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10">https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10</a></p><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p><h2 id="cudnn下载地址"><a href="#cudnn下载地址" class="headerlink" title="cudnn下载地址"></a>cudnn下载地址</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></p><h3 id="版本关系和查看"><a href="#版本关系和查看" class="headerlink" title="版本关系和查看"></a>版本关系和查看</h3><p>cuda： Compute Unified Device Architecture，是一种有NVIDIA推出的通用并行计算架构， 该架构使GPU能够解决复杂的计算问题。</p><p>cudnn： 是NVIDIA 推出的用于深度神经网络的GPU加速库，他强调性能，易用性和低内存开销。</p><p>cuda和cudnn的关系： cudnn是基于cuda架构开发的专门用于深度神经网络的GPU加速库。cuda可以理解为一个大的商圈，但这个商圈是空的，还未装修。cudnn可以理解为装修后的房间，例如负一楼专门针对游乐（深度神经网络）装修成大型游乐厂。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些好的技术博客</title>
      <link href="/posts/39a747bc.html"/>
      <url>/posts/39a747bc.html</url>
      
        <content type="html"><![CDATA[<p>陈梓瀚 <a href="http://cppblog.com/vczh">http://cppblog.com/vczh</a></p><p>赵劼 <a href="http://blog.zhaojie.me/">http://blog.zhaojie.me/</a></p><p>martin <a href="https://www.martinfowler.com/">https://www.martinfowler.com/</a></p><p>jakewharton <a href="https://jakewharton.com/">https://jakewharton.com/</a></p><p>stallman <a href="https://stallman.org/">https://stallman.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> records </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-volatile关键字</title>
      <link href="/posts/23a4cdd8.html"/>
      <url>/posts/23a4cdd8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile是Java虚拟机提供的-轻量级-的同步机制"><a href="#Volatile是Java虚拟机提供的-轻量级-的同步机制" class="headerlink" title="Volatile是Java虚拟机提供的**轻量级**的同步机制"></a>Volatile是Java虚拟机提供的**<code>轻量级</code>**的同步机制</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>volatile修饰的变量，不拷贝副本到工作内存，直接操作主内存，任何修改都可以其他线程读取到。<br>volatile的可以保证写入和读取 64 位值（long类型和double类型 ）的原子性。</p><p>单例中 volatile  + synchronized 的作用</p><pre><code>volatile 可见性、禁止指令重排synchronized保证操作的原子性、一致性和可见性。</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-主成分分析"><a href="#title-主成分分析" class="headerlink" title="title:主成分分析"></a>title:主成分分析</h2><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>1、神经网络最好设计成三层结构（输入层、隐藏层、输出层）<br>2、如果隐藏非要设计多层，保持每层的神经元数量相同<br>3、输入层神经元的数量与特性个数相同<br>4、输出层的神经元数量与输出结果的要求相关。比如10分类网络的输出层神经元数量是10个<br>5、隐层神经元的数量越多效果越好，但是过多的话，会增加计算量。最好多于输入层神经元的数量</p><h1 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a>训练步骤</h1><p>1、随机初始化所有权重矩阵<br>2、向前传播计算所有层的激活值<br>3、计算损失成本<br>4、反向传播计算更新权重<br>5、使用“梯度检验”确认反向传播计算是否足够有效。(注意：一旦确认有效，立即关闭“梯度检验”)<br>6、使用梯度下降或任何有效算法获得最优权重矩阵</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-主成分分析"><a href="#title-主成分分析" class="headerlink" title="title:主成分分析"></a>title:主成分分析</h2><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>主成分分析能降低所研究的数据空间的维数。即用研究m维的Y空间代替p维的X空间(m&lt;p)，而低维的Y空间代替高维的x空间所损失的信息很少。即：使只有一个主成分Yl(即 m&#x3D;1)时，这个Yl仍是使用全部X变量(p个)得到的。例如要计算Yl的均值也得使用全部x的均值。在所选的前m个主成分中，如果某个Xi的系数全部近似于零的话，就可以把这个Xi删除，这也是一种删除多余变量的方法。</p><h2 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h2><p>有时可通过因子负荷aij的结论，弄清X变量间的某些关系。</p><h2 id="图形分析"><a href="#图形分析" class="headerlink" title="图形分析"></a>图形分析</h2><p>多维数据的一种图形表示方法。我们知道当维数大于3时便不能画出几何图形，多元统计研究的问题大都多于3个变量。要把研究的问题用图形表示出来是不可能的。然而，经过主成分分析后，我们可以选取前两个主成分或其中某两个主成分，根据主成分的得分，画出n个样品在二维平面上的分布况，由图形可直观地看出各样品在主分量中的地位，进而还可以对样本进行分类处理，可以由图形发现远离大多数样本点的离群点。</p><h2 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h2><p>由主成分分析法构造回归模型。即把各主成分作为新自变量代替原来自变量x做回归分析。</p><h2 id="降低计算量"><a href="#降低计算量" class="headerlink" title="降低计算量"></a>降低计算量</h2><p>用主成分分析筛选回归变量。回归变量的选择有着重的实际意义，为了使模型本身易于做结构分析、控制和预报，好从原始变量所构成的子集合中选择最佳变量，构成最佳变量集合。用主成分分析筛选变量，可以用较少的计算量来选择量，获得选择最佳变量子集合的效果。</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-机器学习的10个项目"><a href="#title-机器学习的10个项目" class="headerlink" title="title:机器学习的10个项目"></a>title:机器学习的10个项目</h2><h1 id="Deepy"><a href="#Deepy" class="headerlink" title="Deepy"></a>Deepy</h1><p>   Deepy 由 Raphael Shu 开发，是一个基于 Theano 扩展深度学习框架，它提供了一个简洁的、高阶的组件（如 LSTMs）、批规范化、自动编码等功能。Deepy 宣称其框架是十分简洁明了的，它的官方文档和示例也同样如此。<br>   Deepy 工作原理：在给定训练数据和参数（随机初始化）下运行模型，将错误（或梯度）反馈并更新参数，这个过程反复进行。 </p><h1 id="MLxtend"><a href="#MLxtend" class="headerlink" title="MLxtend"></a>MLxtend</h1><p>   MLxtend 由 Sebastian Raschka 开发，是一系列有效工具的集合，也是针对机器学习任务的扩展。Sebastian Raschka 提到 MLxtend 本质上是一些有效的工具集，也是与机器学习和数据科学相关的参考资料。他提到开发 MLxtend 主要是基于以下几个原因：<br>   一些其他地方找不到的特定算法（如序列特征选择算法、多数表决分类器、叠加预估、绘图决策区域等）<br>   用于教学目的（逻辑回归、Softmax 回归、多层感知器、PCA、PCA 内核等）这些实现主要关注于代码的可读性，而不是单纯的效率<br>   打包便利：tensorflow、Softmax 回归和多层感知器<br>   MLxtend 基本上是 Sebastian Raschka 所写的一个机器学习运行常用的库，其中很多功能的实现都与 scikit-learn 的 API 相似，但作者仍在持续更新中，且作者表示所有的新增特性与创新的算法都会一起打包在 MLxtend 中。</p><h1 id="Datacleaner"><a href="#Datacleaner" class="headerlink" title="Datacleaner"></a>Datacleaner</h1><p>   datacleaner 由 Randal Olson 开发，他认为自己开发的 datacleaner 是一个“能自动清除数据集并且让它们便于分析的 Python 工具。”他认为：datacleaner 所做的将会节约你大量的编码和清理数据的时间。<br>   datacleaner 还处于开发过程中，但目前已经能够处理以下常规（传统方式下耗时量巨大的）数据清洗任务：<br>   在列的基础上，用模式或中位数替换丢失的值<br>   用数值等价物对非数值变量进行编码等</p><h1 id="Auto-sklearn"><a href="#Auto-sklearn" class="headerlink" title="Auto-sklearn"></a>Auto-sklearn</h1><p>   auto-sklearn 由德国弗莱堡大学机器学习自动算法小组开发，是针对 Scikit-learn 环境的自动机器学习工具。<br>   auto-sklearn 能将机器学习用户从算法选择和高参数调整中解救出来，它利用了近期在贝叶斯优化、元学习和集成构筑上研究的优势。其大致工作原理如下：</p><h1 id="Deep-Mining"><a href="#Deep-Mining" class="headerlink" title="Deep Mining"></a>Deep Mining</h1><p>   Deep Mining 由来自 MIT CSAIL 实验室的 Sebastien Dubois 开发，是一个机器学习深管道自动调谐器。为了尽快实现最好的分类精度，该软件将迭代、智能地测试一些超参数集。<br>   另外值得一提的是文件夹 GCP-HPO 包含所有高斯过程（GCP）的实现代码以及基于其基础上的超参数优化（HPO）。高斯过程（GCP）可以看作是一种改进的版本。这项新技术被证明优于基于 GP 的超参数优化，已经远比随机搜索表现要好。</p><h1 id="Rusty-Machine"><a href="#Rusty-Machine" class="headerlink" title="Rusty Machine"></a>Rusty Machine</h1><p>   Rusty Machine 是基于 Rust 的机器学习方法，Rust 是由 Mozilla 赞助开发的一种与C和 C++ 较为相似的计算机编程语言，其号称“Rust 是一种系统的编程语言，运行速度极快，可以防止错误，并保证线程安全。”<br>   Rusty Machine 的开发者是否活跃，目前支持一系列想学习技术，包括：线性回归、逻辑回归、k-均值聚类、神经网络、支持向量机等等。<br>   Rusty Machine 还支持数据结构，如内置向量和矩阵。作为一种常见的模型接口，Rusty Machine 为每个支持的模型提供了训练和预测的功能。</p><h1 id="Scikit-image"><a href="#Scikit-image" class="headerlink" title="Scikit-image"></a>Scikit-image</h1><p>   scikit-image 图像是针对 SciPy 使用 Python 的图像处理方法。scikit-image 是机器学习吗？它其实是一个机器学习项目（没有确切地表示他们必须用机器学习方法），scikit-image 就属于数据处理和准备工具这一类。该项目包括一些图像处理算法，如点检测、滤波、特征选择和形态学等。</p><h1 id="NLP-Compromise"><a href="#NLP-Compromise" class="headerlink" title="NLP Compromise"></a>NLP Compromise</h1><p>   NLP Compromise 是由 Java 语言编写的，其在浏览器中进行自然语言处理过程。NLP Compromise 非常容易安装和使用，以下是它的一个使用范例：</p><h1 id="Datatest"><a href="#Datatest" class="headerlink" title="Datatest"></a>Datatest</h1><p>   Datatest 是一个依靠数据冲突的测试集，其由 Python 编写。<br>   Datatest 扩展了数据校正的测试工具标准数据库<br>   Datatest 是一种寻找数据冲突和准备的不同方式，如果你的大部分时间都被花在这个任务上，也许换一种新的方法是值得的。</p><h1 id="GoLearn"><a href="#GoLearn" class="headerlink" title="GoLearn"></a>GoLearn</h1><pre><code>GoLearn 是一种针对 Go 语言的机器学习库，自称 Go 语言机器学习的“内置电池”学习库。简洁、易定制是其追求的目标。对于一些想分支出来的 Python 用户或者想尝试下机器学习的 Go 语言用户来说，GoLearn 是一个不错的选项。GoLearn 实现了熟悉的 Scikit-learn 适应/预测界面，可实现快速预估测试和交换。</code></pre>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>plt绘图</title>
      <link href="/posts/8c2e92d2.html"/>
      <url>/posts/8c2e92d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplotasplt</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">r_basicdx=redis.Redis(host=<span class="string">&#x27;172.20.3.52&#x27;</span>,port=<span class="number">6373</span>,db=<span class="number">1</span>)</span><br><span class="line">l_basicdx=redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">6379</span>,db=<span class="number">1</span>)</span><br><span class="line">keys=r_basicdx.keys()</span><br><span class="line">forkeyinkeys:</span><br><span class="line">value=r_basicdx.get(key)</span><br><span class="line">l_basicdx.<span class="built_in">set</span>(key,value)</span><br><span class="line">image=pickle.loads(value)</span><br><span class="line">f=plt.figure()</span><br><span class="line">ax=f.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.text(<span class="number">0.1</span>,<span class="number">0.9</span>,key,ha=<span class="string">&#x27;center&#x27;</span>,va=<span class="string">&#x27;center&#x27;</span>,transform=ax.transAxes)</span><br><span class="line">plt.imshow(image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow安装</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>你可以使用我们提供的 Pip, Docker, Virtualenv, Anaconda 或 源码编译的方法安装 TensorFlow.<br>Pip 安装<br>Pip 是一个 Python 的软件包安装与管理工具.<br>在安装 TensorFlow 过程中要涉及安装或升级的包详见 列表<br>首先安装 pip (或 Python3 的 pip3 ):</p><h1 id="Ubuntu-x2F-Linux-64-bit"><a href="#Ubuntu-x2F-Linux-64-bit" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit"></a>Ubuntu&#x2F;Linux 64-bit</h1><p>$ sudo apt-get install python-pip python-dev</p><h1 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h1><p>$ sudo easy_install pip<br>安装 TensorFlow :</p><h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:</h1><p>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl</a></p><h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below"><a href="#For-other-versions-see-“Install-from-sources”-below" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl</a></p><h1 id="Mac-OS-X-CPU-only"><a href="#Mac-OS-X-CPU-only" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>$ sudo easy_install –upgrade six<br>$ sudo pip install –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py2-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py2-none-any.whl</a><br>如果是 Python3 :</p><h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:</h1><p>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl</a></p><h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-1"><a href="#For-other-versions-see-“Install-from-sources”-below-1" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0-cp34-cp34m-linux_x86_64.whl</a></p><h1 id="Mac-OS-X-CPU-only-1"><a href="#Mac-OS-X-CPU-only-1" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>$ sudo easy_install –upgrade six<br>$ sudo pip3 install –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py3-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0-py3-none-any.whl</a><br>备注：如果之前安装过 TensorFlow &lt; 0.7.1 的版本,应该先使用 pip uninstall 卸载 TensorFlow 和 protobuf ,保证获取的是一个最新 protobuf 依赖下的安装包.<br>之后可以测试一下.<br>基于 Docker 的安装<br>我们也支持通过 Docker 运行 TensorFlow. 该方式的优点是不用操心软件依赖问题.<br>首先, 安装 Docker. 一旦 Docker 已经启动运行, 可以通过命令启动一个容器:<br>$ docker run -it b.gcr.io&#x2F;tensorflow&#x2F;tensorflow<br>该命令将启动一个已经安装好 TensorFlow 及相关依赖的容器.<br>其它镜像<br>默认的 Docker 镜像只包含启动和运行 TensorFlow 所需依赖库的一个最小集. 我们额外提供了 下面的容器, 该容器同样可以通过上述 docker run 命令安装:<br>b.gcr.io&#x2F;tensorflow&#x2F;tensorflow-full: 镜像中的 TensorFlow 是从源代码完整安装的, 包含了编译和运行 TensorFlow 所需的全部工具. 在该镜像上, 可以直接使用源代码进行实验, 而不需要再安装上述的任何依赖.<br>基于 VirtualEnv 的安装<br>我们推荐使用 virtualenv 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.<br>首先, 安装所有必备工具:</p><h1 id="在-Linux-上"><a href="#在-Linux-上" class="headerlink" title="在 Linux 上:"></a>在 Linux 上:</h1><p>$ sudo apt-get install python-pip python-dev python-virtualenv</p><h1 id="在-Mac-上"><a href="#在-Mac-上" class="headerlink" title="在 Mac 上:"></a>在 Mac 上:</h1><p>$ sudo easy_install pip  # 如果还没有安装 pip<br>$ sudo pip install –upgrade virtualenv<br>接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~&#x2F;tensorflow 目录下, 执行:<br>$ virtualenv –system-site-packages ~&#x2F;tensorflow<br>$ cd ~&#x2F;tensorflow<br>然后, 激活 virtualenv:<br>$ source bin&#x2F;activate  # 如果使用 bash<br>$ source bin&#x2F;activate.csh  # 如果使用 csh<br>(tensorflow)$  # 终端提示符应该发生变化<br>在 virtualenv 内, 安装 TensorFlow:<br>(tensorflow)$ pip install –upgrade &lt;$url_to_binary.whl&gt;<br>接下来, 使用类似命令运行 TensorFlow 程序:<br>(tensorflow)$ cd tensorflow&#x2F;models&#x2F;image&#x2F;mnist<br>(tensorflow)$ python convolutional.py</p><h1 id="当使用完-TensorFlow"><a href="#当使用完-TensorFlow" class="headerlink" title="当使用完 TensorFlow"></a>当使用完 TensorFlow</h1><p>(tensorflow)$ deactivate  # 停用 virtualenv</p><p>$  # 你的命令提示符会恢复原样<br>基于 Anaconda 的安装<br>Anaconda 是一个集成许多第三方科学计算库的 Python 科学计算环境,Anaconda 使用 conda 作为自己的包管理工具,同时具有自己的计算环境,类似 Virtualenv.<br>和 Virtualenv 一样,不同 Python 工程需要的依赖包,conda 将他们存储在不同的地方。 TensorFlow 上安装的 Anaconda 不会对之前安装的 Python 包进行覆盖.<br>安装 Anaconda<br>建立一个 conda 计算环境<br>激活环境,使用 conda 安装 TensorFlow<br>安装成功后,每次使用 TensorFlow 的时候需要激活 conda 环境<br>安装 Anaconda :<br>参考 Anaconda 的下载页面的指导<br>建立一个 conda 计算环境名字叫tensorflow:</p><h1 id="Python-2-7"><a href="#Python-2-7" class="headerlink" title="Python 2.7"></a>Python 2.7</h1><p>$ conda create -n tensorflow python&#x3D;2.7</p><h1 id="Python-3-4"><a href="#Python-3-4" class="headerlink" title="Python 3.4"></a>Python 3.4</h1><p>$ conda create -n tensorflow python&#x3D;3.4<br>激活tensorflow环境,然后使用其中的 pip 安装 TensorFlow. 当使用easy_install使用–ignore-installed标记防止错误的产生。<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change</p><h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7-1"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-2-7-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 2.7:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</a></p><h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-2-7-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-2"><a href="#For-other-versions-see-“Install-from-sources”-below-2" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</a></p><h1 id="Mac-OS-X-CPU-only-2"><a href="#Mac-OS-X-CPU-only-2" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py2-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py2-none-any.whl</a><br>对于 Python 3.x :<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change</p><h1 id="Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4-1"><a href="#Ubuntu-x2F-Linux-64-bit-CPU-only-Python-3-4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:"></a>Ubuntu&#x2F;Linux 64-bit, CPU only, Python 3.4:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</a></p><h1 id="Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1"><a href="#Ubuntu-x2F-Linux-64-bit-GPU-enabled-Python-3-4-Requires-CUDA-toolkit-7-5-and-CuDNN-v4-1" class="headerlink" title="Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4."></a>Ubuntu&#x2F;Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</h1><h1 id="For-other-versions-see-“Install-from-sources”-below-3"><a href="#For-other-versions-see-“Install-from-sources”-below-3" class="headerlink" title="For other versions, see “Install from sources” below."></a>For other versions, see “Install from sources” below.</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</a></p><h1 id="Mac-OS-X-CPU-only-3"><a href="#Mac-OS-X-CPU-only-3" class="headerlink" title="Mac OS X, CPU only:"></a>Mac OS X, CPU only:</h1><p>(tensorflow)$ pip install –ignore-installed –upgrade <a href="https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl">https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl</a><br>conda 环境激活后,你可以测试<br>当你不用 TensorFlow 的时候,关闭环境:<br>(tensorflow)$ source deactivate</p><p>$  # Your prompt should change back<br>再次使用的时候再激活 :-)<br>$ source activate tensorflow<br>(tensorflow)$  # Your prompt should change.</p><h1 id="Run-Python-programs-that-use-TensorFlow"><a href="#Run-Python-programs-that-use-TensorFlow" class="headerlink" title="Run Python programs that use TensorFlow."></a>Run Python programs that use TensorFlow.</h1><p>…</p><h1 id="When-you-are-done-using-TensorFlow-deactivate-the-environment"><a href="#When-you-are-done-using-TensorFlow-deactivate-the-environment" class="headerlink" title="When you are done using TensorFlow, deactivate the environment."></a>When you are done using TensorFlow, deactivate the environment.</h1><p>(tensorflow)$ source deactivate</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>量化交易</title>
      <link href="/posts/28981.html"/>
      <url>/posts/28981.html</url>
      
        <content type="html"><![CDATA[<p>投资决策模型化，基于历史数据验证，交易自动执行</p><p>股市波动，长期、短期、相对</p><h2 id="投资指标"><a href="#投资指标" class="headerlink" title="投资指标"></a>投资指标</h2><h3 id="风险收益率"><a href="#风险收益率" class="headerlink" title="风险收益率"></a>风险收益率</h3><p>夏普率&#x3D;（收益-无风险利率）&#x2F;波动率</p><h3 id="胜率赔率"><a href="#胜率赔率" class="headerlink" title="胜率赔率"></a>胜率赔率</h3><p>胜率是指出手赚钱次数与总出手次数之比</p><p>赔率是指平均每次出手赚到的钱除以平均每次出手赔的钱，也叫做盈亏比</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="阿尔法策略"><a href="#阿尔法策略" class="headerlink" title="阿尔法策略"></a>阿尔法策略</h3><p>优点：不管指数是涨还是下跌，都能赚钱的一种方法，具体的操作思路是找出市场里最优秀的品种，做多这些品种，然后做空相应多的指数，这样就锁定了最优秀的品种带来的收益，而把指数带来的波动进行了平抑。<br>缺点：回撤和收益都比较小的交易策略</p><h3 id="程序化CTA"><a href="#程序化CTA" class="headerlink" title="程序化CTA"></a>程序化CTA</h3><p>优点：适合大众使用的程序化交易方法，是指将交易策略的思想设计成完整的逻辑运行体系，然后用合适的计算机语言编写成程序，有计算机进行自动交易。程序化交易的优点是，将交易模式系统化，制度化，排除人性的心理障碍，确保交易策略的执行行。挣的是趋势的钱，挣的是纪律的钱，但因为趋势不常有，所以这是一种低胜率，高赔率的方法。</p><p>入场条件、出场条件，品种选择、时机选择，资金管理</p><h3 id="统计套利"><a href="#统计套利" class="headerlink" title="统计套利"></a>统计套利</h3><p>通过计算某些关联品种之间出现了价差的扩大，那就可以在品种之间进行配对交易，从而进行套利</p><h3 id="低风险套利"><a href="#低风险套利" class="headerlink" title="低风险套利"></a>低风险套利</h3><p>ETF套利也是一种低风险套利，比如某个ETF指数基金现在的价格是2.1，而如果我们用一揽子股票来组成这个ETF指数基金，价格是2块，那么我们就可以在市场上卖出基金，买入股票，来得到这0.1的差价。这些套利比较容易执行，收入也很可观，而且风险很小。</p><h3 id="高频交易"><a href="#高频交易" class="headerlink" title="高频交易"></a>高频交易</h3><p>利用计算机处理市场微观结构层面的不均衡性，往往交易次数多，持仓时间短，可能会送大量交易指令，又快速撤单，再反向做交易获得收益，每笔交易平均利润小但稳定。</p><p>优点是总收益率极高，当日平仓降低隔夜风险，隔夜资金利息收入降低资金成本，绩效评估周期短。</p><h3 id="算法交易"><a href="#算法交易" class="headerlink" title="算法交易"></a>算法交易</h3><p>降低冲击成本的一种被动的程序化交易，通过科学的成本估算模型和交易实施算法，将一个大额的交易拆分成系列小额交易 在合理的时间点分别执行，以此来尽量减少 对市场价格造成的冲击，降低交易成本，而且还能帮助机构投资者快速增加交易量。适合的对象包括大小非减持者，大宗交易接盘出货，“大宗交易-融券卖出”套利者，Alpha套利者，套期保值者，日以上级别程序化交易者等。</p><p>参考：<a href="https://www.jianshu.com/p/2c470ef5d083">https://www.jianshu.com/p/2c470ef5d083</a></p>]]></content>
      
      
      <categories>
          
          <category> quant </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/posts/7457.html"/>
      <url>/posts/7457.html</url>
      
        <content type="html"><![CDATA[<p>开发过程中，需要根据不同场景选择不同算法和策略。</p><p>将需要经常改变的部分抽象提取为接口，通过引用该接口，就可以调用该接口实现类的行为，即具体策略。实现了策略具体实现和调用者的隔离。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以动态改变对象行为</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>使用哪种策略需要调用者自己决定</li><li>产生很多策略类</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public interface IStrategy &#123;    public void doSomething();&#125;public class Strategy1 implements IStrategy &#123;    @Override    public void doSomething() &#123;    &#125;&#125;public class Strategy2 implements IStrategy &#123;    @Override    public void doSomething() &#123;    &#125;&#125;public class Context implements IStrategy &#123;    private IStrategy strategy;    public Context(IStrategy strategy)&#123;        this.strategy = strategy;    &#125;    @Override    public void doSomething() &#123;        strategy.doSomething();    &#125;&#125;public static void main(String[] args) &#123;    IStrategy strategy = new Strategy1();    Context context = new Context(strategy);    context.doSomething();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板方法</title>
      <link href="/posts/40592.html"/>
      <url>/posts/40592.html</url>
      
        <content type="html"><![CDATA[<p>流程相同，执行过程中有差别</p><p>可用于定义算法骨架，将一些实现放到子类中实现，达到不用改变算法结构，重新实现算法的目的</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package template;public abstract class Model &#123;    /**     * 类似的行为、逻辑     */    protected abstract void start();    protected abstract void stop();    /**     * 固定的流程  模板化     */    final public void excet()&#123;        this.start();        this.stop();    &#125;&#125;package template;public class Ocar extends Model &#123;    @Override    protected void start() &#123;    &#125;    @Override    protected void stop() &#123;    &#125;&#125;package template;public class Wcar extends Model &#123;    @Override    protected void start() &#123;    &#125;    @Override    protected void stop() &#123;    &#125;&#125;package template;public class Client &#123;    public static void main(String[] args) &#123;        Model wcar=new Wcar();        wcar.excet();        Model ocar=new Ocar();        ocar.excet();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-委派模式</title>
      <link href="/posts/36157.html"/>
      <url>/posts/36157.html</url>
      
        <content type="html"><![CDATA[<p>代理模式+策略模式，典型 Spring 中的 DispatcherServlet</p><p>用户将任务全权委派给代理负责，代理负责根据策略任务调度具体的执行单元</p><h2 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h2><pre><code>/** * 执行单元实现的接口 */public interface ITarget &#123;    void doSomething(String command);&#125;/** * 执行单元A */public class TargetA implements ITarget &#123;    @Override    public void doSomething(String command) &#123;    &#125;&#125;/** * 执行单元B */public class TargetB implements ITarget &#123;    @Override    public void doSomething(String command) &#123;            &#125;&#125;</code></pre><h2 id="执行单元调度者"><a href="#执行单元调度者" class="headerlink" title="执行单元调度者"></a>执行单元调度者</h2><pre><code>public class Manager &#123;    private Map&lt;String ,ITarget&gt; targets = new HashMap&lt;String ,ITarget&gt;();    public Manager()&#123;        targets.put(&quot;commandA&quot;,new TargetA());        targets.put(&quot;commandB&quot;,new TargetB());    &#125;    public void dispatch(String command)&#123;        targets.get(command).doSomething(command);    &#125;&#125;</code></pre><h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><pre><code>public class Boss &#123;        public static void main(String[] args) &#123;        Manager manager = new Manager();        manager.dispatch(&quot;Command1&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/posts/41018.html"/>
      <url>/posts/41018.html</url>
      
        <content type="html"><![CDATA[<p>使用原型对象的方法创建对象的实列，创建的实例equals原型</p><p>final 类型修饰的成员变量不能进行深度拷贝</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等</li><li>构造对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li><li>工厂模式中使用</li><li>共有信息很多</li></ul><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对象内引用原先原型的对象</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对象内引用也拷贝一份</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package prototype;//Cloneable 标记对象可拷贝public class PersonClone implements Cloneable &#123;    @Override //Override Object方法    public PersonClone clone()&#123;        try &#123;            //clone 不会调用构造方法            return (PersonClone)super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;package prototype;public class MainClass &#123;    public static void main(String[] args) &#123;        PersonClone personClone = new PersonClone();        PersonClone clone = personClone.clone();        System.out.println(personClone.hashCode());        System.out.println(clone.hashCode());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/posts/19482.html"/>
      <url>/posts/19482.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>volatile：保证多线程下的可见性</p><blockquote><p>读volatile：每当子线程读取volatile变量时，都会从主线程重新拷贝一份<br>写volatile: 每当子线程修改volatile变量时，都会在修改后同步到主线程去</p></blockquote><p>synchronized：对象锁、类锁、方法锁（其它篇有介绍）</p><pre><code>public class Singleton &#123;    private static volatile Singleton instance;    private Singleton()&#123;    &#125;    public static Singleton getInstance()&#123;        if(instance == null)&#123;            synchronized(Singleton.class)&#123;                if(instance == null)&#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法</title>
      <link href="/posts/34642.html"/>
      <url>/posts/34642.html</url>
      
        <content type="html"><![CDATA[<p>遗传算法（Genetic Algorithms ）是基于生物进化理论的原理发展起来的一种广为应用的、高效的随机搜索与优化的方法。其主要特点是群体搜索策略和群体中个体之间的信息交换，搜索不依赖于梯度信息。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>初始化 t←0进化代数计数器；T是最大进化代数；随机生成M个个体作为初始群体P（t）</li><li>个体评价 计算P（t）中各个个体的适应度；</li><li>选择运算 将选择算子作用于群体；</li><li>交叉运算 将交叉算子作用于群体；</li><li>变异运算 将变异算子作用于群体，并通过以上运算得到下一代群体P（t + 1）;</li><li>终止条件判断  t≦T：t← t+1 转到步骤2；t&gt;T：终止 输出解。</li></ol><h2 id="模型构成"><a href="#模型构成" class="headerlink" title="模型构成"></a>模型构成</h2><ol><li>决策变量及各种约束条件，即个体的表现型X和问题的解空间</li><li>目标函数最大OR 最小， 数学描述形式 量化方法</li><li>染色体编码方法 （二进制、整数、浮点数）</li><li>解码方法</li><li>个体适应度的量化评价方法 F(x)  （旅行商问题及最短路径）</li><li>设计遗传算子</li><li>有关运行参数</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>局部收敛</li><li>全局搜索能力不够强</li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul><li>交叉算子</li><li>变异算子</li><li>选择策略</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah;    import java.io.BufferedReader;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.InputStreamReader;  import java.util.Random;    public class GA &#123;        private int scale;// 种群规模      private int cityNum; // 城市数量，染色体长度      private int MAX_GEN; // 运行代数      private int[][] distance; // 距离矩阵      private int bestT;// 最佳出现代数      private int bestLength; // 最佳长度      private int[] bestTour; // 最佳路径        // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段      private int[][] oldPopulation;      private int[][] newPopulation;// 新的种群，子代种群      private int[] fitness;// 种群适应度，表示种群中各个个体的适应度        private float[] Pi;// 种群中各个个体的累计概率      private float Pc;// 交叉概率      private float Pm;// 变异概率      private int t;// 当前代数        private Random random;        public GA() &#123;        &#125;        /**      * constructor of GA      *       * @param s      *            种群规模      * @param n      *            城市数量      * @param g      *            运行代数      * @param c      *            交叉率      * @param m      *            变异率      *       **/      public GA(int s, int n, int g, float c, float m) &#123;          scale = s;          cityNum = n;          MAX_GEN = g;          Pc = c;          Pm = m;      &#125;        // 给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默      @SuppressWarnings(&quot;resource&quot;)      /**      * 初始化GA算法类      * @param filename 数据文件名，该文件存储所有城市节点坐标数据      * @throws IOException      */      private void init(String filename) throws IOException &#123;          // 读取数据          int[] x;          int[] y;          String strbuff;          BufferedReader data = new BufferedReader(new InputStreamReader(                  new FileInputStream(filename)));          distance = new int[cityNum][cityNum];          x = new int[cityNum];          y = new int[cityNum];          for (int i = 0; i &lt; cityNum; i++) &#123;              // 读取一行数据，数据格式1 6734 1453              strbuff = data.readLine();              // 字符分割              String[] strcol = strbuff.split(&quot; &quot;);              x[i] = Integer.valueOf(strcol[1]);// x坐标              y[i] = Integer.valueOf(strcol[2]);// y坐标          &#125;          // 计算距离矩阵          // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628          for (int i = 0; i &lt; cityNum - 1; i++) &#123;              distance[i][i] = 0; // 对角线为0              for (int j = i + 1; j &lt; cityNum; j++) &#123;                  double rij = Math                          .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])                                  * (y[i] - y[j])) / 10.0);                  // 四舍五入，取整                  int tij = (int) Math.round(rij);                  if (tij &lt; rij) &#123;                      distance[i][j] = tij + 1;                      distance[j][i] = distance[i][j];                  &#125; else &#123;                      distance[i][j] = tij;                      distance[j][i] = distance[i][j];                  &#125;              &#125;          &#125;          distance[cityNum - 1][cityNum - 1] = 0;            bestLength = Integer.MAX_VALUE;          bestTour = new int[cityNum + 1];          bestT = 0;          t = 0;            newPopulation = new int[scale][cityNum];          oldPopulation = new int[scale][cityNum];          fitness = new int[scale];          Pi = new float[scale];            random = new Random(System.currentTimeMillis());          /*          * for(int i=0;i&lt;cityNum;i++) &#123; for(int j=0;j&lt;cityNum;j++) &#123;          * System.out.print(distance[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125;          */          // 初始化种群        &#125;        // 初始化种群      void initGroup() &#123;          int i, j, k;          // Random random = new Random(System.currentTimeMillis());          for (k = 0; k &lt; scale; k++)// 种群数          &#123;              oldPopulation[k][0] = random.nextInt(65535) % cityNum;              for (i = 1; i &lt; cityNum;)// 染色体长度              &#123;                  oldPopulation[k][i] = random.nextInt(65535) % cityNum;                  for (j = 0; j &lt; i; j++) &#123;                      if (oldPopulation[k][i] == oldPopulation[k][j]) &#123;                          break;                      &#125;                  &#125;                  if (j == i) &#123;                      i++;                  &#125;              &#125;          &#125;            /*          * for(i=0;i&lt;scale;i++) &#123; for(j=0;j&lt;cityNum;j++) &#123;          * System.out.print(oldPopulation[i][j]+&quot;,&quot;); &#125; System.out.println(); &#125;          */      &#125;        public int evaluate(int[] chromosome) &#123;          // 0123          int len = 0;          // 染色体，起始城市,城市1,城市2...城市n          for (int i = 1; i &lt; cityNum; i++) &#123;              len += distance[chromosome[i - 1]][chromosome[i]];          &#125;          // 城市n,起始城市          len += distance[chromosome[cityNum - 1]][chromosome[0]];          return len;      &#125;        // 计算种群中各个个体的累积概率，前提是已经计算出各个个体的适应度fitness[max]，作为赌轮选择策略一部分，Pi[max]      void countRate() &#123;          int k;          double sumFitness = 0;// 适应度总和            double[] tempf = new double[scale];            for (k = 0; k &lt; scale; k++) &#123;              tempf[k] = 10.0 / fitness[k];              sumFitness += tempf[k];          &#125;            Pi[0] = (float) (tempf[0] / sumFitness);          for (k = 1; k &lt; scale; k++) &#123;              Pi[k] = (float) (tempf[k] / sumFitness + Pi[k - 1]);          &#125;            /*          * for(k=0;k&lt;scale;k++) &#123; System.out.println(fitness[k]+&quot; &quot;+Pi[k]); &#125;          */      &#125;        // 挑选某代种群中适应度最高的个体，直接复制到子代中      // 前提是已经计算出各个个体的适应度Fitness[max]      public void selectBestGh() &#123;          int k, i, maxid;          int maxevaluation;            maxid = 0;          maxevaluation = fitness[0];          for (k = 1; k &lt; scale; k++) &#123;              if (maxevaluation &gt; fitness[k]) &#123;                  maxevaluation = fitness[k];                  maxid = k;              &#125;          &#125;            if (bestLength &gt; maxevaluation) &#123;              bestLength = maxevaluation;              bestT = t;// 最好的染色体出现的代数;              for (i = 0; i &lt; cityNum; i++) &#123;                  bestTour[i] = oldPopulation[maxid][i];              &#125;          &#125;            // System.out.println(&quot;代数 &quot; + t + &quot; &quot; + maxevaluation);          // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置          copyGh(0, maxid);// 将当代种群中适应度最高的染色体k复制到新种群中，排在第一位0      &#125;        // 复制染色体，k表示新染色体在种群中的位置，kk表示旧的染色体在种群中的位置      public void copyGh(int k, int kk) &#123;          int i;          for (i = 0; i &lt; cityNum; i++) &#123;              newPopulation[k][i] = oldPopulation[kk][i];          &#125;      &#125;        // 赌轮选择策略挑选      public void select() &#123;          int k, i, selectId;          float ran1;          // Random random = new Random(System.currentTimeMillis());          for (k = 1; k &lt; scale; k++) &#123;              ran1 = (float) (random.nextInt(65535) % 1000 / 1000.0);              // System.out.println(&quot;概率&quot;+ran1);              // 产生方式              for (i = 0; i &lt; scale; i++) &#123;                  if (ran1 &lt;= Pi[i]) &#123;                      break;                  &#125;              &#125;              selectId = i;              // System.out.println(&quot;选中&quot; + selectId);              copyGh(k, selectId);          &#125;      &#125;        //进化函数，正常交叉变异      public void evolution() &#123;          int k;          // 挑选某代种群中适应度最高的个体          selectBestGh();            // 赌轮选择策略挑选scale-1个下一代个体          select();            // Random random = new Random(System.currentTimeMillis());          float r;            // 交叉方法          for (k = 0; k &lt; scale; k = k + 2) &#123;              r = random.nextFloat();// /产生概率              // System.out.println(&quot;交叉率...&quot; + r);              if (r &lt; Pc) &#123;                  // System.out.println(k + &quot;与&quot; + k + 1 + &quot;进行交叉...&quot;);                  //OXCross(k, k + 1);// 进行交叉                  OXCross1(k, k + 1);              &#125; else &#123;                  r = random.nextFloat();// /产生概率                  // System.out.println(&quot;变异率1...&quot; + r);                  // 变异                  if (r &lt; Pm) &#123;                      // System.out.println(k + &quot;变异...&quot;);                      OnCVariation(k);                  &#125;                  r = random.nextFloat();// /产生概率                  // System.out.println(&quot;变异率2...&quot; + r);                  // 变异                  if (r &lt; Pm) &#123;                      // System.out.println(k + 1 + &quot;变异...&quot;);                      OnCVariation(k + 1);                  &#125;              &#125;            &#125;      &#125;        //进化函数，保留最好染色体不进行交叉变异      public void evolution1() &#123;          int k;          // 挑选某代种群中适应度最高的个体          selectBestGh();            // 赌轮选择策略挑选scale-1个下一代个体          select();            // Random random = new Random(System.currentTimeMillis());          float r;            for (k = 1; k + 1 &lt; scale / 2; k = k + 2) &#123;              r = random.nextFloat();// /产生概率              if (r &lt; Pc) &#123;                  OXCross1(k, k + 1);// 进行交叉                  //OXCross(k,k+1);//进行交叉              &#125; else &#123;                  r = random.nextFloat();// /产生概率                  // 变异                  if (r &lt; Pm) &#123;                      OnCVariation(k);                  &#125;                  r = random.nextFloat();// /产生概率                  // 变异                  if (r &lt; Pm) &#123;                      OnCVariation(k + 1);                  &#125;              &#125;          &#125;          if (k == scale / 2 - 1)// 剩最后一个染色体没有交叉L-1          &#123;              r = random.nextFloat();// /产生概率              if (r &lt; Pm) &#123;                  OnCVariation(k);              &#125;          &#125;        &#125;        // 类OX交叉算子      void OXCross(int k1, int k2) &#123;          int i, j, k, flag;          int ran1, ran2, temp;          int[] Gh1 = new int[cityNum];          int[] Gh2 = new int[cityNum];          // Random random = new Random(System.currentTimeMillis());            ran1 = random.nextInt(65535) % cityNum;          ran2 = random.nextInt(65535) % cityNum;          // System.out.println();          // System.out.println(&quot;-----------------------&quot;);          // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);            while (ran1 == ran2) &#123;              ran2 = random.nextInt(65535) % cityNum;          &#125;            if (ran1 &gt; ran2)// 确保ran1&lt;ran2          &#123;              temp = ran1;              ran1 = ran2;              ran2 = temp;          &#125;          // System.out.println();          // System.out.println(&quot;-----------------------&quot;);          // System.out.println(&quot;----&quot;+ran1+&quot;----&quot;+ran2);          // System.out.println(&quot;-----------------------&quot;);          // System.out.println();          flag = ran2 - ran1 + 1;// 删除重复基因前染色体长度          for (i = 0, j = ran1; i &lt; flag; i++, j++) &#123;              Gh1[i] = newPopulation[k2][j];              Gh2[i] = newPopulation[k1][j];          &#125;          // 已近赋值i=ran2-ran1个基因            for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度          &#123;              Gh1[j] = newPopulation[k1][k++];              for (i = 0; i &lt; flag; i++) &#123;                  if (Gh1[i] == Gh1[j]) &#123;                      break;                  &#125;              &#125;              if (i == flag) &#123;                  j++;              &#125;          &#125;            for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度          &#123;              Gh2[j] = newPopulation[k2][k++];              for (i = 0; i &lt; flag; i++) &#123;                  if (Gh2[i] == Gh2[j]) &#123;                      break;                  &#125;              &#125;              if (i == flag) &#123;                  j++;              &#125;          &#125;            for (i = 0; i &lt; cityNum; i++) &#123;              newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群              newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群          &#125;            // System.out.println(&quot;进行交叉--------------------------&quot;);          // System.out.println(k1+&quot;交叉后...&quot;);          // for (i = 0; i &lt; cityNum; i++) &#123;          // System.out.print(newPopulation[k1][i] + &quot;-&quot;);          // &#125;          // System.out.println();          // System.out.println(k2+&quot;交叉后...&quot;);          // for (i = 0; i &lt; cityNum; i++) &#123;          // System.out.print(newPopulation[k2][i] + &quot;-&quot;);          // &#125;          // System.out.println();          // System.out.println(&quot;交叉完毕--------------------------&quot;);      &#125;        // 交叉算子,相同染色体交叉产生不同子代染色体      public void OXCross1(int k1, int k2) &#123;          int i, j, k, flag;          int ran1, ran2, temp;          int[] Gh1 = new int[cityNum];          int[] Gh2 = new int[cityNum];          // Random random = new Random(System.currentTimeMillis());            ran1 = random.nextInt(65535) % cityNum;          ran2 = random.nextInt(65535) % cityNum;          while (ran1 == ran2) &#123;              ran2 = random.nextInt(65535) % cityNum;          &#125;            if (ran1 &gt; ran2)// 确保ran1&lt;ran2          &#123;              temp = ran1;              ran1 = ran2;              ran2 = temp;          &#125;            // 将染色体1中的第三部分移到染色体2的首部          for (i = 0, j = ran2; j &lt; cityNum; i++, j++) &#123;              Gh2[i] = newPopulation[k1][j];          &#125;            flag = i;// 染色体2原基因开始位置            for (k = 0, j = flag; j &lt; cityNum;)// 染色体长度          &#123;              Gh2[j] = newPopulation[k2][k++];              for (i = 0; i &lt; flag; i++) &#123;                  if (Gh2[i] == Gh2[j]) &#123;                      break;                  &#125;              &#125;              if (i == flag) &#123;                  j++;              &#125;          &#125;            flag = ran1;          for (k = 0, j = 0; k &lt; cityNum;)// 染色体长度          &#123;              Gh1[j] = newPopulation[k1][k++];              for (i = 0; i &lt; flag; i++) &#123;                  if (newPopulation[k2][i] == Gh1[j]) &#123;                      break;                  &#125;              &#125;              if (i == flag) &#123;                  j++;              &#125;          &#125;            flag = cityNum - ran1;            for (i = 0, j = flag; j &lt; cityNum; j++, i++) &#123;              Gh1[j] = newPopulation[k2][i];          &#125;            for (i = 0; i &lt; cityNum; i++) &#123;              newPopulation[k1][i] = Gh1[i];// 交叉完毕放回种群              newPopulation[k2][i] = Gh2[i];// 交叉完毕放回种群          &#125;      &#125;        // 多次对换变异算子      public void OnCVariation(int k) &#123;          int ran1, ran2, temp;          int count;// 对换次数            // Random random = new Random(System.currentTimeMillis());          count = random.nextInt(65535) % cityNum;            for (int i = 0; i &lt; count; i++) &#123;                ran1 = random.nextInt(65535) % cityNum;              ran2 = random.nextInt(65535) % cityNum;              while (ran1 == ran2) &#123;                  ran2 = random.nextInt(65535) % cityNum;              &#125;              temp = newPopulation[k][ran1];              newPopulation[k][ran1] = newPopulation[k][ran2];              newPopulation[k][ran2] = temp;          &#125;            /*          * for(i=0;i&lt;L;i++) &#123; printf(&quot;%d &quot;,newGroup[k][i]); &#125; printf(&quot;\n&quot;);          */      &#125;        public void solve() &#123;          int i;          int k;            // 初始化种群          initGroup();          // 计算初始化种群适应度，Fitness[max]          for (k = 0; k &lt; scale; k++) &#123;              fitness[k] = evaluate(oldPopulation[k]);              // System.out.println(fitness[k]);          &#125;          // 计算初始化种群中各个个体的累积概率，Pi[max]          countRate();          System.out.println(&quot;初始种群...&quot;);          for (k = 0; k &lt; scale; k++) &#123;              for (i = 0; i &lt; cityNum; i++) &#123;                  System.out.print(oldPopulation[k][i] + &quot;,&quot;);              &#125;              System.out.println();              System.out.println(&quot;----&quot; + fitness[k] + &quot; &quot; + Pi[k]);          &#125;                    for (t = 0; t &lt; MAX_GEN; t++) &#123;              //evolution1();              evolution();              // 将新种群newGroup复制到旧种群oldGroup中，准备下一代进化              for (k = 0; k &lt; scale; k++) &#123;                  for (i = 0; i &lt; cityNum; i++) &#123;                      oldPopulation[k][i] = newPopulation[k][i];                  &#125;              &#125;              // 计算种群适应度              for (k = 0; k &lt; scale; k++) &#123;                  fitness[k] = evaluate(oldPopulation[k]);              &#125;              // 计算种群中各个个体的累积概率              countRate();          &#125;            System.out.println(&quot;最后种群...&quot;);          for (k = 0; k &lt; scale; k++) &#123;              for (i = 0; i &lt; cityNum; i++) &#123;                  System.out.print(oldPopulation[k][i] + &quot;,&quot;);              &#125;              System.out.println();              System.out.println(&quot;---&quot; + fitness[k] + &quot; &quot; + Pi[k]);          &#125;            System.out.println(&quot;最佳长度出现代数：&quot;);          System.out.println(bestT);          System.out.println(&quot;最佳长度&quot;);          System.out.println(bestLength);          System.out.println(&quot;最佳路径：&quot;);          for (i = 0; i &lt; cityNum; i++) &#123;              System.out.print(bestTour[i] + &quot;,&quot;);          &#125;        &#125;              /**      * @param args      * @throws IOException      */      public static void main(String[] args) throws IOException &#123;          System.out.println(&quot;Start....&quot;);          GA ga = new GA(30, 48, 1000, 0.8f, 0.9f);          ga.init(&quot;c://data.txt&quot;);          ga.solve();      &#125;    &#125;</code></pre><p>参考：<a href="https://blog.csdn.net/tyhj_sf/article/details/53321527">https://blog.csdn.net/tyhj_sf/article/details/53321527</a></p>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法-旅行商问题</title>
      <link href="/posts/25120.html"/>
      <url>/posts/25120.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？</p><p>还有 背包、装箱 问题</p><p>注： 递归，时间复杂度为n!</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在对问题求解时，总是做出当前情况下的最好选择，否则将来可能会后悔，故名“贪心”。这是一种算法策略，每次选择得到的都是局部最优解。选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p><p>求解的问题分成若干个子问题，每一个子问题求解，得到子问题的局部最优解，子问题的局部最优解合成原问题的一个解</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>从某一个城市开始，每次选择一个城市，直到所有的城市被走完。 </p></li><li><p>每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p><pre><code> 从问题的某一初始解出发；     while （能朝给定总目标前进一步）     &#123;            利用可行的决策，求出可行解的一个解元素；     &#125; 由所有解元素组合成问题的一个可行解</code></pre></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不能保证最终为最优解</li><li>不能用来求最大最小解问题</li><li>无后效性</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>package noah; import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader; public class TxTsp &#123;     private int cityNum; // 城市数量    private int[][] distance; // 距离矩阵     private int[] colable;//代表列，也表示是否走过，走过置0    private int[] row;//代表行，选过置0     public TxTsp(int n) &#123;        cityNum = n;    &#125;     private void init(String filename) throws IOException &#123;        // 读取数据        int[] x;        int[] y;        String strbuff;        BufferedReader data = new BufferedReader(new InputStreamReader(                new FileInputStream(filename)));        distance = new int[cityNum][cityNum];        x = new int[cityNum];        y = new int[cityNum];        for (int i = 0; i &lt; cityNum; i++) &#123;            // 读取一行数据，数据格式1 6734 1453            strbuff = data.readLine();            // 字符分割            String[] strcol = strbuff.split(&quot; &quot;);            x[i] = Integer.valueOf(strcol[1]);// x坐标            y[i] = Integer.valueOf(strcol[2]);// y坐标        &#125;        data.close();         // 计算距离矩阵        // ，针对具体问题，距离计算方法也不一样，此处用的是att48作为案例，它有48个城市，距离计算方法为伪欧氏距离，最优值为10628        for (int i = 0; i &lt; cityNum - 1; i++) &#123;            distance[i][i] = 0; // 对角线为0            for (int j = i + 1; j &lt; cityNum; j++) &#123;                double rij = Math                        .sqrt(((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])                                * (y[i] - y[j])) / 10.0);                // 四舍五入，取整                int tij = (int) Math.round(rij);                if (tij &lt; rij) &#123;                    distance[i][j] = tij + 1;                    distance[j][i] = distance[i][j];                &#125; else &#123;                    distance[i][j] = tij;                    distance[j][i] = distance[i][j];                &#125;            &#125;        &#125;         distance[cityNum - 1][cityNum - 1] = 0;         colable = new int[cityNum];        colable[0] = 0;        for (int i = 1; i &lt; cityNum; i++) &#123;            colable[i] = 1;        &#125;         row = new int[cityNum];        for (int i = 0; i &lt; cityNum; i++) &#123;            row[i] = 1;        &#125;     &#125;        public void solve()&#123;                int[] temp = new int[cityNum];        String path=&quot;0&quot;;                int s=0;//计算距离        int i=0;//当前节点        int j=0;//下一个节点        //默认从0开始        while(row[i]==1)&#123;            //复制一行            for (int k = 0; k &lt; cityNum; k++) &#123;                temp[k] = distance[i][k];                //System.out.print(temp[k]+&quot; &quot;);            &#125;            //System.out.println();            //选择下一个节点，要求不是已经走过，并且与i不同            j = selectmin(temp);            //找出下一节点            row[i] = 0;//行置0，表示已经选过            colable[j] = 0;//列0，表示已经走过                        path+=&quot;--&gt;&quot; + j;            //System.out.println(i + &quot;--&gt;&quot; + j);            //System.out.println(distance[i][j]);            s = s + distance[i][j];            i = j;//当前节点指向下一节点        &#125;        System.out.println(&quot;路径:&quot; + path);        System.out.println(&quot;总距离为:&quot; + s);            &#125;        public int selectmin(int[] p)&#123;        int j = 0, m = p[0], k = 0;        //寻找第一个可用节点，注意最后一次寻找，没有可用节点        while (colable[j] == 0) &#123;            j++;            //System.out.print(j+&quot; &quot;);            if(j&gt;=cityNum)&#123;                //没有可用节点，说明已结束，最后一次为 *--&gt;0                m = p[0];                break;                //或者直接return 0;            &#125;            else&#123;                m = p[j];            &#125;        &#125;        //从可用节点J开始往后扫描，找出距离最小节点        for (; j &lt; cityNum; j++) &#123;            if (colable[j] == 1) &#123;                if (m &gt;= p[j]) &#123;                    m = p[j];                    k = j;                &#125;            &#125;        &#125;        return k;    &#125;      public void printinit() &#123;        System.out.println(&quot;print begin....&quot;);        for (int i = 0; i &lt; cityNum; i++) &#123;            for (int j = 0; j &lt; cityNum; j++) &#123;                System.out.print(distance[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        System.out.println(&quot;print end....&quot;);    &#125;     public static void main(String[] args) throws IOException &#123;        System.out.println(&quot;Start....&quot;);        TxTsp ts = new TxTsp(48);        ts.init(&quot;c://data.txt&quot;);        //ts.printinit();        ts.solve();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性dp LIS</title>
      <link href="/posts/37887.html"/>
      <url>/posts/37887.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>石子合并问题</title>
      <link href="/posts/11863.html"/>
      <url>/posts/11863.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环形DP</title>
      <link href="/posts/40386.html"/>
      <url>/posts/40386.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>状压DP</title>
      <link href="/posts/55387.html"/>
      <url>/posts/55387.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度优先广度优先</title>
      <link href="/posts/24306.html"/>
      <url>/posts/24306.html</url>
      
        <content type="html"><![CDATA[<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。整个遍历过程如下：</p><ol><li><p>首先将A节点压入栈中，stack（A）;</p></li><li><p>将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p></li><li><p>将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）；</p></li><li><p>将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）；</p></li><li><p>将E节点弹出，同时将E的子节点I压入，stack（I,C）；</p></li></ol><p>…依次往下，最终遍历完成</p><pre><code>public void depthFirst() &#123;    Stack&lt;Map&lt;String, Object&gt;&gt; nodeStack = new Stack&lt;Map&lt;String, Object&gt;&gt;();    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();    nodeStack.add(node);    while (!nodeStack.isEmpty()) &#123;        node = nodeStack.pop();        System.out.println(node);        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);        if (children != null &amp;&amp; !children.isEmpty()) &#123;            for (Map child : children) &#123;                nodeStack.push(child);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p> 广度优先遍历各个节点，需要使用到队列（Queue）这种数据结构，queue的特点是先进先出，其实也可以使用双端队列，区别就是双端队列首尾都可以插入和弹出节点。整个遍历过程如下：</p><ol><li><p>首先将A节点插入队列中，queue（A）;</p></li><li><p>将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；</p></li><li><p>将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;</p></li><li><p>将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；</p></li><li><p>将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；</p></li></ol><p>…依次往下，最终遍历完成</p><pre><code>public void breadthFirst() &#123;    Deque&lt;Map&lt;String, Object&gt;&gt; nodeDeque = new ArrayDeque&lt;Map&lt;String, Object&gt;&gt;();    Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;();    nodeDeque.add(node);    while (!nodeDeque.isEmpty()) &#123;        node = nodeDeque.peekFirst();        System.out.println(node);        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点        List&lt;Map&lt;String, Object&gt;&gt; children = getChildren(node);        if (children != null &amp;&amp; !children.isEmpty()) &#123;            for (Map child : children) &#123;                nodeDeque.add(child);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列最大连续子序列和，最长公共子串</title>
      <link href="/posts/51333.html"/>
      <url>/posts/51333.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数位DP</title>
      <link href="/posts/13990.html"/>
      <url>/posts/13990.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>插头DP</title>
      <link href="/posts/58609.html"/>
      <url>/posts/58609.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日乘子法</title>
      <link href="/posts/18339.html"/>
      <url>/posts/18339.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历</title>
      <link href="/posts/42854.html"/>
      <url>/posts/42854.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/** * 无向图 */public class NoDirectionGraph &#123;     private int mMaxSize; //图中包含的最大顶点数    private GraphVertex[] vertexList; //顶点数组    private int[][] indicatorMat; //指示顶点之间的连通关系的邻接矩阵    private int nVertex; //当前实际保存的顶点数目            public NoDirectionGraph(int maxSize) &#123;        mMaxSize = maxSize;        vertexList = new GraphVertex[mMaxSize];        indicatorMat = new int[mMaxSize][mMaxSize];        nVertex = 0;        //初始化邻接矩阵元素为0        for(int j=0;j&lt;mMaxSize;j++) &#123;            for(int k=0;k&lt;mMaxSize;k++) &#123;                indicatorMat[j][k] = 0;            &#125;        &#125;    &#125;            public void addVertex(GraphVertex v) &#123;        if(nVertex &lt; mMaxSize) &#123;            vertexList[nVertex++] = v;                    &#125; else &#123;            System.out.println(&quot;---插入失败，顶点数量已达上限!&quot;);        &#125;    &#125;        /**     * 修改邻接矩阵，添加新的边     * @param start     * @param end     */    public void addEdge(int start,int end) &#123;        indicatorMat[start][end] = 1;        indicatorMat[end][start] = 1;    &#125;        /**     * 打印邻接矩阵     */    public void printIndicatorMat() &#123;                for(int[] line:indicatorMat) &#123;            for(int i:line) &#123;                System.out.print(i + &quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;        /**     * 深度优先遍历     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数     */    public void DFS(int vertexIndex) &#123;        ArrayStack stack = new ArrayStack();        //1.添加检索元素到栈中        vertexList[vertexIndex].setVisited(true);        stack.push(vertexIndex);        int nextVertexIndex = getNextVertexIndex(vertexIndex);        while(!stack.isEmpty()) &#123; //不断地压栈、出栈，直到栈为空(检索元素也没弹出了栈)为止            if(nextVertexIndex != -1) &#123;                vertexList[nextVertexIndex].setVisited(true);                stack.push(nextVertexIndex);                stack.printElems();            &#125; else &#123;                stack.pop();            &#125;            //检索当前栈顶元素是否包含其他未遍历过的节点            if(!stack.isEmpty()) &#123;                nextVertexIndex = getNextVertexIndex(stack.peek());             &#125;        &#125;    &#125;        /**     * 得到当前顶点的下一个顶点所在行     * @param column     * @return     */    public int getNextVertexIndex(int column) &#123;        for(int i=0;i&lt;indicatorMat[column].length;i++) &#123;            if(indicatorMat[column][i] == 1 &amp;&amp; !vertexList[i].isVisited()) &#123;                return i;            &#125;        &#125;        return -1;    &#125;        /**     * 广度优先遍历     * @param vertexIndex 表示要遍历的起点,即图的邻接矩阵中的行数     */    public void BFS(int vertexIndex) &#123;        ChainQueue queue = new ChainQueue();        vertexList[vertexIndex].setVisited(true);        queue.insert(new QueueNode(vertexIndex));        int nextVertexIndex = getNextVertexIndex(vertexIndex);        while(!queue.isEmpty()) &#123;            if(nextVertexIndex != -1) &#123;                vertexList[nextVertexIndex].setVisited(true);                queue.insert(new QueueNode(nextVertexIndex));            &#125; else &#123;                queue.remove();            &#125;            if(!queue.isEmpty()) &#123;                nextVertexIndex = getNextVertexIndex(queue.peek().data);                queue.printElems();            &#125;        &#125;    &#125;&#125; /** * 使用数组实现栈结构 */public class ArrayStack &#123;     private int[] tArray;     private int topIndex = -1; //表示当前栈顶元素的索引位置    private int CAPACITY_STEP = 12; //数组容量扩展步长            public ArrayStack() &#123;        /***创建泛型数组的一种方法***/        tArray = new int[CAPACITY_STEP];     &#125;        /**     * 弹出栈顶元素方法     * @return     */    public int pop() &#123;        if(isEmpty()) &#123;            System.out.println(&quot;错误，栈中元素为空，不能pop&quot;);            return -1;        &#125; else &#123;            int i = tArray[topIndex];            tArray[topIndex--] = -1; //擦除pop元素            return i;        &#125;    &#125;        /**     * 向栈中插入一个元素     * @param t     */    public void push(int t) &#123;        //检查栈是否已满        if(topIndex == (tArray.length-1)) &#123;            //扩展容量            int[] tempArray = new int[tArray.length + CAPACITY_STEP];            for(int i=0;i&lt;tArray.length;i++) &#123;                tempArray[i] = tArray[i];            &#125;            tArray = tempArray;            tempArray = null;        &#125; else &#123;            topIndex ++;            tArray[topIndex] = t;        &#125;    &#125;        /**     * 得到栈顶元素，但不弹出     * @return     */    public int peek() &#123;        if(isEmpty()) &#123;            System.out.println(&quot;错误，栈中元素为空，不能peek&quot;);            return -1;        &#125; else &#123;            return tArray[topIndex];        &#125;    &#125;        /**     * 判断当前栈是否为空     * @return     */    public boolean isEmpty() &#123;        return (topIndex &lt; 0);    &#125;        /**     * 打印栈中元素     */    public void printElems() &#123;        for(int i=0;i&lt;=topIndex;i++) &#123;            System.out.print(tArray[i] + &quot; &quot;);        &#125;        System.out.println();    &#125;&#125;/** * 使用链表实现队列 */public class ChainQueue &#123;    private QueueNode head; // 指向队列头节点    private QueueNode tail; // 指向队列尾节点    private int size = 0; // 队列尺寸     public ChainQueue() &#123;     &#125;     /**     * 插入新节点到队列尾     */    public void insert(QueueNode node) &#123;         // 当然也可以这么写,添加tail.prev = node        if (head == null) &#123;            head = node;            tail = head;        &#125; else &#123;            node.next = tail;            tail.prev = node; // 双向连接，确保head.prev不为空            tail = node;        &#125;        size++;    &#125;     /**     * 移除队列首节点     */    public QueueNode remove() &#123;        if (!isEmpty()) &#123;            QueueNode temp = head;            head = head.prev;            size--;            return temp;        &#125; else &#123;            System.out.println(&quot;异常操作，当前队列为空!&quot;);            return null;        &#125;    &#125;     /**     * 队列是否为空     *      * @return     */    public boolean isEmpty() &#123;        if (size &gt; 0) &#123;            return false;        &#125; else &#123;            return true;        &#125;    &#125;     /**     * 返回队列首节点，但不移除     */    public QueueNode peek() &#123;        if (!isEmpty()) &#123;            return head;        &#125; else &#123;            System.out.println();            System.out.println(&quot;异常操作，当前队列为空!&quot;);            return null;        &#125;    &#125;     /**     * 返回队列大小     *      * @return     */    public int size() &#123;        return size;    &#125;        /**     * 打印队列中的元素     */    public void printElems() &#123;        QueueNode tempNode = head;        while(tempNode != null) &#123;            System.out.print(tempNode.data + &quot; &quot;);            tempNode = tempNode.prev;        &#125;        System.out.println();    &#125;&#125; /** * 节点类 *  * @author wly *  */class QueueNode &#123;    QueueNode prev;    QueueNode next;     int data;     public QueueNode(int data) &#123;        this.data = data;    &#125;     public int getData() &#123;        return data;    &#125;     public void setData(int data) &#123;        this.data = data;    &#125;     @Override    public String toString() &#123;        // TODO Auto-generated method stub        super.toString();        return data + &quot;&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单调队列优化</title>
      <link href="/posts/4900.html"/>
      <url>/posts/4900.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/posts/40091.html"/>
      <url>/posts/40091.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关键路径算法</title>
      <link href="/posts/24685.html"/>
      <url>/posts/24685.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>兔子数列</title>
      <link href="/posts/43734.html"/>
      <url>/posts/43734.html</url>
      
        <content type="html"><![CDATA[<p>自然界现象抽象化得到的数列模型——斐波那契数列</p><ol><li>初始状态：一对刚出生的兔子</li><li>下一步：生长</li><li><code>繁殖得到 一对刚出生的兔子-&gt; 第1步</code></li></ol><p>总结： 当月的兔子数&#x3D;上月兔子数+当月新生兔子  数列的当前列&#x3D;前两列之和</p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>指数阶算法，效率较低，时间复杂度爆炸增量</p><pre><code>    Fib1(int n)        &#123; if(n&lt;1)               return -1;          if(n==1||n==2)                return 1;           return Fib1(n-1)+Fib1(n-2);        &#125;    </code></pre><h2 id="数组记录先两项值"><a href="#数组记录先两项值" class="headerlink" title="数组记录先两项值"></a>数组记录先两项值</h2><p>时间复杂度从指数阶降到了多项式阶O(n),空间复杂度O(n)</p><pre><code>Fib2(intn)&#123;    if(n&lt;1)        return-1;    int[] a=new int[n];    a[1]=1;    a[2]=1;    for(int i=3;i&lt;=n;i++)        a[i]=a[i-1]+a[i-2];        return a[n];     &#125;&#125;             </code></pre><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>不记录中间结果，只记录中间项，空间复杂度降到O(1)</p><pre><code>Fib3(intn)&#123;    inti,s1,s2;    if(n&lt;1)        return-1;    if(n==1||n==2)        return1;    s1=1;s2=1;    for(i=3;i&lt;=n;i++)    &#123;        s2=s1+s2;//辗转相加法        s1=s2-s1;//记录前一项    &#125;    return s2; &#125; </code></pre><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p><code>斐波那契数列(F(n),F(n-1))为(1,1)与&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;的n-2次幂的乘积, 可通过递推求证</code></p><pre><code>   public static int ValueN(int n)&#123;         if(n&lt;1)&#123;             return 0;         &#125;         if(n==1 || n==2)&#123;             return 1;         &#125;          int [][] base=&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;          int [][] res=matrixPower(base,n-2);          return res[0][0]+res[1][0];       &#125;       public static int[][] matrixPower(int[][] m,int p)&#123;           if(p==0)               return null;           if(p==1)               return m;           int[][] res=matrixPower(m,p&gt;&gt;1);           res=muliMatrix(res,res);           if((p&amp;1)==1)&#123;               res=muliMatrix(res,m);           &#125;           return res;       &#125;       //求两个矩阵相乘得到一个新的矩阵       public static int[][] muliMatrix(int[][] m1,int[][] m2)&#123;           int [][] res=new int[m1.length][m2[0].length];           for(int i=0;i&lt;m1.length;i++)&#123;               for(int j=0;j&lt;m2[0].length;j++)&#123;                   for(int k=0;k&lt;m2.length;k++)&#123;                       res[i][j]+=m1[i][k]*m2[k][j];                   &#125;               &#125;           &#125;           return res;       &#125;   &#125;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>倍增</title>
      <link href="/posts/47317.html"/>
      <url>/posts/47317.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/42877.html"/>
      <url>/posts/42877.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RMQ算法</title>
      <link href="/posts/56550.html"/>
      <url>/posts/56550.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Prim算法</title>
      <link href="/posts/46211.html"/>
      <url>/posts/46211.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LCA最近公共祖先算法</title>
      <link href="/posts/53370.html"/>
      <url>/posts/53370.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/posts/35921.html"/>
      <url>/posts/35921.html</url>
      
        <content type="html"><![CDATA[<p>KMP算法解决的是字符串模式匹配定位问题</p><p>主串：  ABACBFG  —i<br>模式串：ABAD     —j</p><h2 id="简单算法："><a href="#简单算法：" class="headerlink" title="简单算法："></a>简单算法：</h2><p>从左到右一个一个匹配，遇到不匹配，i回到i-j+1,j回到0，重新匹配（不考虑模式串本身特性–最大前后缀数）</p><pre><code>/** * @param ts 主串 * @param ps 模式串 * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1 */public static int bf(String ts, String ps) &#123;    char[] t = ts.toCharArray();    char[] p = ps.toCharArray();    int i = 0; // 主串的位置    int j = 0; // 模式串的位置    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;       if (t[i] == p[j]) &#123; // 当两个字符相同，就比较下一个           i++;           j++;       &#125; else &#123;           i = i - j + 1; // 一旦不匹配，i后退           j = 0; // j归0       &#125;    &#125;    if (j == p.length) &#123;       return i - j;    &#125; else &#123;       return -1;    &#125;&#125;</code></pre><p>优化：考虑先前匹配的结果和模式串的特点（最长前缀），i可以不动，只移动j，到位置k</p><h2 id="寻找k"><a href="#寻找k" class="headerlink" title="寻找k"></a>寻找k</h2><p>规律： 最前面的k个字符和j之前的最后k个字符是一样的</p><p> <img src="http://thyrsi.com/t6/625/1543997868x1822611383.jpg" alt="alt text" title="示例"></p><h2 id="推导："><a href="#推导：" class="headerlink" title="推导："></a>推导：</h2><pre><code>T[i] != P[j] T[i-j ~ i-1] == P[0 ~ j-1] P[0 ~ k-1] == P[j-k ~ j-1]==&gt; T[i-k ~ i-1] == P[0 ~ k-1]</code></pre><h3 id="由于每个j对应的k都可能不同，可以找到一个j-k对应关系-next-j-k"><a href="#由于每个j对应的k都可能不同，可以找到一个j-k对应关系-next-j-k" class="headerlink" title="由于每个j对应的k都可能不同，可以找到一个j~k对应关系 next[j] = k"></a>由于每个j对应的k都可能不同，可以找到一个j~k对应关系 <code>next[j] = k</code></h3><h2 id="四个规则"><a href="#四个规则" class="headerlink" title="四个规则"></a>四个规则</h2><ol><li>j在最左边了，匹配失败，i指针后移</li><li><code>P[0 ~ k-1] == p[j-k ~ j-1] 且 P[k] == P[j]时，next[j+1] == k + 1 == next[j] + 1，找到最大公共前后缀数</code></li><li><code>P[0 ~ k-1] == p[j-k ~ j-1] 且 P[k] != P[j]时，k=next[k]（在位置k不匹配了，往下找不到更长的前缀字串了，但可以根据k找到最长前后缀数）</code></li></ol><blockquote><p>递归思想: 不匹配，递归找不匹配位置k前面有没有相同前缀后缀，一直找到next[0]&#x3D;-1为止，此时next[j]&#x3D;k+1&#x3D;-1+1&#x3D;0</p></blockquote><p><img src="http://thyrsi.com/t6/625/1543997916x1822611383.jpg" alt="alt text"></p><pre><code>public static int[] getNext(String ps) &#123;    char[] p = ps.toCharArray();    int[] next = new int[p.length];    next[0] = -1;    int j = 0;    int k = -1;    while (j &lt; p.length - 1) &#123;       if (k == -1 || p[j] == p[k]) &#123;           next[++j] = ++k;       &#125; else &#123;           k = next[k];       &#125;    &#125;    return next;&#125;</code></pre><h3 id="当P-j-x3D-x3D-P-next-j-已经与主串不匹配-96"><a href="#当P-j-x3D-x3D-P-next-j-已经与主串不匹配-96" class="headerlink" title="当P[j] &#x3D;&#x3D; P[next[j]],已经与主串不匹配&#96;"></a>当P[j] &#x3D;&#x3D; P[next[j]],已经与主串不匹配&#96;</h3><pre><code>public static int[] getNext(String ps) &#123;    char[] p = ps.toCharArray();    int[] next = new int[p.length];    next[0] = -1;    int j = 0;    int k = -1;    while (j &lt; p.length - 1) &#123;       if (k == -1 || p[j] == p[k]) &#123;           if (p[++j] == p[++k]) &#123; // 当两个字符相等时要跳过              next[j] = next[k];           &#125; else &#123;              next[j] = k;           &#125;       &#125; else &#123;           k = next[k];       &#125;    &#125;    return next;&#125;</code></pre><h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><pre><code>public static int KMP(String ts, String ps) &#123;    char[] t = ts.toCharArray();    char[] p = ps.toCharArray();    int i = 0; // 主串的位置    int j = 0; // 模式串的位置    int[] next = getNext(ps);    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;       if (j == -1 || t[i] == p[j]) &#123; // 当j为-1时，要移动的是i，当然j也要归0           i++;           j++;       &#125; else &#123;           // i不需要回溯了           // i = i - j + 1;           j = next[j]; // j回到指定位置       &#125;    &#125;    if (j == p.length) &#123;       return i - j;    &#125; else &#123;       return -1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EM算法</title>
      <link href="/posts/55519.html"/>
      <url>/posts/55519.html</url>
      
        <content type="html"><![CDATA[<p>极大似然估计：应用广泛的参数估计方法</p><p>链接：<a href="https://www.cnblogs.com/bigmoyan/p/4550375.html">EM算法详细推导和讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DP 树的最小支配集，最小点覆盖与最大独立集</title>
      <link href="/posts/145.html"/>
      <url>/posts/145.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随机森林</title>
      <link href="/posts/47295.html"/>
      <url>/posts/47295.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归</title>
      <link href="/posts/60504.html"/>
      <url>/posts/60504.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>logistic回归又称logistic回归分析，是一种广义的线性回归分析模型</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>词袋模型</title>
      <link href="/posts/23220.html"/>
      <url>/posts/23220.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/posts/52662.html"/>
      <url>/posts/52662.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>留一验证</title>
      <link href="/posts/25124.html"/>
      <url>/posts/25124.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-奇异值分解SVD</title>
      <link href="/posts/106.html"/>
      <url>/posts/106.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/pinard/p/6251584.html" title="SVD">奇异值分解在特征降维中的作用</a></p><p><a href="https://www.cnblogs.com/lzllovesyl/p/5243370.html" title="SVD">奇异值分解在推荐系统中的应用</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>欠采样undersampling，过采样oversampling</title>
      <link href="/posts/44165.html"/>
      <url>/posts/44165.html</url>
      
        <content type="html"><![CDATA[<p>又称为 上采样  下采样</p><h2 id="数据不平衡问题"><a href="#数据不平衡问题" class="headerlink" title="数据不平衡问题"></a>数据不平衡问题</h2><p>默认阈值(比如二分类正反例中0.5)导致模型输出倾向于数据多的类别</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>调整分类阈值，偏向数据少的类别</li><li>选择ROC或F1作为评估标准</li><li>过采样、欠采样</li></ol><h3 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h3><p>将样本数量少的类别生成的样本数量和数量多的类别一样多，合成新的样本来缓解类不平衡</p><p>注：随机过采样采用简单复制样本增加少数类样本，导致模型不够泛化</p><h3 id="欠采样"><a href="#欠采样" class="headerlink" title="欠采样"></a>欠采样</h3><p>从数量多的类别中抽取与等量的样本数据，抛弃一些样本来缓解类不平衡</p><h3 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a>SMOTE</h3><p>经典过采样</p><p>人工合成数据（Synthetic Minority Over-sampling Technique）</p><p>分析数量较少类别的样本数据，基于“插值”来为少数类合成新样本，并添加到数据集</p><ol><li>确定采样倍率 N（N为整数，N&gt;&#x3D;1）</li><li>计算少数类 样本x(i)到本样本欧式距离，得到x(i)的k个近邻</li><li>随机选择近邻x^, xnew &#x3D; x + rand(0,1)*(x^-x),重复N次，得到N个新样本</li><li>对所有少数类样本x(i)执行1，2操作，合成NT个新样本</li></ol>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降法</title>
      <link href="/posts/3313.html"/>
      <url>/posts/3313.html</url>
      
        <content type="html"><![CDATA[<h2 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h2>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最大似然</title>
      <link href="/posts/46933.html"/>
      <url>/posts/46933.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得从模型中抽取该n组样本观测值的概率最大，而不是像最小二乘估计法旨在得到使得模型能最好地拟合样本数据的参数估计量。</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间序列分析</title>
      <link href="/posts/60273.html"/>
      <url>/posts/60273.html</url>
      
        <content type="html"><![CDATA[<h2 id="自相关性"><a href="#自相关性" class="headerlink" title="自相关性"></a>自相关性</h2><p>协方差矩阵和相关系数主要研究两个连续变量的相似程度（相关性）</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据清洗</title>
      <link href="/posts/12365.html"/>
      <url>/posts/12365.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>特征选择</title>
      <link href="/posts/13744.html"/>
      <url>/posts/13744.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多元回归</title>
      <link href="/posts/38286.html"/>
      <url>/posts/38286.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于信息熵分词</title>
      <link href="/posts/5567.html"/>
      <url>/posts/5567.html</url>
      
        <content type="html"><![CDATA[<p>分片属性：分片概率、分片频度、自由度、凝固程度</p><h2 id="自由度"><a href="#自由度" class="headerlink" title="自由度"></a>自由度</h2><p>文本片段的自由运用程度</p><p>如果一个文本片段能够算作一个词的话，它应该能够灵活地出现在各种不同的环境中，具有非常丰富的左邻字集合和右邻字集合。</p><h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>衡量信息量大小</p><p>用信息熵来衡量一个文本片段的左邻字集合和右邻字集合丰富程度。考虑这么一句话”吃葡萄不吐葡萄皮不吃葡萄倒吐葡萄皮”，”葡萄”一词出现了四次，其中左邻字分别为 {吃, 吐, 吃, 吐} ，右邻字分别为 {不, 皮, 倒, 皮} 。根据公式，”葡萄”一词的左邻字的信息熵为 - (1&#x2F;2) · log(1&#x2F;2) - (1&#x2F;2) · log(1&#x2F;2) ≈ 0.693 ，它的右邻字的信息熵则为 - (1&#x2F;2) · log(1&#x2F;2) - (1&#x2F;4) · log(1&#x2F;4) - (1&#x2F;4) · log(1&#x2F;4) ≈ 1.04 。可见，在这个句子中，”葡萄”一词的右邻字更加丰富一些。</p><p>一个文本片段的自由运用程度为它的左邻字信息熵和右邻字信息熵中的较小值。</p><p>通过信息熵算法，可以很好的区分一些专有名词像玫瑰、蝙蝠等，一些地名像新西兰、伦敦等，这些自由度较低的词汇的</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/posts/51507.html"/>
      <url>/posts/51507.html</url>
      
        <content type="html"><![CDATA[<p>用于分类和回归的非监督学习方法，通过简单的决策规则（if-else）预测目标</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>思想简单，可视乎表达，易理解，可以处理多分类问题</li><li>可能会过拟合，此时需要剪枝、采用设置最小样本数目或树的深度</li><li>基于启发式算法，节点采用贪婪算法（局部最优），不能保证全局最优，可以随机抽取样本，训练多个树</li><li>过于复杂的概念，无法表达</li></ul><h2 id="决策树-CART"><a href="#决策树-CART" class="headerlink" title="决策树 CART"></a>决策树 CART</h2><p>CART: classifcation and regression tree</p><h2 id="irsi数据集构建分类决策树"><a href="#irsi数据集构建分类决策树" class="headerlink" title="irsi数据集构建分类决策树"></a>irsi数据集构建分类决策树</h2><pre><code>from sklearn.datasets import load_irisfrom sklearn import tree#加载iris数据集iris = load_iris()clf = tree.DecisionTreeClassifier()clf = clf.fit(iris.data, iris.target)import pydotplusdot_data = tree.export_graphviz(clf, out_file=None)#dot_data = tree.export_graphviz(clf, out_file=None,                               feature_names=iris.feature_names,                                class_names=iris.target_names,                                filled=True, rounded=True,                                special_characters=True)graph = pydotplus.graph_from_dot_data(dot_data)#导出决策树graph.write_pdf(&quot;iris.pdf&quot;) #Image(graph.create_png())</code></pre><p><img src="http://thyrsi.com/t6/625/1543991582x2890174459.jpg" alt="iris树"></p><h2 id="sklearn-example"><a href="#sklearn-example" class="headerlink" title="sklearn example"></a>sklearn example</h2><pre><code>import numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.tree import DecisionTreeClassifier# Parametersn_classes = 3plot_colors = &quot;ryb&quot;plot_step = 0.02# Load datairis = load_iris()for pairidx, pair in enumerate([[0, 1], [0, 2], [0, 3],                                [1, 2], [1, 3], [2, 3]]):    # We only take the two corresponding features    X = iris.data[:, pair]    y = iris.target    # Train    clf = DecisionTreeClassifier().fit(X, y)    # Plot the decision boundary    plt.subplot(2, 3, pairidx + 1)    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1    xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),                         np.arange(y_min, y_max, plot_step))    plt.tight_layout(h_pad=0.5, w_pad=0.5, pad=2.5)    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])    Z = Z.reshape(xx.shape)    cs = plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu)    plt.xlabel(iris.feature_names[pair[0]])    plt.ylabel(iris.feature_names[pair[1]])    # Plot the training points    for i, color in zip(range(n_classes), plot_colors):        idx = np.where(y == i)        plt.scatter(X[idx, 0], X[idx, 1], c=color, label=iris.target_names[i],                    cmap=plt.cm.RdYlBu, edgecolor=&#39;black&#39;, s=15)plt.suptitle(&quot;Decision surface of a decision tree using paired features&quot;)plt.legend(loc=&#39;lower right&#39;, borderpad=0, handletextpad=0)plt.axis(&quot;tight&quot;)plt.show()</code></pre><p>   <img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_iris_0011.png" alt="iris树"></p><p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_iris.html#sphx-glr-auto-examples-tree-plot-iris-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_iris.html#sphx-glr-auto-examples-tree-plot-iris-py</a></p><h2 id="决策树回归"><a href="#决策树回归" class="headerlink" title="决策树回归"></a>决策树回归</h2><p>max_depth：图的深度，值太大会导致过拟合</p><pre><code># Import the necessary modules and librariesimport numpy as npfrom sklearn.tree import DecisionTreeRegressorimport matplotlib.pyplot as plt# Create a random datasetrng = np.random.RandomState(1)X = np.sort(5 * rng.rand(80, 1), axis=0)y = np.sin(X).ravel() #学习sin曲线y[::5] += 3 * (0.5 - rng.rand(16)) #干扰值# Fit regression modelregr_1 = DecisionTreeRegressor(max_depth=2)regr_2 = DecisionTreeRegressor(max_depth=5)regr_1.fit(X, y)regr_2.fit(X, y)# PredictX_test = np.arange(0.0, 5.0, 0.01)[:, np.newaxis]y_1 = regr_1.predict(X_test)y_2 = regr_2.predict(X_test)# Plot the resultsplt.figure()plt.scatter(X, y, s=20, edgecolor=&quot;black&quot;,            c=&quot;darkorange&quot;, label=&quot;data&quot;)plt.plot(X_test, y_1, color=&quot;cornflowerblue&quot;,         label=&quot;max_depth=2&quot;, linewidth=2)plt.plot(X_test, y_2, color=&quot;yellowgreen&quot;, label=&quot;max_depth=5&quot;, linewidth=2)plt.xlabel(&quot;data&quot;)plt.ylabel(&quot;target&quot;)plt.title(&quot;Decision Tree Regression&quot;)plt.legend()plt.show()</code></pre><p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_tree_regression_001.png" alt="iris树"></p><p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_tree_regression.html#sphx-glr-auto-examples-tree-plot-tree-regression-py</a></p><h2 id="多输出问题"><a href="#多输出问题" class="headerlink" title="多输出问题"></a>多输出问题</h2><pre><code>import numpy as npimport matplotlib.pyplot as pltfrom sklearn.tree import DecisionTreeRegressor# Create a random datasetrng = np.random.RandomState(1)X = np.sort(200 * rng.rand(100, 1) - 100, axis=0)y = np.array([np.pi * np.sin(X).ravel(), np.pi * np.cos(X).ravel()]).T #输出X正弦 余弦y[::5, :] += (0.5 - rng.rand(20, 2)) #干扰# Fit regression modelregr_1 = DecisionTreeRegressor(max_depth=2)regr_2 = DecisionTreeRegressor(max_depth=5)regr_3 = DecisionTreeRegressor(max_depth=8)regr_1.fit(X, y)regr_2.fit(X, y)regr_3.fit(X, y)# PredictX_test = np.arange(-100.0, 100.0, 0.01)[:, np.newaxis]y_1 = regr_1.predict(X_test)y_2 = regr_2.predict(X_test)y_3 = regr_3.predict(X_test)# Plot the resultsplt.figure()s = 25plt.scatter(y[:, 0], y[:, 1], c=&quot;navy&quot;, s=s,            edgecolor=&quot;black&quot;, label=&quot;data&quot;)plt.scatter(y_1[:, 0], y_1[:, 1], c=&quot;cornflowerblue&quot;, s=s,            edgecolor=&quot;black&quot;, label=&quot;max_depth=2&quot;)plt.scatter(y_2[:, 0], y_2[:, 1], c=&quot;red&quot;, s=s,            edgecolor=&quot;black&quot;, label=&quot;max_depth=5&quot;)plt.scatter(y_3[:, 0], y_3[:, 1], c=&quot;orange&quot;, s=s,            edgecolor=&quot;black&quot;, label=&quot;max_depth=8&quot;)plt.xlim([-6, 6])plt.ylim([-6, 6])plt.xlabel(&quot;target 1&quot;)plt.ylabel(&quot;target 2&quot;)plt.title(&quot;Multi-output Decision Tree Regression&quot;)plt.legend(loc=&quot;best&quot;)plt.show()</code></pre><p><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_tree_regression_multioutput_001.png" alt="iris树"></p><p>链接：<a href="https://scikit-learn.org/stable/auto_examples/tree/plot_tree_regression_multioutput.html#sphx-glr-auto-examples-tree-plot-tree-regression-multioutput-py">https://scikit-learn.org/stable/auto_examples&#x2F;tree&#x2F;plot_tree_regression_multioutput.html#sphx-glr-auto-examples-tree-plot-tree-regression-multioutput-py</a> </p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息熵</title>
      <link href="/posts/5656.html"/>
      <url>/posts/5656.html</url>
      
        <content type="html"><![CDATA[<p>不确定性程度的物理量</p><p>自封闭系统的运动向均匀分布—熵总是增加的</p><h2 id="联合熵"><a href="#联合熵" class="headerlink" title="联合熵"></a>联合熵</h2><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>ID3</p><h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h2><p>C4.5</p><h2 id="gini系数"><a href="#gini系数" class="headerlink" title="gini系数"></a>gini系数</h2><p>CART</p><h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉验证</title>
      <link href="/posts/54780.html"/>
      <url>/posts/54780.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉熵</title>
      <link href="/posts/37871.html"/>
      <url>/posts/37871.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中文分词</title>
      <link href="/posts/742.html"/>
      <url>/posts/742.html</url>
      
        <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>基于字典、词库匹配</li><li>基于词频度统计</li><li>基于知识理解</li></ul><h2 id="字典、词库匹配"><a href="#字典、词库匹配" class="headerlink" title="字典、词库匹配"></a>字典、词库匹配</h2><p>中文复杂、丰富，词典、词库匹配无法有效处理大规模文本分词处理</p><ol><li>逐词遍历法：全字典遍历一遍，效率低，不适用于大系统</li><li>机械分词法</li></ol><h3 id="最大正向匹配法"><a href="#最大正向匹配法" class="headerlink" title="最大正向匹配法"></a>最大正向匹配法</h3><p>假定词典词最大长度为i,被处理文档的当前字串中的前i个字作为匹配字段，匹配成功，则切分出来，匹配失败，则i-1，继续匹配，若成功则i+1，知道文档处理完成</p><h3 id="逆向最大匹配法"><a href="#逆向最大匹配法" class="headerlink" title="逆向最大匹配法"></a>逆向最大匹配法</h3><p>文档逆序处理，通过逆序词典匹配，汉语中偏正结构较多，若从后向前匹配，可以适当提高精确度，逆向最大匹配法比正向最大匹配法的误差要小</p><h3 id="最少切分法"><a href="#最少切分法" class="headerlink" title="最少切分法"></a>最少切分法</h3><p>使每一句中切出的词数最小</p><h3 id="双向匹配法"><a href="#双向匹配法" class="headerlink" title="双向匹配法"></a>双向匹配法</h3><p>将正向最大匹配法与逆向最大匹配法组合，如果两种分词方法得到的匹配结果相同，则认为分词正确，否则，按最小集处理</p><h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>考虑到相邻字词关系、词频、共现信息，有较好的实用性</p><h3 id="全切分和基于词的频度统计的分词方法"><a href="#全切分和基于词的频度统计的分词方法" class="headerlink" title="全切分和基于词的频度统计的分词方法"></a>全切分和基于词的频度统计的分词方法</h3><p>基于词的频度统计的分词方法是一种全切分方法</p><p>全切分要求获得输入序列的所有可接受的切分形式，而部分切分只取得一种或几种可接受的切分形式，由于部分切分忽略了可能的其他切分形式，所以建立在部分切分基础上的分词方法不管采取何种歧义纠正策略，都可能会遗漏正确的切分，造成分词错误或失败。而建立在全切分基础上的分词方法，由于全切分取得了所有可能的切分形式，因而从根本上避免了可能切分形式的遗漏，克服了部分切分方法的缺陷。</p><p>问题：</p><ol><li><p>全切分算法只是能获得正确分词的前提，因为全切分不具有歧义检测功能，最终分词结果的正确性和完全性依赖于独立的歧义处理方法，如果评测有误，也会造成错误的结果。</p></li><li><p>全切分的切分结果个数随句子长度的增长呈指数增长，一方面将导致庞大的无用数据充斥于存储数据库；另一方面当句长达到一定长度后，由于切分形式过多,造成分词效率严重下降。</p></li></ol><p>解决方案：</p><p>基于词的频度统计的分词方法：</p><p>这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。</p><h2 id="基于知识理解"><a href="#基于知识理解" class="headerlink" title="基于知识理解"></a>基于知识理解</h2><p>基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。</p><h2 id="并行分词方法"><a href="#并行分词方法" class="headerlink" title="并行分词方法"></a>并行分词方法</h2><p>并行分词方法：这种分词方法借助于一个含有分词词库的管道进行 ,比较匹配过程是分步进行的 ,每一步可以对进入管道中的词同时与词库中相应的词进行比较 ,由于同时有多个词进行比较匹配 ,因而分词速度可以大幅度提高。这种方法涉及到多级内码理论和管道的词典数据结构。（详细算法可以参考吴胜远的《并行分词方法的研究》。）</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xgboost</title>
      <link href="/posts/50689.html"/>
      <url>/posts/50689.html</url>
      
        <content type="html"><![CDATA[<p>参考: [博客 xgboost原理]( <a href="https://www.cnblogs.com/zhouxiaohui888/p/6008368.html">https://www.cnblogs.com/zhouxiaohui888/p/6008368.html</a> “xgboost”）</p><p>参考: <a href="https://github.com/dmlc/xgboost" title="xgboost">github xgboost学习</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>svm</title>
      <link href="/posts/22038.html"/>
      <url>/posts/22038.html</url>
      
        <content type="html"><![CDATA[<p>在特征空间上找到最佳的分离超平面使得训练集上正负样本间隔最大</p><p>用来解决二分类问题的有监督学习算法</p><p>引入了核方法之后SVM也可以用来解决非线性问题</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。</li><li>软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。</li><li>非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。</li></ul><p>参考: <a href="https://blog.csdn.net/liugan528/article/details/79448379" title="svm">svm</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>softmax回归</title>
      <link href="/posts/27391.html"/>
      <url>/posts/27391.html</url>
      
        <content type="html"><![CDATA[<p>可以看作是逻辑回归的推广</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-ResNet</title>
      <link href="/posts/28677.html"/>
      <url>/posts/28677.html</url>
      
        <content type="html"><![CDATA[<p>深度残差网络（Deep residual network, ResNet）的提出是CNN图像史上的一件里程碑事件</p><p>从经验来看，网络的深度对模型的性能至关重要，当增加网络层数后，网络可以进行更加复杂的特征模式的提取，所以当模型更深时理论上可以取得更好的结果，从图2中也可以看出网络越深而效果越好的一个实践证据。但是更深的网络其性能一定会更好吗？实验发现深度网络出现了退化问题（Degradation problem）：网络深度增加时，网络准确度出现饱和，甚至出现下降。这个现象可以在图3中直观看出来：56层的网络比20层网络效果还要差。这不会是过拟合问题，因为56层网络的训练误差同样高。我们知道深层网络存在着梯度消失或者爆炸的问题，这使得深度学习模型很难训练。但是现在已经存在一些技术手段如BatchNorm来缓解这个问题。因此，出现深度网络的退化问题是非常令人诧异的。</p><p>深度网络的退化问题至少说明深度网络不容易训练。但是我们考虑这样一个事实：现在你有一个浅层网络，你想通过向上堆积新层来建立深层网络，一个极端情况是这些增加的层什么也不学习，仅仅复制浅层网络的特征，即这样新层是恒等映射（Identity mapping）。在这种情况下，深层网络应该至少和浅层网络性能一样，也不应该出现退化现象。好吧，你不得不承认肯定是目前的训练方法有问题，才使得深层网络很难去找到一个好的参数。</p><p>这个有趣的假设让何博士灵感爆发，他提出了残差学习来解决退化问题。对于一个堆积层结构（几层堆积而成）当输入为时其学习到的特征记为，现在我们希望其可以学习到残差，这样其实原始的学习特征是。之所以这样是因为残差学习相比原始特征直接学习更容易。当残差为0时，此时堆积层仅仅做了恒等映射，至少网络性能不会下降，实际上残差不会为0，这也会使得堆积层在输入特征基础上学习到新的特征，从而拥有更好的性能。残差学习的结构如图4所示。这有点类似与电路中的“短路”，所以是一种短路连接（shortcutconnection）。</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hinge损失函数</title>
      <link href="/posts/6463.html"/>
      <url>/posts/6463.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GMM模型</title>
      <link href="/posts/35874.html"/>
      <url>/posts/35874.html</url>
      
        <content type="html"><![CDATA[<p>高斯混合模型是一种混合模型，混合的基本分布是高斯分布</p><p>参考《统计学习方法》</p><p>链接：<a href="https://www.cnblogs.com/mmziscoming/p/5750849.html">浅显易懂的GMM模型及其训练过程</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GBDT原理</title>
      <link href="/posts/134.html"/>
      <url>/posts/134.html</url>
      
        <content type="html"><![CDATA[<p>Gradient Boosting Decision Tree 迭代决策树，泛化能力较强</p><p>几乎可用于所有回归问题（线性&#x2F;非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）。<br>可用于<a href="http://research.microsoft.com/pubs/132652/MSR-TR-2010-82.pdf" title="搜索排序">搜索排序</a></p><h2 id="Regression-Decistion-Tree"><a href="#Regression-Decistion-Tree" class="headerlink" title="Regression Decistion Tree"></a>Regression Decistion Tree</h2><h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>C4.5分类树:在每次分枝时，是穷举每一个feature的每一个阈值，找到使得按照feature&lt;&#x3D;阈值，和feature&gt;阈值分成的两个分枝的熵最大的feature和阈值（熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1），按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。</p><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差–即（每个人的年龄-预测年龄）^2 的总和 &#x2F; N，或者说是每个人的预测误差平方和 除以 N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。</p><p>参考：<a href="http://www.schonlau.net/publication/05stata_boosting.pdf">http://www.schonlau.net/publication/05stata_boosting.pdf</a></p><h2 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h2><p>多棵树来共同决策。GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义，简单吧。</p><p>残差： A的预测值 + A的残差 &#x3D; A的实际值 ，残差为0，极为真实值，（过拟合问题）</p><p>优点：Boosting的最大好处在于，每一步的残差计算其实变相地增大了分错instance的权重，而已经分对的instance则都趋向于0。这样后面的树就能越来越专注那些前面被分错的instance。</p><p>Adaboost是另一种boost方法，它按分类对错，分配不同的weight，计算cost function时使用这些weight，从而让“错分的样本权重越来越大，使它们更被重视”。Bootstrap也有类似思想，它在每一步迭代时不改变模型本身，也不计算残差，而是从N个instance训练集中按一定概率重新抽取N个instance出来（单个instance可以被重复sample），对着这N个新的instance再训练一轮。由于数据集变了迭代模型训练结果也不一样，而一个instance被前面分错的越厉害，它的概率就被设的越高，这样就能同样达到逐步关注被分错的instance，逐步完善的效果。Adaboost的方法被实践证明是一种很好的防止过拟合的方法，但至于为什么则至今没从理论上被证明。GBDT也可以在使用残差的同时引入Bootstrap re-sampling，GBDT多数实现版本中也增加的这个选项，但是否一定使用则有不同看法。re-sampling一个缺点是它的随机性，即同样的数据集合训练两遍结果是不一样的，也就是模型不可稳定复现，这对评估是很大挑战，比如很难说一个模型变好是因为你选用了更好的feature，还是由于这次sample的随机因素。</p><p>参考：<a href="http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting">http://en.wikipedia.org/wiki/Gradient_boosted_trees#Gradient_tree_boosting</a></p><h2 id="Shrinkage"><a href="#Shrinkage" class="headerlink" title="Shrinkage"></a>Shrinkage</h2><p>每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。</p><p>没用Shrinkage时：（yi表示第i棵树上y的预测值， y(1~i)表示前i棵树y的综合预测值）</p><p>y(i+1) &#x3D; 残差(y1<del>yi)， 其中： 残差(y1</del>yi) &#x3D;  y真实值 - y(1 ~ i)</p><p>y(1 ~ i) &#x3D; SUM(y1, …, yi)</p><p>Shrinkage不改变第一个方程，只把第二个方程改为： </p><p>y(1 ~ i) &#x3D; y(1 ~ i-1) + step * yi</p><p>即Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分（step*残差）逐步逼近目标，step一般都比较小，如0.01~0.001（注意该step非gradient的step），导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。</p><h2 id="RankNet"><a href="#RankNet" class="headerlink" title="RankNet"></a>RankNet</h2><p>实际的搜索排序使用的是LambdaMART算法，必须指出的是由于这里要使用排序需要的cost function，LambdaMART迭代用的并不是残差。Lambda在这里充当替代残差的计算方法，它使用了一种类似Gradient*步长模拟残差的方法。这里的MART在求解方法上和之前说的残差略有不同，其区别描述见这里。</p><p>就像所有的机器学习一样，搜索排序的学习也需要训练集，这里一般是用人工标注实现，即对每一个(query,doc) pair给定一个分值（如1,2,3,4）,分值越高表示越相关，越应该排到前面。然而这些绝对的分值本身意义不大，例如你很难说1分和2分文档的相关程度差异是1分和3分文档差距的一半。相关度本身就是一个很主观的评判，标注人员无法做到这种定量标注，这种标准也无法制定。但标注人员很容易做到的是”AB都不错，但文档A比文档B更相关，所以A是4分，B是3分“。RankNet就是基于此制定了一个学习误差衡量方法，即cost function。具体而言，RankNet对任意两个文档A,B，通过它们的人工标注分差，用sigmoid函数估计两者顺序和逆序的概率P1。然后同理用机器学习到的分差计算概率P2（sigmoid的好处在于它允许机器学习得到的分值是任意实数值，只要它们的分差和标准分的分差一致，P2就趋近于P1）。这时利用P1和P2求的两者的交叉熵，该交叉熵就是cost function。它越低说明机器学得的当前排序越趋近于标注排序。为了体现NDCG的作用（NDCG是搜索排序业界最常用的评判标准），RankNet还在cost function中乘以了NDCG。</p><p>好，现在我们有了cost function，而且它是和各个文档的当前分值yi相关的，那么虽然我们不知道它的全局最优方向，但可以求导求Gradient，Gradient即每个文档得分的一个下降方向组成的N维向量，N为文档个数（应该说是query-doc pair个数）。这里仅仅是把”求残差“的逻辑替换为”求梯度“，可以这样想：梯度方向为每一步最优方向，累加的步数多了，总能走到局部最优点，若该点恰好为全局最优点，那和用残差的效果是一样的。这时套到之前讲的逻辑，GDBT就已经可以上了。那么最终排序怎么产生呢？很简单，每个样本通过Shrinkage累加都会得到一个最终得分，直接按分数从大到小排序就可以了（因为机器学习产生的是实数域的预测分，极少会出现在人工标注中常见的两文档分数相等的情况，几乎不同考虑同分文档的排序方式）</p><p>另外，如果feature个数太多，每一棵回归树都要耗费大量时间，这时每个分支时可以随机抽一部分feature来遍历求最优（ELF源码实现方式）。</p><p>参考：<a href="https://www.cnblogs.com/pinard/p/6140514.html">https://www.cnblogs.com/pinard/p/6140514.html</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-机器学习-GAN"><a href="#title-机器学习-GAN" class="headerlink" title="title:机器学习-GAN"></a>title:机器学习-GAN</h2><p>Generative Adversarial Network，就是大家耳熟能详的 GAN，由 Ian Goodfellow 首先提出，在这两年更是深度学习中最热门的东西，仿佛什么东西都能由 GAN 做出来。我最近刚入门 GAN，看了些资料，做一些笔记。</p><p>1.Generation<br>什么是生成（generation）？就是模型通过学习一些数据，然后生成类似的数据。让机器看一些动物图片，然后自己来产生动物的图片，这就是生成。</p><p>以前就有很多可以用来生成的技术了，比如 auto-encoder（自编码器）</p><p>你训练一个 encoder，把 input 转换成 code，然后训练一个 decoder，把 code 转换成一个 image，然后计算得到的 image 和 input 之间的 MSE（mean square error），训练完这个 model 之后，取出后半部分 NN Decoder，输入一个随机的 code，就能 generate 一个 image。</p><p>但是 auto-encoder 生成 image 的效果，当然看着很别扭啦，一眼就能看出真假。所以后来还提出了比如VAE这样的生成模型，我对此也不是很了解，在这就不细说。</p><p>上述的这些生成模型，其实有一个非常严重的弊端。比如 VAE，它生成的 image 是希望和 input 越相似越好，但是 model 是如何来衡量这个相似呢？model 会计算一个 loss，采用的大多是 MSE，即每一个像素上的均方差。loss 小真的表示相似嘛？</p><p><a href="https://www.cnblogs.com/bonelee/p/9166084.html" title="gan">gan</a></p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>baggging</title>
      <link href="/posts/2664.html"/>
      <url>/posts/2664.html</url>
      
        <content type="html"><![CDATA[<p>又放回采样</p><p>OOB数据</p><p>测试误差</p>]]></content>
      
      
      <categories>
          
          <category> mechine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/posts/23014.html"/>
      <url>/posts/23014.html</url>
      
        <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>开始节点--&gt;  数据元素 ... --&gt; 终端节点</code></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>clear、isEmpty、length、get、insert、remove、indexOf</p><pre><code>public interface IList &#123;    // 线性表置空操作    public void clear();    // 判断线性表是否为空操作    public boolean isEmpty();    // 获取线性表中元素的长度操作    public int length();    // 获取指定位置上面的元素操作    public Object get(int i);    // 在指定位置上面插入元素的操作    public void insert(int i, Object x);    // 删除指定位置上面的元素的操作    public void remove(int i);    // 查找指定元素的位置首次出现的位置操作    public int indexOf(Object x);    // 显示线性表中的内容操作    public void display();&#125;</code></pre><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序存储， 逻辑上相邻的数据元素，在物理存储上也是相邻的。 不便于插入和删除</p><pre><code>   public class SqList implements IList &#123;       // 线性表存储空间       private Object[] listElem;       // 线性表的当前长度       private int curLen;          // 顺序表类的构造函数，构造一个存储空间容量为maxSize的线性表       public SqList(int maxSize) &#123;           // TODO Auto-generated constructor stub           curLen = 0;           listElem = new Object[maxSize];       &#125;          // 将一个已经存在的线性表置成空表       public void clear() &#123;           // TODO Auto-generated method stub           // 置顺序表的当前长度为0           curLen = 0;       &#125;          // 判断线性表中的数据元素的个数是否为0，若为0则返回true，否则返回false       public boolean isEmpty() &#123;           // TODO Auto-generated method stub           return curLen == 0;       &#125;          // 求线性表中的数据元素的个数并返回其值       public int length() &#123;           // TODO Auto-generated method stub           // 返回顺序表的当前长度           return curLen;       &#125;          // 读取到线性表中的第i个数据元素并由函数返回其值，其中i的取值范围为0≤i≤length()-1，若i不在此范围则抛出异常       public Object get(int i) &#123;           // TODO Auto-generated method stub           if (i &lt; 0 || i &gt;= curLen) &#123;               throw new RuntimeException(&quot;第&quot; + i + &quot;个元素不存在&quot;);           &#125;           return listElem[i];       &#125;          // 在线性表的第i个数据元素之前插入一个值位x的数据元素       public void insert(int i, Object x) &#123;           // TODO Auto-generated method stub           // 判断表是否满了           if (curLen == listElem.length) &#123;               throw new RuntimeException(&quot;存储空间已经满了，无法插入新的元素&quot;);           &#125;           // 插入的位置不合法           if (i &lt; 0 || i &gt; curLen) &#123;               throw new RuntimeException(&quot;插入的位置不合法&quot;);           &#125;           // 必须要从最后一个元素开始依次逐个后移动，直到第i个数据元素移动完毕为止。           for (int j = curLen; j &gt; i; j--) &#123;               listElem[j] = listElem[j - 1];           &#125;           listElem[i] = x;           curLen++;       &#125;          public void remove(int i) &#123;           // TODO Auto-generated method stub           if (i &lt; 0 || i &gt; curLen - 1) &#123;               throw new RuntimeException(&quot;删除的位置不合法&quot;);           &#125;           for (int j = i; j &lt; curLen; j++) &#123;               listElem[j] = listElem[j+1];           &#125;           curLen--;       &#125;          // 返回线性表中首次出现指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1       public int indexOf(Object x) &#123;           // TODO Auto-generated method stub           for (int i = 0; i &lt; curLen; i++) &#123;               if (listElem[i].equals(x)) &#123;                   return i;               &#125;           &#125;           return -1;       &#125;          // 输出线性表中的数据元素       public void display() &#123;           // TODO Auto-generated method stub           for (int i = 0; i &lt; curLen; i++) &#123;               System.out.print(listElem[i] + &quot; &quot;);           &#125;           System.out.println();       &#125;          // 测试       public static void main(String[] args) &#123;           SqList sqList = new SqList(10);           sqList.insert(0, &quot;a&quot;);           sqList.insert(1, &quot;z&quot;);           sqList.insert(2, &quot;d&quot;);           sqList.insert(3, &quot;m&quot;);           sqList.insert(4, &quot;z&quot;);           int order = sqList.indexOf(&quot;z&quot;);           if (order!=-1) &#123;               System.out.println(&quot;顺序表中第一次出现的值为z的数据元素的位置为：&quot;+order);           &#125;else &#123;               System.out.println(&quot;顺序表中不包括z元素&quot;);           &#125;       &#125;   &#125;</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式存储，单向链表，节点保存下一个节点的引用，便于插入和删除</p><pre><code>public class Node &#123;    // 存放结点的值    private Object data;    // 后继结点的引用    private Node next;    // 无参数时的构造函数    public Node() &#123;        // TODO Auto-generated constructor stub        this(null, null);    &#125;    // 带有一个参数时的构造函数    public Node(Object data) &#123;        this(data, null);    &#125;    // 带有两个参数时的构造函数    public Node(Object data, Node next) &#123;        this.data = data;        this.next = next;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data = data;    &#125;    public Node getNext() &#123;        return next;    &#125;    public void setNext(Node next) &#123;        this.next = next;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/posts/28769.html"/>
      <url>/posts/28769.html</url>
      
        <content type="html"><![CDATA[<p>红黑树是特殊的二叉查找树</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点是黑色。 （这里叶子节点，是指为空的叶子节点！）</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><p>注：确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;    private RBTNode&lt;T&gt; mRoot;    // 根结点    private static final boolean RED   = false;    private static final boolean BLACK = true;    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;        boolean color;        // 颜色        T key;                // 关键字(键值)        RBTNode&lt;T&gt; left;    // 左孩子        RBTNode&lt;T&gt; right;    // 右孩子        RBTNode&lt;T&gt; parent;    // 父结点        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;            this.key = key;            this.color = color;            this.parent = parent;            this.left = left;            this.right = right;        &#125;    &#125;    ...&#125;public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;    private RBTNode&lt;T&gt; mRoot;    // 根结点    private static final boolean RED   = false;    private static final boolean BLACK = true;    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;        boolean color;        // 颜色        T key;                // 关键字(键值)        RBTNode&lt;T&gt; left;    // 左孩子        RBTNode&lt;T&gt; right;    // 右孩子        RBTNode&lt;T&gt; parent;    // 父结点        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;            this.key = key;            this.color = color;            this.parent = parent;            this.left = left;            this.right = right;        &#125;    &#125;    ...&#125;/*  * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： *      px                              px *     /                               / *    x                               y                 *   /  \      --(左旋)-.           / \                # *  lx   y                          x  ry      *     /   \                       /  \ *    ly   ry                     lx  ly   * * */private void leftRotate(RBTNode&lt;T&gt; x) &#123;    // 设置x的右孩子为y    RBTNode&lt;T&gt; y = x.right;    // 将 “y的左孩子” 设为 “x的右孩子”；    // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”    x.right = y.left;    if (y.left != null)        y.left.parent = x;    // 将 “x的父亲” 设为 “y的父亲”    y.parent = x.parent;    if (x.parent == null) &#123;        this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点    &#125; else &#123;        if (x.parent.left == x)            x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”        else            x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”    &#125;        // 将 “x” 设为 “y的左孩子”    y.left = x;    // 将 “x的父节点” 设为 “y”    x.parent = y;&#125;/*  * 对红黑树的节点(y)进行右旋转 * * 右旋示意图(对节点y进行左旋)： *            py                               py *           /                                / *          y                                x                   *         /  \      --(右旋)-.            /  \                     # *        x   ry                           lx   y   *       / \                                   / \                   # *      lx  rx                                rx  ry *  */private void rightRotate(RBTNode&lt;T&gt; y) &#123;    // 设置x是当前节点的左孩子。    RBTNode&lt;T&gt; x = y.left;    // 将 “x的右孩子” 设为 “y的左孩子”；    // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”    y.left = x.right;    if (x.right != null)        x.right.parent = y;    // 将 “y的父亲” 设为 “x的父亲”    x.parent = y.parent;    if (y.parent == null) &#123;        this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点    &#125; else &#123;        if (y == y.parent.right)            y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”        else            y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”    &#125;    // 将 “y” 设为 “x的右孩子”    x.right = y;    // 将 “y的父节点” 设为 “x”    y.parent = x;&#125;/*  * 将结点插入到红黑树中 * * 参数说明： *     node 插入的结点        // 对应《算法导论》中的node */private void insert(RBTNode&lt;T&gt; node) &#123;    int cmp;    RBTNode&lt;T&gt; y = null;    RBTNode&lt;T&gt; x = this.mRoot;    // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。    while (x != null) &#123;        y = x;        cmp = node.key.compareTo(x.key);        if (cmp &lt; 0)            x = x.left;        else            x = x.right;    &#125;    node.parent = y;    if (y!=null) &#123;        cmp = node.key.compareTo(y.key);        if (cmp &lt; 0)            y.left = node;        else            y.right = node;    &#125; else &#123;        this.mRoot = node;    &#125;    // 2. 设置节点的颜色为红色    node.color = RED;    // 3. 将它重新修正为一颗二叉查找树    insertFixUp(node);&#125;/*  * 新建结点(key)，并将其插入到红黑树中 * * 参数说明： *     key 插入结点的键值 */public void insert(T key) &#123;    RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);    // 如果新建结点失败，则返回。    if (node != null)        insert(node);&#125;/* * 红黑树插入修正函数 * * 在向红黑树中插入节点之后(失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     node 插入的结点        // 对应《算法导论》中的z */private void insertFixUp(RBTNode&lt;T&gt; node) &#123;    RBTNode&lt;T&gt; parent, gparent;    // 若“父节点存在，并且父节点的颜色是红色”    while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) &#123;        gparent = parentOf(parent);        //若“父节点”是“祖父节点的左孩子”        if (parent == gparent.left) &#123;            // Case 1条件：叔叔节点是红色            RBTNode&lt;T&gt; uncle = gparent.right;            if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;                setBlack(uncle);                setBlack(parent);                setRed(gparent);                node = gparent;                continue;            &#125;            // Case 2条件：叔叔是黑色，且当前节点是右孩子            if (parent.right == node) &#123;                RBTNode&lt;T&gt; tmp;                leftRotate(parent);                tmp = parent;                parent = node;                node = tmp;            &#125;            // Case 3条件：叔叔是黑色，且当前节点是左孩子。            setBlack(parent);            setRed(gparent);            rightRotate(gparent);        &#125; else &#123;    //若“z的父节点”是“z的祖父节点的右孩子”            // Case 1条件：叔叔节点是红色            RBTNode&lt;T&gt; uncle = gparent.left;            if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;                setBlack(uncle);                setBlack(parent);                setRed(gparent);                node = gparent;                continue;            &#125;            // Case 2条件：叔叔是黑色，且当前节点是左孩子            if (parent.left == node) &#123;                RBTNode&lt;T&gt; tmp;                rightRotate(parent);                tmp = parent;                parent = node;                node = tmp;            &#125;            // Case 3条件：叔叔是黑色，且当前节点是右孩子。            setBlack(parent);            setRed(gparent);            leftRotate(gparent);        &#125;    &#125;    // 将根节点设为黑色    setBlack(this.mRoot);&#125;/*  * 删除结点(node)，并返回被删除的结点 * * 参数说明： *     node 删除的结点 */private void remove(RBTNode&lt;T&gt; node) &#123;    RBTNode&lt;T&gt; child, parent;    boolean color;    // 被删除节点的&quot;左右孩子都不为空&quot;的情况。    if ( (node.left!=null) &amp;&amp; (node.right!=null) ) &#123;        // 被删节点的后继节点。(称为&quot;取代节点&quot;)        // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。        RBTNode&lt;T&gt; replace = node;        // 获取后继节点        replace = replace.right;        while (replace.left != null)            replace = replace.left;        // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)        if (parentOf(node)!=null) &#123;            if (parentOf(node).left == node)                parentOf(node).left = replace;            else                parentOf(node).right = replace;        &#125; else &#123;            // &quot;node节点&quot;是根节点，更新根节点。            this.mRoot = replace;        &#125;        // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。        // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。        child = replace.right;        parent = parentOf(replace);        // 保存&quot;取代节点&quot;的颜色        color = colorOf(replace);        // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;        if (parent == node) &#123;            parent = replace;        &#125; else &#123;            // child不为空            if (child!=null)                setParent(child, parent);            parent.left = child;            replace.right = node.right;            setParent(node.right, replace);        &#125;        replace.parent = node.parent;        replace.color = node.color;        replace.left = node.left;        node.left.parent = replace;        if (color == BLACK)            removeFixUp(child, parent);        node = null;        return ;    &#125;    if (node.left !=null) &#123;        child = node.left;    &#125; else &#123;        child = node.right;    &#125;    parent = node.parent;    // 保存&quot;取代节点&quot;的颜色    color = node.color;    if (child!=null)        child.parent = parent;    // &quot;node节点&quot;不是根节点    if (parent!=null) &#123;        if (parent.left == node)            parent.left = child;        else            parent.right = child;    &#125; else &#123;        this.mRoot = child;    &#125;    if (color == BLACK)        removeFixUp(child, parent);    node = null;&#125;/*  * 删除结点(z)，并返回被删除的结点 * * 参数说明： *     tree 红黑树的根结点 *     z 删除的结点 */public void remove(T key) &#123;    RBTNode&lt;T&gt; node;     if ((node = search(mRoot, key)) != null)        remove(node);&#125;/* * 红黑树删除修正函数 * * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数； * 目的是将它重新塑造成一颗红黑树。 * * 参数说明： *     node 待修正的节点 */private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;    RBTNode&lt;T&gt; other;    while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) &#123;        if (parent.left == node) &#123;            other = parent.right;            if (isRed(other)) &#123;                // Case 1: x的兄弟w是红色的                  setBlack(other);                setRed(parent);                leftRotate(parent);                other = parent.right;            &#125;            if ((other.left==null || isBlack(other.left)) &amp;&amp;                (other.right==null || isBlack(other.right))) &#123;                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的                  setRed(other);                node = parent;                parent = parentOf(node);            &#125; else &#123;                if (other.right==null || isBlack(other.right)) &#123;                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。                      setBlack(other.left);                    setRed(other);                    rightRotate(other);                    other = parent.right;                &#125;                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。                setColor(other, colorOf(parent));                setBlack(parent);                setBlack(other.right);                leftRotate(parent);                node = this.mRoot;                break;            &#125;        &#125; else &#123;            other = parent.left;            if (isRed(other)) &#123;                // Case 1: x的兄弟w是红色的                  setBlack(other);                setRed(parent);                rightRotate(parent);                other = parent.left;            &#125;            if ((other.left==null || isBlack(other.left)) &amp;&amp;                (other.right==null || isBlack(other.right))) &#123;                // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的                  setRed(other);                node = parent;                parent = parentOf(node);            &#125; else &#123;                if (other.left==null || isBlack(other.left)) &#123;                    // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。                      setBlack(other.right);                    setRed(other);                    leftRotate(other);                    other = parent.left;                &#125;                // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。                setColor(other, colorOf(parent));                setBlack(parent);                setBlack(other.left);                rightRotate(parent);                node = this.mRoot;                break;            &#125;        &#125;    &#125;    if (node!=null)        setBlack(node);&#125;</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>/** * Java 语言: 红黑树 * * @author skywang * @date 2013/11/07 */public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;    private RBTNode&lt;T&gt; mRoot;    // 根结点    private static final boolean RED   = false;    private static final boolean BLACK = true;    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;        boolean color;        // 颜色        T key;                // 关键字(键值)        RBTNode&lt;T&gt; left;    // 左孩子        RBTNode&lt;T&gt; right;    // 右孩子        RBTNode&lt;T&gt; parent;    // 父结点        public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123;            this.key = key;            this.color = color;            this.parent = parent;            this.left = left;            this.right = right;        &#125;        public T getKey() &#123;            return key;        &#125;        public String toString() &#123;            return &quot;&quot;+key+(this.color==RED?&quot;(R)&quot;:&quot;B&quot;);        &#125;    &#125;    public RBTree() &#123;        mRoot=null;    &#125;    private RBTNode&lt;T&gt; parentOf(RBTNode&lt;T&gt; node) &#123;        return node!=null ? node.parent : null;    &#125;    private boolean colorOf(RBTNode&lt;T&gt; node) &#123;        return node!=null ? node.color : BLACK;    &#125;    private boolean isRed(RBTNode&lt;T&gt; node) &#123;        return ((node!=null)&amp;&amp;(node.color==RED)) ? true : false;    &#125;    private boolean isBlack(RBTNode&lt;T&gt; node) &#123;        return !isRed(node);    &#125;    private void setBlack(RBTNode&lt;T&gt; node) &#123;        if (node!=null)            node.color = BLACK;    &#125;    private void setRed(RBTNode&lt;T&gt; node) &#123;        if (node!=null)            node.color = RED;    &#125;    private void setParent(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;        if (node!=null)            node.parent = parent;    &#125;    private void setColor(RBTNode&lt;T&gt; node, boolean color) &#123;        if (node!=null)            node.color = color;    &#125;    /*     * 前序遍历&quot;红黑树&quot;     */    private void preOrder(RBTNode&lt;T&gt; tree) &#123;        if(tree != null) &#123;            System.out.print(tree.key+&quot; &quot;);            preOrder(tree.left);            preOrder(tree.right);        &#125;    &#125;    public void preOrder() &#123;        preOrder(mRoot);    &#125;    /*     * 中序遍历&quot;红黑树&quot;     */    private void inOrder(RBTNode&lt;T&gt; tree) &#123;        if(tree != null) &#123;            inOrder(tree.left);            System.out.print(tree.key+&quot; &quot;);            inOrder(tree.right);        &#125;    &#125;    public void inOrder() &#123;        inOrder(mRoot);    &#125;    /*     * 后序遍历&quot;红黑树&quot;     */    private void postOrder(RBTNode&lt;T&gt; tree) &#123;        if(tree != null)        &#123;            postOrder(tree.left);            postOrder(tree.right);            System.out.print(tree.key+&quot; &quot;);        &#125;    &#125;    public void postOrder() &#123;        postOrder(mRoot);    &#125;    /*     * (递归实现)查找&quot;红黑树x&quot;中键值为key的节点     */    private RBTNode&lt;T&gt; search(RBTNode&lt;T&gt; x, T key) &#123;        if (x==null)            return x;        int cmp = key.compareTo(x.key);        if (cmp &lt; 0)            return search(x.left, key);        else if (cmp &gt; 0)            return search(x.right, key);        else            return x;    &#125;    public RBTNode&lt;T&gt; search(T key) &#123;        return search(mRoot, key);    &#125;    /*     * (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点     */    private RBTNode&lt;T&gt; iterativeSearch(RBTNode&lt;T&gt; x, T key) &#123;        while (x!=null) &#123;            int cmp = key.compareTo(x.key);            if (cmp &lt; 0)                 x = x.left;            else if (cmp &gt; 0)                 x = x.right;            else                return x;        &#125;        return x;    &#125;    public RBTNode&lt;T&gt; iterativeSearch(T key) &#123;        return iterativeSearch(mRoot, key);    &#125;    /*      * 查找最小结点：返回tree为根结点的红黑树的最小结点。     */    private RBTNode&lt;T&gt; minimum(RBTNode&lt;T&gt; tree) &#123;        if (tree == null)            return null;        while(tree.left != null)            tree = tree.left;        return tree;    &#125;    public T minimum() &#123;        RBTNode&lt;T&gt; p = minimum(mRoot);        if (p != null)            return p.key;        return null;    &#125;         /*      * 查找最大结点：返回tree为根结点的红黑树的最大结点。     */    private RBTNode&lt;T&gt; maximum(RBTNode&lt;T&gt; tree) &#123;        if (tree == null)            return null;        while(tree.right != null)            tree = tree.right;        return tree;    &#125;    public T maximum() &#123;        RBTNode&lt;T&gt; p = maximum(mRoot);        if (p != null)            return p.key;        return null;    &#125;    /*      * 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。     */    public RBTNode&lt;T&gt; successor(RBTNode&lt;T&gt; x) &#123;        // 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。        if (x.right != null)            return minimum(x.right);        // 如果x没有右孩子。则x有以下两种可能：        // (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。        // (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。        RBTNode&lt;T&gt; y = x.parent;        while ((y!=null) &amp;&amp; (x==y.right)) &#123;            x = y;            y = y.parent;        &#125;        return y;    &#125;         /*      * 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。     */    public RBTNode&lt;T&gt; predecessor(RBTNode&lt;T&gt; x) &#123;        // 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。        if (x.left != null)            return maximum(x.left);        // 如果x没有左孩子。则x有以下两种可能：        // (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。        // (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。        RBTNode&lt;T&gt; y = x.parent;        while ((y!=null) &amp;&amp; (x==y.left)) &#123;            x = y;            y = y.parent;        &#125;        return y;    &#125;    /*      * 对红黑树的节点(x)进行左旋转     *     * 左旋示意图(对节点x进行左旋)：     *      px                              px     *     /                               /     *    x                               y                     *   /  \      --(左旋)-.           / \                #     *  lx   y                          x  ry          *     /   \                       /  \     *    ly   ry                     lx  ly       *     *     */    private void leftRotate(RBTNode&lt;T&gt; x) &#123;        // 设置x的右孩子为y        RBTNode&lt;T&gt; y = x.right;        // 将 “y的左孩子” 设为 “x的右孩子”；        // 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”        x.right = y.left;        if (y.left != null)            y.left.parent = x;        // 将 “x的父亲” 设为 “y的父亲”        y.parent = x.parent;        if (x.parent == null) &#123;            this.mRoot = y;            // 如果 “x的父亲” 是空节点，则将y设为根节点        &#125; else &#123;            if (x.parent.left == x)                x.parent.left = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”            else                x.parent.right = y;    // 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”        &#125;                // 将 “x” 设为 “y的左孩子”        y.left = x;        // 将 “x的父节点” 设为 “y”        x.parent = y;    &#125;    /*      * 对红黑树的节点(y)进行右旋转     *     * 右旋示意图(对节点y进行左旋)：     *            py                               py     *           /                                /     *          y                                x                       *         /  \      --(右旋)-.            /  \                     #     *        x   ry                           lx   y       *       / \                                   / \                   #     *      lx  rx                                rx  ry     *      */    private void rightRotate(RBTNode&lt;T&gt; y) &#123;        // 设置x是当前节点的左孩子。        RBTNode&lt;T&gt; x = y.left;        // 将 “x的右孩子” 设为 “y的左孩子”；        // 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”        y.left = x.right;        if (x.right != null)            x.right.parent = y;        // 将 “y的父亲” 设为 “x的父亲”        x.parent = y.parent;        if (y.parent == null) &#123;            this.mRoot = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点        &#125; else &#123;            if (y == y.parent.right)                y.parent.right = x;    // 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”            else                y.parent.left = x;    // (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”        &#125;        // 将 “y” 设为 “x的右孩子”        x.right = y;        // 将 “y的父节点” 设为 “x”        y.parent = x;    &#125;    /*     * 红黑树插入修正函数     *     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；     * 目的是将它重新塑造成一颗红黑树。     *     * 参数说明：     *     node 插入的结点        // 对应《算法导论》中的z     */    private void insertFixUp(RBTNode&lt;T&gt; node) &#123;        RBTNode&lt;T&gt; parent, gparent;        // 若“父节点存在，并且父节点的颜色是红色”        while (((parent = parentOf(node))!=null) &amp;&amp; isRed(parent)) &#123;            gparent = parentOf(parent);            //若“父节点”是“祖父节点的左孩子”            if (parent == gparent.left) &#123;                // Case 1条件：叔叔节点是红色                RBTNode&lt;T&gt; uncle = gparent.right;                if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;                    setBlack(uncle);                    setBlack(parent);                    setRed(gparent);                    node = gparent;                    continue;                &#125;                // Case 2条件：叔叔是黑色，且当前节点是右孩子                if (parent.right == node) &#123;                    RBTNode&lt;T&gt; tmp;                    leftRotate(parent);                    tmp = parent;                    parent = node;                    node = tmp;                &#125;                // Case 3条件：叔叔是黑色，且当前节点是左孩子。                setBlack(parent);                setRed(gparent);                rightRotate(gparent);            &#125; else &#123;    //若“z的父节点”是“z的祖父节点的右孩子”                // Case 1条件：叔叔节点是红色                RBTNode&lt;T&gt; uncle = gparent.left;                if ((uncle!=null) &amp;&amp; isRed(uncle)) &#123;                    setBlack(uncle);                    setBlack(parent);                    setRed(gparent);                    node = gparent;                    continue;                &#125;                // Case 2条件：叔叔是黑色，且当前节点是左孩子                if (parent.left == node) &#123;                    RBTNode&lt;T&gt; tmp;                    rightRotate(parent);                    tmp = parent;                    parent = node;                    node = tmp;                &#125;                // Case 3条件：叔叔是黑色，且当前节点是右孩子。                setBlack(parent);                setRed(gparent);                leftRotate(gparent);            &#125;        &#125;        // 将根节点设为黑色        setBlack(this.mRoot);    &#125;    /*      * 将结点插入到红黑树中     *     * 参数说明：     *     node 插入的结点        // 对应《算法导论》中的node     */    private void insert(RBTNode&lt;T&gt; node) &#123;        int cmp;        RBTNode&lt;T&gt; y = null;        RBTNode&lt;T&gt; x = this.mRoot;        // 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。        while (x != null) &#123;            y = x;            cmp = node.key.compareTo(x.key);            if (cmp &lt; 0)                x = x.left;            else                x = x.right;        &#125;        node.parent = y;        if (y!=null) &#123;            cmp = node.key.compareTo(y.key);            if (cmp &lt; 0)                y.left = node;            else                y.right = node;        &#125; else &#123;            this.mRoot = node;        &#125;        // 2. 设置节点的颜色为红色        node.color = RED;        // 3. 将它重新修正为一颗二叉查找树        insertFixUp(node);    &#125;    /*      * 新建结点(key)，并将其插入到红黑树中     *     * 参数说明：     *     key 插入结点的键值     */    public void insert(T key) &#123;        RBTNode&lt;T&gt; node=new RBTNode&lt;T&gt;(key,BLACK,null,null,null);        // 如果新建结点失败，则返回。        if (node != null)            insert(node);    &#125;    /*     * 红黑树删除修正函数     *     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；     * 目的是将它重新塑造成一颗红黑树。     *     * 参数说明：     *     node 待修正的节点     */    private void removeFixUp(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent) &#123;        RBTNode&lt;T&gt; other;        while ((node==null || isBlack(node)) &amp;&amp; (node != this.mRoot)) &#123;            if (parent.left == node) &#123;                other = parent.right;                if (isRed(other)) &#123;                    // Case 1: x的兄弟w是红色的                      setBlack(other);                    setRed(parent);                    leftRotate(parent);                    other = parent.right;                &#125;                if ((other.left==null || isBlack(other.left)) &amp;&amp;                    (other.right==null || isBlack(other.right))) &#123;                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的                      setRed(other);                    node = parent;                    parent = parentOf(node);                &#125; else &#123;                    if (other.right==null || isBlack(other.right)) &#123;                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。                          setBlack(other.left);                        setRed(other);                        rightRotate(other);                        other = parent.right;                    &#125;                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。                    setColor(other, colorOf(parent));                    setBlack(parent);                    setBlack(other.right);                    leftRotate(parent);                    node = this.mRoot;                    break;                &#125;            &#125; else &#123;                other = parent.left;                if (isRed(other)) &#123;                    // Case 1: x的兄弟w是红色的                      setBlack(other);                    setRed(parent);                    rightRotate(parent);                    other = parent.left;                &#125;                if ((other.left==null || isBlack(other.left)) &amp;&amp;                    (other.right==null || isBlack(other.right))) &#123;                    // Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的                      setRed(other);                    node = parent;                    parent = parentOf(node);                &#125; else &#123;                    if (other.left==null || isBlack(other.left)) &#123;                        // Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。                          setBlack(other.right);                        setRed(other);                        leftRotate(other);                        other = parent.left;                    &#125;                    // Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。                    setColor(other, colorOf(parent));                    setBlack(parent);                    setBlack(other.left);                    rightRotate(parent);                    node = this.mRoot;                    break;                &#125;            &#125;        &#125;        if (node!=null)            setBlack(node);    &#125;    /*      * 删除结点(node)，并返回被删除的结点     *     * 参数说明：     *     node 删除的结点     */    private void remove(RBTNode&lt;T&gt; node) &#123;        RBTNode&lt;T&gt; child, parent;        boolean color;        // 被删除节点的&quot;左右孩子都不为空&quot;的情况。        if ( (node.left!=null) &amp;&amp; (node.right!=null) ) &#123;            // 被删节点的后继节点。(称为&quot;取代节点&quot;)            // 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。            RBTNode&lt;T&gt; replace = node;            // 获取后继节点            replace = replace.right;            while (replace.left != null)                replace = replace.left;            // &quot;node节点&quot;不是根节点(只有根节点不存在父节点)            if (parentOf(node)!=null) &#123;                if (parentOf(node).left == node)                    parentOf(node).left = replace;                else                    parentOf(node).right = replace;            &#125; else &#123;                // &quot;node节点&quot;是根节点，更新根节点。                this.mRoot = replace;            &#125;            // child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。            // &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。            child = replace.right;            parent = parentOf(replace);            // 保存&quot;取代节点&quot;的颜色            color = colorOf(replace);            // &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;            if (parent == node) &#123;                parent = replace;            &#125; else &#123;                // child不为空                if (child!=null)                    setParent(child, parent);                parent.left = child;                replace.right = node.right;                setParent(node.right, replace);            &#125;            replace.parent = node.parent;            replace.color = node.color;            replace.left = node.left;            node.left.parent = replace;            if (color == BLACK)                removeFixUp(child, parent);            node = null;            return ;        &#125;        if (node.left !=null) &#123;            child = node.left;        &#125; else &#123;            child = node.right;        &#125;        parent = node.parent;        // 保存&quot;取代节点&quot;的颜色        color = node.color;        if (child!=null)            child.parent = parent;        // &quot;node节点&quot;不是根节点        if (parent!=null) &#123;            if (parent.left == node)                parent.left = child;            else                parent.right = child;        &#125; else &#123;            this.mRoot = child;        &#125;        if (color == BLACK)            removeFixUp(child, parent);        node = null;    &#125;    /*      * 删除结点(z)，并返回被删除的结点     *     * 参数说明：     *     tree 红黑树的根结点     *     z 删除的结点     */    public void remove(T key) &#123;        RBTNode&lt;T&gt; node;         if ((node = search(mRoot, key)) != null)            remove(node);    &#125;    /*     * 销毁红黑树     */    private void destroy(RBTNode&lt;T&gt; tree) &#123;        if (tree==null)            return ;        if (tree.left != null)            destroy(tree.left);        if (tree.right != null)            destroy(tree.right);        tree=null;    &#125;    public void clear() &#123;        destroy(mRoot);        mRoot = null;    &#125;    /*     * 打印&quot;红黑树&quot;     *     * key        -- 节点的键值      * direction  --  0，表示该节点是根节点;     *               -1，表示该节点是它的父结点的左孩子;     *                1，表示该节点是它的父结点的右孩子。     */    private void print(RBTNode&lt;T&gt; tree, T key, int direction) &#123;        if(tree != null) &#123;            if(direction==0)    // tree是根节点                System.out.printf(&quot;%2d(B) is root\n&quot;, tree.key);            else                // tree是分支节点                System.out.printf(&quot;%2d(%s) is %2d&#39;s %6s child\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction==1?&quot;right&quot; : &quot;left&quot;);            print(tree.left, tree.key, -1);            print(tree.right,tree.key,  1);        &#125;    &#125;    public void print() &#123;        if (mRoot != null)            print(mRoot, mRoot.key, 0);    &#125;&#125;/** * Java 语言: 二叉查找树 * * @author skywang * @date 2013/11/07 */public class RBTreeTest &#123;    private static final int a[] = &#123;10, 40, 30, 60, 90, 70, 20, 50, 80&#125;;    private static final boolean mDebugInsert = false;    // &quot;插入&quot;动作的检测开关(false，关闭；true，打开)    private static final boolean mDebugDelete = false;    // &quot;删除&quot;动作的检测开关(false，关闭；true，打开)    public static void main(String[] args) &#123;        int i, ilen = a.length;        RBTree&lt;Integer&gt; tree=new RBTree&lt;Integer&gt;();        System.out.printf(&quot;== 原始数据: &quot;);        for(i=0; i&lt;ilen; i++)            System.out.printf(&quot;%d &quot;, a[i]);        System.out.printf(&quot;\n&quot;);        for(i=0; i&lt;ilen; i++) &#123;            tree.insert(a[i]);            // 设置mDebugInsert=true,测试&quot;添加函数&quot;            if (mDebugInsert) &#123;                System.out.printf(&quot;== 添加节点: %d\n&quot;, a[i]);                System.out.printf(&quot;== 树的详细信息: \n&quot;);                tree.print();                System.out.printf(&quot;\n&quot;);            &#125;        &#125;        System.out.printf(&quot;== 前序遍历: &quot;);        tree.preOrder();        System.out.printf(&quot;\n== 中序遍历: &quot;);        tree.inOrder();        System.out.printf(&quot;\n== 后序遍历: &quot;);        tree.postOrder();        System.out.printf(&quot;\n&quot;);        System.out.printf(&quot;== 最小值: %s\n&quot;, tree.minimum());        System.out.printf(&quot;== 最大值: %s\n&quot;, tree.maximum());        System.out.printf(&quot;== 树的详细信息: \n&quot;);        tree.print();        System.out.printf(&quot;\n&quot;);        // 设置mDebugDelete=true,测试&quot;删除函数&quot;        if (mDebugDelete) &#123;            for(i=0; i&lt;ilen; i++)            &#123;                tree.remove(a[i]);                System.out.printf(&quot;== 删除节点: %d\n&quot;, a[i]);                System.out.printf(&quot;== 树的详细信息: \n&quot;);                tree.print();                System.out.printf(&quot;\n&quot;);            &#125;        &#125;        // 销毁二叉树        tree.clear();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-矩阵压缩</title>
      <link href="/posts/44076.html"/>
      <url>/posts/44076.html</url>
      
        <content type="html"><![CDATA[<h2 id="对称矩阵的压缩"><a href="#对称矩阵的压缩" class="headerlink" title="对称矩阵的压缩"></a>对称矩阵的压缩</h2><p><code>n阶对称矩阵：只存储上三角或者下三角矩阵中的元素，把原来需要存储n*n个元素压缩至n*(n-1)/2个元素</code></p><pre><code>//对称矩阵的压缩算法public class SymeMatric &#123;    double[] a;// 矩阵元素    int n; // 矩阵的阶数    int m;// 一维数组的元素的个数--长度    public SymeMatric(int n) &#123;        // 对称矩阵中不重复元素，保存到一维数组中所需要的一维数组的长度        // 2阶对称矩阵对应(1+2=3)维数组，3阶对称矩阵对应1+2+3=6维数组，        // 4阶对称矩阵对应1+2+3+4维数组，n阶对称矩阵对应前n项和，        // 所以一维数组的长度m的值为1,2,3...n的前n项和        m = n * (n + 1) / 2;         a = new double[m];        this.n = n;    &#125;    // 通过一个二维数组来初始化    public void evalute(double[][] b) &#123;        int k = 0;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                // i &gt;= j表示只保存下三角元素                if (i &gt;= j) &#123;                    a[k++] = b[i][j];                &#125;            &#125;        &#125;    &#125;    // 通过一个一维数组来初始化,那么这个一维数组就是对称矩阵元素的一个副本    public void evalute(double[] b) &#123;        for (int k = 0; k &lt; m; k++) &#123;            a[k] = b[k];        &#125;    &#125;    // 对称矩阵相加    public SymeMatric add(SymeMatric b) &#123;        SymeMatric t = new SymeMatric(n);        int k;        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                if (i &gt;= j) &#123;                    k = i * (i - 1) / 2 + j - 1;                &#125; else &#123;                    k = j * (j - 1) / 2 + i - 1;                &#125;                // 求和                t.a[k] = a[k] + b.a[k];            &#125;        &#125;        return t;    &#125;    // 打印对称矩阵，这个才是关键！！    public void print() &#123;        int k;        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                if (i &gt;= j) &#123;                    k = i * (i - 1) / 2 + j - 1;                &#125; else &#123;                    k = j * (j - 1) / 2 + i - 1;                &#125;                System.out.print(&quot; &quot; + a[k]);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre><h2 id="三角矩阵的压缩"><a href="#三角矩阵的压缩" class="headerlink" title="三角矩阵的压缩"></a>三角矩阵的压缩</h2><p><code>m对角矩阵：非零元素在每行中有m个，一维数组s[k]和A[i][j]的对应关系为：k = m*i+j</code></p><h2 id="稀疏矩阵的压缩"><a href="#稀疏矩阵的压缩" class="headerlink" title="稀疏矩阵的压缩"></a>稀疏矩阵的压缩</h2><p><code>矩阵m*n如果有t个非零元素，那么s = t/m*n称为矩阵的稀疏因子，如果s&lt;=0.05那么矩阵为稀疏矩阵</code></p><p>注：三元组顺序表表示，其中三元组格式为(i,j,e)记录了非零元素的行号、列号以及非零元素</p><pre><code>inal int _ROWS=5;//定义行数final int _COLS=5;//定义列数final int _NOTZERO=6;//定义稀疏矩阵中不为零的个数int i,j,tmpRW,tmpCL,tmpNZ;int temp=1;int Sparse[][]=new int[_ROWS][_COLS];//声明稀疏矩阵int Compress[][]=new int[_NOTZERO+1][3];//声明压缩矩阵    for(i=0;i&lt;_ROWS;i++) //将矩阵初始值都设为0    for(j=0;j&lt;_COLS;j++)        Sparse[i][j]=0;tmpNZ=_NOTZERO;//产生随机稀疏矩阵for(i=1;i&lt;tmpNZ+1;i++) &#123;    tmpRW=(int)(Math.random()*100);    tmpRW=(tmpRW%_ROWS);    tmpCL=(int)(Math.random()*100);    tmpCL=(tmpCL%_COLS);    if(Sparse[tmpRW][tmpCL]!=0)        tmpNZ++;    Sparse[tmpRW][tmpCL]=i;&#125;/*开始压缩稀疏矩阵*/Compress[0][0]=_ROWS;Compress[0][1]=_COLS;Compress[0][2]=_NOTZERO;for(i=0;i&lt;_ROWS;i++) &#123;    for(j=0;j&lt;_COLS;j++) &#123;        if(Sparse[i][j]!=0)&#123;            Compress[temp][0]=i;            Compress[temp][1]=j;            Compress[temp][2]=Sparse[i][j];            temp++;        &#125;    &#125;&#125;    </code></pre><p>链接：<a href="https://www.cnblogs.com/gaosheng-221/p/6133443.html">https://www.cnblogs.com/gaosheng-221/p/6133443.html</a></p>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树堆</title>
      <link href="/posts/46674.html"/>
      <url>/posts/46674.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树链</title>
      <link href="/posts/38791.html"/>
      <url>/posts/38791.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈、队列</title>
      <link href="/posts/12863.html"/>
      <url>/posts/12863.html</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(LIFO, Last In First Out)</p><h3 id="静态栈"><a href="#静态栈" class="headerlink" title="静态栈"></a>静态栈</h3><p>数组 栈大小固定</p><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>链表 栈大小不固定</p><pre><code>public class Node &#123;    //数据域    public int data;    //指针域，指向下一个节点    public Node next;    public Node() &#123;    &#125;    public Node(int data) &#123;        this.data = data;    &#125;    public Node(int data, Node next) &#123;        this.data = data;        this.next = next;    &#125;    &#125;public class Stack &#123;    public Node stackTop;//栈顶    public Node stackBottom;//栈底    public Stack(Node stackTop, Node stackBottom) &#123;        this.stackTop = stackTop;        this.stackBottom = stackBottom;    &#125;    public Stack() &#123;    &#125;&#125;/** * 进栈 * * @param stack 栈 * @param value 要进栈的元素 */public static void pushStack(Stack stack, int value) &#123;    // 封装数据成节点    Node newNode = new Node(value);    // 栈顶本来指向的节点交由新节点来指向    newNode.next = stack.stackTop;    // 栈顶指针指向新节点    stack.stackTop = newNode;&#125;/** * 遍历栈(只要栈顶指针不指向栈底指针，就一直输出) * * @param stack */public static void traverse(Stack stack) &#123;    Node stackTop = stack.stackTop;    while (stackTop != stack.stackBottom) &#123;        System.out.println(&quot;关注公众号：Java3y：&quot; + stackTop.data);        stackTop = stackTop.next;    &#125;&#125;/** * 判断该栈是否为空 * * @param stack */public static void isEmpty(Stack stack) &#123;    if (stack.stackTop == stack.stackBottom) &#123;        System.out.println(&quot;关注公众号：Java3y----&gt;该栈为空&quot;);    &#125; else &#123;        System.out.println(&quot;关注公众号：Java3y----&gt;该栈不为空&quot;);    &#125;&#125;/** * 出栈(将栈顶的指针指向下一个节点) * @param stack */public static void popStack(Stack stack) &#123;    // 栈不为空才能出栈    if (!isEmpty(stack)) &#123;        //栈顶元素        Node top = stack.stackTop;        // 栈顶指针指向下一个节点        stack.stackTop = top.next;        System.out.println(&quot;关注公众号：Java3y----&gt;出栈的元素是：&quot; + top.data);    &#125;&#125;/** * 清空栈 * @param stack */public static void clearStack(Stack stack) &#123;    stack.stackTop = null;    stack.stackBottom = stack.stackTop;&#125;</code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(LILO, Last In Last Out)</p><h3 id="静态队列"><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h3><p>数组实现循环队列，节省内存资源</p><pre><code>public class Queue &#123;    //数组    public int [] arrays;    //指向第一个有效的元素    public int front = 0;    //指向有效数据的下一个元素(即指向无效的数据)    public int rear = 0;&#125;/** * 入队 * * @param queue */public static void enQueue(Queue queue,int value) &#123;    // 不是满的队列才能入队    if (!isFull(queue)) &#123;        // 将新的元素插入到队尾中        queue.arrays[queue.rear] = value;        // rear节点移动到新的无效元素位置上        queue.rear = (queue.rear + 1) % queue.arrays.length;    &#125;&#125;/** * 出队 * * @param queue */public static void outQueue(Queue queue) &#123;    //判断该队列是否为null    if (!isEmpty(queue)) &#123;        //不为空才出队        int value = queue.arrays[queue.front];        System.out.println(&quot;关注公众号：Java3y---&gt;出队的元素是：&quot; + value);        // front指针往后面移        queue.front = (queue.front + 1) % queue.arrays.length;    &#125;&#125;/** * 判断队列是否空，front和rear指针相等，就是空了 * @param queue * @return */public static boolean isEmpty(Queue queue) &#123;    if (queue.rear  == queue.front) &#123;        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列空的！&quot;);        return true;    &#125; else &#123;        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列非空！&quot;);        return false;    &#125;&#125;        /** * 判断队列是否满了，front和rear指针紧挨着，就是满了 * @param queue * @return */public static boolean isFull(Queue queue) &#123;    if ((queue.rear + 1) % queue.arrays.length == queue.front) &#123;        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列满了！&quot;);        return true;    &#125; else &#123;        System.out.println(&quot;关注公众号：Java3y---&gt;此时队列没满了！&quot;);        return false;    &#125;&#125;/** * 遍历队列 * @param queue * */public static void traverseQueue(Queue queue) &#123;    // front的位置    int i = queue.front;    while (i != queue.rear) &#123;        System.out.println(&quot;关注公众号：Java3y---&gt;&quot; + queue.arrays[i]);        //移动front        i = (i + 1) % queue.arrays.length;    &#125;&#125;    </code></pre><h3 id="动态队列"><a href="#动态队列" class="headerlink" title="动态队列"></a>动态队列</h3><p>链表实现</p>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/posts/23384.html"/>
      <url>/posts/23384.html</url>
      
        <content type="html"><![CDATA[<p>树由根节点(root)和若干子树(T1,T2, … Tm-1)构成的具有层次关系的数据结构。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>节点的度 : 该节点子树个数，度为0的节点为叶子节点，度不为0的节点为分支节点</p><p>树的度 : 树中的节点的度最大值为树的度</p><p>节点的层次 : 根为第一层，往下依次递增</p><p>树的深度 : 节点层次最大值为树的深度</p><p>森林 : n棵不相交的树的集合为森林</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>常用于实现二叉查找树、二叉堆</p><ul><li><p>每个节点至多有两颗子树（树的度&lt;&#x3D;2）,子树分左右</p></li><li><p>第i层至多有2i-1个节点，深度为k的二叉树，最多节点数2^k-1个节点（具有最多节点的称作满二叉树），其中每个节点都与深度k满二叉树中1-n节点对应，则为完全二叉树</p></li></ul><p><img src="http://thyrsi.com/t6/626/1544146169x2890211738.jpg" alt="满二叉树"></p><p><img src="http://thyrsi.com/t6/626/1544146212x2890211738.jpg" alt="完全二叉树"></p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><ul><li>左子树所有节点值小于根节点，右子树所有节点值大于根节点值</li><li>左右子树都是二叉排序树</li></ul><h2 id="二叉平衡树-AVL"><a href="#二叉平衡树-AVL" class="headerlink" title="二叉平衡树 AVL"></a>二叉平衡树 AVL</h2><ul><li>左右子树深度差不超过1</li><li>左右子树都是二叉平衡树</li></ul><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>最优二叉树</p><p><a href="#hafman">代码实现</a></p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>解决报文编码的问题，将字符串转换为唯一的二进制码，且二进制码的长度最小</p><p>每个字符在字符串中出现频率为W，其编码长度为L，编码字符n个，则编码后二进制码的总长度为W1L1+W2L2+…+WnLn，利用哈夫曼树特性求总长最小编码</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>平衡的多路查找树</p><p>B树的阶：所有孩子节点树的最大值（m叉树：每个节点最多m棵子树）</p><p>分支节点最少有两颗子树</p><p>分支节点包含信息（n，A0，K1，A1，K2，A2，…，Kn，An），其中，n为结点中的关键字树，A为指向子树根结点的指针，K为关键字，且Ai-1所指子树中所有结点的关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn；</p><p>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶B+树和m阶的B-树的差异在于</p><ol><li><p>有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点；</p></li><li><p>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</p></li></ol><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似于平衡的。树中每个结点包含5个属性：color、key、left、right和p。如果一个结点没有子节点或父节点，则该结点相应的指针属性值为NIL，我们可以把这些NIL视为指向二叉搜索树的叶节点（外部结点）的指针，而把带关键字的结点视为树的内部结点。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>每个结点或是红色的，或是黑色的</li><li>根结点是黑色的</li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li><li>虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</li></ol><h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p>如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树或字符树，来表示这样的字符串的集合。键树的结构受启发于一部大型字典的“书边标目”。字典中标出首字母是 A，B，C，…，Z的单词所在页，再对各部分标出第二字母为A，B，C，…，Z的单词所在的页等等。<br>键树是一种特殊的查找树，它是一棵度大于等于2的树，树中的每个节点不是包含一个或几个关键字，而是只含有组成关键字的符号。<br>比如：如果关键字是数值，则节点中只包含一个数位；如果关键字是单词，则节点中只包含一个字母字符。根结点不代表任何字符，根以下第一层的结点对应于字符串的第一个字符，第二层的结点对应于字符串的第二个字符……每个字符串可由一个特殊的字符如“$”等作为字符串的结束符，用一个叶子结点来表示该特殊字符。把从根到叶子的路径上，所有结点（除根以外）对应的字符连接起来，就得到一个字符串。因此，每个叶子结点对应一个关键字。在叶子结点还可以包含一个指针，指向该关键字所对应的元素。整个字符串集合中的字符串的数目等于叶子结点的数目。如果一个集合中的关键字都具有这样的字符串特性，那么，该关键字集合就可采用这样一棵键树来表示。 </p><p>键树的存储通常有两种方式： </p><ol><li>用树的孩子兄弟链来表示键树，称为双链树；每个Node有三个域：symbol域：存储关键字的一个字符；son域：存储指向第一棵子树的根的指针；brother域：存储指向右兄弟的指针。 </li><li>用多重链表来表示键树，称为Trie树或字典树。</li></ol><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>如果以树的多重链表来表示键树，则树的每个结点应包含d个（d为关键字符的基，如：字符集由英文大写字母构成时，则d&#x3D;26）指针域，此时的键树又称为字典树。<br>字典树典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　<br>Tire树的三个基本性质： </p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符； </li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； </li><li>每个节点的所有子节点包含的字符都不相同。<br>Tire树的应用： </li><li>串的快速检索<br>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。 </li><li>“串”排序<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。 </li><li>最长公共前缀</li></ol><h2 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h2><p>所谓后缀树，就是包含一则字符串所有后缀的压缩了的字典树。先说说后缀的定义。给定一长度为n的字符串S&#x3D;S1S2..Si..Sn，和整数i，1 &lt;&#x3D; i &lt;&#x3D; n，子串SiSi+1…Sn都是字符串S的后缀。以字符串S&#x3D;XMADAMYX为例，它的长度为8，所以S[1..8],S[2..8], … , S[8..8]都算S的后缀，我们一般还把空字串也算成后缀。这样，我们一共有如下后缀。对于后缀S[i..n]，我们说这项后缀起始于i。<br>键树只适合前缀匹配和全字匹配，并不适合后缀和子串匹配，而后缀树在这方面则非常合适。它与键树的最大不同在于，后缀树的单词集合是由指定字符串的后缀子串构成。</p><h2 id="区间树与线段树"><a href="#区间树与线段树" class="headerlink" title="区间树与线段树"></a>区间树与线段树</h2><p>区间树是在红黑树基础上进行扩展得到的支持以区间为元素的动态集合的操作，其中每个节点的关键值是区间的左端点。通过建立这种特定的结构，可是使区间的元素的查找和插入都可以在O(lgn)的时间内完成。相比于基础的红黑树数据结构，增加了一个max[x]，即以x为根的子树中所有区间的端点的最大值。<br>线段树是一种平衡二叉查找树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。主要的处理思想是基于分治的思想。<br>设根节点的区间为[a,b),区间长度为L &#x3D; b - a，线段树的性质：<br>1）线段树是一个平衡树，树的高度为log(L)；<br>2）线段树把区间上的任意长度为L的线段都分成不超过2log(L)线段。</p><h2 id="败者树与胜者树"><a href="#败者树与胜者树" class="headerlink" title="败者树与胜者树"></a>败者树与胜者树</h2><p>胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。在胜者树、败者树中，每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。不同的是，胜者树中的每个非终端结点均表示其左、右孩子结点中的“胜者”；而在败者树中，父结点中记下刚进行完的这场比赛中的败者，而让胜者去参加更高一层的比赛</p><p><span id="hafman">哈夫曼树代码实现</span></p><pre><code>import java.util.ArrayDeque;import java.util.ArrayList;import java.util.List;import java.util.Queue; public class HuffmanTree &#123;     public static class Node&lt;E&gt; &#123;        E data;        double weight;        Node leftChild;        Node rightChild;         public Node(E data, double weight) &#123;            super();            this.data = data;            this.weight = weight;        &#125;         public String toString() &#123;            return &quot;Node[data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;;        &#125;    &#125;     public static void main(String[] args) &#123;        List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();         nodes.add(new Node(&quot;A&quot;, 40.0));        nodes.add(new Node(&quot;B&quot;, 8.0));        nodes.add(new Node(&quot;C&quot;, 10.0));        nodes.add(new Node(&quot;D&quot;, 30.0));        nodes.add(new Node(&quot;E&quot;, 10.0));        nodes.add(new Node(&quot;F&quot;, 2.0));                Node root = HuffmanTree.createTree(nodes);                System.out.println(breadthFirst(root));     &#125;     /**     * 构造哈夫曼树     *      * @param nodes     *            节点集合     * @return 构造出来的哈夫曼树的根节点     */    private static Node createTree(List&lt;Node&gt; nodes) &#123;        // 只要nodes数组中还有2个以上的节点        while (nodes.size() &gt; 1) &#123;            quickSort(nodes);            //获取权值最小的两个节点            Node left = nodes.get(nodes.size()-1);            Node right = nodes.get(nodes.size()-2);                        //生成新节点，新节点的权值为两个子节点的权值之和            Node parent = new Node(null, left.weight + right.weight);                        //让新节点作为两个权值最小节点的父节点            parent.leftChild = left;            parent.rightChild = right;                        //删除权值最小的两个节点            nodes.remove(nodes.size()-1);            nodes.remove(nodes.size()-1);                        //将新节点加入到集合中            nodes.add(parent);        &#125;                return nodes.get(0);    &#125;     /**     * 将指定集合中的i和j索引处的元素交换     *      * @param nodes     * @param i     * @param j     */    private static void swap(List&lt;Node&gt; nodes, int i, int j) &#123;        Node tmp;        tmp = nodes.get(i);        nodes.set(i, nodes.get(j));        nodes.set(j, tmp);    &#125;     /**     * 实现快速排序算法，用于对节点进行排序     *      * @param nodes     * @param start     * @param end     */    private static void subSort(List&lt;Node&gt; nodes, int start, int end) &#123;        if (start &lt; end) &#123;            // 以第一个元素作为分界值            Node base = nodes.get(start);            // i从左边搜索，搜索大于分界值的元素的索引            int i = start;            // j从右边开始搜索，搜索小于分界值的元素的索引            int j = end + 1;            while (true) &#123;                // 找到大于分界值的元素的索引，或者i已经到了end处                while (i &lt; end &amp;&amp; nodes.get(++i).weight &gt;= base.weight)                    ;                // 找到小于分界值的元素的索引，或者j已经到了start处                while (j &gt; start &amp;&amp; nodes.get(--j).weight &lt;= base.weight)                    ;                 if (i &lt; j) &#123;                    swap(nodes, i, j);                &#125; else &#123;                    break;                &#125;            &#125;             swap(nodes, start, j);             //递归左边子序列            subSort(nodes, start, j - 1);            //递归右边子序列            subSort(nodes, j + 1, end);        &#125;    &#125;        public static void quickSort(List&lt;Node&gt; nodes)&#123;        subSort(nodes, 0, nodes.size()-1);    &#125;        //广度优先遍历    public static List&lt;Node&gt; breadthFirst(Node root)&#123;        Queue&lt;Node&gt; queue = new ArrayDeque&lt;Node&gt;();        List&lt;Node&gt; list = new ArrayList&lt;Node&gt;();                if(root!=null)&#123;            //将根元素加入“队列”            queue.offer(root);        &#125;                while(!queue.isEmpty())&#123;            //将该队列的“队尾”元素加入到list中            list.add(queue.peek());            Node p = queue.poll();                        //如果左子节点不为null，将它加入到队列            if(p.leftChild != null)&#123;                queue.offer(p.leftChild);            &#125;                        //如果右子节点不为null，将它加入到队列            if(p.rightChild != null)&#123;                queue.offer(p.rightChild);            &#125;        &#125;                return list;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图</title>
      <link href="/posts/41634.html"/>
      <url>/posts/41634.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>图是由顶点集（VertexSet）和边集（EdgeSet）组成，针对图G，顶点集和边集分别记为V(G)和E(G)。依据图的边集是否为有向，可把图分为有向图和无向图，根据图是否有权重，可以分为有权图和无权图</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li>邻接点-在一个无向图中，若存在一条边<code>&lt;Vi,Vj&gt;</code>，则称Vi，Vj为此边的两个端点，并称它们互为邻接点</li><li>出&#x2F;入边-在一个有向图张，若存在一条边<code>&lt;Vi,Vj&gt;</code>，则称此边为顶点Vi的出边，顶点Vj的一条入边</li><li>度&#x2F;入度&#x2F;出度-无向图中的度定义为以该顶点为一个端点的边的数目，记为D(V)。有向图的入度定为多少边指向该顶点，出度是该顶点出边的个数</li></ol><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><code>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。对于无向图 如果顶点b1和b2是连接的，那么在二维矩阵中matrix[b1,b2]和matrix[b2,b1]位置的值置为1，如果是有向图b1指向b2，那么 matrix[b1,b2]=1,matrix[b2,b1]=0；下面用一个例子表示无向图和有向图的邻接矩阵；</code></p><p>如果图是一个带权图，需要把1换为相应边上的权值，把非对角线上的换成一个很大的特定的实数则可，表示相应的边不存在，这个特定的实数通常用无穷大或MaxValue来表示，他要大于图G中所有边的权值</p><p><a href="#matrix">代码实现</a></p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接矩阵与邻接表相比，它会造成空间的一定损失，它需要为每个顶点都分配n个边的空间，其实有很多边都是不存在边，但是邻接表的实现就不一样，它只关心存在的边，不关心不存在的边。邻接表由数组+链表组成对于上面的无向图，邻接表表示为（由于有向和无向的差别不是太大，所以只是画出了无向的邻接表表示）</p><p><a href="#table">代码实现</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><span id="matrix">邻接矩阵实现</span></p><pre><code>package Graph;//边集数组 ，存放边的信息//邻域数组表示  和 邻域表表示  是两种不同的表示方式//表示的是插入边的元素，边的起点和终点  边的权重public class EdgeElement &#123;    int fromvex;    int endvex;    int weight;        public EdgeElement(int v1,int v2)&#123;        //对于无权重图的初始化        fromvex=v1;        endvex=v2;        weight=1;    &#125;    public EdgeElement(int v1,int v2,int wgt)&#123;        //对于有权重图的初始化        fromvex=v1;        endvex=v2;        weight=wgt;    &#125;&#125;package Graph;//可以通过边集来得到一个图的构成public interface Graph &#123;    void creatGraph(EdgeElement d[]);//通过边结点来构建一个图    GraphType graphType();//返回图的类型  无向无权图 无向有权图  有向无权图  有向有权图 定义一个枚举变量    int vertices();//返回图的顶点数    int edges();//返回图的边数    boolean find(int i,int j);//从图中查找一条边(i,j)是否存在    void putEdge(EdgeElement theEdge);//像图中插入一条边 theEdge    void removeEdge(int i,int j);//从图中删除一条边    int degree(int i);//返回顶点i的度    int inDegree(int i);//返回顶点i的入度    int outDegree(int i);//返回顶点i的出度    void output();//以图的顶点集和边集的形式输出一个图    void depthFirstSearch(int v);//从顶点v开始深度优先搜索整幅图    void breadthFirstSearch(int v);//从顶点v开始广度优先搜索整幅图&#125;//在邻域数组中写数据public void creatGraph(EdgeElement[] d) &#123;    int i;    for(i=0;i&lt;d.length;i++)&#123;        if(d[i]==null) break;        int v1,v2;        v1=d[i].fromvex;        v2=d[i].endvex;        if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2)&#123;            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);            System.exit(0);        &#125;        if(type==GraphType.NoDirectionNoWeight)&#123;            a[v1][v2]=a[v2][v1]=1;        &#125;else if(type==GraphType.NoDirectionWeight)&#123;            a[v1][v2]=a[v2][v1]=d[i].weight;        &#125;else if(type==GraphType.DirectionNoWeight)&#123;            a[v1][v2]=1;        &#125;else&#123;            a[v1][v2]=d[i].weight;        &#125;    &#125;    e=i;//边的数目&#125;public void putEdge(EdgeElement theEdge) &#123;    int v1,v2;    v1=theEdge.fromvex;    v2=theEdge.endvex;    if(v1&lt;0 || v1&gt;n-1 || v2&lt;0 || v2&gt;n-1 || v1==v2)&#123;        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);        System.exit(0);    &#125;    if(a[v1][v2]==0 || a[v1][v2]==MaxValue) e++;//边数e的值加一    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;        if(type==GraphType.NoDirectionNoWeight)&#123;            a[v1][v2]=a[v2][v1]=1;        &#125;else&#123;            a[v1][v2]=a[v2][v1]=theEdge.weight;        &#125;    &#125;else&#123;        if(type==GraphType.DirectionNoWeight) a[v1][v2]=1;        else&#123;            a[v1][v2]=theEdge.weight;        &#125;    &#125;&#125;public void removeEdge(int i, int j) &#123;    if(i&lt;0 || i&gt;n-1 || j&lt;0 || j&gt;n-1 || i==j)&#123;        System.out.println(&quot;边的顶点序号无效，退出运行！&quot;);        System.exit(0);    &#125;    if(a[i][j]==0 || a[i][j]==MaxValue)&#123;        System.out.println(&quot;要删除的边不存在，退出运行！&quot;);        System.exit(0);    &#125;    if(type==GraphType.NoDirectionNoWeight)&#123;        a[i][j]=a[j][i]=0;    &#125;else if(type==GraphType.NoDirectionWeight)&#123;        a[i][j]=a[j][i]=MaxValue;    &#125;else if(type==GraphType.DirectionNoWeight)&#123;        a[i][j]=0;    &#125;else a[i][j]=MaxValue;    e--;&#125;//得到该结点的度public int degree(int i) &#123;    if(i&lt;0 || i&gt; n-1)&#123;        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);        System.exit(0);    &#125;    int k=0;    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;        for(int j=0;j&lt;n;j++)&#123;            if(a[i][j]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;                    &#125;    &#125;else&#123;        k = inDegree(i)+outDegree(i);    &#125;    return k;&#125;//入度public int inDegree(int i) &#123;    if(i&lt;0 || i&gt; n-1)&#123;        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);        System.exit(0);    &#125;    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;        return -1;    &#125;    int k=0;    for(int j=0;j&lt;n;i++)&#123;        if(a[j][i]!=0 &amp;&amp; a[j][i]!=MaxValue) k++;    &#125;    return k;&#125;//出度public int outDegree(int i) &#123;    if(i&lt;0 || i&gt; n-1)&#123;        System.out.println(&quot;参数的顶点序号值无效，退出运行&quot;);        System.exit(0);    &#125;    if(type==GraphType.NoDirectionNoWeight || type==GraphType.NoDirectionWeight)&#123;        return -1;    &#125;    int k=0;    for(int j=0;j&lt;n;i++)&#123;        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue) k++;    &#125;    return k;&#125;//输出public void output() &#123;    int i,j;    System.out.print(&quot;V=&#123;&quot;);//输出顶点集合    for(i=0;i&lt;n-1;i++)&#123;        System.out.print(i+&quot;,&quot;);    &#125;    System.out.print(n-1+&quot;&#125;&quot;);//输出顶点集合    //输出边集合    System.out.print(&quot;E=&#123;&quot;);    if(type==GraphType.NoDirectionNoWeight || type==GraphType.DirectionNoWeight)&#123;        for(i=0;i&lt;n;i++)&#123;            for(j=0;j&lt;n;j++)&#123;                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue)&#123;                    if(type==GraphType.NoDirectionNoWeight)&#123;                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;),&quot;);                    &#125;else&#123;                        System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;else&#123;        for(i=0;i&lt;n;i++)&#123;            for(j=0;j&lt;n;j++)&#123;                if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue)&#123;                    if(type==GraphType.NoDirectionWeight)&#123;                        if(i&lt;j)System.out.print(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;+a[i][j]+&quot;,&quot;);                    &#125;else System.out.print(&quot;&lt;&quot;+i+&quot;,&quot;+j+&quot;&gt;&quot;+a[i][j]+&quot;,&quot;);                &#125;            &#125;        &#125;    &#125;    System.out.print(&quot;&#125;&quot;);&#125;//深度优先进行搜索   是从哪个顶点开始遍历，这里可以用顶点序号表示顶点public void depthFirstSearch(int v) &#123;//驱动函数    boolean visited[]=new boolean[n];    for(int i=0;i&lt;n;i++)&#123;        visited[i]=false;    &#125;    dfs(v,visited);//把每个结点遍历一次。    System.out.println();&#125;//进行深度优先搜索的内部递归方法使用private void dfs(int i,boolean visited[])&#123;//工作函数    System.out.print(i+&quot; &quot;);    visited[i]=true;    for(int j=0;j&lt;n;j++)&#123;        if(a[i][j]!=0 &amp;&amp; a[i][j]!=MaxValue &amp;&amp; !visited[j])&#123;            dfs(j,visited);        &#125;    &#125;&#125;</code></pre><p><span id="table">邻接表实现</span></p><pre><code>package GraphLink;//定义邻接表类型public class EdgeNode&#123;    //需要一个存储自身结点    int adjvex;    int weight;    EdgeNode next;    //无权图    public EdgeNode(int adj,EdgeNode nt)&#123;        this.adjvex=adj;        this.next=nt;        this.weight=1;    &#125;    //有权图    public EdgeNode(int adj,int wgt,EdgeNode nt)&#123;        this.adjvex=adj;        this.weight=wgt;        this.next=nt;    &#125;&#125;//生成图函数@Overridepublic void creatGraph(EdgeElement[] d) &#123;    int i;    for(i=0;i&lt;d.length;i++)&#123;//处理边集合  如果边集合重复 那程序不就有问题了么  这点要处理        if(d[i]==null) break;        int v1,v2,weight;        v1=d[i].fromvex;        v2=d[i].endvex;        weight=d[i].weight;        if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;            System.out.println(&quot;边的顶点序号无效，退出运行&quot;);            System.exit(0);        &#125;        if(type==GraphType.NoDirectionNoWeight)&#123;//处理无方向 无权重的图            a[v1]=new EdgeNode(v2,a[v1]);//把边挂载在主干上,a为EdgeNode类型的一维数组            a[v2]=new EdgeNode(v1,a[v2]);//处理第二条边        &#125;else if(type==GraphType.NoDirectionWeight)&#123;//处理无向有权图            a[v1]=new EdgeNode(v2,weight,a[v1]);            a[v2]=new EdgeNode(v1,weight,a[v2]);        &#125;else if(type==GraphType.DirectionNoWeight)&#123;//处理有向无权图            a[v1]=new EdgeNode(v2,a[v1]);        &#125;else &#123;            a[v1]=new EdgeNode(v2,weight,a[v1]);        &#125;    &#125;    e=i;&#125;//在图中查找一条边public boolean find(int v1,int v2)&#123;    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);        System.exit(0);    &#125;    EdgeNode p=a[v1];    while(p!=null)&#123;        if(p.adjvex==v2)&#123;            return true;        &#125;        p=p.next;    &#125;    return false;&#125;//向图中插入一条边public void putEdge(EdgeElement theEdge)&#123;    int v1,v2,weight;    v1=theEdge.fromvex;    v2=theEdge.endvex;    weight=theEdge.weight;    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);        System.exit(0);    &#125;    EdgeNode p=a[v1];    while(p!=null)&#123;        if(p.adjvex==v2)&#123;            break;//退出后处理        &#125;        p=p.next;    &#125;    if(p==null) e++;    else&#123;        if(type==GraphType.DirectionWeight || type==GraphType.NoDirectionWeight)&#123;            p.weight=weight;        &#125;        if(type==GraphType.NoDirectionWeight)&#123;//无向有权重的另一条边也要处理            EdgeNode q=a[v2];            while(q!=null)&#123;                if(q.adjvex==v1) break;                q=q.next;            &#125;            q.weight=weight;        &#125;        return;    &#125;    if(type==GraphType.NoDirectionNoWeight)&#123;//如果是无向无权重        a[v1]=new EdgeNode(v2, a[v1]);        a[v2]=new EdgeNode(v1, a[v2]);    &#125;else if(type==GraphType.NoDirectionWeight)&#123;//处理无向有权重        a[v1]=new EdgeNode(v2,weight,a[v1]);        a[v2]=new EdgeNode(v1,weight,a[v2]);    &#125;else if(type==GraphType.DirectionNoWeight)&#123;//有向无权重        a[v1]=new EdgeNode(v2,a[v1]);    &#125;else&#123;        a[v1]=new EdgeNode(v2, weight,a[v1]);    &#125;&#125;public void removeEdge(int v1,int v2)&#123;    if(v1&lt;0||v1&gt;n-1||v2&lt;0||v2&gt;n-1||v1==v2)&#123;        System.out.println(&quot;边的顶点序号无效，退出运行&quot;);        System.exit(0);    &#125;    EdgeNode p=a[v1],q=null;//拿到主干结点    while(p!=null)&#123;        if(p.adjvex==v2) break;        q=p;        p=p.next;    &#125;    if(p==null)&#123;        System.out.println(&quot;要删除的边不存在，程序退出运行&quot;);        System.exit(0);    &#125;    if(q==null)&#123;//该结点在表头上 主干的节点就是需要找的结点        a[v1]=a[v1].next;    &#125;else&#123;        q.next=p.next;//嫁接上    &#125;    //删除无向图的另一个结点上的边    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;        EdgeNode p1=a[v2],q1=null;        while(p1!=null)&#123;            if(p1.adjvex==v1)&#123;                break;            &#125;            q1=p1;            p1=p1.next;        &#125;        if(q1==null)&#123;            a[v2]=a[v2].next;        &#125;else&#123;            q1.next=p1.next;        &#125;    &#125;    e--;&#125;//返回一个顶点的度，度分为入度和出度，要分别处理public int degree(int i)&#123;    if(i&lt;0||i&gt;n-1)&#123;        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);        System.exit(0);    &#125;    int k=0;    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;        EdgeNode p=a[i];        while(p!=null)&#123;            k++;            p=p.next;        &#125;        return k;    &#125;else return inDegree(i)+outDegree(i);&#125;//求出并返回一个顶点的入度public int inDegree(int i)&#123;//返回指向该顶点的度，入度，用双循环来实现    int k=0;//记录入度个数    if(i&lt;0||i&gt;n-1)&#123;        System.out.println(&quot;顶点超过了范围，程序退出运行&quot;);        System.exit(0);    &#125;    if(type==GraphType.NoDirectionNoWeight||type==GraphType.NoDirectionWeight)&#123;        return -1;    &#125;else&#123;        for(int j=0;j&lt;n;j++)&#123;            EdgeNode p=a[j];            while(p!=null)&#123;                if(p.adjvex==i)k++;                p=p.next;            &#125;        &#125;    &#125;    return k;&#125;//返回一个顶点的出度public int outDegree(int i)&#123;    int k=0;//记录出度的数目    EdgeNode p=a[i];    while(p!=null)&#123;        k++;        p=p.next;    &#125;    return k;&#125;//得到邻接矩阵public int[][] getAdjacencyMatrix()&#123;    int adjacencyMatrix[][]=new int[n][n];    if(type==GraphType.DirectionNoWeight||type==GraphType.DirectionWeight)&#123;//有向性        //有向 那不存在的边是存在一个InfinityValue        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                if(i==j) adjacencyMatrix[i][j]=0;                else adjacencyMatrix[i][j]=InfinityValue;            &#125;        &#125;    &#125;else&#123;        //无向 都设置为0        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                 adjacencyMatrix[i][j]=0;            &#125;        &#125;    &#125;        //遍历整个图        for(int i=0;i&lt;n;i++)&#123;            EdgeNode p=a[i];            while(p!=null)&#123;                adjacencyMatrix[i][p.adjvex]=p.weight;                p=p.next;            &#125;        &#125;    return adjacencyMatrix;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/posts/61466.html"/>
      <url>/posts/61466.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/posts/54793.html"/>
      <url>/posts/54793.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>234树</title>
      <link href="/posts/32086.html"/>
      <url>/posts/32086.html</url>
      
        <content type="html"><![CDATA[<p>平衡树，子节点数目可以达到4个</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>若父节点中存有1个数据项，则必有2个子节点。</p></li><li><p>若父节点中存有2个数据项，则必有3个子节点。</p></li><li><p>若父节点中存有3个数据项，则必有4个子节点。</p></li></ol><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>插入数据：</p><ul><li><p>未满节点直接插入</p></li><li><p>满节点 ABC 分裂 A不变 B到父节点 C到右侧</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>class Node&#123;private static final int ORDER = 4;private int numItems;//节点中实际存储的数据项数目，其值一定不大于3private Node parent;private Node childArray[] = new Node[ORDER];//子节点数组private DataItem itemArray[] = new DataItem[ORDER-1];//存储数据项数组//-------------------------------------------------------------// 把参数中的节点作为子节点，与当前节点进行连接public void connectChild(int childNum, Node child)   &#123;   childArray[childNum] = child;   if(child != null)      child.parent = this;//当前节点作为父节点   &#125;//-------------------------------------------------------------// 断开参数确定的节点与当前节点的连接，这个节点一定是当前节点的子节点。public Node disconnectChild(int childNum)   &#123;   Node tempNode = childArray[childNum];   childArray[childNum] = null; //断开连接   return tempNode;//返回要这个子节点   &#125;//-------------------------------------------------------------public Node getChild(int childNum)//获取相应的子节点   &#123; return childArray[childNum]; &#125;//-------------------------------------------------------------public Node getParent()//获取父节点   &#123; return parent; &#125;//-------------------------------------------------------------public boolean isLeaf()//是否是叶结点   &#123; return (childArray[0]==null) ? true : false; &#125;//叶结点没有子节点//-------------------------------------------------------------public int getNumItems()//获取实际存储的数据项数目  &#123; return numItems; &#125;//-------------------------------------------------------------public DataItem getItem(int index)   // 获取具体的数据项   &#123; return itemArray[index]; &#125;//-------------------------------------------------------------public boolean isFull()//该节点是否已满   &#123; return (numItems==ORDER-1) ? true : false; &#125;//-------------------------------------------------------------public int findItem(long key)       // 查找   &#123;                                       for(int j=0; j&lt;ORDER-1; j++)         // 遍历数组      &#123;                                       if(itemArray[j] == null)          // 数组未满，未找到         break;      else if(itemArray[j].dData == key)         return j;      &#125;   return -1;   &#125;  // end findItem//-------------------------------------------------------------public int insertItem(DataItem newItem)//节点未满的插入   &#123;   numItems++;                             long newKey = newItem.dData;         // 获得关键字    for(int j=ORDER-2; j&gt;=0; j--)        // 因为节点未满，所以从倒数第二项向前查找      &#123;                                    if(itemArray[j] == null)          // 没存数据         continue;                            else                                       &#123;                                       long itsKey = itemArray[j].dData;//获得关键字         if(newKey &lt; itsKey)            //插入位置在其前面，但未必相邻            itemArray[j+1] = itemArray[j]; //当前数据项后移         else            &#123;            itemArray[j+1] = newItem;   // 在其后位置插入            return j+1;                 // 返回插入的位置下标            &#125;                           //    new item         &#125;  // end else (not null)      &#125;  // end for                     // shifted all items,   //若上述代码没有执行返回操作，那么这是空节点（只有初始时根是这个情况）   itemArray[0] = newItem;              // insert new item   return 0;   &#125;  // end insertItem()//-------------------------------------------------------------public DataItem removeItem()        // 移除数据项，从后向前移除   &#123;   // 假设节点非空   DataItem temp = itemArray[numItems-1];  // 要移除的数据项   itemArray[numItems-1] = null;           // 移除   numItems--;                             // 数据项数目减一   return temp;                            // 返回要移除的数据项   &#125;//-------------------------------------------------------------public void displayNode()           // format &quot;/24/56/74/&quot;   &#123;   for(int j=0; j&lt;numItems; j++)      itemArray[j].displayItem();   // &quot;/56&quot;   System.out.println(&quot;/&quot;);         // final &quot;/&quot;   &#125;//-------------------------------------------------------------&#125;  // end class Node////////////////////////////////////////////////////////////////class Tree234&#123;private Node root = new Node();            // 创建树的根//-------------------------------------------------------------//获取查找的下一个节点public Node getNextChild(Node theNode, long theValue)&#123;int j;// 假设这个节点不是叶结点int numItems = theNode.getNumItems();//获得当前节点的数据项数目for(j=0; j&lt;numItems; j++)             &#123;                                if( theValue &lt; theNode.getItem(j).dData )      return theNode.getChild(j);  // 返回相应的节点   &#125;  // end for                   return theNode.getChild(j);        // 此时j=numItems&#125;//-------------------------------------------------------------public int find(long key)   &#123;   Node curNode = root;   int childNumber;   while(true)      &#123;      if(( childNumber=curNode.findItem(key) ) != -1)//每次循环这句一定执行         return childNumber;               // found it      else if( curNode.isLeaf() )//叶结点上也没找到         return -1;                        // can&#39;t find it      else                                 // 不是叶结点，则继续向下查找         curNode = getNextChild(curNode, key);      &#125;  // end while   &#125;//-------------------------------------------------------------// 插入数据项public void insert(long dValue)   &#123;   Node curNode = root;//当前节点标志   DataItem tempItem = new DataItem(dValue);//插入数据项封装    while(true)      &#123;      if( curNode.isFull() )               // 是满节点         &#123;         split(curNode);                   // 分裂         curNode = curNode.getParent();    // 回到分裂出的父节点上                                           // 继续向下查找         curNode = getNextChild(curNode, dValue);         &#125;  // end if(node is full)//后面的操作中节点都未满，否则先执行上面的代码      else if( curNode.isLeaf() )          // 是叶结点，非满         break;                            // 跳出，直接插入         else         curNode = getNextChild(curNode, dValue);//向下查找      &#125;  // end while    curNode.insertItem(tempItem);       // 此时节点一定不满，直接插入数据项，   &#125;  // end insert()//-------------------------------------------------------------public void split(Node thisNode)     // 分裂   &#123;   // 操作中节点一定是满节点，否则不会执行该操作   DataItem itemB, itemC;   Node parent, child2, child3;   int itemIndex;    itemC = thisNode.removeItem();    // 移除最右边的两个数据项，并保存为B和C   itemB = thisNode.removeItem();    //    child2 = thisNode.disconnectChild(2); // //断开最右边两个子节点的链接   child3 = thisNode.disconnectChild(3); //     Node newRight = new Node();       //新建一个节点，作为当前节点的兄弟节点    if(thisNode==root)                // 是根      &#123;      root = new Node();                // 新建一个根      parent = root;                    // 把新根设为父节点      root.connectChild(0, thisNode);   // 连接父节点和子节点      &#125;   else                              // 不是根      parent = thisNode.getParent();    // 获取父节点      itemIndex = parent.insertItem(itemB); // 把B插入父节点中，返回插入位置   int n = parent.getNumItems();         // 获得总数据项数目    for(int j=n-1; j&gt;itemIndex; j--)          //从后向前移除      &#123;                                          Node temp = parent.disconnectChild(j); // 断开连接      parent.connectChild(j+1, temp);        // 连接到新的位置      &#125;                              parent.connectChild(itemIndex+1, newRight);//连接到新位置    // 处理兄弟节点   newRight.insertItem(itemC);       // 将C放入兄弟节点中   newRight.connectChild(0, child2); // 把子节点中最右边的两个连接到兄弟节点上   newRight.connectChild(1, child3); //   &#125;  // end split()//-------------------------------------------------------------// gets appropriate child of node during search for value public void displayTree()   &#123;   recDisplayTree(root, 0, 0);   &#125;//-------------------------------------------------------------private void recDisplayTree(Node thisNode, int level,                                           int childNumber)   &#123;   System.out.print(&quot;level=&quot;+level+&quot; child=&quot;+childNumber+&quot; &quot;);   thisNode.displayNode();               // display this node    // call ourselves for each child of this node   int numItems = thisNode.getNumItems();   for(int j=0; j&lt;numItems+1; j++)      &#123;      Node nextNode = thisNode.getChild(j);      if(nextNode != null)         recDisplayTree(nextNode, level+1, j);      else         return;      &#125;   &#125;  // end recDisplayTree()//-------------------------------------------------------------\&#125;  // end class Tree234////////////////////////////////////////////////////////////////import java.io.*; class Tree234App&#123;public static void main(String[] args) throws IOException   &#123;   long value;   Tree234 theTree = new Tree234();    theTree.insert(50);   theTree.insert(40);   theTree.insert(60);   theTree.insert(30);   theTree.insert(70);    while(true)      &#123;      System.out.print(&quot;Enter first letter of &quot;);      System.out.print(&quot;show, insert, or find: &quot;);      char choice = getChar();      switch(choice)         &#123;         case &#39;s&#39;:            theTree.displayTree();            break;         case &#39;i&#39;:            System.out.print(&quot;Enter value to insert: &quot;);            value = getInt();            theTree.insert(value);            break;         case &#39;f&#39;:            System.out.print(&quot;Enter value to find: &quot;);            value = getInt();            int found = theTree.find(value);            if(found != -1)               System.out.println(&quot;Found &quot;+value);            else               System.out.println(&quot;Could not find &quot;+value);            break;         default:            System.out.print(&quot;Invalid entry\n&quot;);         &#125;  // end switch      &#125;  // end while   &#125;  // end main()//--------------------------------------------------------------public static String getString() throws IOException   &#123;   InputStreamReader isr = new InputStreamReader(System.in);   BufferedReader br = new BufferedReader(isr);   String s = br.readLine();   return s;   &#125;//--------------------------------------------------------------public static char getChar() throws IOException   &#123;   String s = getString();   return s.charAt(0);   &#125; //-------------------------------------------------------------public static int getInt() throws IOException   &#123;   String s = getString();   return Integer.parseInt(s);   &#125;//-------------------------------------------------------------&#125;  // end class Tree234App////////////////////////////////////////////////////////////////</code></pre>]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-归并排序</title>
      <link href="/posts/8756.html"/>
      <url>/posts/8756.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-计数排序</title>
      <link href="/posts/14338.html"/>
      <url>/posts/14338.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-桶排序</title>
      <link href="/posts/37369.html"/>
      <url>/posts/37369.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/posts/22315.html"/>
      <url>/posts/22315.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-快速排序</title>
      <link href="/posts/63170.html"/>
      <url>/posts/63170.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-选择排序</title>
      <link href="/posts/4840.html"/>
      <url>/posts/4840.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-希尔排序</title>
      <link href="/posts/59015.html"/>
      <url>/posts/59015.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-快速排序</title>
      <link href="/posts/63169.html"/>
      <url>/posts/63169.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序-基数排序</title>
      <link href="/posts/26468.html"/>
      <url>/posts/26468.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密-md5</title>
      <link href="/posts/29014.html"/>
      <url>/posts/29014.html</url>
      
        <content type="html"><![CDATA[<p>MD5 和SHA-1 是目前使用比较广泛的散列(Hash)函数，也是在消息认证和数字签名中普遍使用的两种加密算法。本文基于AVR 高速嵌入式单片机，实现了MD5和SHA-1 两种加密算法的比较，并对算法进行了汇编语言的优化和改进。根据实验结果，对两种算法的优缺点进行了比较和分析。 0 引言 随着信息技术和Internet 的迅速发展，信息安全和可靠性问题越来越重要。现在信息安全面临两大基本攻击：被动式攻击（获取消息的内容、业务流分析）和主动攻击（假冒、消息的篡改、业务拒绝）。前者主要靠加密和解密技术进行有效处理，而后者就要靠消息认证来处理。在金融交易、电子商务、电子信件、手机用户信息的确认等领域，数据完整性确认和数据来源的真伪鉴定都是很重要的安全服务。实现这些安全服务的最好方法就是使用加密函数中的单项散列（Hash）函数。单项散列（Hash）函数是一种单项密码体制，它是一个从明文到密文的不可逆函数，也就是说，是无法解密的。通常应用在只需要加密、不需要解密的特殊应用场合。单项散列（Hash）函数H(M)作用于一任意长度的消息M，它返回一固定长度的散列值h:h&#x3D;H(M)作为初始消息的独一无二的“数字指纹”，从而能保证数据的完整性和惟一性。 3.1 MD5 与SHA-1 的比较 由于MD5 与SHA-1均是从MD4 发展而来，它们的结构和强度等特性有很多相似之处，表（1）是对MD5 与SHA-1 的结构比较。SHA-1与MD5 的最大区别在于其摘要比MD5 摘要长 32 比特。对于强行攻击，产生任何一个报文使之摘要等于给定报文摘要的难度：MD5 是2128 数量级的操作，SHA-1 是2160 数量级的操作。产生具有相同摘要的两个报文的难度：MD5是 264 是数量级的操作，SHA-1 是280 数量级的操作。因而,SHA-1 对强行攻击的强度更大。但由于SHA-1 的循环步骤比MD5 多（80:64）且要处理的缓存大（160 比特:128 比特），SHA-1 的运行速度比MD5 慢。 5 结束语 MD5 和SHA-1 是单项散列函数的典型代表，它们广泛地应用在信息安全和数字签名等各个领域。从而有效地抗击了信息的主动式攻击，本文基于AVR 单片机实现了这两种算法，并结合汇编语言尽心了优化，取得了较好的效果。根据信息安全的要求的不同层次可以灵活选择这两种算法从而达到实际目的。</p>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis统计信息--INFO</title>
      <link href="/posts/56223.html"/>
      <url>/posts/56223.html</url>
      
        <content type="html"><![CDATA[<p>显示关于redis服务器的状态报告和统计数值</p><pre><code>    redis&gt; INFO    # Server    redis_version:2.9.11 //服务器版本    redis_git_sha1:937384d0    redis_git_dirty:0    redis_build_id:8e9509442863f22    redis_mode:standalone  //mode    os:Linux 3.13.0-35-generic x86_64    arch_bits:64    multiplexing_api:epoll //事件处理机制    gcc_version:4.8.2    process_id:4716 //进程ID    run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc  //随机标识符（用于 Sentinel 和集群）    tcp_port:6379   //监听端口号    uptime_in_seconds:362  //启动以来，经过的秒数    uptime_in_days:0  //启动以来，经过的天数    hz:10  //serverCron运行频率，此值越大表示redis对&quot;间歇性task&quot;的执行次数越频繁(次数/秒)    lru_clock:1725349  //以分钟为单位进行自增的时钟，用于 LRU 管理    config_file:        # Clients    connected_clients:1  //已连接客户端的数量（不包括通过从属服务器连接的客户端）    client_longest_output_list:0  //当前连接的客户端当中，最长的输出列表    client_biggest_input_buf:0  //当前连接的客户端当中，最大输入缓存    blocked_clients:0 //正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量        # Memory    used_memory:508536  //由 Redis 分配器分配的内存总量，以字节（byte）为单位    used_memory_human:496.62K  //以人类可读的格式返回 Redis 分配的内存总量    used_memory_rss:7974912  //从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。    //理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿      //当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片    //当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。    used_memory_peak:508536 //Redis 的内存消耗峰值（以字节为单位）    used_memory_peak_human:496.62K //以人类可读的格式返回 Redis 的内存消耗峰值    used_memory_lua:33792  // Lua 引擎所使用的内存大小（以字节为单位）    mem_fragmentation_ratio:15.68  //used_memory_rss 和 used_memory 之间的比率    mem_allocator:jemalloc-3.2.0  //在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc        # Persistence    loading:0  //一个标志值，记录了服务器是否正在载入持久化文件      rdb_changes_since_last_save:6 //距离最近一次成功创建持久化文件之后，经过了多少秒    rdb_bgsave_in_progress:0 //一个标志值，记录了服务器是否正在创建 RDB 文件    rdb_last_save_time:1411011131 //最近一次成功创建 RDB 文件的 UNIX 时间戳    rdb_last_bgsave_status:ok //一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败    rdb_last_bgsave_time_sec:-1 //记录了最近一次创建 RDB 文件耗费的秒数    rdb_current_bgsave_time_sec:-1 // 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒    aof_enabled:0 //标志值，记录了 AOF 是否处于打开状态。      //如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：          // aof_current_size : AOF 文件目前的大小。      // aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。      // aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。      // aof_buffer_length : AOF 缓冲区的大小。      // aof_rewrite_buffer_length : AOF 重写缓冲区的大小。      // aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。      // aof_delayed_fsync : 被延迟的 fsync 调用数量。    aof_rewrite_in_progress:0 //一个标志值，记录了服务器是否正在创建 AOF 文件。    aof_rewrite_scheduled:0 //一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作    aof_last_rewrite_time_sec:-1 //最近一次创建 AOF 文件耗费的时长。    aof_current_rewrite_time_sec:-1 //如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒    aof_last_bgrewrite_status:ok //一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。    aof_last_write_status:ok //        # Stats    total_connections_received:2 //服务器已接受的连接请求数量    total_commands_processed:4 //服务器已执行的命令数量    instantaneous_ops_per_sec:0 //服务器每秒钟执行的命令数量    rejected_connections:0 //因为最大客户端数量限制而被拒绝的连接请求数量    sync_full:0     sync_partial_ok:0     sync_partial_err:0    expired_keys:0 //因为过期而被自动删除的数据库键数量    evicted_keys:0 //因为最大内存容量限制而被驱逐（evict）的键数量。    keyspace_hits:0 //查找数据库键成功的次数。    keyspace_misses:0 //查找数据库键失败的次数。    pubsub_channels:0 //目前被订阅的频道数量。    pubsub_patterns:0 //目前被订阅的模式数量。    latest_fork_usec:0 //最近一次 fork() 操作耗费的毫秒数。    migrate_cached_sockets:0        # Replication    role:master //如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。    connected_slaves:0    master_repl_offset:0    repl_backlog_active:0    repl_backlog_size:1048576    repl_backlog_first_byte_offset:0    repl_backlog_histlen:0        # CPU    used_cpu_sys:0.21  // Redis 服务器耗费的系统 CPU 。    used_cpu_user:0.17  // Redis 服务器耗费的用户 CPU 。    used_cpu_sys_children:0.00 //后台进程耗费的系统 CPU 。    used_cpu_user_children:0.00 //后台进程耗费的用户 CPU 。        # Cluster    cluster_enabled:0  //一个标志值，记录集群功能是否已经开启        # Keyspace    db0:keys=2,expires=0,avg_ttl=0 //部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-数学</title>
      <link href="/posts/25757.html"/>
      <url>/posts/25757.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="数学分析-概率论基础"><a href="#数学分析-概率论基础" class="headerlink" title="数学分析 概率论基础"></a>数学分析 概率论基础</h2><h3 id="导数与梯度"><a href="#导数与梯度" class="headerlink" title="导数与梯度"></a>导数与梯度</h3><h3 id="taylor展式的应用"><a href="#taylor展式的应用" class="headerlink" title="taylor展式的应用"></a>taylor展式的应用</h3><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>数据收集</li><li>数据清洗</li><li>特征工程</li><li>数据建模</li></ol><h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><p>线性回归、rate、loss</p><p>em code</p><p>em算法</p><p>gmm与图像</p><p>图像的卷积</p><p>去均值ICA分离</p><p>带噪声的信号分离</p><p>SVM: 高斯核函数的影响</p><p>HMM分词：MLE</p><p>LDA</p><p>舆情</p><p>最大熵模型</p><p>聚类</p><p>降维</p><p>SVM</p><p>主题模型pLASA&#x2F;LDA</p><p>条件随机场</p><p>变分推导Variation Inference</p><p>深度学习</p><p>$$ S&#x3D;\frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \frac{1}{4!} + \frac{1}{4!} + \Lambda + \frac{1}{n!}  $$</p><p>跳跃表分析</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown常用语法</title>
      <link href="/posts/43275.html"/>
      <url>/posts/43275.html</url>
      
        <content type="html"><![CDATA[<p>markdown优点是<em>易读易写</em>。格式化编辑，纯文本发布，无标签，但支持html标签。</p><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><p>   段落前后需要空行，若使用换行符<code>&lt;br/&gt;</code>，前面至少两个以上空格才会生效</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote><p>Setext 底线形式</p></blockquote><p>高阶标题\次阶标题,大于等于2个&#x3D;-</p><pre><code>This is Setext H1=================This is Setext H2-----------------</code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>[TOC] 目录 Markdown语法书写的话，可以自动生成层级目录</code></pre><p>六级标题</p><blockquote><p>atx 井号 1-6个</p></blockquote><pre><code># This is H1## This is H2</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>可以加在每一行，也可以加在段落第一行，可以嵌套使用</p><p><code>&gt; 引用文本-一级引用</code>  <br><br><code>&gt;&gt; 引用文本-二级引用</code> <br><br><code>&gt;&gt;&gt; 引用文本-三级引用</code> <br></p><blockquote><p>引用文本-一级引用</p><blockquote><p>引用文本-二级引用</p><blockquote><p>引用文本-三级引用</p></blockquote></blockquote></blockquote><blockquote><p>引用文本-一级引用</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序、有序  <code>&lt;br/&gt;</code><br>无序列表 使用 <code>*、+、-  &lt;br/&gt;</code><br>有序列表 使用 数字+英文句点</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>缩进4个空格或1个制表符 或<code>&lt;pre&gt;、&lt;code&gt;</code>标签</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个以上*、-、_</p><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><p>语法：行内式、参考式语法：行内式、参考式 [方括号]标记</p><p>This is <a href="https://www.baidu.com/" title="title">百度</a>  <br><br>    <code>This is [百度](https://www.baidu.com/ &quot;title&quot;)</code> </p><p>This is <a href="/about" title="about">关于</a>  <br><br>    <code>This is [关于](/about &quot;about&quot;)</code></p><p>This is <a href="https://www.baidu.com/" title="title">百度</a>  <br></p><pre><code>This is [百度][1]  &lt;br&gt;[1]:https://www.baidu.com/ &quot;title&quot;OR: [1]:&lt;https://www.baidu.com/&gt; &quot;title&quot;</code></pre><h2 id="隐式链接标记"><a href="#隐式链接标记" class="headerlink" title="隐式链接标记"></a>隐式链接标记</h2><p><a href="https://www.google.com/">Google</a></p><pre><code>[Google][][Google]:https://www.google.com/</code></pre><p><em>参考式：更易读</em></p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>使用 * 或者底线 _  <code>&lt;strong&gt;</code></p><p><em>this is strong</em> &#x2F;&#x2F;*两侧不能有空白</p><pre><code>*this is strong* //*两侧不能有空白</code></pre><h2 id="行内代码标记"><a href="#行内代码标记" class="headerlink" title="行内代码标记"></a>行内代码标记</h2><p>反引号&#96;&#96;&#96;&#96;&#96;</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>行内式 参考式    <code>&lt;img&gt;</code></p><pre><code>![alt text](/img/img1.jpg &quot;title&quot;)</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="right">状态集</th><th align="right">A</th><th align="right">B</th></tr></thead><tbody><tr><td align="right">1</td><td align="right">43</td><td align="right">33</td></tr><tr><td align="right">2</td><td align="right">0</td><td align="right">33</td></tr><tr><td align="right">3</td><td align="right">130</td><td align="right">118</td></tr><tr><td align="right">4</td><td align="right">0</td><td align="right">0</td></tr><tr><td align="right">5</td><td align="right">17</td><td align="right">6</td></tr><tr><td align="right">6</td><td align="right">180</td><td align="right">111</td></tr><tr><td align="right">总数</td><td align="right">370</td><td align="right">225</td></tr></tbody></table><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签: MARKDOWN</p><p>Tags: MARKDOWN</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><del>这是一条删除线</del></p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>这是一个注脚<a href="%E6%8F%8F%E8%BF%B0">^1</a></p><h2 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h2><p><span id="jump">跳转</span></p><p><a href="#jump">你好</a></p><h2 id="github文件"><a href="#github文件" class="headerlink" title="github文件"></a>github文件</h2><p>github文件地址格式</p><p><a href="https://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/repository%E4%BB%93%E5%BA%93%E5%90%8D/raw/%E5%88%86%E6%94%AF%E5%90%8Dmaster/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0/%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0">https://github.com/用户名/repository仓库名/raw/分支名master/图片文件夹名称/图片名称</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown 公式编辑</title>
      <link href="/posts/57926.html"/>
      <url>/posts/57926.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>文本中加入公式  <code>$ 数学公式 $</code></p><p>单独加入公式 <code>$$ 数学公式 $$</code></p><pre><code>\begin&#123;equation&#125;数学公式\label&#123;eq:当前公式名&#125;\end&#123;equation&#125;自动编号后的公式可在全文任意处使用 \eqref&#123;eq:公式名&#125; 语句引用。</code></pre><p><code>$ J_\alpha(x) = \sum_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha + 1)&#125; &#123;\left(&#123; \frac&#123;x&#125;&#123;2&#125; &#125;\right)&#125;^&#123;2m + \alpha&#125; \text &#123;，行内公式示例&#125;</code></p><p>示例： $ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p><p><code>$$ J_\alpha(x) = \sum_&#123;m=0&#125;^\infty \frac&#123;(-1)^m&#125;&#123;m! \Gamma (m + \alpha + 1)&#125; &#123;\left(&#123; \frac&#123;x&#125;&#123;2&#125; &#125;\right)&#125;^&#123;2m + \alpha&#125; \text &#123;，独立公式示例&#125; $$</code></p><p>示例：$$ J_\alpha(x) &#x3D; \sum_{m&#x3D;0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$ </p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p><code>^</code>表示上标, <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>&#123;&#125;</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用</p><p><code>$$ x^&#123;y^z&#125;=(1+&#123;\rm e&#125;^x)^&#123;-2xy^w&#125; $$</code></p><p>$$ x^{y^z}&#x3D;(1+{\rm e}^x)^{-2xy^w} $$</p><p>左右两边都有上下标，可以用<code>\sideset</code> 命令</p><p><code>$$ \sideset&#123;^1_2&#125;&#123;^3_4&#125;\bigotimes $$</code></p><p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p><h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\&#123;\&#125;</code> 来表示 <code>&#123;&#125;</code>。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令</p><p><code>$$\langle表达式\rangle$$</code></p><p>$$\langle表达式\rangle$$</p><p><code>$$\lceil表达式\rceil$$</code></p><p>$$\lceil表达式\rceil$$</p><p><code>$$\lfloor表达式\rfloor$$</code></p><p>$$\lfloor表达式\rfloor$$</p><p><code>$$\lbrace表达式\rbrace$$</code></p><p>$$\lbrace表达式\rbrace$$</p><p><code>$$ f(x,y,z) = 3y^2z \left( 3+\frac&#123;7x+5&#125;&#123;1+y^2&#125; \right) $$</code></p><p>$$ f(x,y,z) &#x3D; 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 命令产生一个分数\frac {分子} {分母}，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层</p><p><code>$$\frac&#123;a-1&#125;&#123;b-1&#125; \quad and \quad &#123;a+1\over b+1&#125;$$</code></p><p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] &#123;被开方数&#125;</code>命令输入开方。</p><p><code>$$\sqrt&#123;2&#125; \quad and \quad \sqrt[n]&#123;3&#125;$$</code></p><p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号</p><p><code>$$f(x_1,x_2,\underbrace&#123;\ldots&#125;_&#123;\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \underbrace&#123;\cdots&#125;_&#123;\rm cdots&#125; + x_n^2$$</code></p><p>$$f(x_1,x_2,\underbrace{\ldots}<em>{\rm ldots} ,x_n) &#x3D; x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2$$</p><h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec&#123;矢量&#125;</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号</p><p><code>$$\vec&#123;a&#125; \cdot \vec&#123;b&#125;=0$$</code></p><p>$$\vec{a} \cdot \vec{b}&#x3D;0$$</p><p><code>$$\overleftarrow&#123;xy&#125; \quad and \quad \overleftrightarrow&#123;xy&#125; \quad and \quad \overrightarrow&#123;xy&#125;$$</code></p><p>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_</code>积分下限^积分上限  <code>&#123;被积表达式&#125;</code> 来输入一个积分</p><p><code>$$\int_0^1 &#123;x^2&#125; \,&#123;\rm d&#125;x$$</code></p><p>$$\int_0^1 {x^2} ,{\rm d}x$$</p><h2 id="极限运算"><a href="#极限运算" class="headerlink" title="极限运算"></a>极限运算</h2><p>使用<code>\lim_&#123;变量 \to 表达式&#125;</code> 表达式 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号</p><p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p><p><code>$$ \lim_&#123;n \to +\infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125; \quad and \quad \lim_&#123;x\leftarrow&#123;示例&#125;&#125; \frac&#123;1&#125;&#123;n(n+1)&#125; $$</code></p><h2 id="累加、累乘运算"><a href="#累加、累乘运算" class="headerlink" title="累加、累乘运算"></a>累加、累乘运算</h2><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code>来输入一个累加。<br>与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>此类符号在行内显示时上下标表达式将会移至右上角和右下角</p><p><code>$$\sum_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \prod_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \bigcup_&#123;i=1&#125;^&#123;2&#125; R$$</code></p><p>$$\sum_{i&#x3D;1}^n \frac{1}{i^2} \quad and \quad \prod_{i&#x3D;1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i&#x3D;1}^{2} R$$</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code>和<code>\首字母大写希腊字母英文全称</code>来分别输入小写和大写希腊字母。</p><table><thead><tr><th align="right">输入</th><th align="right">显示</th><th align="right">输入</th><th align="right">显示</th></tr></thead><tbody><tr><td align="right">\alpha</td><td align="right">α</td><td align="right">A</td><td align="right">A</td></tr><tr><td align="right">\beta</td><td align="right">β</td><td align="right">B</td><td align="right">B</td></tr><tr><td align="right">\gamma</td><td align="right">γ</td><td align="right">\Gamma</td><td align="right">Γ</td></tr><tr><td align="right">\delta</td><td align="right">δ</td><td align="right">\Delta</td><td align="right">Δ</td></tr><tr><td align="right">\epsilon</td><td align="right">ϵ</td><td align="right">E</td><td align="right">E</td></tr><tr><td align="right">\zeta</td><td align="right">ζ</td><td align="right">Z</td><td align="right">Z</td></tr><tr><td align="right">\eta</td><td align="right">η</td><td align="right">H</td><td align="right">H</td></tr><tr><td align="right">\theta</td><td align="right">θ</td><td align="right">\Theta</td><td align="right">Θ</td></tr><tr><td align="right">\iota</td><td align="right">ι</td><td align="right">I</td><td align="right">I</td></tr><tr><td align="right">\kappa</td><td align="right">κ</td><td align="right">K</td><td align="right">K</td></tr><tr><td align="right">\lambda</td><td align="right">λ</td><td align="right">\Lambda</td><td align="right">Λ</td></tr><tr><td align="right">\nu</td><td align="right">ν</td><td align="right">N</td><td align="right">N</td></tr><tr><td align="right">\mu</td><td align="right">μ</td><td align="right">M</td><td align="right">M</td></tr><tr><td align="right">\xi</td><td align="right">ξ</td><td align="right">\Xi</td><td align="right">Ξ</td></tr><tr><td align="right">o</td><td align="right">o</td><td align="right">O</td><td align="right">O</td></tr><tr><td align="right">\pi</td><td align="right">π</td><td align="right">\Pi</td><td align="right">Π</td></tr><tr><td align="right">\rho</td><td align="right">ρ</td><td align="right">P</td><td align="right">P</td></tr><tr><td align="right">\sigma</td><td align="right">σ</td><td align="right">\Sigma</td><td align="right">Σ</td></tr><tr><td align="right">\tau</td><td align="right">τ</td><td align="right">T</td><td align="right">T</td></tr><tr><td align="right">\upsilon</td><td align="right">υ</td><td align="right">\Upsilon</td><td align="right">Υ</td></tr><tr><td align="right">\phi</td><td align="right">ϕ</td><td align="right">\Phi</td><td align="right">Φ</td></tr><tr><td align="right">\chi</td><td align="right">χ</td><td align="right">X</td><td align="right">X</td></tr><tr><td align="right">\psi</td><td align="right">ψ</td><td align="right">\Psi</td><td align="right">Ψ</td></tr><tr><td align="right">\omega</td><td align="right">ω</td><td align="right">\Omega</td><td align="right">Ω</td></tr></tbody></table><h2 id="大括号和行标的使用"><a href="#大括号和行标的使用" class="headerlink" title="大括号和行标的使用"></a>大括号和行标的使用</h2><p>使用 <code>\left</code>和 <code>\right</code>来创建自动匹配高度的 <code>(圆括号)，[方括号] 和 &#123;花括号&#125; </code>。<br>在每个公式末尾前使用<code>\tag&#123;行标&#125;</code>来实现行标。</p><pre><code>$$f\left(   \left[      \frac&#123;       1+\left\&#123;x,y\right\&#125;     &#125;&#123;       \left(          \frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;       \right)       \left(u+1\right)     &#125;+a   \right]^&#123;3/2&#125;\right)\tag&#123;行标&#125;$$</code></pre><p>$$<br>f\left(<br>   \left[<br>     \frac{<br>       1+\left{x,y\right}<br>     }{<br>       \left(<br>          \frac{x}{y}+\frac{y}{x}<br>       \right)<br>       \left(u+1\right)<br>     }+a<br>   \right]^{3&#x2F;2}<br>\right)<br>\tag{行标}<br>$$</p><p><code>$\smash&#123;\displaystyle\max_&#123;0 \leq q \leq n-1&#125;&#125; f(q) \le n$</code></p><p>$\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$</p><p><code>$f(x + \epsilon) \approx f(x) + f&#39;(x) \epsilon + \mathcal&#123;O&#125;(\epsilon^2).$</code></p><p>$f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$</p><p><code>$\text&#123;d&#125;x$</code></p><p>$\text{d}x$</p><p>链接：<a href="https://www.cnblogs.com/q735613050/p/7253073.html">Markdown公式编辑学习笔记</a><br>链接：<a href="https://www.arxiv-vanity.com/papers/1712.01208/">The Case for Learned Index Structures</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-跳表</title>
      <link href="/posts/63989.html"/>
      <url>/posts/63989.html</url>
      
        <content type="html"><![CDATA[<p>二分查找要求元素可以随机访问，所以决定了需要把元素存储在连续内存。这样查找确实很快，但是插入和删除元素的时候，为了保证元素的有序性，就需要大量的移动元素了。<br>如果需要的是一个能够进行二分查找，又能快速添加和删除元素的数据结构，首先就是二叉查找树，二叉查找树在最坏情况下可能变成一个链表。<br>于是，就出现了平衡二叉树，根据平衡算法的不同有AVL树，B-Tree，B+Tree，红黑树等，但是AVL树实现起来比较复杂，平衡操作较难理解，这时候就可以用SkipList跳跃表结构。</p><p>Key-Value数据结构<br>目前常用的key-value数据结构有三种：Hash表、红黑树、SkipList，它们各自有着不同的优缺点（不考虑删除操作）：<br>Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。<br>红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。<br>SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</p><p>如果要实现一个key-value结构，需求的功能有插入、查找、迭代、修改，那么首先Hash表就不是很适合了，因为迭代的时间复杂度比较高；而红黑树的插入很可能会涉及多个结点的旋转、变色操作，因此需要在外层加锁，这无形中降低了它可能的并发度。而SkipList底层是用链表实现的，可以实现为lock free，同时它还有着不错的性能（单线程下只比红黑树略慢），非常适合用来实现我们需求的那种key-value结构。<br>LevelDB、Reddis的底层存储结构就是用的SkipList。</p><h2 id="基于锁的并发"><a href="#基于锁的并发" class="headerlink" title="基于锁的并发"></a>基于锁的并发</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>编程模型简单，如果小心控制上锁顺序，一般来说不会有死锁的问题；</li><li>可以通过调节锁的粒度来调节性能。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>所有基于锁的算法都有死锁的可能；</li><li>上锁和解锁时进程要从用户态切换到内核态，并可能伴随有线程的调度、上下文切换等，开销比较重；</li><li>对共享数据的读与写之间会有互斥。</li></ol><h2 id="无锁编程（lock-free）"><a href="#无锁编程（lock-free）" class="headerlink" title="无锁编程（lock free）"></a>无锁编程（lock free）</h2><p>常见的lock free编程一般是基于CAS(Compare And Swap)操作：<code>CAS(void *ptr, Any oldValue, Any newValue);</code><br>即查看内存地址ptr处的值，如果为oldValue则将其改为newValue，并返回true，否则返回false。X86平台上的CAS操作一般是通过CPU的CMPXCHG指令来完成的。CPU在执行此指令时会首先锁住CPU总线，禁止其它核心对内存的访问，然后再查看或修改*ptr的值。简单的说CAS利用了CPU的硬件锁来实现对共享资源的串行使用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>开销较小：不需要进入内核，不需要切换线程；</li><li>没有死锁：总线锁最长持续为一次read+write的时间；</li><li>只有写操作需要使用CAS，读操作与串行代码完全相同，可实现读写不互斥。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>编程非常复杂，两行代码之间可能发生任何事，很多常识性的假设都不成立。</li><li>CAS模型覆盖的情况非常少，无法用CAS实现原子的复数操作。</li></ol><p>而在性能层面上，CAS与mutex&#x2F;readwrite lock各有千秋，简述如下：</p><ol><li>单线程下CAS的开销大约为10次加法操作，mutex的上锁+解锁大约为20次加法操作，而readwrite lock的开销则更大一些。</li><li>CAS的性能为固定值，而mutex则可以通过改变临界区的大小来调节性能；</li><li>如果临界区中真正的修改操作只占一小部分，那么用CAS可以获得更大的并发度。</li><li>多核CPU中线程调度成本较高，此时更适合用CAS。<br>跳表和红黑树的性能相当，最主要的优势就是当调整(插入或删除)时，红黑树需要使用旋转来维护平衡性，这个操作需要动多个节点，在并发时候很难控制。而跳表插入或删除时只需定位后插入，插入时只需添加插入的那个节点及其多个层的复制，以及定位和插入的原子性维护。所以它更加可以利用CAS操作来进行无锁编程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/posts/5009.html"/>
      <url>/posts/5009.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表HashMap</title>
      <link href="/posts/24972.html"/>
      <url>/posts/24972.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/posts/36750.html"/>
      <url>/posts/36750.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优先队列</title>
      <link href="/posts/40836.html"/>
      <url>/posts/40836.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/posts/35077.html"/>
      <url>/posts/35077.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-同步锁-synchronized</title>
      <link href="/posts/22933.html"/>
      <url>/posts/22933.html</url>
      
        <content type="html"><![CDATA[<p>控制Java多线程环境下的线程同步</p><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>synchronized修饰方法或者代码块</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>synchronized修饰静态方法或者代码块</p><h2 id="方法锁（对象锁）"><a href="#方法锁（对象锁）" class="headerlink" title="方法锁（对象锁）"></a>方法锁（对象锁）</h2><p>synchronized修饰方法，锁住的也是这个对象</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public class SynchronizeTest &#123;    static class S&#123;        String name;        public void setName(String name) throws InterruptedException &#123;            synchronized (this) &#123;                System.out.println(&quot;..........&quot;);                Thread.sleep(1000*5L);                this.name = name;            &#125;        &#125;        public void print()&#123;            synchronized (this)&#123;                System.out.println(name);            &#125;        &#125;        public synchronized void doSomething1()&#123;            System.out.println(&quot;doSomething1&quot;);            try &#123;                Thread.sleep(1000*5L);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        public synchronized void doSomething2()&#123;            System.out.println(name);        &#125;    &#125;    public static void main(String[] args) throws Exception&#123;        S s = new S();//        Thread t1 = new Thread(() -&gt; &#123;//            try &#123;//                s.setName(&quot;hello&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        t1.start();//        Thread t2 = new Thread(() -&gt; &#123;//                s.print();//        &#125;);//        t2.start();//        t1.join();//        t2.join();        Thread t1 = new Thread(() -&gt; &#123;             s.doSomething1();        &#125;);        t1.start();        Thread t2 = new Thread(() -&gt; &#123;            s.doSomething2();        &#125;);        t2.start();        t1.join();        t2.join();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-java8语法</title>
      <link href="/posts/22404.html"/>
      <url>/posts/22404.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-rbac权限管理</title>
      <link href="/posts/43300.html"/>
      <url>/posts/43300.html</url>
      
        <content type="html"><![CDATA[<p>RBAC : 基于角色的权限访问控制（Role-Based Access Control）通过角色绑定权限，然后给用户划分角色。在web应用中，可以将权限理解为url，一个权限对应一个url。</p><h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><p>用户，角色，权限，权限组，菜单</p><p>用户和角色，多对多<br>角色和权限，多对多<br>权限和权限组，多对一<br>权限组和菜单，多对一<br>菜单和菜单，自引用</p><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>用户登录后，取出其权限及所属菜单信息，写入session中</p><p>自定义中间件，检查用户权限，进行访问控制</p><p>参考：<a href="https://www.jianshu.com/p/f45b54768aa9">https://www.jianshu.com/p/f45b54768aa9</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-JVM内存模型</title>
      <link href="/posts/1252.html"/>
      <url>/posts/1252.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p><img src="/img/jvm_memory_20221229161909.png" alt="JVM内存模型"></p><h2 id="指令重排-编译器、运行时"><a href="#指令重排-编译器、运行时" class="headerlink" title="指令重排(编译器、运行时)"></a>指令重排(编译器、运行时)</h2><p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><pre><code>编译器优化重排序指令级并行重排序内存系统重排序</code></pre><h2 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p><h2 id="指令级并行重排序"><a href="#指令级并行重排序" class="headerlink" title="指令级并行重排序"></a>指令级并行重排序</h2><p>编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>指令级并行的重排序：现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><h2 id="内存系统重排序"><a href="#内存系统重排序" class="headerlink" title="内存系统重排序"></a>内存系统重排序</h2><p>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行(强调的是内存缓存)。<br>在虚拟机层面，为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><h3 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h3><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><h3 id="基于保守策略的JMM内存屏障插入策略："><a href="#基于保守策略的JMM内存屏障插入策略：" class="headerlink" title="基于保守策略的JMM内存屏障插入策略："></a>基于保守策略的JMM内存屏障插入策略：</h3><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-JDK动态代理或CGLIB</title>
      <link href="/posts/37039.html"/>
      <url>/posts/37039.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用JDK动态代理"><a href="#使用JDK动态代理" class="headerlink" title="使用JDK动态代理"></a>使用JDK动态代理</h1><p>Spring AOP默认使用JDK动态代理（基于接口的代理）。</p><p>如果被代理的目标对象已经实现了接口，则使用JDK动态代理。如果目标对象未实现任何接口，则会创建CGLIB代理。</p><h1 id="使用CGLIB代理注意"><a href="#使用CGLIB代理注意" class="headerlink" title="使用CGLIB代理注意"></a>使用CGLIB代理注意</h1><ul><li>final方法不建议使用，因为它们无法被覆盖。</li><li>除非强制使用CGLIB，需要将元素 <code>&lt;</code>aop:config<code>&gt;</code> 的属性proxy-target-class值设置为true。</li><li>需要CGLIB库，找不到CGLIB库类时，Spring会发出警告。</li><li>代理对象的构造函数将被调用两次。这是因为CGLIB代理会为每个代理对象生成子类。构造函数中只做赋值和初始化，不能实现其他的逻辑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-java8语法</title>
      <link href="/posts/22405.html"/>
      <url>/posts/22405.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="stream-forEach-循环处理"><a href="#stream-forEach-循环处理" class="headerlink" title="stream().forEach()循环处理"></a>stream().forEach()循环处理</h3><pre><code>List&lt;String&gt; list = com.google.common.collect.Lists.newArrayList();list.add(&quot;1&quot;);list.add(&quot;2&quot;);list.add(&quot;3&quot;);list.stream().forEach(string -&gt;&#123;    System.out.println(string);&#125;);</code></pre><h3 id="stream-map-处理集合，collect-Collectors-toList-结果输出为List"><a href="#stream-map-处理集合，collect-Collectors-toList-结果输出为List" class="headerlink" title="stream().map()处理集合，collect(Collectors.toList())结果输出为List"></a>stream().map()处理集合，collect(Collectors.toList())结果输出为List</h3><pre><code>List&lt;String&gt; list1 = Lists.newArrayList();list1.add(&quot;1&quot;);list1.add(&quot;2&quot;);list1.add(&quot;3&quot;);List&lt;String&gt; list2 = list1.stream().map(string -&gt; &#123;    return &quot;stream().map()处理之后：&quot; + string;&#125;).collect(Collectors.toList());System.out.println(list2.toString());</code></pre><h3 id="stream-filter-过滤集合"><a href="#stream-filter-过滤集合" class="headerlink" title="stream().filter()过滤集合"></a>stream().filter()过滤集合</h3><pre><code>List&lt;String&gt; list1 = Lists.newArrayList();list1.add(&quot;1&quot;);list1.add(&quot;1&quot;);list1.add(&quot;2&quot;);list1.add(&quot;3&quot;);List&lt;String&gt; list2 = list1.stream().filter(s -&gt; !s.equals(&quot;1&quot;)).collect(Collectors.toList());System.out.println(list2.toString());</code></pre><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>一个只包含一个方法的接口,可以使用Lambda表达式作为参数</p><pre><code>new Thread(() -&gt; System.out.println(&quot;Hello World!&quot;));public interface Interface1 &#123;     void test();&#125;private void func(Interface1 interface1) &#123;    interface1.test();&#125;func(() -&gt; System.out.println(&quot;Hello World&quot;));//有参数，参数知名类型更规范func((Integer x) -&gt; System.out.println(&quot;Hello World&quot; + x));//有参数，有返回值func((Integer x) -&gt; &#123;    System.out.println(&quot;Hello World&quot; + x);    return true;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-EL-Spring 表达式语言</title>
      <link href="/posts/21202.html"/>
      <url>/posts/21202.html</url>
      
        <content type="html"><![CDATA[<p>EL-Spring 表达式语言，支持xml和注解中使用表达式，类似JSP 的EL 表达式，可以实现普通文件、网址、配置文件、系统环境变量的注入</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>@PropertySource(&quot;classpath:application.properties&quot;)@Value(&quot;This is common string&quot;) // 注入普通字符串private String normal;@Value(&quot;#&#123;systemProperties[&#39;os.name&#39;]&#125;&quot;) // 注入操作系统属性private String osName;@Value(&quot;#&#123;T(java.lang.Math).random()*100.0&#125;&quot;) // 注入表达式结果private double randomNumber;@Value(&quot;#&#123;anotherService.property&#125;&quot;) // 注入其他Bean属性private String propfromAnother;@Value(&quot;#&#123;T(com.demo.el.spring_el_demo.DemoService).getCalc()*100&#125;&quot;) // 注入类static方法结果,支持运算处理private double result;@Value(&quot;classpath:test.txt&quot;) // 注入文件资源private Resource testFile;@Value(&quot;http://www.baidu.com&quot;) // 注入网址资源private Resource testUrl;@Value(&quot;$&#123;book.name&#125;&quot;) // 注入配置文件private String bookName;@Autowiredprivate Environment environment;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LF will be replaced by CRLF</title>
      <link href="/posts/b76ba195.html"/>
      <url>/posts/b76ba195.html</url>
      
        <content type="html"><![CDATA[<p>LF和CRLF其实都是换行符。</p><p>LF是linux和Unix系统的换行符，CRLF是window系统的换行符。</p><p>Git提供了换行符自动转换的功能，默认开启，自动把代码里换行的方式转换成当前系统的换行方式。提交代码时，Git就会提示 LF will be replaced by CRLF in。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config core.autocrlf false</span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> warning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Permission denied publickey</title>
      <link href="/posts/81df75d5.html"/>
      <url>/posts/81df75d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="查看全局配置"><a href="#查看全局配置" class="headerlink" title="查看全局配置"></a>查看全局配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;email@email.com&quot;</span><br></pre></td></tr></table></figure><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email@email.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; <span class="built_in">cat</span> /c/Users/Alan/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><h2 id="配置github授权"><a href="#配置github授权" class="headerlink" title="配置github授权"></a>配置github授权</h2><p>GitHub—&gt;setting—&gt;SSH and GPG keys—&gt;SSH keys </p><h2 id="测试是否生效"><a href="#测试是否生效" class="headerlink" title="测试是否生效"></a>测试是否生效</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> Permission </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装git</title>
      <link href="/posts/8d39085b.html"/>
      <url>/posts/8d39085b.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置代理</title>
      <link href="/posts/6e63a28a.html"/>
      <url>/posts/6e63a28a.html</url>
      
        <content type="html"><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks://127.0.0.1:10808</span><br><span class="line">git config --global http.proxy http://127.0.0.1:10809</span><br><span class="line">git config --global http.proxy https://127.0.0.1:10808</span><br></pre></td></tr></table></figure><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-asset-image问题修改</title>
      <link href="/posts/d35bf8ef.html"/>
      <url>/posts/d35bf8ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改更新url的代码"><a href="#修改更新url的代码" class="headerlink" title="修改更新url的代码"></a>修改更新url的代码</h2><p>node_modules&#x2F;hexo-asset-image&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">           srcArray.<span class="title function_">shift</span>();</span><br><span class="line">           src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">           $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, <span class="string">&quot;/img/&quot;</span> + src);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+<span class="string">&quot;/img/&quot;</span> + src);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo-asset-image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo自定义菜单</title>
      <link href="/posts/bd184e2.html"/>
      <url>/posts/bd184e2.html</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-版本"><a href="#nodejs-版本" class="headerlink" title="nodejs 版本"></a>nodejs 版本</h2><p>需要考虑主题支持的版本范围，最好应大于10 小于 15，推荐使用12</p><p>参考官方文档 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">安装前提</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install -g hexo </span><br><span class="line">环境变量配置 全局安装的目录</span><br></pre></td></tr></table></figure><h2 id="启动一个blog项目"><a href="#启动一个blog项目" class="headerlink" title="启动一个blog项目"></a>启动一个blog项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo new &quot;postName&quot;</span><br><span class="line">hexo new page &quot;pageName&quot;</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h2 id="菜单项配置"><a href="#菜单项配置" class="headerlink" title="菜单项配置"></a>菜单项配置</h2><h3 id="新增页面"><a href="#新增页面" class="headerlink" title="新增页面"></a>新增页面</h3><p>source 目录下新建 tags、categories、about文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><h3 id="博文的头部"><a href="#博文的头部" class="headerlink" title="博文的头部"></a>博文的头部</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2022/3/26 00:00:00</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> Web</span><br><span class="line"><span class="section">- Server</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>theme&#x2F;next&#x2F;_config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure><h2 id="定制页面"><a href="#定制页面" class="headerlink" title="定制页面"></a>定制页面</h2><p>Hexo的scripts目录下新增customcategory.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filteredCategory = <span class="string">&#x27;分析&#x27;</span>;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">generator</span>.<span class="title function_">register</span>(<span class="string">&#x27;customcategory&#x27;</span>, <span class="keyword">function</span>(<span class="params">locals</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> analysisPosts = locals.<span class="property">posts</span>.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="property">categories</span>.<span class="property">data</span>[<span class="number">0</span>].<span class="property">name</span> == filteredCategory;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(<span class="string">&#x27;analysis&#x27;</span>, analysisPosts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;customcategory&#x27;</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参考 <a href="https://github.com/hexojs/hexo-pagination#hexo-pagination">hexo-pagination</a> 的使用方式</p><h2 id="定制模板"><a href="#定制模板" class="headerlink" title="定制模板"></a>定制模板</h2><p>theme&#x2F;next&#x2F;layout 下新增 customcategory.swig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125;</span><br><span class="line">&#123;% import &#x27;_macro/post-collapse.swig&#x27; as post_template with context %&#125;</span><br><span class="line">&#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template with context %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; __(&#x27;title.category&#x27;) &#125;&#125;: &#123;&#123; page.category &#125;&#125; | &#123;&#123; title &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block class %&#125;category&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &#123;### CATEGORY BLOCK ###&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &lt;div class=&quot;post-block&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;posts-collapse&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class="line">        &lt;h2 class=&quot;collection-header&quot;&gt;</span><br><span class="line">          &#123;&#123;- page.category &#125;&#125;</span><br><span class="line">          &lt;small&gt;&#123;&#123; __(&#x27;title.category&#x27;) &#125;&#125;&lt;/small&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &#123;&#123; post_template.render(page.posts) &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">  &#123;### END CATEGORY BLOCK ###&#125;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% include &#x27;_partials/pagination.swig&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br><span class="line">hexo deploy</span><br><span class="line">(新版本支持首字母缩写命令，如 hexo g -&gt; hexo generate)</span><br></pre></td></tr></table></figure><h2 id="hexo常用插件"><a href="#hexo常用插件" class="headerlink" title="hexo常用插件"></a>hexo常用插件</h2><p>插件地址: <a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;hexo&quot;: &quot;^5.4.2&quot;,</span><br><span class="line">&quot;hexo-cake-moon-menu&quot;: &quot;^2.5.0&quot;,</span><br><span class="line">&quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">&quot;hexo-asset-image&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;hexo-auto-category&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">&quot;hexo-calendar&quot;: &quot;^1.0.6&quot;,</span><br><span class="line">&quot;hexo-cli&quot;: &quot;^4.3.0&quot;,</span><br><span class="line">&quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">&quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">&quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;,</span><br><span class="line">&quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">&quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">&quot;hexo-generator-search&quot;: &quot;^2.4.3&quot;,</span><br><span class="line">&quot;hexo-generator-searchdb&quot;: &quot;^1.4.1&quot;,</span><br><span class="line">&quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">&quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">&quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">&quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">&quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">&quot;hexo-renderer-swig&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">&quot;hexo-server&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">&quot;hexo-theme-next&quot;: &quot;^8.14.0&quot;,</span><br><span class="line">&quot;hexo-word-counter&quot;: &quot;^0.1.0&quot;</span><br></pre></td></tr></table></figure><h2 id="hexo-note用法"><a href="#hexo-note用法" class="headerlink" title="hexo note用法"></a>hexo note用法</h2><p><a href="https://hexo.io/zh-cn/docs/tag-plugins">https://hexo.io/zh-cn/docs/tag-plugins</a></p><h3 id="配置部分"><a href="#配置部分" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment">#false时PC端不显示图标，但移动端仍会显示，故需要在标签语句中手动no-icon进行标注</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="执行模板"><a href="#执行模板" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">note.js</span><br><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br><span class="line">All parameters are optional.</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">#### Default Header</span><br><span class="line">Welcome to [Hexo!](https://hexo.io)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo-tabs用法"><a href="#hexo-tabs用法" class="headerlink" title="hexo tabs用法"></a>hexo tabs用法</h2><h3 id="配置部分-1"><a href="#配置部分-1" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">next/_config.yml</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="执行模板-1"><a href="#执行模板-1" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span><br><span class="line">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span><br><span class="line">                Only for current url of post/page must be unique!</span><br><span class="line">[index]       : Index number of active tab.</span><br><span class="line">                If not specified, first tab (1) will be selected.</span><br><span class="line">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span><br><span class="line">                Optional parameter.</span><br><span class="line">[Tab caption] : Caption of current tab.</span><br><span class="line">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span><br><span class="line">                If not caption specified, but specified icon, caption will empty.</span><br><span class="line">                Optional parameter.</span><br><span class="line">[@icon]       : FontAwesome icon name (without &#x27;fa-&#x27; at the begining).</span><br><span class="line">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span><br><span class="line">                Optional parameter.</span><br></pre></td></tr></table></figure><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo-pdf用法"><a href="#hexo-pdf用法" class="headerlink" title="hexo pdf用法"></a>hexo pdf用法</h2><h3 id="配置部分-2"><a href="#配置部分-2" class="headerlink" title="配置部分"></a>配置部分</h3><p>theme&#x2F;next&#x2F;_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">next/_config.yml</span></span><br><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br></pre></td></tr></table></figure><h3 id="执行模板-2"><a href="#执行模板-2" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pdf.js</span><br><span class="line">&#123;% pdf url [height] %&#125;</span><br><span class="line">[url]    : Relative path to PDF file.</span><br><span class="line">[height] : Optional. Height of the PDF display element, e.g. 800px.</span><br></pre></td></tr></table></figure><h3 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https://example.com/sample.pdf %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo-video用法"><a href="#hexo-video用法" class="headerlink" title="hexo video用法"></a>hexo video用法</h2><h3 id="执行模板-3"><a href="#执行模板-3" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">video.js</span><br><span class="line">&#123;% video url %&#125;</span><br></pre></td></tr></table></figure><h3 id="example-3"><a href="#example-3" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video /path/to/your/video.mp4 %&#125;</span><br><span class="line">&#123;% video https://example.com/sample.mp4 %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo-Group-pictures用法"><a href="#hexo-Group-pictures用法" class="headerlink" title="hexo Group-pictures用法"></a>hexo Group-pictures用法</h2><h3 id="执行模板-4"><a href="#执行模板-4" class="headerlink" title="执行模板"></a>执行模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group-pictures.js</span><br><span class="line">&#123;% grouppicture [group]-[layout] %&#125;&#123;% endgrouppicture %&#125;</span><br><span class="line">&#123;% gp [group]-[layout] %&#125;&#123;% endgp %&#125;</span><br><span class="line">[group]  : Total number of pictures to add in the group.</span><br><span class="line">[layout] : Default picture under the group to show.</span><br></pre></td></tr></table></figure><h3 id="example-4"><a href="#example-4" class="headerlink" title="example"></a>example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% grouppicture 7-5%&#125;</span><br><span class="line">  ![](https://suncos-01-1254144885.cos.ap-shanghai.myqcloud.com/%E6%89%8B%E6%9C%BA/IMG_20160720_192243_AO_HDR.jpg)</span><br><span class="line">  ![](https://suncos-01-1254144885.cos.ap-shanghai.myqcloud.com/%E6%89%8B%E6%9C%BA/IMG_20160817_185254_AO_HDR.jpg)</span><br><span class="line">&#123;% endgrouppicture %&#125;</span><br></pre></td></tr></table></figure><h2 id="hexo-写作模板"><a href="#hexo-写作模板" class="headerlink" title="hexo 写作模板"></a>hexo 写作模板</h2><p><a href="https://www.bas369.com/more/learning_notes/2020/03/14/Markdown%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/">https://www.bas369.com/more/learning_notes/2020/03/14/Markdown%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/</a></p><h2 id="hexo-资源文件夹"><a href="#hexo-资源文件夹" class="headerlink" title="hexo 资源文件夹"></a>hexo 资源文件夹</h2><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><h2 id="github-svg-corner"><a href="#github-svg-corner" class="headerlink" title="github svg corner"></a>github svg corner</h2><p><a href="https://tholman.com/github-corners/">https://tholman.com/github-corners/</a></p><h2 id="githubPage访问地址问题"><a href="#githubPage访问地址问题" class="headerlink" title="githubPage访问地址问题"></a>githubPage访问地址问题</h2><p>repository名称需要与githubPage名称保持一致<br>域名在github repository setting中配置，每次上传被覆盖<br>需要配置cname文件</p><p><img src="/img/gitio_custom_domain_20221228193328.png" alt="GithubPage"></p><h2 id="cname-重定向"><a href="#cname-重定向" class="headerlink" title="cname 重定向"></a>cname 重定向</h2><p>hexo 站点配置文件 _config.yml中设置url为域名<br>githubPage 重定向机制 source目录新建CNAME文件，添加域名地址<br>如果你的 CNAME 文件为 example.com，那么 <a href="http://www.example.com/">www.example.com</a> 会定向到 example.com。<br>如果你的 CNAME 文件为 <a href="http://www.example.com,那么/">www.example.com，那么</a> example.com 会定向到 <a href="http://www.example.com/">www.example.com</a></p><p><img src="/img/ali_dns_config_20221228164219.png" alt="阿里DNS配置"></p><h2 id="hexo配置文件说明"><a href="#hexo配置文件说明" class="headerlink" title="hexo配置文件说明"></a>hexo配置文件说明</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p><h2 id="hexo-语言"><a href="#hexo-语言" class="headerlink" title="hexo 语言"></a>hexo 语言</h2><p>站点配置文件 language: zh-Hans &#x2F;&#x2F; 这里设置语言 简体中文<br>对应主题语言目录中的 文件名 需要保持一致</p><h2 id="hexo-问题处理"><a href="#hexo-问题处理" class="headerlink" title="hexo 问题处理"></a>hexo 问题处理</h2><p><a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a></p><h3 id="访问页面直接显示未经过渲染的模板"><a href="#访问页面直接显示未经过渲染的模板" class="headerlink" title="访问页面直接显示未经过渲染的模板"></a>访问页面直接显示未经过渲染的模板</h3><p>hexo在5.0版本以上移除了swig</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-swig --save</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.eson.org/categories/">https://blog.eson.org/categories/</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>theme配置</title>
      <link href="/posts/f80e45ab.html"/>
      <url>/posts/f80e45ab.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">git clone --branch v6.0.0 https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>hexo _config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm常用命令</title>
      <link href="/posts/cf3ec6ef.html"/>
      <url>/posts/cf3ec6ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo@版本号</span><br></pre></td></tr></table></figure><h2 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean -f</span><br><span class="line">npm install-g n</span><br><span class="line">n stable</span><br></pre></td></tr></table></figure><h2 id="npm-check-updates安装"><a href="#npm-check-updates安装" class="headerlink" title="npm-check-updates安装"></a>npm-check-updates安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure><h2 id="检查包"><a href="#检查包" class="headerlink" title="检查包"></a>检查包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure><h2 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h2><p>npm update <package></package></p><h2 id="检查-package-json-的最新依赖项"><a href="#检查-package-json-的最新依赖项" class="headerlink" title="检查 package.json 的最新依赖项"></a>检查 package.json 的最新依赖项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">ncu</span><br></pre></td></tr></table></figure><h2 id="更新-package-json-的最新依赖项"><a href="#更新-package-json-的最新依赖项" class="headerlink" title="更新 package.json 的最新依赖项"></a>更新 package.json 的最新依赖项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><h2 id="检查包是否最新"><a href="#检查包是否最新" class="headerlink" title="检查包是否最新"></a>检查包是否最新</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu &lt;package&gt;</span><br></pre></td></tr></table></figure><h2 id="更新包到最新"><a href="#更新包到最新" class="headerlink" title="更新包到最新"></a>更新包到最新</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm update &lt;name&gt; -g</span><br><span class="line"></span><br><span class="line">ncu -u &lt;package&gt;</span><br></pre></td></tr></table></figure><h2 id="查看全局安装包最新版本"><a href="#查看全局安装包最新版本" class="headerlink" title="查看全局安装包最新版本"></a>查看全局安装包最新版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -g</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node常见错误处理</title>
      <link href="/posts/343ed70.html"/>
      <url>/posts/343ed70.html</url>
      
        <content type="html"><![CDATA[<h2 id="npm-ERR-Refusing-to-delete"><a href="#npm-ERR-Refusing-to-delete" class="headerlink" title="npm ERR! Refusing to delete"></a>npm ERR! Refusing to delete</h2><p>删除node_modules,重新执行npm install</p><h2 id="SyntaxError-Unexpected-token"><a href="#SyntaxError-Unexpected-token" class="headerlink" title="SyntaxError: Unexpected token"></a>SyntaxError: Unexpected token</h2><p>版本问题，找到匹配的版本</p><h2 id="node-与-npm-版本不匹配"><a href="#node-与-npm-版本不匹配" class="headerlink" title="node 与 npm 版本不匹配"></a>node 与 npm 版本不匹配</h2><p><a href="https://nodejs.org/zh-cn/download/releases/">https://nodejs.org/zh-cn/download/releases/</a></p><h2 id="下载包超时问题"><a href="#下载包超时问题" class="headerlink" title="下载包超时问题"></a>下载包超时问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="npm-ERR-notsup-Unsupported-platform-for-x66-115-101-118-x65-x6e-116-x73-x40-x31-x2e-48-46-49-52-wanted-“os”-“darwin”-“arch”-“any”"><a href="#npm-ERR-notsup-Unsupported-platform-for-x66-115-101-118-x65-x6e-116-x73-x40-x31-x2e-48-46-49-52-wanted-“os”-“darwin”-“arch”-“any”" class="headerlink" title="npm ERR! notsup Unsupported platform for &#x66;&#115;&#101;&#118;&#x65;&#x6e;&#116;&#x73;&#x40;&#x31;&#x2e;&#48;&#46;&#49;&#52;: wanted {“os”:“darwin”,“arch”:“any”}"></a>npm ERR! notsup Unsupported platform for <a href="mailto:&#x66;&#115;&#101;&#118;&#x65;&#x6e;&#116;&#x73;&#x40;&#x31;&#x2e;&#48;&#46;&#49;&#52;">&#x66;&#115;&#101;&#118;&#x65;&#x6e;&#116;&#x73;&#x40;&#x31;&#x2e;&#48;&#46;&#49;&#52;</a>: wanted {“os”:“darwin”,“arch”:“any”}</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法一 npm install-g npm@3.10.7 (更高版本会强制在window下安装fsevent，而fsevent只会在mac系统上可用)</span><br><span class="line">方法二 删除pafsevent依赖</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm多版本管理</title>
      <link href="/posts/b00c03e2.html"/>
      <url>/posts/b00c03e2.html</url>
      
        <content type="html"><![CDATA[<h2 id="nvm配置修改"><a href="#nvm配置修改" class="headerlink" title="nvm配置修改"></a>nvm配置修改</h2><p>修改nvm的安装目录settings</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nvm                  // 提示相关命令</span><br><span class="line">nvm ls               // 查看已安装node版本</span><br><span class="line">nvm install XX      // 安装XX版本的node</span><br><span class="line">nvm uninstall XX    // 卸载XX版本的node</span><br><span class="line">nvm use XX         // 切换到XX版本</span><br><span class="line">nvm current // 显示当前版本</span><br><span class="line">nvm ls available // 查看运程线上所有版本</span><br><span class="line">nvm root // 查看nvm安装路径</span><br><span class="line">nvm proxy // 查看设置与代理</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>nvm use 切换环境无效</p><ul><li>切换到管理员权限</li><li>node 在nvm之前安装，切换无效，需要卸载后使用nvm安装（npm ls -g –depth&#x3D;0）</li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌账号停用</title>
      <link href="/posts/4107aa29.html"/>
      <url>/posts/4107aa29.html</url>
      
        <content type="html"><![CDATA[<h2 id="停用原因"><a href="#停用原因" class="headerlink" title="停用原因"></a>停用原因</h2><p>使用了代理，频繁的切换IP地区</p><h2 id="申诉方法"><a href="#申诉方法" class="headerlink" title="申诉方法"></a>申诉方法</h2><p>登陆账号，按照提示申诉</p><p>申诉模板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">您好我的账户是xxxxx@gmail.com。我是中国区用户，必需使用vpn代理才能使用谷歌产品，可能由于vpn的不稳定和频繁切换造成账号异常被停用，这个账号对我很重要，希望您可以帮我解决一下，非常感谢。</span><br><span class="line">Hello my account is xxxxx@gmail.com. I am a user in China, must use VPN proxy to use Google products, may be due to VPN instability and frequent switching caused by abnormal account deactivation, this account is very important to me, I hope you can help me solve it, thank you very much.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> records </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> 申诉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线段树</title>
      <link href="/posts/93732293.html"/>
      <url>/posts/93732293.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序-并查集</title>
      <link href="/posts/59655.html"/>
      <url>/posts/59655.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 99 Solution</title>
      <link href="/posts/6c98c656.html"/>
      <url>/posts/6c98c656.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s99;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>, y = <span class="literal">null</span>, pred = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;</span><br><span class="line">                y = root;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x = pred;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode x, TreeNode y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 98 Solution</title>
      <link href="/posts/835aad68.html"/>
      <url>/posts/835aad68.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s98;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有效 二叉搜索树定义如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line"><span class="comment"> * 节点的右子树只包含 大于 当前节点的数。</span></span><br><span class="line"><span class="comment"> * 所有左子树和右子树自身必须也是二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/validate-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个边界Long.MIN_VALUE, Long.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line">        <span class="comment">//节点的右子树只包含 大于 当前节点的数</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有左子树和右子树自身必须也是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 97 Solution</title>
      <link href="/posts/7251f6e5.html"/>
      <url>/posts/7251f6e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s97;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交错字符串</span></span><br><span class="line"><span class="comment"> * 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = s1 + s2 + ... + sn</span></span><br><span class="line"><span class="comment"> * t = t1 + t2 + ... + tm</span></span><br><span class="line"><span class="comment"> * |n - m| &lt;= 1</span></span><br><span class="line"><span class="comment"> * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</span></span><br><span class="line"><span class="comment"> * 注意：a + b 意味着字符串 a 和 b 连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/interleaving-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 96 Solution</title>
      <link href="/posts/9d939ddb.html"/>
      <url>/posts/9d939ddb.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s96;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 95 Solution</title>
      <link href="/posts/76a426d8.html"/>
      <url>/posts/76a426d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s95;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的二叉搜索树 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">currTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 94 Solution</title>
      <link href="/posts/99664de6.html"/>
      <url>/posts/99664de6.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s94;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈 存节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//由根节点开始遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// 当前节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//遍历左节点 节点压栈</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遍历完左分支，把左分支弹出遍历右分支</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                <span class="comment">//遍历右分支</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 93 Solution</title>
      <link href="/posts/7bba569f.html"/>
      <url>/posts/7bba569f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s93;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复原 IP 地址</span></span><br><span class="line"><span class="comment"> * 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#x27;.&#x27; 分隔。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span></span><br><span class="line"><span class="comment"> * 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#x27;.&#x27; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/restore-ip-addresses</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//按. 分割 有4段数字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEG_COUNT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//定义结果list</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span>[] segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line">        <span class="comment">//把ip地址当做4层树，深度遍历</span></span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> segId, <span class="type">int</span> segStart)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT) &#123;</span><br><span class="line">            <span class="comment">//如果遍历到最后一段了，就全部拼起来 组成新的ip</span></span><br><span class="line">            <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">ipAddr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                    ipAddr.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                        ipAddr.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ipAddr.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(segStart) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">segEnd</span> <span class="operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 92 Solution</title>
      <link href="/posts/94783da1.html"/>
      <url>/posts/94783da1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s92;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-linked-list-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//哑结点，方便返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//记录翻转链表区间的前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//指针移动到left-1位置，记为pre</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left位置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">// cur节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//记录翻转链表区间的前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从left 到 right 范围链表翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//当前节点指向前置节点</span></span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            <span class="comment">//翻转链表区间的前置节点 指向当前的节点，随着当前节点后移</span></span><br><span class="line">            pre.next=cur;</span><br><span class="line">            <span class="comment">//遍历时移动到下一个节点</span></span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点不为空时，也就是没有遍历到最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//原先left位置节点指向下一个节点</span></span><br><span class="line">            start.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 91 Solution</title>
      <link href="/posts/7f4f86a2.html"/>
      <url>/posts/7f4f86a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s91;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  解码方法</span></span><br><span class="line"><span class="comment"> *  一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;A&#x27; -&gt; &quot;1&quot;</span></span><br><span class="line"><span class="comment"> * &#x27;B&#x27; -&gt; &quot;2&quot;</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &#x27;Z&#x27; -&gt; &quot;26&quot;</span></span><br><span class="line"><span class="comment"> * 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;AAJF&quot; ，将消息分组为 (1 1 10 6)</span></span><br><span class="line"><span class="comment"> * &quot;KJF&quot; ，将消息分组为 (11 10 6)</span></span><br><span class="line"><span class="comment"> * 注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据保证答案肯定是一个 32 位 的整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/decode-ways</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 90 Solution</title>
      <link href="/posts/908ded9c.html"/>
      <url>/posts/908ded9c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s90;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/subsets-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (mask &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 9 Solution</title>
      <link href="/posts/ba3d2168.html"/>
      <url>/posts/ba3d2168.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s9;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文数</span></span><br><span class="line"><span class="comment"> * 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，121 是回文，而 123 不是。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/palindrome-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 89 Solution</title>
      <link href="/posts/ad161996.html"/>
      <url>/posts/ad161996.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s89;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格雷编码</span></span><br><span class="line"><span class="comment"> * n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：</span></span><br><span class="line"><span class="comment"> * 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）</span></span><br><span class="line"><span class="comment"> * 第一个整数是 0</span></span><br><span class="line"><span class="comment"> * 一个整数在序列中出现 不超过一次</span></span><br><span class="line"><span class="comment"> * 每对 相邻 整数的二进制表示 恰好一位不同 ，且</span></span><br><span class="line"><span class="comment"> * 第一个 和 最后一个 整数的二进制表示 恰好一位不同</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/gray-code</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123; add(<span class="number">0</span>); &#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 88 Solution</title>
      <link href="/posts/42d472a8.html"/>
      <url>/posts/42d472a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s88;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组</span></span><br><span class="line"><span class="comment"> * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/merge-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//定义新数组</span></span><br><span class="line">        <span class="type">int</span>[] all = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> cur;</span><br><span class="line">            <span class="comment">//num1遍历完了，遍历num2</span></span><br><span class="line">            <span class="keyword">if</span>(i == m) &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">                <span class="comment">//num2遍历完了，遍历num1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == n) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">                <span class="comment">//小的元素先排上</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;= nums2[j]) &#123;</span><br><span class="line">                cur = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            all[i+j-<span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组元素再放到num1中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t&lt; n + m; t++) &#123;</span><br><span class="line">            nums1[t] = all[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 87 Solution</title>
      <link href="/posts/b3df2925.html"/>
      <url>/posts/b3df2925.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s87;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扰乱字符串</span></span><br><span class="line"><span class="comment"> * 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</span></span><br><span class="line"><span class="comment"> * 如果字符串的长度为 1 ，算法停止</span></span><br><span class="line"><span class="comment"> * 如果字符串的长度 &gt; 1 ，执行下述步骤：</span></span><br><span class="line"><span class="comment"> * 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。</span></span><br><span class="line"><span class="comment"> * 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。</span></span><br><span class="line"><span class="comment"> * 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。</span></span><br><span class="line"><span class="comment"> * 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/scramble-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记忆化搜索存储状态的数组</span></span><br><span class="line">    <span class="comment">// -1 表示 false，1 表示 true，0 表示未计算</span></span><br><span class="line">    <span class="type">int</span>[][][] memo;</span><br><span class="line">    String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="built_in">this</span>.memo = <span class="keyword">new</span> <span class="title class_">int</span>[length][length][length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.s1 = s1;</span><br><span class="line">        <span class="built_in">this</span>.s2 = s2;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i1][i2][length] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个子串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span></span><br><span class="line">        <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;</span><br><span class="line">            memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举分割位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 不交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfSimilar</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; freq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s2.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 86 Solution</title>
      <link href="/posts/5c1d421b.html"/>
      <url>/posts/5c1d421b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s86;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分隔链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你应当 保留 两个分区中每个节点的初始相对位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/partition-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode() &#123;&#125;</span><br><span class="line">     ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lessHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">moreHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curLess</span> <span class="operator">=</span> lessHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curMore</span> <span class="operator">=</span> moreHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                curLess.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.val);</span><br><span class="line">                curLess = curLess.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curMore.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.val);</span><br><span class="line">                curMore = curMore.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curLess.next = moreHead.next;</span><br><span class="line">        <span class="keyword">return</span> lessHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 85 Solution</title>
      <link href="/posts/b72af918.html"/>
      <url>/posts/b72af918.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s85;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大矩形</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] left = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span> : left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">            <span class="type">int</span>[] up = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">            <span class="type">int</span>[] down = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stack.isEmpty() ? m : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> down[i] - up[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> height * left[i][j];</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 84 Solution</title>
      <link href="/posts/58e89226.html"/>
      <url>/posts/58e89226.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s84;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 柱状图中最大的矩形</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 求在该柱状图中，能够勾勒出来的矩形的最大面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 83 Solution</title>
      <link href="/posts/ba34895f.html"/>
      <url>/posts/ba34895f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s83;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除排序链表中的重复元素</span></span><br><span class="line"><span class="comment"> * 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 82 Solution</title>
      <link href="/posts/55f6e261.html"/>
      <url>/posts/55f6e261.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s82;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除排序链表中的重复元素 II</span></span><br><span class="line"><span class="comment"> * 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dum.next = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 81 Solution</title>
      <link href="/posts/bec15962.html"/>
      <url>/posts/bec15962.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s81;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组 II</span></span><br><span class="line"><span class="comment"> * 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须尽可能减少整个操作步骤。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-in-rotated-sorted-array-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] == nums[mid]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//target在前半部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则，去后半部分找</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//后半部分有序</span></span><br><span class="line">                <span class="comment">//target在后半部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则，去后半部分找</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一直没找到，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 80 Solution</title>
      <link href="/posts/5103325c.html"/>
      <url>/posts/5103325c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s80;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除有序数组中的重复项 II</span></span><br><span class="line"><span class="comment"> * 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 8 Solution</title>
      <link href="/posts/55ff4a56.html"/>
      <url>/posts/55ff4a56.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转换整数 (atoi)</span></span><br><span class="line"><span class="comment"> * 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数 myAtoi(string s) 的算法如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读入字符串并丢弃无用的前导空格</span></span><br><span class="line"><span class="comment"> * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</span></span><br><span class="line"><span class="comment"> * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</span></span><br><span class="line"><span class="comment"> * 将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</span></span><br><span class="line"><span class="comment"> * 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</span></span><br><span class="line"><span class="comment"> * 返回整数作为最终结果。</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中的空白字符只包括空格字符 &#x27; &#x27; 。</span></span><br><span class="line"><span class="comment"> * 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/string-to-integer-atoi</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 自动机</span></span><br><span class="line">        HashMap&lt;String, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;signed&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;number&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        map.put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//第一步开始</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">step</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length() &amp;&amp; !step.equals(<span class="string">&quot;end&quot;</span>); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getChar(ch);</span><br><span class="line">            <span class="comment">//下一步，根据上一步和当前字符 匹配 自动机 得出</span></span><br><span class="line">            step = map.get(step)[n];</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;number&quot;</span>.equals(step)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                num = sign == <span class="number">1</span> ? Math.min(num, (<span class="type">long</span>)Integer.MAX_VALUE) : Math.min(num, -<span class="number">1</span> * (<span class="type">long</span>)Integer.MIN_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;signed&quot;</span>.equals(step)) &#123;</span><br><span class="line">                sign = (ch == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;signed&quot;</span>.equals(step)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * (<span class="type">int</span>)num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getChar</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span> == ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;+&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> &lt;= ch-<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch-<span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 79 Solution</title>
      <link href="/posts/3eeeed50.html"/>
      <url>/posts/3eeeed50.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s79;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词搜索</span></span><br><span class="line"><span class="comment"> * 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-search</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> board.length, w = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[h][w];</span><br><span class="line">        <span class="comment">//遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="comment">//检查单词是否存在</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, i, j, word, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//对比字符，到达字符长度，递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记为已访问过</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上下左右四个方向查找</span></span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="comment">//没有访问过的网格，继续递归查找</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, newi, newj, s, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到则标记为没有访问过，下次有可能组成新的单词时，再次访问</span></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 78 Solution</title>
      <link href="/posts/d12c866e.html"/>
      <url>/posts/d12c866e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s78;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    t.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 77 Solution</title>
      <link href="/posts/2027dde3.html"/>
      <url>/posts/2027dde3.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s77;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合</span></span><br><span class="line"><span class="comment"> * 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以按 任何顺序 返回答案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 76 Solution</title>
      <link href="/posts/cfe5b6dd.html"/>
      <url>/posts/cfe5b6dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s76;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小覆盖子串</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment"> * 如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/minimum-window-substring</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//t 中每个字符出现的次数 存到 ori中</span></span><br><span class="line">    Map&lt;Character, Integer&gt; ori = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="comment">//记录字符串 s 子串中字符出现次数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="comment">//遍历t 统计出 ori</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            ori.put(c, ori.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//子字符串长度len</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE, ansL = -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">//子字符串从 0 开始 到 r</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; sLen) &#123;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="comment">//如果 s字符串的字符出现了 t总字符</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                <span class="comment">//则累加值 放到cnt中计数</span></span><br><span class="line">                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果满足要求了，尝试缩短子串</span></span><br><span class="line">            <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="comment">//如果比当前最小长度len 还小 则 更新len</span></span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// l 左移 对应统计cnt中字符数字也要减1</span></span><br><span class="line">                <span class="keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ansL 存在 则返回 子字符串</span></span><br><span class="line">        <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否完全满足 t的字符及出现次数要求</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> ori.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(key, <span class="number">0</span>) &lt; val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 75 Solution</title>
      <link href="/posts/24d20dde.html"/>
      <url>/posts/24d20dde.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s75;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;给定一个包含红色、白色和蓝色、共&amp;nbsp;&lt;code&gt;n&lt;/code&gt;&lt;em&gt; &lt;/em&gt;个元素的数组&lt;meta charset=&quot;UTF-8&quot; /&gt;&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;，&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;我们使用整数 &lt;code&gt;0&lt;/code&gt;、&amp;nbsp;&lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 分别表示红色、白色和蓝色。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 74 Solution</title>
      <link href="/posts/cb1066e0.html"/>
      <url>/posts/cb1066e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s74;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;编写一个高效的算法来判断 &lt;code&gt;m x n&lt;/code&gt; 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowIndex</span> <span class="operator">=</span> binarySearchFirstColumn(matrix, target);</span><br><span class="line">        <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">1</span>, high = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>[] row, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = row.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 73 Solution</title>
      <link href="/posts/29cc7d99.html"/>
      <url>/posts/29cc7d99.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s73;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 矩阵置零</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;给定一个&amp;nbsp;&lt;code&gt;&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;&lt;/code&gt; 的矩阵，如果一个元素为 &lt;strong&gt;0 &lt;/strong&gt;，则将其所在行和列的所有元素都设为 &lt;strong&gt;0&lt;/strong&gt; 。请使用 &lt;strong&gt;&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt; 算法&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 72 Solution</title>
      <link href="/posts/c60e16a7.html"/>
      <url>/posts/c60e16a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s72;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编辑距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m + n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//j == 0 也就是 words2 长度为0时，编辑距离 完全取决于words1长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i == 0 也就是 words1 长度为0时，编辑距离 完全取决于words2长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">//字符相等 则编辑距离不变</span></span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//取决于前者编辑距离的最小值 + 1</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 718 Solution</title>
      <link href="/posts/111f277f.html"/>
      <url>/posts/111f277f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s718;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.length &lt; B.length ? findMax(A, B) : findMax(B, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">an</span> <span class="operator">=</span> A.length, bn = B.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>; len &lt;= an; len++) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, <span class="number">0</span>, B, bn - len, len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bn-an; j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, <span class="number">0</span>, B, j, an));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;an;i++) &#123;</span><br><span class="line">            max = Math.max(max, maxLen(A, i, B, <span class="number">0</span>, an - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span>[] b, <span class="type">int</span> j, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+k] == b[j+k]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max, count);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span> ? Math.max(max, count) : max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 71 Solution</title>
      <link href="/posts/2d39ada4.html"/>
      <url>/posts/2d39ada4.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s71;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化路径</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &#x27;/&#x27; 开头），请你将其转化为更加简洁的规范路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&#x27;//&#x27;）都被视为单个斜杠 &#x27;/&#x27; 。 对于此问题，任何其他格式的点（例如，&#x27;...&#x27;）均被视为文件/目录名称。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，返回的 规范路径 必须遵循下述格式：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 始终以斜杠 &#x27;/&#x27; 开头。</span></span><br><span class="line"><span class="comment"> * 两个目录名之间必须只有一个斜杠 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment"> * 最后一个目录名（如果存在）不能 以 &#x27;/&#x27; 结尾。</span></span><br><span class="line"><span class="comment"> * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &#x27;.&#x27; 或 &#x27;..&#x27;）。</span></span><br><span class="line"><span class="comment"> * 返回简化后得到的 规范路径 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/simplify-path</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 双端队列</span></span><br><span class="line">        Deque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 分割字符</span></span><br><span class="line">        String[] res = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> res[i];</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;.&quot;</span>) || s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;..&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.offer(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            sb.append(queue.poll());</span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(<span class="string">&quot;&quot;</span>) ? <span class="string">&quot;/&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 704 Solution</title>
      <link href="/posts/caad1831.html"/>
      <url>/posts/caad1831.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s704;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串拼接 StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        <span class="comment">//num1 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="comment">//num2 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i + j &lt;= m + n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numa</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">                numa = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numa = num1.charAt(m - i++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; n) &#123;</span><br><span class="line">                numb = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numb = num2.charAt(n - j++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右向左 逐位数字相加</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numa + numb + carray;</span><br><span class="line">            <span class="comment">//满10 进一位</span></span><br><span class="line">            carray = sum / <span class="number">10</span>;</span><br><span class="line">            builder.append(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次相加后 如果有进位 则拼接到字符串</span></span><br><span class="line">        <span class="keyword">if</span>(carray != <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(carray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 70 Solution</title>
      <link href="/posts/c2fbc69a.html"/>
      <url>/posts/c2fbc69a.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s70;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 爬楼梯</span></span><br><span class="line"><span class="comment"> * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//倒推 func(n) = func(n-1) + func(n-2)</span></span><br><span class="line">        <span class="comment">//边界 func(3) = func(2) + func(1)</span></span><br><span class="line">        <span class="comment">// func(2) = 2</span></span><br><span class="line">        <span class="comment">// func(1) = 1</span></span><br><span class="line">        <span class="comment">// func(0) = 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 7 Solution</title>
      <link href="/posts/a4f411db.html"/>
      <url>/posts/a4f411db.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数反转</span></span><br><span class="line"><span class="comment"> * 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设环境不允许存储 64 位整数（有符号或无符号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-integer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数字拆分</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; Integer.MIN_VALUE/<span class="number">10</span> || res &gt; Integer.MAX_VALUE/<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 69 Solution</title>
      <link href="/posts/ff603290.html"/>
      <url>/posts/ff603290.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s69;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x平方根</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sqrtx</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//中间值 二分法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左右移动 l  r</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(tmp == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">                ret = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 68 Solution</title>
      <link href="/posts/10a259ae.html"/>
      <url>/posts/10a259ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s68;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本左右对齐</span></span><br><span class="line"><span class="comment"> * 给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 &#x27; &#x27; 填充，使得每行恰好有 maxWidth 个字符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 文本的最后一行应为左对齐，且单词之间不插入额外的空格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词是指由非空格字符组成的字符序列。</span></span><br><span class="line"><span class="comment"> * 每个单词的长度大于 0，小于等于 maxWidth。</span></span><br><span class="line"><span class="comment"> * 输入单词数组 words 至少包含一个单词。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/text-justification</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">fullJustify</span><span class="params">(String[] words, <span class="type">int</span> maxWidth)</span> &#123;</span><br><span class="line">        <span class="comment">//定义0-maxWidth个空格字符串，方便之后直接调用</span></span><br><span class="line">        <span class="keyword">final</span> String[] space = <span class="keyword">new</span> <span class="title class_">String</span>[maxWidth+<span class="number">1</span>];</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;maxWidth+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            space[i] = s.toString();</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建List，用来存最后的结果。</span></span><br><span class="line">        List&lt;String&gt; pWords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历整个words，一行一行的排版</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;words.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curlen</span> <span class="operator">=</span> words[i].length();</span><br><span class="line">            <span class="comment">//记录当前已读取单词的长度，当&gt;=maxWidth时进行排版</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//记录本次读取单词的起点</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; words.length-<span class="number">1</span> &amp;&amp; curlen&lt;maxWidth)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                curlen = curlen+words[i].length()+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 每多读一个单词都要加一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curlen&gt;maxWidth)&#123;</span><br><span class="line">                <span class="comment">//当前长度&gt;maxWidth，说明已经多读取了一个单词</span></span><br><span class="line">                curlen = curlen-words[i].length()-<span class="number">1</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一行一行的排版</span></span><br><span class="line">            pWords.add(processCurline(words,startI,i,curlen,maxWidth,space));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pWords;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processCurline</span><span class="params">(String[] words,<span class="type">int</span> si,<span class="type">int</span> ei,<span class="type">int</span> curlen,<span class="type">int</span> maxWidth,String[] space)</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();   <span class="comment">//用来进行排版</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">map</span> <span class="operator">=</span> ei-si;                   <span class="comment">// 记录单词之间的有几个间隙</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addSpace</span> <span class="operator">=</span> maxWidth - curlen+map;   <span class="comment">//记录这一行总共有多少个空格</span></span><br><span class="line">        <span class="keyword">if</span>(map==<span class="number">0</span>)&#123;               <span class="comment">//间隙为0，证明只有一个单词</span></span><br><span class="line">            sb.append(words[ei]);</span><br><span class="line">            sb.append(space[addSpace]);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ei == words.length-<span class="number">1</span>)&#123;            <span class="comment">//证明要排版最后一行了，格式特殊</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>si;i&lt;ei;i++)&#123;</span><br><span class="line">                sb.append(words[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(words[ei]);             <span class="comment">//最后一个单词不用加空格</span></span><br><span class="line">            sb.append(space[addSpace-map]);   <span class="comment">//如果还有多余空格，一起加上</span></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">allAddSpace</span> <span class="operator">=</span> addSpace/map;     <span class="comment">//所有的空格数 / 间隙 = 每个间隙必加的空格数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> addSpace % map + si;     <span class="comment">//多出来的空格要从si开始，依次加在间隙中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> si;i&lt;ei;i++)&#123;</span><br><span class="line">            sb.append(words[i]).append(space[allAddSpace]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; left) sb.append(<span class="string">&quot; &quot;</span>);     <span class="comment">// &lt;left就要多加一个空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(words[ei]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 67 Solution</title>
      <link href="/posts/e1a90223.html"/>
      <url>/posts/e1a90223.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s67;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x 的平方根</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sqrtx</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//中间值 二分法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左右移动 l  r</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(tmp == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt;= x) &#123;</span><br><span class="line">                ret = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 66 Solution</title>
      <link href="/posts/e6b691d.html"/>
      <url>/posts/e6b691d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s66;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制求和</span></span><br><span class="line"><span class="comment"> * 给你两个二进制字符串，返回它们的和（用二进制表示）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入为 非空 字符串且只包含数字 1 和 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(a.length(), b.length()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.append((<span class="type">char</span>) (carry % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 65 Solution</title>
      <link href="/posts/e55cd21e.html"/>
      <url>/posts/e55cd21e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s65;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效数字</span></span><br><span class="line"><span class="comment"> * 有效数字（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个 小数 或者 整数</span></span><br><span class="line"><span class="comment"> * （可选）一个 &#x27;e&#x27; 或 &#x27;E&#x27; ，后面跟着一个 整数</span></span><br><span class="line"><span class="comment"> * 小数（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （可选）一个符号字符（&#x27;+&#x27; 或 &#x27;-&#x27;）</span></span><br><span class="line"><span class="comment"> * 下述格式之一：</span></span><br><span class="line"><span class="comment"> * 至少一位数字，后面跟着一个点 &#x27;.&#x27;</span></span><br><span class="line"><span class="comment"> * 至少一位数字，后面跟着一个点 &#x27;.&#x27; ，后面再跟着至少一位数字</span></span><br><span class="line"><span class="comment"> * 一个点 &#x27;.&#x27; ，后面跟着至少一位数字</span></span><br><span class="line"><span class="comment"> * 整数（按顺序）可以分成以下几个部分：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * （可选）一个符号字符（&#x27;+&#x27; 或 &#x27;-&#x27;）</span></span><br><span class="line"><span class="comment"> * 至少一位数字</span></span><br><span class="line"><span class="comment"> * 部分有效数字列举如下：[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 部分无效数字列举如下：[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> State.STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">CharType</span> <span class="variable">type</span> <span class="operator">=</span> toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CharType <span class="title function_">toCharType</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CharType</span> &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 64 Solution</title>
      <link href="/posts/a9eb920.html"/>
      <url>/posts/a9eb920.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小路径和</span></span><br><span class="line"><span class="comment"> * 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：每次只能向下或者向右移动一步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/minimum-path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 63 Solution</title>
      <link href="/posts/e842a259.html"/>
      <url>/posts/e842a259.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s63;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同路径 II</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 网格中的障碍物和空位置分别用 1 和 0 来表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/unique-paths-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    f[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] += f[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 62 Solution</title>
      <link href="/posts/780c967.html"/>
      <url>/posts/780c967.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s62;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同路径</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 问总共有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/unique-paths</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//新建dp二维数组，记录每步状态</span></span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化边界情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历行列，补全其他状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">//动态转移方程</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 61 Solution</title>
      <link href="/posts/ecb77264.html"/>
      <url>/posts/ecb77264.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s61;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span>  head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算断开的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> n - k % n;</span><br><span class="line">        <span class="comment">//特殊情况也就是链表不变的情况</span></span><br><span class="line">        <span class="keyword">if</span>(y == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾部连接到链表头</span></span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">while</span>(y -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照计算的断开位置断开链表</span></span><br><span class="line">        head = cur.next;</span><br><span class="line">        cur.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 60 Solution</title>
      <link href="/posts/375195a.html"/>
      <url>/posts/375195a.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s60;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排列序列</span></span><br><span class="line"><span class="comment"> * 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;123&quot;</span></span><br><span class="line"><span class="comment"> * &quot;132&quot;</span></span><br><span class="line"><span class="comment"> * &quot;213&quot;</span></span><br><span class="line"><span class="comment"> * &quot;231&quot;</span></span><br><span class="line"><span class="comment"> * &quot;312&quot;</span></span><br><span class="line"><span class="comment"> * &quot;321&quot;</span></span><br><span class="line"><span class="comment"> * 给定 n 和 k，返回第 k 个排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/permutation-sequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] factorial = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span>[] valid = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(valid, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                order -= valid[j];</span><br><span class="line">                <span class="keyword">if</span> (order == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append(j);</span><br><span class="line">                    valid[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= factorial[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 6 Solution</title>
      <link href="/posts/4b367ae5.html"/>
      <url>/posts/4b367ae5.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Z 字形变换</span></span><br><span class="line"><span class="comment"> * 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/zigzag-conversion</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cycleLen</span> <span class="operator">=</span> <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j + i &lt; n; j += cycleLen) &#123;</span><br><span class="line">                ret.append(s.charAt(j + i));</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; j + cycleLen - i &lt; n)</span><br><span class="line">                    ret.append(s.charAt(j + cycleLen - i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 59 Solution</title>
      <link href="/posts/66825491.html"/>
      <url>/posts/66825491.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s59;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 螺旋矩阵 II</span></span><br><span class="line"><span class="comment"> * 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//返回值数组</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 右下左上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">directionIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNum &lt;= maxNum) &#123;</span><br><span class="line">            matrix[row][column] = curNum;</span><br><span class="line">            curNum++;</span><br><span class="line">            <span class="comment">//行</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextRow</span> <span class="operator">=</span> row + directions[directionIndex][<span class="number">0</span>],</span><br><span class="line">                    <span class="comment">//列</span></span><br><span class="line">                    nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//行列边界判断，需要调整方向</span></span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 顺时针旋转至下一个方向</span></span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 58 Solution</title>
      <link href="/posts/89403faf.html"/>
      <url>/posts/89403faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s58;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一个单词的长度</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/length-of-last-word</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">&#x27; &#x27;</span>) start--;</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 57 Solution</title>
      <link href="/posts/784b6422.html"/>
      <url>/posts/784b6422.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s57;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  插入区间</span></span><br><span class="line"><span class="comment"> * 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/insert-interval</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] insert(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">placed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ansList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 56 Solution</title>
      <link href="/posts/97890f1c.html"/>
      <url>/posts/97890f1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s56;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并区间</span></span><br><span class="line"><span class="comment"> * 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/merge-intervals</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 55 Solution</title>
      <link href="/posts/7cbeb41f.html"/>
      <url>/posts/7cbeb41f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s55;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判断你是否能够到达最后一个下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">                rightmost = Math.max(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 543 Solution</title>
      <link href="/posts/7493ee55.html"/>
      <url>/posts/7493ee55.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s543;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">            <span class="comment">//遍历树</span></span><br><span class="line">            deep(root);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deep</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//到叶子节点返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> deep(root.left);</span><br><span class="line">        <span class="comment">//右子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> deep(root.right);</span><br><span class="line">        <span class="comment">// 左右子树深度和</span></span><br><span class="line">        ans = Math.max(ans, l + r);</span><br><span class="line">        <span class="comment">//加上根节点自身 就是直径</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 54 Solution</title>
      <link href="/posts/937cdf21.html"/>
      <url>/posts/937cdf21.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s54;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 螺旋矩阵</span></span><br><span class="line"><span class="comment"> * 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length ==<span class="number">0</span> || matrix[<span class="number">0</span>].length ==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断需要旋转的几个方向</span></span><br><span class="line">        <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">//列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] visited = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">//方向</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">directions</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; m*n; cnt++) &#123;</span><br><span class="line">            <span class="comment">//已访问</span></span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            ret.add(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一个节点对应的行  遍历的方向 dirs[directions][0] 控制</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nexti</span> <span class="operator">=</span> i + dirs[directions][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//下一个节点对应的列  遍历的方向 dirs[directions][1] 控制</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextj</span> <span class="operator">=</span> j + dirs[directions][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">if</span>(nexti &lt; <span class="number">0</span> || nexti &gt; m-<span class="number">1</span> || nextj &lt; <span class="number">0</span> ||nextj &gt; n-<span class="number">1</span> || visited[nexti][nextj] == <span class="number">1</span> ) &#123;</span><br><span class="line">                directions = (directions+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//行数变更 + 1 或者 不变</span></span><br><span class="line">            i = i + dirs[directions][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//列数变更 + 1 或者 不变</span></span><br><span class="line">            j = j + dirs[directions][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 53 Solution</title>
      <link href="/posts/71a0c458.html"/>
      <url>/posts/71a0c458.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s53;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大子数组和</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//假定第一个是最大子元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//设置一个和参数，默认0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//累计的和大于0，则继续累计</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//累计和不大于0 ，重新开始累计</span></span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//求最大和</span></span><br><span class="line">            max = Math.max(sum, max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 52 Solution</title>
      <link href="/posts/9e62af66.html"/>
      <url>/posts/9e62af66.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s52;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * N皇后 II</span></span><br><span class="line"><span class="comment"> * n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/n-queens-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">return</span> backtrack(n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                count += backtrack(n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 51 Solution</title>
      <link href="/posts/75551465.html"/>
      <url>/posts/75551465.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s51;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * N 皇后</span></span><br><span class="line"><span class="comment"> *按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/n-queens</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solutions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] queens = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        backtrack(solutions, queens, n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; solutions, <span class="type">int</span>[] queens, <span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generateBoard(queens, n);</span><br><span class="line">            solutions.add(board);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                backtrack(solutions, queens, n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateBoard</span><span class="params">(<span class="type">int</span>[] queens, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 50 Solution</title>
      <link href="/posts/9a977f5b.html"/>
      <url>/posts/9a977f5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s50;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pow(x, n)</span></span><br><span class="line"><span class="comment"> * 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//基数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">base</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">//判断n 小于0 基数特殊处理</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            base = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数次</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans * base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            base = base * base;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 5 Solution</title>
      <link href="/posts/a001c1e6.html"/>
      <url>/posts/a001c1e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长回文子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//定义回文子串的起始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历字符串字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//以当前字符为中心点扩展</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">//以当前字符和下一个字符为中心点扩展</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//取两种方式扩展最大长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(max &gt; end -start + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//-1防止 当前字符和下一个字符为中心点扩展 导致的问题</span></span><br><span class="line">                start = i - (max-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + max /<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,  end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//左右相等则扩展</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left --;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回扩展的子串长度</span></span><br><span class="line">        <span class="keyword">return</span> right - left -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 49 Solution</title>
      <link href="/posts/a70c8b51.html"/>
      <url>/posts/a70c8b51.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s49;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母异位词分组</span></span><br><span class="line"><span class="comment"> * 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/group-anagrams</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 48 Solution</title>
      <link href="/posts/48cee06f.html"/>
      <url>/posts/48cee06f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s48;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  旋转图像</span></span><br><span class="line"><span class="comment"> *  给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/rotate-image</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix.length != matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums - i; ++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[nums - <span class="number">1</span> - j][nums - <span class="number">1</span> - i];</span><br><span class="line">                matrix[nums - <span class="number">1</span> - j][nums - <span class="number">1</span> - i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (nums &gt;&gt; <span class="number">1</span>); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums; ++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[nums - <span class="number">1</span> - i][j];</span><br><span class="line">                matrix[nums - <span class="number">1</span> - i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 470 Solution</title>
      <link href="/posts/9de37f38.html"/>
      <url>/posts/9de37f38.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s470;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-rand10-using-rand7</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span> % <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机产生01</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">random01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rand7();</span><br><span class="line">        <span class="comment">//通过4分割 123 -&gt; 0 ;567 -&gt; 1 如果刚好是4 就重来</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( i &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> random01();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机10 通过4位二进制标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> random01();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 &lt;&lt; i; <span class="comment">//左移i位</span></span><br><span class="line">            x = x + i2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果超出了 [1, 10] 重新来</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rand10();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 47 Solution</title>
      <link href="/posts/b9c5bbe2.html"/>
      <url>/posts/b9c5bbe2.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s47;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列 II</span></span><br><span class="line"><span class="comment"> * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//对原数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//从下标0开始 回溯nums 中间结果存perm， 最终结果放到ans</span></span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="type">int</span> idx, List&lt;Integer&gt; perm)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            <span class="comment">//回溯过得本地不再回溯</span></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            <span class="comment">//第二次开始重置为false</span></span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 46 Solution</title>
      <link href="/posts/5607d0dc.html"/>
      <url>/posts/5607d0dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s46;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//参数结果定义</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//排列结果</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="comment">//初始数组列表</span></span><br><span class="line">            numbers.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯 填空， 从 0 开始 填写  numbers.size() 个数字，结果写到 ret</span></span><br><span class="line">        backtrack(numbers, ret, numbers.size(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> n, <span class="type">int</span> try1)</span> &#123;</span><br><span class="line">        <span class="comment">//填完n个数后</span></span><br><span class="line">        <span class="keyword">if</span> (try1 == n) &#123;</span><br><span class="line">            <span class="comment">//记录到res</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> try1; i&lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//将i填写到try1位置</span></span><br><span class="line">            Collections.swap(output, i, try1);</span><br><span class="line">            <span class="comment">//将i填写到try1 + 1位置</span></span><br><span class="line">            backtrack(output, res, n, try1 + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//还原tray1位置的值，从i+1位置开始重新试填</span></span><br><span class="line">            Collections.swap(output, try1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 45 Solution</title>
      <link href="/posts/bd306bdf.html"/>
      <url>/posts/bd306bdf.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s45;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏 II</span></span><br><span class="line"><span class="comment"> * 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设你总是可以到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/jump-game-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    steps++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 44 Solution</title>
      <link href="/posts/52f200e1.html"/>
      <url>/posts/52f200e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s44;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通配符匹配</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#x27;?&#x27; 和 &#x27;*&#x27; 的通配符匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;?&#x27; 可以匹配任何单个字符。</span></span><br><span class="line"><span class="comment"> * &#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。</span></span><br><span class="line"><span class="comment"> * 两个字符串完全匹配才算匹配成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="comment"> * p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/wildcard-matching</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;?&#x27;</span> || s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 43 Solution</title>
      <link href="/posts/b02e1b98.html"/>
      <url>/posts/b02e1b98.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s43;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串相乘</span></span><br><span class="line"><span class="comment"> * 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/multiply-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//判断特殊值 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建一个结果数据，存放临时结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="comment">//遍历字符串num1每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//转换成数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//遍历字符串num1每个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//转换成数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//计算乘积</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                <span class="comment">//满10进1</span></span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结果数组 合并为字符串结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == <span class="number">0</span> &amp;&amp; result.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(res[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 42 Solution</title>
      <link href="/posts/5fec70a6.html"/>
      <url>/posts/5fec70a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s42;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接雨水</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左侧开始找最大值</span></span><br><span class="line">        <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            maxLeft[i] = Math.max(maxLeft[i-<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右侧开始找最大值</span></span><br><span class="line">        <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        maxRight[height.length -<span class="number">1</span>] = height[height.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = Math.max(maxRight[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计所有雨水小矩形的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">//左右侧最大值的最小值累加</span></span><br><span class="line">            sum += Math.min(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 415 Solution</title>
      <link href="/posts/937f7e3f.html"/>
      <url>/posts/937f7e3f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s415;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-strings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串拼接 StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        <span class="comment">//num1 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="comment">//num2 遍历 下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i + j &lt;= m + n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numa</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">                numa = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numa = num1.charAt(m - i++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//补0对齐位数</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; n) &#123;</span><br><span class="line">                numb = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//字符转数字 从右向左 取值</span></span><br><span class="line">                numb = num2.charAt(n - j++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右向左 逐位数字相加</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numa + numb + carray;</span><br><span class="line">            <span class="comment">//满10 进一位</span></span><br><span class="line">            carray = sum / <span class="number">10</span>;</span><br><span class="line">            builder.append(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次相加后 如果有进位 则拼接到字符串</span></span><br><span class="line">        <span class="keyword">if</span>(carray != <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(carray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 41 Solution</title>
      <link href="/posts/b4dbcba5.html"/>
      <url>/posts/b4dbcba5.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s41;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缺失的第一个正数</span></span><br><span class="line"><span class="comment"> * 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//处理下负的值，把对应的值改成一个大于n的数字，因为找第一个正数，所以n+1 后面遍历会被忽略掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把存在于 0 -n 之间的值 填到对应的下标处 也变成负值（表示未缺失），后面统计正的数就可以了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= n) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到第一个&gt;0 数字的下标就是 第一个缺失的正数了，因为上一步已经把存在的值标记到对应下标的位置了（负的值表示存在）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 40 Solution</title>
      <link href="/posts/5b19a09b.html"/>
      <url>/posts/5b19a09b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s40;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合总和 II</span></span><br><span class="line"><span class="comment"> * 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * candidates 中的每个数字在每个组合中只能使用 一次 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：解集不能包含重复的组合。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/combination-sum-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; freq = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; sequence = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : candidates) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> freq.size();</span><br><span class="line">            <span class="keyword">if</span> (freq.isEmpty() || num != freq.get(size - <span class="number">1</span>)[<span class="number">0</span>]) &#123;</span><br><span class="line">                freq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.get(size - <span class="number">1</span>)[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(sequence));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.size() || rest &lt; freq.get(pos)[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">most</span> <span class="operator">=</span> Math.min(rest / freq.get(pos)[<span class="number">0</span>], freq.get(pos)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.add(freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">            dfs(pos + <span class="number">1</span>, rest - i * freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.remove(sequence.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 4 Solution</title>
      <link href="/posts/4fc3aad8.html"/>
      <url>/posts/4fc3aad8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法的时间复杂度应该为 O(log (m+n)) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/median-of-two-sorted-arrays</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.length &gt; nums2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m;</span><br><span class="line">            <span class="comment">// i + j = m-i + n -j -1  j = m+n+1/2 -i m&lt;n</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">median1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">median2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mediana1</span> <span class="operator">=</span> (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i-<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">mediana2</span> <span class="operator">=</span> (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">medianb1</span> <span class="operator">=</span> (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">medianb2</span> <span class="operator">=</span> (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line">                <span class="keyword">if</span>(mediana1 &lt;= medianb2) &#123;</span><br><span class="line">                    median1 = Math.max(mediana1, medianb1);</span><br><span class="line">                    median2 = Math.min(mediana2, medianb2);</span><br><span class="line">                    left = i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right  = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ( m + n) %<span class="number">2</span>==<span class="number">0</span>? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 39 Solution</title>
      <link href="/posts/8e379ed2.html"/>
      <url>/posts/8e379ed2.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s39;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合总和</span></span><br><span class="line"><span class="comment"> * 给你一个 无重复元素 的整数数组candidates 和一个目标整数target，找出candidates中可以使数字和为目标数target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于给定的输入，保证和为target 的不同组合数少于 150 个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/combination-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 38 Solution</title>
      <link href="/posts/61f5f5ec.html"/>
      <url>/posts/61f5f5ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s38;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观数列</span></span><br><span class="line"><span class="comment"> * 给定一个正整数 n ，输出外观数列的第 n 项。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以将其视作是由递归公式定义的数字字符串序列：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * countAndSay(1) = &quot;1&quot;</span></span><br><span class="line"><span class="comment"> * countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/count-and-say</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lastStr</span> <span class="operator">=</span> countAndSay(n - <span class="number">1</span>); <span class="comment">// 1 2 1 1</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, len = lastStr.length();</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastStr.charAt(i) != lastStr.charAt(j)) &#123;</span><br><span class="line">                    ans.append(j - i).append(lastStr.charAt(i));</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(j - i).append(lastStr.charAt(i));</span><br><span class="line">            <span class="keyword">return</span> ans.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 37 Solution</title>
      <link href="/posts/90feae61.html"/>
      <url>/posts/90feae61.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s37;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解数独</span></span><br><span class="line"><span class="comment"> * 编写一个程序，通过填充空格来解决数独问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数独的解法需 遵循如下规则：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一行只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一列只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span></span><br><span class="line"><span class="comment"> * 数独部分空格内已填入了数字，空白格用 &#x27;.&#x27; 表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sudoku-solver</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] line = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] column = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][][] block = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt; spaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.size()) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] space = spaces.get(pos);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> space[<span class="number">0</span>], j = space[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = (<span class="type">char</span>) (digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">                dfs(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 36 Solution</title>
      <link href="/posts/7f3cc55f.html"/>
      <url>/posts/7f3cc55f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s36;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效的数独</span></span><br><span class="line"><span class="comment"> * 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一行只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一列只能出现一次。</span></span><br><span class="line"><span class="comment"> * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个有效的数独（部分已被填充）不一定是可解的。</span></span><br><span class="line"><span class="comment"> * 只需要根据以上规则，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment"> * 空白格用 &#x27;.&#x27; 表示。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-sudoku</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">// init data</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] rows = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] columns = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; [] boxes = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            rows[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            columns[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            boxes[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// validate a board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>)num;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">box_index</span> <span class="operator">=</span> (i / <span class="number">3</span> ) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// keep the current cell value</span></span><br><span class="line">                    rows[i].put(n, rows[i].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    columns[j].put(n, columns[j].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// check if this value has been already seen before</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i].get(n) &gt; <span class="number">1</span> || columns[j].get(n) &gt; <span class="number">1</span> || boxes[box_index].get(n) &gt; <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 35 Solution</title>
      <link href="/posts/940b7e5c.html"/>
      <url>/posts/940b7e5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s35;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索插入位置</span></span><br><span class="line"><span class="comment"> * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请必须使用时间复杂度为 O(log n) 的算法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-insert-position</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 34 Solution</title>
      <link href="/posts/7bc91562.html"/>
      <url>/posts/7bc91562.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s34;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="comment"> * 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果数组中不存在目标值 target，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; left &lt;= nums.length-<span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; left &lt;= nums.length-<span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[left] == target)&#123;</span><br><span class="line">            res[<span class="number">1</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 33 Solution</title>
      <link href="/posts/99150e1b.html"/>
      <url>/posts/99150e1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s33;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * 整数数组 nums 按升序排列，数组中的值 互不相同 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/search-in-rotated-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//数组大小判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个值情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二分法 左右边界和中间值</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            mid = (i + j) /<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果中间值 就是target 则返回mid</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果0 ~mid 为上升，则mid在左升区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//如果 target 在i ~ mid之间</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// target 在mid ~ j之间</span></span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果0 ~mid 为下降，则mid在右降区间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果 target 在i ~ mid之间</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j = mid -<span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 322 Solution</title>
      <link href="/posts/9cd9eac8.html"/>
      <url>/posts/9cd9eac8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s322;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以认为每种硬币的数量是无限的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/coin-change</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="title class_">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> rem, <span class="type">int</span>[] count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(rem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rem ==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> coinChange(coins, rem - coin, count);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min) &#123;</span><br><span class="line">                min = <span class="number">1</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[rem - <span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min;</span><br><span class="line">        <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 32 Solution</title>
      <link href="/posts/76d76525.html"/>
      <url>/posts/76d76525.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长有效括号</span></span><br><span class="line"><span class="comment"> * 给你一个只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建一个栈 用来从左到右存括号字符串</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//压一个初始长度-1</span></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果是左括号 就压栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//右括号就弹出</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//弹出后如果空了就压当前i的值，表示有效子串开始的位置</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不为空就比较下 有效子串是否为最长 ，更新maxans</span></span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 31 Solution</title>
      <link href="/posts/9de0de26.html"/>
      <url>/posts/9de0de26.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s31;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个排列</span></span><br><span class="line"><span class="comment"> * 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span></span><br><span class="line"><span class="comment"> * 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span></span><br><span class="line"><span class="comment"> * 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span></span><br><span class="line"><span class="comment"> * 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，找出 nums 的下一个排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 必须 原地 修改，只允许使用额外常数空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/next-permutation</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//从右到左找出开始递增的位置  1612354 中 3 就是</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了，再从右到左找出第一个大于nums[i]的值  1612354 中 4 就是</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换两个数字位置 1612453</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转 i + 1 到 结束 也就是  53 变成 35</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 300 Solution</title>
      <link href="/posts/c0408334.html"/>
      <url>/posts/c0408334.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s300;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-increasing-subsequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//严格递增子序列数组</span></span><br><span class="line">        <span class="type">int</span>[] sub = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第0个节点</span></span><br><span class="line">        sub[size] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//前一个小于后一个节点时，记录到sub数组</span></span><br><span class="line">        <span class="keyword">if</span>(sub[size] &lt; nums[i]) &#123;</span><br><span class="line">        sub[++size] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//重置sub数组，分左右两个指针判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="comment">//如果sub中找不到比nums[i]小的元素则从0开始替换</span></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移动两边指针</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//取中间点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//因为sub已经有序，所以二分法，找到满足升序的中间点pos，更新sub数组</span></span><br><span class="line">        <span class="keyword">if</span>(sub[mid] &lt;  nums[i]) &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">        pos = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新sub数组</span></span><br><span class="line">        sub[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 30 Solution</title>
      <link href="/posts/7222b518.html"/>
      <url>/posts/7222b518.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s30;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串联所有单词的子串</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/substring-with-concatenation-of-all-words</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">one_word</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">word_num</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">all_len</span> <span class="operator">=</span> one_word * word_num;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - all_len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i, i + all_len);</span><br><span class="line">            HashMap&lt;String, Integer&gt; tmp_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; all_len; j += one_word) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> tmp.substring(j, j + one_word);</span><br><span class="line">                tmp_map.put(w, tmp_map.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.equals(tmp_map)) res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 3 Solution</title>
      <link href="/posts/ad1fb1a1.html"/>
      <url>/posts/ad1fb1a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//字符串 字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//游标 子串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//子串最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//出现字符 及对应的下标&lt;字符， 最近一次出现的下标&gt;</span></span><br><span class="line">        Map&lt;Character, Integer&gt; cs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="comment">//子串中字符上次出现位置</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">lastExist</span> <span class="operator">=</span> cs.get(chars[i]);</span><br><span class="line">            <span class="comment">//如果已经出现过该字符且在子串中</span></span><br><span class="line">            <span class="keyword">if</span>(lastExist!=<span class="literal">null</span> &amp;&amp; lastExist &gt;= start) &#123;</span><br><span class="line">                <span class="comment">// 则从字符出现重复后端下一个位置开始</span></span><br><span class="line">                start = lastExist + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果字符长度大于目前记录的最大长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i - start + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                <span class="comment">//则更新最大长度记录</span></span><br><span class="line">                max = i - start + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次遍历把字符 及出现的下标记录下来</span></span><br><span class="line">            cs.put(chars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 29 Solution</title>
      <link href="/posts/4fb94112.html"/>
      <url>/posts/4fb94112.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s29;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两数相除</span></span><br><span class="line"><span class="comment"> * 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回被除数 dividend 除以除数 divisor 得到的商。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/divide-two-integers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == -<span class="number">2147483648</span> &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">2147483647</span> &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="comment">// 对两种特殊情况的快速处理，大概算是偷鸡了吧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNeg</span> <span class="operator">=</span> (dividend &lt; <span class="number">0</span> ^ divisor &lt; <span class="number">0</span>); <span class="comment">// 异或运算确定结果正负性</span></span><br><span class="line">        dividend = -Math.abs(dividend);</span><br><span class="line">        divisor = -Math.abs(divisor);</span><br><span class="line">        <span class="comment">// 使用绝对值再取负，全部转化为负数进行运算</span></span><br><span class="line">        <span class="comment">// 特别的，在int范围内，-2147483648的正负数都是其自身，因此不会出错</span></span><br><span class="line">        <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> divisor; <span class="comment">// d为本轮所用的除数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// cnt表示d为原除数的cnt倍</span></span><br><span class="line">            <span class="keyword">while</span> (dividend &lt;= d &amp;&amp; d &gt;= -<span class="number">1073741824</span>) &#123;</span><br><span class="line">                <span class="comment">// 每次对d和cnt都进行翻倍，快速到达大于被除数的最小除数</span></span><br><span class="line">                <span class="comment">// 等效d=d*2，但题目禁用乘法，且位运算左移速度更快</span></span><br><span class="line">                d = d &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                cnt = cnt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当 dividend &gt; d 时，表明此时d已经小于被除数了，不能继续</span></span><br><span class="line">            <span class="comment">// 当 d &lt; -1073741824 时，表明此时d再翻倍会造成溢出，不能继续</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dividend &lt;= d) &#123;</span><br><span class="line">                <span class="comment">// 此时说明上一步d再翻倍会造成溢出</span></span><br><span class="line">                <span class="comment">// 可知d已经是大于被除数的最小除数，直接使用即可</span></span><br><span class="line">                dividend -= d;</span><br><span class="line">                result += cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时d是小于被除数的最大除数，需要右移补回一次</span></span><br><span class="line">                <span class="comment">// 才能成为大于被除数的最小除数，再进行使用</span></span><br><span class="line">                dividend -= d &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                result += cnt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNeg ? -result : result;</span><br><span class="line">        <span class="comment">// result为所有倍数的和，需要补充正负性再返回</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 28 Solution</title>
      <link href="/posts/a07b2a2c.html"/>
      <url>/posts/a07b2a2c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s28;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> * 实现 strStr()</span></span><br><span class="line"><span class="comment"> * 实现 strStr() 函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-strstr</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 27 Solution</title>
      <link href="/posts/517071a1.html"/>
      <url>/posts/517071a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s27;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为什么返回数值是整数，但输出的答案是数组呢?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以想象内部操作如下:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="comment"> * int len = removeElement(nums, val);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"> * // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment"> *     print(nums[i]);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-element</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 26 Solution</title>
      <link href="/posts/beb21a9f.html"/>
      <url>/posts/beb21a9f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s26;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  删除有序数组中的重复项</span></span><br><span class="line"><span class="comment"> *  给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将最终结果插入 nums 的前 k 个位置后返回 k 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判题标准:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 系统会用下面的代码来测试你的题解:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 25 Solution</title>
      <link href="/posts/5585a19c.html"/>
      <url>/posts/5585a19c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s25;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * K 个一组翻转链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-nodes-in-k-group</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定一个数据结构，存放链表 分组</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pharse</span> &#123;</span><br><span class="line">        <span class="comment">//链表开始节点</span></span><br><span class="line">        ListNode begin;</span><br><span class="line">        <span class="comment">//链表开始节点</span></span><br><span class="line">        ListNode end;</span><br><span class="line">        <span class="comment">//链表是否需要翻转</span></span><br><span class="line">        <span class="type">boolean</span> reverse;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pharse</span><span class="params">(ListNode begin, ListNode end, <span class="type">boolean</span> reverse)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.begin = begin;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.reverse = reverse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseSubGroup</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//前置节点都未null</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//当前节点为begin</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> begin;</span><br><span class="line">            <span class="comment">//开始翻转</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="comment">//需要判断翻转结束条件</span></span><br><span class="line">                <span class="keyword">if</span>(cur == end || tmp == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转向后给出新的交换后的 begin end</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> begin;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//判断入参</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//一个元素直接返回</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哑巴节点，标记头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//当前节点从head开始</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//开始位置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//链表分组</span></span><br><span class="line">        List&lt;Pharse&gt; pharses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表开始</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//链表结束</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//开始分组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; cur != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//k个元素 开始的位置</span></span><br><span class="line">            <span class="keyword">if</span>(i % k == <span class="number">0</span> &amp;&amp; !flag) &#123;</span><br><span class="line">                start = cur;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//区间就一个元素了，开始即是结束</span></span><br><span class="line">                <span class="keyword">if</span>(cur.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                    end = cur;</span><br><span class="line">                    pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">false</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//k个元素后 结束的位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((i + <span class="number">1</span>) % k == <span class="number">0</span> &amp;&amp; flag) &#123;</span><br><span class="line">                end = cur;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">true</span>));</span><br><span class="line">                <span class="comment">//区间没有满k个元素，提前结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                end = cur;</span><br><span class="line">                pharses.add(<span class="keyword">new</span> <span class="title class_">Pharse</span>(start, end, <span class="literal">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一个元素</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ph</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(Pharse pharse : pharses) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pharse.reverse) &#123;</span><br><span class="line">                <span class="comment">//每个区间内翻转</span></span><br><span class="line">                pharse.reverseSubGroup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多个区间指针反向修改</span></span><br><span class="line">            ph.next = pharse.begin;</span><br><span class="line">            ph = pharse.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 24 Solution</title>
      <link href="/posts/ba47caa2.html"/>
      <url>/posts/ba47caa2.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s24;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两两交换链表中的节点</span></span><br><span class="line"><span class="comment"> * 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//新建哑巴节点，存放头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="comment">//从哑巴节点开始 往后找到后两个节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换节点</span></span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 239 Solution</title>
      <link href="/posts/3e128290.html"/>
      <url>/posts/3e128290.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s239;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sliding-window-maximum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                <span class="comment">//非最大值出队列</span></span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到k个最大值 对应的下标放到队列中</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义结果数组</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//前面找到的那个第一次窗口k个最大值 放入数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = nums[deque.peekFirst()];</span><br><span class="line">        <span class="comment">//继续遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">//如果超过当前窗口范围 移出窗口</span></span><br><span class="line">            <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把窗口最后一次的最大值放到结果数组中</span></span><br><span class="line">            ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 236 Solution</title>
      <link href="/posts/cf19d91d.html"/>
      <url>/posts/cf19d91d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s236;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图示两个链表在节点 c1 开始相交：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据 保证 整个链式结构中不存在环。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，函数返回结果后，链表必须 保持其原始结构 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义评测：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 评测系统 的输入如下（你设计的程序 不适用 此输入）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</span></span><br><span class="line"><span class="comment"> * listA - 第一个链表</span></span><br><span class="line"><span class="comment"> * listB - 第二个链表</span></span><br><span class="line"><span class="comment"> * skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</span></span><br><span class="line"><span class="comment"> * skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</span></span><br><span class="line"><span class="comment"> * 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/intersection-of-two-linked-lists</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 234 Solution</title>
      <link href="/posts/cbec0920.html"/>
      <url>/posts/cbec0920.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s234;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                        fast = fast.next.next;</span><br><span class="line">                        tmp.next = pre;</span><br><span class="line">                        pre = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fast != <span class="literal">null</span>) &#123;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(pre != <span class="literal">null</span> &amp;&amp; slow != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(pre.val != slow.val) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pre = pre.next;</span><br><span class="line">                        slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 232 Solution</title>
      <link href="/posts/c6f27967.html"/>
      <url>/posts/c6f27967.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s232;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 MyQueue 类：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * void push(int x) 将元素 x 推到队列的末尾</span></span><br><span class="line"><span class="comment"> * int pop() 从队列的开头移除并返回元素</span></span><br><span class="line"><span class="comment"> * int peek() 返回队列开头的元素</span></span><br><span class="line"><span class="comment"> * boolean empty() 如果队列为空，返回 true ；否则，返回 false</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</span></span><br><span class="line"><span class="comment"> * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/implement-queue-using-stacks</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//两个栈 一个入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="comment">//两个栈 一个出栈</span></span><br><span class="line">    Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//push进inStack</span></span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果outStack为空</span></span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//将inStack写入到outStack</span></span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从outStack读出</span></span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从outStack取栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//inStack、outStack都为空</span></span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//inStack写入outStack</span></span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 23 Solution</title>
      <link href="/posts/589bd1db.html"/>
      <url>/posts/589bd1db.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s23;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并K个升序链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表数组，每个链表都已经按升序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你将所有链表合并到一个升序链表中，返回合并后的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge2Lists</span><span class="params">(ListNode lista, ListNode listb)</span> &#123;</span><br><span class="line">        <span class="comment">//哑巴节点方便返回链表head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//遍历链表 cur 为当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历完lista</span></span><br><span class="line">            <span class="keyword">if</span>(lista == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = listb;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历完listb</span></span><br><span class="line">            <span class="keyword">if</span>(listb == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = lista;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照升序排列链表</span></span><br><span class="line">            <span class="keyword">if</span>(lista.val &lt;= listb.val) &#123;</span><br><span class="line">                cur.next = lista;</span><br><span class="line">                lista = lista.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = listb;</span><br><span class="line">                listb = listb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//链表节点后移一位</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个链表合并，变为两两合并</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//多个链表两两合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i &lt; lists.length; i ++) &#123;</span><br><span class="line">            dum = merge2Lists(dum, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 226 Solution</title>
      <link href="/posts/e9706dd.html"/>
      <url>/posts/e9706dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s226;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">                root.left = right;</span><br><span class="line">                root.right = left;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 221 Solution</title>
      <link href="/posts/ec4b1da4.html"/>
      <url>/posts/ec4b1da4.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s221;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个由 &#x27;0&#x27; 和 &#x27;1&#x27; 组成的二维矩阵内，找到只包含 &#x27;1&#x27; 的最大正方形，并返回其面积。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断 边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//新建一个dp二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">        <span class="comment">//遇到1的情况 考虑动态转移方程</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//边界的情况，初始化为1</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//左侧、上侧、左上侧 三个 最大值加1</span></span><br><span class="line">        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大值 正方形长度</span></span><br><span class="line">        maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算面积</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSquare</span> <span class="operator">=</span> maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 22 Solution</title>
      <link href="/posts/b759bae5.html"/>
      <url>/posts/b759bae5.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号生成</span></span><br><span class="line"><span class="comment"> * 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//定义结果list</span></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//回溯法</span></span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">//如果长度够了 就添加到list 返回  max是括号对数</span></span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//open 左括号个数 close 右括号个数</span></span><br><span class="line">        <span class="comment">//如果 左括号个数没有到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            <span class="comment">//就再拼接一个左括号</span></span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//递归 继续拼接</span></span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            <span class="comment">//开始回溯 每次减去一个左括号</span></span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 右括号个数没有到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            <span class="comment">//开始回溯 每次减去一个左括号</span></span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 215 Solution</title>
      <link href="/posts/7c42dbdf.html"/>
      <url>/posts/7c42dbdf.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s215;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 215. 数组中的第K个最大元素</span></span><br><span class="line"><span class="comment"> * 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/kth-largest-element-in-an-array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//定义堆的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//初始构建大顶堆，大小为全部的数组长度</span></span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="comment">//大顶堆每次去掉最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//去掉最大元素</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            <span class="comment">//构建一个次小堆</span></span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//复杂度 heapSize / 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//左子节点  右子节点， 根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="comment">//堆 大小范围内， 如果 左子节点 &gt; 根</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            <span class="comment">// 根为左子节点</span></span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆 大小范围内， 如果 右子节点 &gt; 根</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            <span class="comment">// 根为右子节点</span></span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根被替换</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="comment">// 执行移动操作</span></span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            <span class="comment">//重新构建</span></span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 21 Solution</title>
      <link href="/posts/5c6e01e6.html"/>
      <url>/posts/5c6e01e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s21;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序链表</span></span><br><span class="line"><span class="comment"> * 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从小到大排列</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val) &#123;</span><br><span class="line">            <span class="comment">//合并子链表</span></span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list2.next, list1);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 206 Solution</title>
      <link href="/posts/56fbbf1c.html"/>
      <url>/posts/56fbbf1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s206;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 206. 反转链表</span></span><br><span class="line"><span class="comment"> * 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//前置节点 后一个节点指向的节点，初始的前置节点为null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//当前节点，从head开始遍历</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//当前节点不为null</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//下一个节点先存中间变量</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//下一个节点指向前一个节点</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">//当前节点称为前置节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//下一个节点为当前节点</span></span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 200 Solution</title>
      <link href="/posts/5be5cf5b.html"/>
      <url>/posts/5be5cf5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s200;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 20 Solution</title>
      <link href="/posts/b3ac6ad8.html"/>
      <url>/posts/b3ac6ad8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效的括号</span></span><br><span class="line"><span class="comment"> * 给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有效字符串需满足：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment"> * 左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/valid-parentheses</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//根据入参判断 不能为奇数</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//符号对</span></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        pairs.put(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="comment">//字符串转字符数组</span></span><br><span class="line">        <span class="type">char</span>[] charr =s.toCharArray();</span><br><span class="line">        <span class="comment">//放入栈中判断</span></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; charr.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//如果为左侧符号， 符号对key中一定存在，则压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pairs.containsKey(charr[i])) &#123;</span><br><span class="line">                stack.push(pairs.get(charr[i]));</span><br><span class="line">                <span class="comment">//如果符号对key中不存在，栈中有元素，且栈顶符号等于当前符号，则弹栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stack.size()!=<span class="number">0</span> &amp;&amp; stack.peek() == charr[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 2 Solution</title>
      <link href="/posts/42ddda9f.html"/>
      <url>/posts/42ddda9f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/add-two-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//新建结果链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">//记录当前节点 方便后面移动</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//相加 &gt; 10 进一位 进位的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carray</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断结束条件</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carray!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对应位相加的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//l1各位已经加完了， l2 还没有结束</span></span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                <span class="comment">//l2各位已经加完了， l1 还没有结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="literal">null</span> &amp;&amp; l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                <span class="comment">//l1 l2 对应位置有值则相加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(l2 != <span class="literal">null</span> &amp;&amp; l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                sum = l1.val + l2.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接到结果链表链表后面</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>((sum + carray) % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">//需要进一位的保存在变量carray</span></span><br><span class="line">            carray = (sum + carray) / <span class="number">10</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 199 Solution</title>
      <link href="/posts/ab2308e4.html"/>
      <url>/posts/ab2308e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s199;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_dep</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右分支视图按层输出</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; rightViewAtDepth = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">//节点压栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        <span class="comment">//深度压栈</span></span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(nodeStack.size() != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">//节点弹栈</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeStack.pop();</span><br><span class="line">            <span class="comment">//深度弹栈</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">dep</span> <span class="operator">=</span> depthStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//最大深度</span></span><br><span class="line">                max_dep = Math.max(dep, max_dep);</span><br><span class="line">                <span class="comment">//右视图未遍历到该层，第一次遍历到的一定是右节点</span></span><br><span class="line">                <span class="keyword">if</span>(!rightViewAtDepth.containsKey(dep)) &#123;</span><br><span class="line">                    <span class="comment">//存入视图</span></span><br><span class="line">                    rightViewAtDepth.put(dep, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左节点压栈</span></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                <span class="comment">//右节点压栈</span></span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                <span class="comment">//层数存入深度栈</span></span><br><span class="line">                depthStack.push(dep + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//层数存入深度栈</span></span><br><span class="line">                depthStack.push(dep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历深度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt;= max_dep; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> rightViewAtDepth.get(i);</span><br><span class="line">            ret.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 19 Solution</title>
      <link href="/posts/d65b2713.html"/>
      <url>/posts/d65b2713.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s19;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表的倒数第 N 个结点</span></span><br><span class="line"><span class="comment"> * 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = dum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt; cnt-n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 18 Solution</title>
      <link href="/posts/39994c2d.html"/>
      <url>/posts/39994c2d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s18;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四数之和</span></span><br><span class="line"><span class="comment"> * 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 &lt;= a, b, c, d &lt; n</span></span><br><span class="line"><span class="comment"> * a、b、c 和 d 互不相同</span></span><br><span class="line"><span class="comment"> * nums[a] + nums[b] + nums[c] + nums[d] == target</span></span><br><span class="line"><span class="comment"> * 你可以按 任意顺序 返回答案 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/4sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> quadruplets;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 17 Solution</title>
      <link href="/posts/c89217a0.html"/>
      <url>/posts/c89217a0.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电话号码的字母组合</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/letter-combinations-of-a-phone-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 169 Solution</title>
      <link href="/posts/38dbfc22.html"/>
      <url>/posts/38dbfc22.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s169;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/majority-element</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">countNums</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!counts.containsKey(num)) &#123;</span><br><span class="line">                counts.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(num, counts.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = countNums(nums);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (majorityEntry == <span class="literal">null</span> || entry.getValue() &gt; majorityEntry.getValue()) &#123;</span><br><span class="line">                majorityEntry = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 165 Solution</title>
      <link href="/posts/22e71cac.html"/>
      <url>/posts/22e71cac.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s165;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你两个版本号 version1 和 version2 ，请你比较它们。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 版本号由一个或多个修订号组成，各修订号由一个 &#x27;.&#x27; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回规则如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 version1 &gt; version2 返回 1，</span></span><br><span class="line"><span class="comment"> * 如果 version1 &lt; version2 返回 -1，</span></span><br><span class="line"><span class="comment"> * 除此之外返回 0。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/compare-version-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        String[] v1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] v2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v1.length||i&lt;v2.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v1.length) &#123;</span><br><span class="line">                x = Integer.parseInt(v1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v2.length) &#123;</span><br><span class="line">                y = Integer.parseInt(v2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 160 Solution</title>
      <link href="/posts/c4ced7e8.html"/>
      <url>/posts/c4ced7e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s160;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">         next = <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 16 Solution</title>
      <link href="/posts/27507c9e.html"/>
      <url>/posts/27507c9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最接近的三数之和</span></span><br><span class="line"><span class="comment"> * 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回这三个数的和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假定每组输入只存在恰好一个解。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/3sum-closest</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k0</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">j0</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 155 Solution</title>
      <link href="/posts/bb057aad.html"/>
      <url>/posts/bb057aad.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 MinStack 类:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MinStack() 初始化堆栈对象。</span></span><br><span class="line"><span class="comment"> * void push(int val) 将元素val推入堆栈。</span></span><br><span class="line"><span class="comment"> * void pop() 删除堆栈顶部的元素。</span></span><br><span class="line"><span class="comment"> * int top() 获取堆栈顶部的元素。</span></span><br><span class="line"><span class="comment"> * int getMin() 获取堆栈中的最小元素。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/min-stack</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line">    <span class="comment">//最小栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        data.push(val);</span><br><span class="line">        <span class="keyword">if</span>(minStack.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//最小值存栈顶，如果不是最小，取栈顶的最小值再存一次，保证pop后 最小值还在栈顶</span></span><br><span class="line">            minStack.push(Math.min(val, minStack.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 151 Solution</title>
      <link href="/posts/b2eedad7.html"/>
      <url>/posts/b2eedad7.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，颠倒字符串中 单词 的顺序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reverse-words-in-a-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 15 Solution</title>
      <link href="/posts/cc67c79d.html"/>
      <url>/posts/cc67c79d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数之和</span></span><br><span class="line"><span class="comment"> * 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/3sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//结果list</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//判断入参</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">//排序数据，方便设置左右边界 遍历</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//先定义一个元素遍历，作为三个中最小的一个值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt; nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//判断终止条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="comment">//忽略到相同的值</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//第二个元素 取区间左边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第三个元素 取区间右边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果左右边界重合 则停止</span></span><br><span class="line">            <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">                <span class="comment">//如果三数和为0</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[L] + nums[R] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//记录三个数</span></span><br><span class="line">                    <span class="type">List</span> <span class="variable">numbers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                    numbers.add(nums[i]);</span><br><span class="line">                    numbers.add(nums[L]);</span><br><span class="line">                    numbers.add(nums[R]);</span><br><span class="line">                    ret.add(numbers);</span><br><span class="line">                    <span class="comment">//基于已有的和为0 左右移动边界 寻找其他的记录</span></span><br><span class="line">                    <span class="keyword">while</span>(L&lt; R &amp;&amp; (nums[L] == nums[L+<span class="number">1</span>])) &#123;</span><br><span class="line">                        <span class="comment">//忽略相同的数值 左边界右移</span></span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(R &gt; L &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">//忽略相同的数值 右边界左移</span></span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//移动左右边界</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[L] + nums[R] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 和小于0  左边界右移</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 和大于0  右边界左移</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 148 Solution</title>
      <link href="/posts/8f752edd.html"/>
      <url>/posts/8f752edd.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s148;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail) &#123;</span><br><span class="line">            fast  = fast.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">m</span> <span class="operator">=</span> sortList(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> sortList(mid, tail);</span><br><span class="line">        <span class="keyword">return</span> mergeList(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 != <span class="literal">null</span> &amp;&amp; tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1.val &lt; tmp2.val) &#123;</span><br><span class="line">                tmp.next = tmp1;</span><br><span class="line">                tmp1 = tmp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = tmp2;</span><br><span class="line">                tmp2 = tmp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 147 Solution</title>
      <link href="/posts/7e7e7550.html"/>
      <url>/posts/7e7e7550.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s147;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序链表</span></span><br><span class="line"><span class="comment"> * 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail) &#123;</span><br><span class="line">            fast  = fast.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">m</span> <span class="operator">=</span> sortList(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> sortList(mid, tail);</span><br><span class="line">        <span class="keyword">return</span> mergeList(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 != <span class="literal">null</span> &amp;&amp; tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp1.val &lt; tmp2.val) &#123;</span><br><span class="line">                tmp.next = tmp1;</span><br><span class="line">                tmp1 = tmp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = tmp2;</span><br><span class="line">                tmp2 = tmp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.next = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 146 Solution</title>
      <link href="/posts/91bc1e6e.html"/>
      <url>/posts/91bc1e6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s146;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU 缓存</span></span><br><span class="line"><span class="comment"> * 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</span></span><br><span class="line"><span class="comment"> * 实现 LRUCache 类：</span></span><br><span class="line"><span class="comment"> * LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</span></span><br><span class="line"><span class="comment"> * int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> * void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</span></span><br><span class="line"><span class="comment"> * 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/lru-cache</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LRU队列中的元素定义 双向链表存储 方便随机访问 删除 添加操作</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="comment">//缓存key</span></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="comment">//缓存值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">//队列前一个节点</span></span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        <span class="comment">//队列后一个节点</span></span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LRU缓存map&lt;缓存的值, 缓存的元素&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="comment">//缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//缓存容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">//头结点 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line">    <span class="comment">//缓存初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//使用伪头部和伪尾部节点 方便尾部查询，头部删除</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//先从map中取</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 key 存在，先通过哈希表定位，再移到头部， 头插尾删。</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//先从map中取</span></span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            <span class="comment">//记录元素个数</span></span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *头插</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该节点</span></span><br><span class="line"><span class="comment">     * 并把该节点移动到头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾部节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 145 Solution</title>
      <link href="/posts/7a8ba56d.html"/>
      <url>/posts/7a8ba56d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s145;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的后序遍历</span></span><br><span class="line"><span class="comment"> * 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">//先左孩子入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">//右孩子入栈</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 144 Solution</title>
      <link href="/posts/9549ce53.html"/>
      <url>/posts/9549ce53.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s144;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的前序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//定义结果list</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义队列 遍历时存放当前节点用</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(stack.size() != <span class="number">0</span> || node!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="comment">//先当前节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                <span class="comment">//后left节点</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后右节点</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 143 Solution</title>
      <link href="/posts/7795d52a.html"/>
      <url>/posts/7795d52a.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s143;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重排链表</span></span><br><span class="line"><span class="comment"> * 给定一个单链表 L 的头节点 head ，单链表 L 表示为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L0 → L1 → … → Ln - 1 → Ln</span></span><br><span class="line"><span class="comment"> * 请将其重新排列后变为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span></span><br><span class="line"><span class="comment"> * 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/reorder-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找链表中间点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMid(head);</span><br><span class="line">        <span class="comment">//拆分成前后两个链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//翻转后面的链表</span></span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        <span class="comment">//两个链表合并</span></span><br><span class="line">        mergeList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next!= <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间点</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l1_tmp</span> <span class="operator">=</span> l1.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">l2_tmp</span> <span class="operator">=</span> l2.next;</span><br><span class="line">            <span class="comment">//l1 指向 l2</span></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            <span class="comment">//l2 要指向 l1.next 也就是未修改指向的l1_tmp</span></span><br><span class="line">            l2.next = l1_tmp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下一步</span></span><br><span class="line">            l1 = l1_tmp;</span><br><span class="line">            l2 = l2_tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 142 Solution</title>
      <link href="/posts/9857be14.html"/>
      <url>/posts/9857be14.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s142;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形链表 II</span></span><br><span class="line"><span class="comment"> * 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不允许修改 链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/linked-list-cycle-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快慢指针，快指针走两步，慢指针走一步</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//快慢指针都走完结束</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//快慢指针相遇</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="comment">//快慢指针相遇后，此时慢指针走到链表环开始节点的距离，刚好等于head节点到链表环开始节点的距离</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 141 Solution</title>
      <link href="/posts/73600517.html"/>
      <url>/posts/73600517.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s141;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形链表</span></span><br><span class="line"><span class="comment"> * 给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/linked-list-cycle</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//下一步不为null</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//快指针走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">//慢指针走一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">//快慢相遇则出现环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 140 Solution</title>
      <link href="/posts/9ca26e29.html"/>
      <url>/posts/9ca26e29.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s140;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词拆分 II</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：词典中的同一个单词可能在分段中被重复使用多次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-break-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; wordBreaks = backtrack(s, s.length(), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(wordDict), <span class="number">0</span>, map);</span><br><span class="line">        List&lt;String&gt; breakList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; wordBreak : wordBreaks) &#123;</span><br><span class="line">            breakList.add(String.join(<span class="string">&quot; &quot;</span>, wordBreak));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> breakList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> length, Set&lt;String&gt; wordSet, <span class="type">int</span> index, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(index)) &#123;</span><br><span class="line">            List&lt;List&lt;String&gt;&gt; wordBreaks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">                wordBreaks.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(index, i);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(word)) &#123;</span><br><span class="line">                    List&lt;List&lt;String&gt;&gt; nextWordBreaks = backtrack(s, length, wordSet, i, map);</span><br><span class="line">                    <span class="keyword">for</span> (List&lt;String&gt; nextWordBreak : nextWordBreaks) &#123;</span><br><span class="line">                        LinkedList&lt;String&gt; wordBreak = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(nextWordBreak);</span><br><span class="line">                        wordBreak.offerFirst(word);</span><br><span class="line">                        wordBreaks.add(wordBreak);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(index, wordBreaks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 14 Solution</title>
      <link href="/posts/23a5aca3.html"/>
      <url>/posts/23a5aca3.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s14;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长公共前缀</span></span><br><span class="line"><span class="comment"> * 编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不存在公共前缀，返回空字符串 &quot;&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取第一个数组做对比</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">//字符串个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="comment">//遍历字符串字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="comment">//对比其他字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="comment">//达到其他字符串最大长度 或者 字符匹配不上，则终止</span></span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 139 Solution</title>
      <link href="/posts/498c5060.html"/>
      <url>/posts/498c5060.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s139;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词拆分</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-break</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Set&lt;Integer&gt; wordLength = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            wordLength.add(word.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单词去重</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        Set&lt;String&gt; wrongSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> matchWords(s, dict, wordLength, wrongSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchWords</span><span class="params">(String s, Set&lt;String&gt; dict, Set&lt;Integer&gt; wordLength, Set&lt;String&gt; wrongSet)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(s) || dict.contains(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历单词所有字符</span></span><br><span class="line">        <span class="keyword">for</span>(Integer j : wordLength) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; s.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, j);</span><br><span class="line">            <span class="comment">//截取字符串，找到单词表中存在的子串</span></span><br><span class="line">            <span class="keyword">if</span>(dict.contains(sub)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subEnd</span> <span class="operator">=</span> s.substring(j);</span><br><span class="line">                <span class="keyword">if</span>(!wrongSet.contains(subEnd) &amp;&amp; matchWords(subEnd, dict, wordLength, wrongSet)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wrongSet.add(subEnd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 138 Solution</title>
      <link href="/posts/a64e3b5e.html"/>
      <url>/posts/a64e3b5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s138;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制带随机指针的链表</span></span><br><span class="line"><span class="comment"> * 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回复制链表的头节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * val：一个表示 Node.val 的整数。</span></span><br><span class="line"><span class="comment"> * random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</span></span><br><span class="line"><span class="comment"> * 你的代码 只 接受原链表的头节点 head 作为传入参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/copy-list-with-random-pointer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//节点缓存到map</span></span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果已经缓存说明节点已存在，则不用复制</span></span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class="line">            <span class="comment">//复制节点值</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            <span class="comment">//缓存新旧节点</span></span><br><span class="line">            cachedNode.put(head, headNew);</span><br><span class="line">            <span class="comment">//新节点next指向下一个新节点</span></span><br><span class="line">            headNew.next = copyRandomList(head.next);</span><br><span class="line">            <span class="comment">//新节点random指向下一个新节点</span></span><br><span class="line">            headNew.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 137 Solution</title>
      <link href="/posts/574560d3.html"/>
      <url>/posts/574560d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s137;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//最终的结果值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int类型有32位，统计每一位1的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//统计第i位中1的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oneCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                oneCount += (nums[j] &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果1的个数不是3的倍数，说明那个只出现一次的数字</span></span><br><span class="line">            <span class="comment">//的二进制位中在这一位是1</span></span><br><span class="line">            <span class="keyword">if</span> (oneCount % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 136 Solution</title>
      <link href="/posts/b8870bed.html"/>
      <url>/posts/b8870bed.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s136;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/single-number</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashMap</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="comment">//将其存入哈希表中，含义为，若该元素不存在则存入表中，并计数为1，若已经存在获取次数并加1.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            map.put(x , map.getOrDefault(x,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历出出现次数为1的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(y) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 135 Solution</title>
      <link href="/posts/53b0b0ee.html"/>
      <url>/posts/53b0b0ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s135;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发糖果</span></span><br><span class="line"><span class="comment"> * n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你需要按照以下要求，给这些孩子分发糖果：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个孩子至少分配到 1 个糖果。</span></span><br><span class="line"><span class="comment"> * 相邻两个孩子评分更高的孩子会获得更多的糖果。</span></span><br><span class="line"><span class="comment"> * 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/candy</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//从左到右发，最少给1个 分高就比右边多给一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右向左，保证左侧分高的能多分一个糖</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += Math.max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 134 Solution</title>
      <link href="/posts/bc72dbd0.html"/>
      <url>/posts/bc72dbd0.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s134;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加油站</span></span><br><span class="line"><span class="comment"> * 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/gas-station</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumOfGas</span> <span class="operator">=</span> <span class="number">0</span>, sumOfCost = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (i + cnt) % n;</span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                sumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span> (sumOfCost &gt; sumOfGas) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + cnt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 133 Solution</title>
      <link href="/posts/5eaec0a9.html"/>
      <url>/posts/5eaec0a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s133;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 克隆图</span></span><br><span class="line"><span class="comment"> * 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * class Node &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/clone-graph</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt;&gt; ();</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cloneNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        <span class="comment">// 哈希表存储</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor: node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 132 Solution</title>
      <link href="/posts/b16cab97.html"/>
      <url>/posts/b16cab97.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s132;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割回文串 II</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回符合要求的 最少分割次数 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] g = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(g[i], <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                f[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[j + <span class="number">1</span>][i]) &#123;</span><br><span class="line">                        f[i] = Math.min(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 131 Solution</title>
      <link href="/posts/5a5b1094.html"/>
      <url>/posts/5a5b1094.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s131;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割回文串</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回文串 是正着读和反着读都一样的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] f;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(f[i], <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                ans.add(s.substring(i, j + <span class="number">1</span>));</span><br><span class="line">                dfs(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.remove(ans.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 130 Solution</title>
      <link href="/posts/b5997baa.html"/>
      <url>/posts/b5997baa.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s130;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被围绕的区域</span></span><br><span class="line"><span class="comment"> * 给你一个 m x n 的矩阵 board ，由若干字符 &#x27;X&#x27; 和 &#x27;O&#x27; ，找到所有被 &#x27;X&#x27; 围绕的区域，并将这些区域里所有的 &#x27;O&#x27; 用 &#x27;X&#x27; 填充。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 13 Solution</title>
      <link href="/posts/c179b7da.html"/>
      <url>/posts/c179b7da.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 罗马数字转整数</span></span><br><span class="line"><span class="comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment"> * 给定一个罗马数字，将其转换成整数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/roman-to-integer</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; symbolValues = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> symbolValues.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; value &lt; symbolValues.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                ans -= value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 129 Solution</title>
      <link href="/posts/88028fa0.html"/>
      <url>/posts/88028fa0.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s129;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求根节点到叶节点数字之和</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</span></span><br><span class="line"><span class="comment"> * 每条从根节点到叶节点的路径都代表一个数字：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</span></span><br><span class="line"><span class="comment"> * 计算从根节点到叶节点生成的 所有数字之和 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//深度遍历 累加数字</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> prevSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//累加数字，每位进10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevSum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="comment">//左右子树为null 则返回和</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//继续深度遍历</span></span><br><span class="line">            <span class="keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 128 Solution</title>
      <link href="/posts/67c0e49e.html"/>
      <url>/posts/67c0e49e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s128;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长连续序列</span></span><br><span class="line"><span class="comment"> * 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-consecutive-sequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//数字集合</span></span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            num_set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最长序列长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : num_set) &#123;</span><br><span class="line">            <span class="comment">//找到最小的数字开始</span></span><br><span class="line">            <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//找更大的数字是否存在，并统计连续数字序列长度</span></span><br><span class="line">                <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//比较最长的序列</span></span><br><span class="line">                longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 127 Solution</title>
      <link href="/posts/96cbbf13.html"/>
      <url>/posts/96cbbf13.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s127;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词接龙</span></span><br><span class="line"><span class="comment"> * 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一对相邻的单词只差一个字母。</span></span><br><span class="line"><span class="comment"> *  对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。</span></span><br><span class="line"><span class="comment"> * sk == endWord</span></span><br><span class="line"><span class="comment"> * 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-ladder</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">            addEdge(word);</span><br><span class="line">        &#125;</span><br><span class="line">        addEdge(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        que.offer(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it : edge.get(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        addWord(word);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">        <span class="type">char</span>[] array = word.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            addWord(newWord);</span><br><span class="line">            <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">            edge.get(id1).add(id2);</span><br><span class="line">            edge.get(id2).add(id1);</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class="line">            wordId.put(word, nodeNum++);</span><br><span class="line">            edge.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 126 Solution</title>
      <link href="/posts/7909d42d.html"/>
      <url>/posts/7909d42d.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s126;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词接龙 II</span></span><br><span class="line"><span class="comment"> * 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk 这样的单词序列，并满足：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每对相邻的单词之间仅有单个字母不同。</span></span><br><span class="line"><span class="comment"> * 转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</span></span><br><span class="line"><span class="comment"> * sk == endWord</span></span><br><span class="line"><span class="comment"> * 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/word-ladder-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span></span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="comment">// 特殊用例判断</span></span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dict.remove(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：广度优先遍历建图</span></span><br><span class="line">        <span class="comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span></span><br><span class="line">        Map&lt;String, Integer&gt; steps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        steps.put(beginWord, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; from = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> beginWord.length();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">char</span>[] charArray = currWord.toCharArray();</span><br><span class="line">                <span class="comment">// 将每一位替换成 26 个小写英文字母</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> charArray[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        charArray[j] = c;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                        <span class="keyword">if</span> (steps.containsKey(nextWord) &amp;&amp; step == steps.get(nextWord)) &#123;</span><br><span class="line">                            from.get(nextWord).add(currWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!dict.contains(nextWord)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span></span><br><span class="line">                        dict.remove(nextWord);</span><br><span class="line">                        <span class="comment">// 这一层扩展出的单词进入队列</span></span><br><span class="line">                        queue.offer(nextWord);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 记录 nextWord 从 currWord 而来</span></span><br><span class="line">                        from.putIfAbsent(nextWord, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                        from.get(nextWord).add(currWord);</span><br><span class="line">                        <span class="comment">// 记录 nextWord 的 step</span></span><br><span class="line">                        steps.put(nextWord, step);</span><br><span class="line">                        <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                            found = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charArray[j] = origin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            path.add(endWord);</span><br><span class="line">            dfs(from, path, beginWord, endWord, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; from, Deque&lt;String&gt; path, String beginWord, String cur, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(beginWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String precursor : from.get(cur)) &#123;</span><br><span class="line">            path.addFirst(precursor);</span><br><span class="line">            dfs(from, path, beginWord, precursor, res);</span><br><span class="line">            path.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 125 Solution</title>
      <link href="/posts/923e6f2e.html"/>
      <url>/posts/923e6f2e.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证回文串</span></span><br><span class="line"><span class="comment"> * 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lowerCase</span> <span class="operator">=</span> s.toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> lowerCase.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 指针left小于指针right且当前考察的字符不是字母或数字，指针left向左移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针left小于指针right且当前考察的字符不是字母或数字，指针right向右移动</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(lowerCase.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果指针left指向的字符与指针right指向的字符不同，则不是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (lowerCase.charAt(left) != lowerCase.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针left左移，指针right右移，继续考察下一对字符</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 124 Solution</title>
      <link href="/posts/7dfc0410.html"/>
      <url>/posts/7dfc0410.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s124;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中的最大路径和</span></span><br><span class="line"><span class="comment"> * 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 路径和 是路径中各节点值的总和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ，返回其 最大路径和 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewpath</span> <span class="operator">=</span> node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 123 Solution</title>
      <link href="/posts/9f201f69.html"/>
      <url>/posts/9f201f69.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment"> * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 122 Solution</title>
      <link href="/posts/70e27457.html"/>
      <url>/posts/70e27457.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s122;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 你能获得的 最大 利润 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//构建dp数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//买入股票的成本</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//前一天卖出，或者今天卖出</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">//前一天买入，或者今天买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 121 Solution</title>
      <link href="/posts/9bd5cf54.html"/>
      <url>/posts/9bd5cf54.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s121;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 买卖股票的最佳时机</span></span><br><span class="line"><span class="comment"> * 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//设置最小金额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minBuy</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//设置最大利润</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//买入的最小金额</span></span><br><span class="line">            minBuy = Math.min(minBuy, prices[i]);</span><br><span class="line">            <span class="comment">//卖出的最大金额</span></span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minBuy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 120 Solution</title>
      <link href="/posts/7417a46a.html"/>
      <url>/posts/7417a46a.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s120;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三角形最小路径和</span></span><br><span class="line"><span class="comment"> * 给定一个三角形 triangle ，找出自顶向下的最小路径和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/triangle</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> i % <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">1</span> - curr;</span><br><span class="line">            f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[curr][j] = Math.min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTotal</span> <span class="operator">=</span> f[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, f[(n - <span class="number">1</span>) % <span class="number">2</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 12 Solution</title>
      <link href="/posts/2ebbdce4.html"/>
      <url>/posts/2ebbdce4.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s12;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整数转罗马数字</span></span><br><span class="line"><span class="comment"> * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment"> * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line"><span class="comment"> * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment"> * 给你一个整数，将其转为罗马数字。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/integer-to-roman</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> symbols[i];</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                roman.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 119 Solution</title>
      <link href="/posts/11e0e9a1.html"/>
      <url>/posts/11e0e9a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s119;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杨辉三角 II</span></span><br><span class="line"><span class="comment"> * 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在「杨辉三角」中，每个数是它左上方和右上方的数的和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(C.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + C.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            C.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 118 Solution</title>
      <link href="/posts/fe22829f.html"/>
      <url>/posts/fe22829f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s118;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杨辉三角</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在「杨辉三角」中，每个数是它左上方和右上方的数的和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row.add(ret.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + ret.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 117 Solution</title>
      <link href="/posts/f29d912.html"/>
      <url>/posts/f29d912.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s117;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充每个节点的下一个右侧节点指针 II</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   Node *left;</span></span><br><span class="line"><span class="comment"> *   Node *right;</span></span><br><span class="line"><span class="comment"> *   Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 初始状态下，所有 next 指针都被设置为 NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进阶：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你只能使用常量级额外空间。</span></span><br><span class="line"><span class="comment"> * 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, Node _left, Node _right, Node _next)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (f.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(f.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(f.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">                    last.next = f;</span><br><span class="line">                &#125;</span><br><span class="line">                last = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 116 Solution</title>
      <link href="/posts/e0ebb22c.html"/>
      <url>/posts/e0ebb22c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s116;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 填充每个节点的下一个右侧节点指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val, Node _left, Node _right, Node _next)</span> &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列同时将第一层节点加入队列中，即根节点</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层的 while 循环迭代的是层数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录当前队列大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历这一层的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从队首取出元素</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 连接</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    node.next = queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拓展下一层节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 115 Solution</title>
      <link href="/posts/bdc092f.html"/>
      <url>/posts/bdc092f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s115;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不同的子序列</span></span><br><span class="line"><span class="comment"> * 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&quot;ACE&quot; 是 &quot;ABCDE&quot; 的一个子序列，而 &quot;AEC&quot; 不是）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目数据保证答案符合 32 位带符号整数范围。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/distinct-subsequences</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">sChar</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tChar</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (sChar == tChar) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1143 Solution</title>
      <link href="/posts/523dbc44.html"/>
      <url>/posts/523dbc44.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s1143;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。</span></span><br><span class="line"><span class="comment"> * 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/longest-common-subsequence</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建二维数组 m n  做动态规划</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果对应位置字符相同，增对应位置值 为 前一位置（i-1,j -1）值 + 1</span></span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则取其中前面(i-1,j) 或者（i, j-1）最大的那个值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 114 Solution</title>
      <link href="/posts/e41e6211.html"/>
      <url>/posts/e41e6211.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s114;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树展开为链表</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根结点 root ，请你将它展开为一个单链表：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</span></span><br><span class="line"><span class="comment"> * 展开后的单链表应该与二叉树 先序遍历 顺序相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/flatten-binary-tree-to-linked-list</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> list.get(i - <span class="number">1</span>), curr = list.get(i);</span><br><span class="line">            prev.left = <span class="literal">null</span>;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 113 Solution</title>
      <link href="/posts/6c27968.html"/>
      <url>/posts/6c27968.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s113;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径总和 II</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/path-sum-ii</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义结果list</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//定义路径</span></span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//深度遍历</span></span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历到叶子节点结束</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把遍历路径的值存到队列中</span></span><br><span class="line">        path.offerLast(root.val);</span><br><span class="line">        <span class="comment">//目标值减小</span></span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="comment">//直到没有叶子节点了，或者 目标值为0 也就是 路径和 == targetSum了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//把队列的路径存到结果list中</span></span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度遍历左子树</span></span><br><span class="line">        dfs(root.left, targetSum);</span><br><span class="line">        <span class="comment">//深度遍历右子树</span></span><br><span class="line">        dfs(root.right, targetSum);</span><br><span class="line">        <span class="comment">//把路径中的值弹出</span></span><br><span class="line">        path.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 112 Solution</title>
      <link href="/posts/e9001256.html"/>
      <url>/posts/e9001256.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s112;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径总和</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历树时存放节点用</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存放当前路径值</span></span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//从root开始遍历</span></span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val);</span><br><span class="line">        <span class="comment">//遍历Queue中节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">now</span> <span class="operator">=</span> queNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queVal.poll();</span><br><span class="line">            <span class="comment">//深度遍历终止条件，左右子树为null，存入的长度 == sum</span></span><br><span class="line">            <span class="keyword">if</span> (now.left == <span class="literal">null</span> &amp;&amp; now.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左子树不为null</span></span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.left);</span><br><span class="line">                queVal.offer(now.left.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右子树不为null</span></span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.right);</span><br><span class="line">                queVal.offer(now.right.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 111 Solution</title>
      <link href="/posts/237a955.html"/>
      <url>/posts/237a955.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s111;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的最小深度</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最小深度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：叶子节点是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min_depth</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 110 Solution</title>
      <link href="/posts/edf5c26b.html"/>
      <url>/posts/edf5c26b.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s110;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平衡二叉树</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，判断它是否是高度平衡的二叉树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中，一棵高度平衡二叉树定义为：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//如果等于-1就表示不是平衡的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNBALANCED</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root) != UNBALANCED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左子节点不是平衡二叉树，直接返回UNBALANCED</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == UNBALANCED)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果右子节点不是平衡二叉树，直接返回UNBALANCED</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> helper(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == UNBALANCED)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左右子节点都是平衡二叉树，但他们的高度相差大于1，</span></span><br><span class="line">        <span class="comment">//直接返回UNBALANCED</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> UNBALANCED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则就返回二叉树中节点的最大高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 11 Solution</title>
      <link href="/posts/c58c67e7.html"/>
      <url>/posts/c58c67e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 盛最多水的容器</span></span><br><span class="line"><span class="comment"> * 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/container-with-most-water</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> Math.min(height[l], height[r]) * (r - l);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 109 Solution</title>
      <link href="/posts/d06e3661.html"/>
      <url>/posts/d06e3661.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s109;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有序链表转换二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> getMedian(left, right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right = buildTree(mid.next, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getMedian</span><span class="params">(ListNode left, ListNode right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (fast != right &amp;&amp; fast.next != right) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 108 Solution</title>
      <link href="/posts/3fac5d5f.html"/>
      <url>/posts/3fac5d5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s108;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 107 Solution</title>
      <link href="/posts/cea706d2.html"/>
      <url>/posts/cea706d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s107;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历 II</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelOrder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> levelOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left, right = node.right;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelOrder.add(<span class="number">0</span>, level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> levelOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 106 Solution</title>
      <link href="/posts/21656dec.html"/>
      <url>/posts/21656dec.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s106;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从中序与后序遍历序列构造二叉树</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="literal">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> inorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">postorderVal</span> <span class="operator">=</span> postorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 105 Solution</title>
      <link href="/posts/ca52d6ef.html"/>
      <url>/posts/ca52d6ef.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s105;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从前序与中序遍历序列构造二叉树</span></span><br><span class="line"><span class="comment"> * 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; inorder.length;i++) &#123;</span><br><span class="line">            cache.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(cache, preorder, inorder, <span class="number">0</span>, preorder.length, <span class="number">0</span>, inorder.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">( Map&lt;Integer, Integer&gt; cache, <span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> pres, <span class="type">int</span> pree, <span class="type">int</span> inos, <span class="type">int</span> inoe)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pres &gt;= pree) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cache.get(preorder[pres]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pres]);</span><br><span class="line">        node.left =  buildTree(cache, preorder, inorder, pres+<span class="number">1</span>, pres+<span class="number">1</span> + index-inos, inos, index);</span><br><span class="line">        node.right =  buildTree(cache, preorder, inorder, pres+<span class="number">1</span> + index-inos, pree,  index+<span class="number">1</span>, inoe);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 104 Solution</title>
      <link href="/posts/2590bdd1.html"/>
      <url>/posts/2590bdd1.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s104;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的最大深度</span></span><br><span class="line"><span class="comment"> * 给定一个二叉树，找出其最大深度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明: 叶子节点是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> * 给定二叉树 [3,9,20,null,null,15,7]，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     3</span></span><br><span class="line"><span class="comment"> *    / \</span></span><br><span class="line"><span class="comment"> *   9  20</span></span><br><span class="line"><span class="comment"> *     /  \</span></span><br><span class="line"><span class="comment"> *    15   7</span></span><br><span class="line"><span class="comment"> * 返回它的最大深度 3 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">     TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="built_in">this</span>.val = val;</span><br><span class="line">         <span class="built_in">this</span>.left = left;</span><br><span class="line">         <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//到叶子节点结束</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左子树最大深度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="comment">//右子树最大深度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="comment">//最大值</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 103 Solution</title>
      <link href="/posts/c74ca6a8.html"/>
      <url>/posts/c74ca6a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s103;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的锯齿形层序遍历</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//定义返回结果集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//放入根节点</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">//定义顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">zig</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从队列取值</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//每层单独存放到对应的链表中，头插尾插 根据zig区分</span></span><br><span class="line">            Deque&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="comment">//队列取值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zig) &#123;</span><br><span class="line">                    level.offerLast(cur.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    level.offerFirst(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前节点不为null，取下一层，从左往右</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每下层更新下 zig</span></span><br><span class="line">            zig = !zig;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(level));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 102 Solution</title>
      <link href="/posts/288ecd96.html"/>
      <url>/posts/288ecd96.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s102;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 101 Solution</title>
      <link href="/posts/c3b97695.html"/>
      <url>/posts/c3b97695.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s101;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对称二叉树</span></span><br><span class="line"><span class="comment"> * 给你一个二叉树的根节点 root ， 检查它是否轴对称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 100 Solution</title>
      <link href="/posts/2c7b1dab.html"/>
      <url>/posts/2c7b1dab.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s100;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相同的树</span></span><br><span class="line"><span class="comment"> * 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 10 Solution</title>
      <link href="/posts/2a4e0cd9.html"/>
      <url>/posts/2a4e0cd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#x27;.&#x27; 和 &#x27;*&#x27; 的正则表达式匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;.&#x27; 匹配任意单个字符</span></span><br><span class="line"><span class="comment"> * &#x27;*&#x27; 匹配零个或多个前面的那一个元素</span></span><br><span class="line"><span class="comment"> * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode.cn/problems/regular-expression-matching</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] = f[i][j] || f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matches(s, p, i, j)) &#123;</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String s, String p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1 Solution</title>
      <link href="/posts/a9ea619c.html"/>
      <url>/posts/a9ea619c.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//定义返回结果</span></span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//缓存出现过的数&lt;数字和下标&gt;</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//另一个数字之前出现过</span></span><br><span class="line">            <span class="keyword">if</span>(cache.containsKey(target -nums[i] )) &#123;</span><br><span class="line">                ret[<span class="number">0</span>] = cache.get(target -nums[i]);</span><br><span class="line">                ret[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没出现过则缓存下来</span></span><br><span class="line">                cache.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Solution</span>().twoSum(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algrithom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
